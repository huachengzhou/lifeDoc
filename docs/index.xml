<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Introduction on 所悟所想</title>
    <link>https://huachengzhou.github.io/life/</link>
    <description>Recent content in Introduction on 所悟所想</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 07 Mar 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://huachengzhou.github.io/life/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>python 说明</title>
      <link>https://huachengzhou.github.io/life/docs/python/base/remark/</link>
      <pubDate>Mon, 06 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/python/base/remark/</guid>
      <description>版本问题 #  Python发行版通常与以前的版本向后兼容。 Python 2.7在很大程度上向后兼容Python 2.6
在python3和python2之间有着一个特殊的版本叫做python2.6，这个版本是作为试验版本和过渡版本而存在的。它基本上采用的都是python2的库以及语法，但同时也可以使用python3的语法。虽然可以使用两个不同版本的python语法，但它还是不可以去运行python3的程序，因为本质上是不兼容的
包管理问题 #   自己开发 可以使用pip 比较简单  Python 的包管理工具常见的有：easy_install，setuptools，distribute，pip
他们之间的关系如下
文档 #  python3.6 python w3school
html转markdown</description>
    </item>
    
    <item>
      <title>python pyqt5</title>
      <link>https://huachengzhou.github.io/life/docs/python/install/pyqt5/</link>
      <pubDate>Thu, 02 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/python/install/pyqt5/</guid>
      <description>关于 PyQt5 #  PyQt5 是Digia的一套Qt5应用框架与python的结合，同时支持2.x和3.x。本教程使用的是3.x。Qt库由Riverbank Computing开发，是最强大的GUI库之一 ，官方网站：www.riverbankcomputing.co.uk/news。
PyQt5是由一系列Python模块组成。超过620个类，6000函数和方法。能在诸如Unix、Windows和Mac OS等主流操作系统上运行。PyQt5有两种证书，GPL和商业证书。
PyQt5类分为很多模块，主要模块有：
 QtCore 包含了核心的非GUI的功能。主要和时间、文件与文件夹、各种数据、流、URLs、mime类文件、进程与线程一起使用。 QtGui 包含了窗口系统、事件处理、2D图像、基本绘画、字体和文字类。 QtWidgets QtMultimedia QtBluetooth QtNetwork QtPositioning Enginio QtWebSockets QtWebKit QtWebKitWidgets QtXml QtSvg QtSql QtTest  QtWidgets类包含了一系列创建桌面应用的UI元素。 QtMultimedia包含了处理多媒体的内容和调用摄像头API的类。 QtBluetooth模块包含了查找和连接蓝牙的类。 QtNetwork包含了网络编程的类，这些工具能让TCP/IP和UDP开发变得更加方便和可靠。 QtPositioning包含了定位的类，可以使用卫星、WiFi甚至文本。 Engine包含了通过客户端进入和管理Qt Cloud的类。 QtWebSockets包含了WebSocket协议的类。 QtWebKit包含了一个基WebKit2的web浏览器。 QtWebKitWidgets包含了基于QtWidgets的WebKit1的类。 QtXml包含了处理xml的类，提供了SAX和DOM API的工具。 QtSvg提供了显示SVG内容的类，Scalable Vector Graphics (SVG)是一种是一种基于可扩展标记语言（XML），用于描述二维矢量图形的图形格式（这句话来自于维基百科）。 QtSql提供了处理数据库的工具。 QtTest提供了测试PyQt5应用的工具。
PyQt4和PyQt5的区别 #  PyQt5不兼容PyQt4。PyQt5有一些巨大的改进。但是，迁移并不是很难，两者的区别如下：
 重新组合模块，一些模块已经被废弃(QtScript)，有些被分为两个子模块(QtGui, QtWebKit)。 添加了新的模块，比如QtBluetooth, QtPositioning，和Enginio。 废弃了SINGAL()和SLOT()的调用方式，使用了新的信号和xx处理方式。 不再支持被标记为废弃的或不建议使用的API。  安装 #  pip3 install PyQt5 -i https://pypi.douban.com/simple pip3 install PyQt5-tools -i https://pypi.</description>
    </item>
    
    <item>
      <title>什么叫魅力</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/iqcs36rgjy/fdhcmhstpw/</link>
      <pubDate>Sun, 29 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/iqcs36rgjy/fdhcmhstpw/</guid>
      <description>什么叫魅力 #  魅力
 气场 存在感 本质上是由什么决定的;当一个人有魅力会自然而然的吸引别人的目光
 魅力＝框架+能量
框架 #  框架 : 国有国法,家有家规;个人也有个人的框架;国法和家规是为了维持一个国家 或者一个家庭内在的秩序,同时它也警告外来者这是我的主权和领土 有一些东西你是不可以侵犯的,同样我们每个人他也是有像法律这样的框架 也就是你喜欢什么、不喜欢什么，你能够接受什么、不能够接受什么
这些东西构成了你的框架 其实我们人和人熟悉和交往的过程,本质上就是一个相互试探、了解彼此框架的过程
大家有没有发现我们初次和一个人见面或者说是和一个人完全不太熟的时候
很少会有人上来就攻击你或者欺负你 呀 王总王总你好 哎呀小多呀 小多好 小多是湖南人吧
什么时候我们有空一起去吃湘菜
好呀好呀 我们以后有时间就多约多聊
大家都是客客气气的 因为没有把彼此完全摸透 不知道对方的水有多深
能量 #  当你的因积累到一定程度之后,你所散发出来的一种气场
“胜兵先胜而后求战，败兵先战而后求胜”“善战者无智名，无勇功（善战者无赫赫之功，善医者无煌煌之名）
决定能量最重要的一个东西叫做实力
&amp;ldquo;自卑和自傲是孪生兄弟,我们要自信,自信的支柱是实力&amp;rdquo;
实力 #  我们的社会是墓强的
其他人如何看待你 就是取决于他们怎么看待你的实力 而我们作为个体 想要过得好的办法就是提高自己的实力
在绝对实力面前 所谓的技巧、伎俩、手段通通没用
产品卖得好是产品本身好 如果产品本身不好
实力 = 价值 + 稀缺性
需要找到自己实力的领域 优势+兴趣 做起来不太费力 经常受到别人的称赞和表扬
&amp;ldquo;价值&amp;rdquo; :被别人需要
链接</description>
    </item>
    
    <item>
      <title>如何提升自信</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/confident/</link>
      <pubDate>Wed, 05 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/confident/</guid>
      <description>case1 #  相信很多兄弟，多多少少都有点自卑，那么我们又应该如何去掉这些自卑，从而变得自信起来呢？
在你想要变得自信之前，首先我们要知道自卑是什么。
精神学家阿尔弗雷德·阿德勒在《自卑与超越》里曾经说过，人的自卑根源都来源于三个点：身体缺陷，骄纵，忽略。
自卑的定义是什么？阿德勒提出：当一个人面对一个需要解决的问题的时候，他无能为力，一点办法都没有，这个时候他所出现的情绪就是自卑。
换句话来说就是：自卑其实只是一种情绪。
回头想想我们的过往经历，的确在很多场景中也出现过这样的情绪，比如：
在面对比自己优秀的人的时候，比如看到一个非常漂亮的女生的时候，自己连正眼都不敢看向她。
在重要场合中，比如职场中需要上台说话，会变得异常紧张，手心冒汗。
在日常生活中，比如我们用的手机没有别人的贵，就会不好意思拿出手机来玩。
这些都是比较大众化的，在这里，我来给兄弟们讲讲我的故事。
昨天的文章也有写到，我原本出生在一个极其贫困的农村里，如果我后面没有走出来城市，我可能永远都不会因为觉得自己家太穷而自卑。
农村的孩子一般都长不高，在出来城市里，面对着这些从小就经常运动的同学们，我的身高只能坐在课堂的前两排。
因为前面的两个点，导致了我自卑的情绪从童年开始就一直伴随着我，人就会变得不爱说话，不喜欢和别人交往，长久以来，我就开始变得越来越内向，甚至是自闭。
从小几乎就没有朋友，因为经常孤单只影，同学们也喜欢欺负我，撕烂我的书本，零用钱被抢，放学经常被人打。
因为童年的这些阴影，包括家庭条件，个人条件（身高，性格），导致了我出来了社会之后还是一如既往的自卑。
那个时候我已经放弃挣扎了，就像变成了一条死鱼，翻着白眼随着江水一直漂啊漂啊&amp;hellip;
我的自卑到底来源于哪里？我总结过，你也可以看看你有没有。
1，身体有缺陷
可能很多兄弟都和我一样，觉得自己不够高，不够帅，不够壮，脸上有痘痘或者痘印痘坑之类的，或者其他的缺陷。
比如像我在六年级的时候，因为被人追着打，把门牙摔崩了一颗，导致了我从小就不爱笑，因为一笑，就会露出我崩掉的门牙，从而导致了我对自己的身体很自卑。
2，童年有阴影
成绩差，同学的欺负，父母的离异，异性的拒绝，青春期的生理变化（青春痘，声音变化），这些情况都会导致了你性格内向，不爱说话，不喜欢与人交流等等习惯。
3，他人的眼光
自己眼里的自己，和别人眼里的自己，都会呈现出不同的版本。
我们小时候要活给父母看，我们要做乖孩子。
读书的时候要活给老师同学看，我们要有好成绩。
出来职场后要活给同事看，我们需要好业绩。
生活中要活给亲朋好友看，我们要过上好生活。
对于这种现象，我们都已经习以为常了，因为从小就在这样的环境下成长，需要得到别人的认同，我们才能够确认到自己的价值所在。
万一我们出现的现实和别人的期望值相差太远，我们就会开始自卑。
4，生活的挫折
比如我们在学习的时候成绩比不过别人，在职场上待遇没有别人好，求爱的时候频频遇到拒绝，包括家庭背景，住的房子，有没有车，开得什么车，日常的生活等等挫折。
这些都是我们自卑的根源。
当我们知道了自卑的根源和背后形成的原因之后，我们就能“对症下药”，逐步的解决问题。
如何解决呢？
我在线下课程的时候，针对自信这节课，就说过一句话：所有的不自信都是源于你有自卑点，想要变得自信，那你必须要把这些自卑点一个个的找出来，然后逐个的去掉它们，再不断的加强，这样的话你就能够变得自信起来了。
解决自卑有一个公式：现实生活与心理预期差距太大——变得自卑——接受不能改变的，改变能改变的——产生优越感——不断强化——变得自信
具体变得自信的方法是：
1，独立
活在父母庇护下的孩子永远长不大，所以我们的第一步就是要学会独立，不再依赖任何人。
如果你能够独立起来，那你就能够有一个“不再活在别人眼里”的环境，再也不会受到别人的否定，嫌弃等等评价。
以及你会拥有一个新的“自我评价”，我们的心理在没有完全成熟之前，会更多的依赖到别人的评价来确认自己的价值，但是一旦独立了，我们的心理就会逐步的成熟起来，这个时候的我们会更加的相信自我评价。
2，减低期望
人生最大的悲剧是：不甘于现状，但是能力又撑不起自己的野心，可是你又很努力，这种落差就是，你配不上自己的野心，也辜负了所受的苦。
对自己的期望，要求，要跟实际情况相应的改变一下，就像你跟我说，今年想赚100万，可是你现在连一份工作都没有的，太过于不切实际。
所以我建议兄弟们，我们在期望，在设定目标的时候，不需要想得太过于长远，不如想想下一个小时要做什么，明天要做什么。
内心有着一个终极目标就行了，不需要时时刻刻都想着要完成它，因为可能这个目标距离你非常遥远，所以你需要做的，就是先把计划划分好，再提前计划好你每一天要做的事情。
比如：你在下午的5点到7点，计划好要做什么，8点到10点计划好要做什么，然后按照你的计划去执行就是了。
而你要去做这些“小时”的计划的时候，切记是要提前做，不要到了时间段才做，比如你要求自己在9点到10点的时候认真的看一本书，那你在晚上7点前就要计划好。
而你每完成一次你的目标，就能够获得一次优越感，完成的次数多了，你自然就会越来越自信。
3，接受
有很多东西，我们再怎么努力可能都没有办法改变，那就要学会坦然的接受它，比如我们的容貌，我们的身高等等。
而有些东西在短时间内并不能改变的，那就暂时接受它，比如没什么钱，阅历不够，情商不够，经验不够，不够成熟等等。
4，改变
当我们清楚了我们的自卑点是什么了之后，我们就要想出办法逐个解决。
比如：
我身高一直都是我的自卑点，那我想尽了一切的办法，比如穿了一双内增高6厘米的鞋子，把头发梳成大背头，用风筒吹上去一点，发型可以为我的身高增加3厘米左右，这样的话我164的身高看起来也会有172左右，有了这样的身高之后，我再也没有为我的身高而感到自卑过。
比如：
我以前走路经常会弯腰驼背，后面意识到了这一点之后开始慢慢的改正，但是很难很难，我去问了健身教练，他告诉我说只要你坚持的去做俯卧撑你就能不再弯腰驼背了，后来我每天都要做100个左右的俯卧撑，我现在走路腰板都是很直的。
比如：
我觉得我口才不行，一点都不会说话，即使和亲戚朋友之间都是没什么话题可聊，那我就开始去看书，去看课程，看相关的教程，再逐步的锻炼，现在我不能说我口才有多么的好，但是基本上的人际交往都不会有什么压力。
比如：
我一直都觉得我比较穷，那我就开始想办法赚钱，我列出了所有我能够做的工作，再一个个的排除，最终从一个小小的厨师一个月收入1700，变成了一个古典家具的师傅，一个月有7000左右，后来自己创业，收入越来越高。
我们缺了什么，就去补充什么，也许和别人比，我们还是不够优秀，但是和昨天的自己比，那我又进步了一点，这样长久下去，即使我还是不够自信，但是我绝对也不会自卑了。
5，强化
当你开始不自卑的时候，你想要获得真正的自信，那你就需要有拿得出手的东西。
比如你通过努力了之后变得有点钱，或者说变得有点情商，有点阅历，口才有点好等等；</description>
    </item>
    
    <item>
      <title>跨域问题</title>
      <link>https://huachengzhou.github.io/life/docs/http/teywty5qnc/</link>
      <pubDate>Wed, 05 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/http/teywty5qnc/</guid>
      <description>跨域 #  介绍 #   跨域，指的是从一个域名去请求另外一个域名的资源，即跨域名请求。跨域时，浏览器不能执行其他域名网站的脚本，这是由浏览器的同源策略造成的，是浏览器施加的安全限制， 跨域限制访问，其实是浏览器的限制。
  同源策略是浏览器最核心也最基本的安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源 ，这是一个用于隔离潜在恶意文件的重要安全机制。所以跨域问题只在浏览器中出现，如果客户端是APP的话，那跨域问题就不存在了。 PS：IE端口除外，IE对同源策略的定义有略微的不同，具体可以查看文末给出的同源策略的链接。
 为什么会跨域 #  说到跨域不得不谈的就是浏览器的同源策略，跨域也是因为浏览器这个机制引起的，这个机制的存在还是在于安全
1.什么是源 #   Web内容的源由用于访问它的URL 的方案(协议)，主机(域名)和端口定义。只有当方案，主机和端口都匹配时，两个对象具有相同的起源。
  所谓同源是指：域名，协议，端口相同，即两个资源具有相同的源。 只要三者之间有一个不同，就是跨域（跨源） 同源不同源一句话就可以判断：就是url中 scheme host port 都相同即为同源。 下面认识下url 结构中的这三个部分  2. URL结构 #   URL 代表着是统一资源定位符（Uniform Resource Locator）。URL 无非就是一个给定的独特资源在 Web 上的地址。
   URL有如下结构组成：
  Schme 或者 Protocol
   Domain Name 也叫做host域名   port 端口号   Parameters参数   Anchor 锚点，一般用于定位位置  3.</description>
    </item>
    
    <item>
      <title>ThreadLocal</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/thread_local/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/thread_local/</guid>
      <description>一:介绍 #   ThreadLocal直译为线程局部变量，或许将它命名为ThreadLocalVariable更为合适。其主要作用就是实现线程本地存储功能，通过线程本地资源隔离，解决多线程并发场景下线程安全问题
  类ThreadLocal 主要解决的就是每个线程绑定自己的值,可以将ThreadLocal类比喻成全局存放数据的盒子,盒子中可以存放每个线程 的私有数据
 二:用法举例 #  public class ToolsThreadLocal { public static ThreadLocal t1 = new ThreadLocal(); } public class ThreadLocalA extends Thread { @Override public void run() { for (int i = 0; i &amp;lt; 50; i++) { ToolsThreadLocal.t1.set(&amp;#34;thread a &amp;#34;+i); System.out.println(ToolsThreadLocal.t1.get()); } } } public class ThreadLocalB extends Thread { @Override public void run() { for (int i = 0; i &amp;lt; 50; i++) { ToolsThreadLocal.</description>
    </item>
    
    <item>
      <title>ECMAScript 6</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/javascript/es6/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/javascript/es6/</guid>
      <description>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。  Module 的语法 #  概述 #  历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。
在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。
ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。
// CommonJS模块let { stat, exists, readFile } = require(&#39;fs&#39;);// 等同于let _fs = require(&#39;fs&#39;);let stat = _fs.stat;let exists = _fs.exists;let readfile = _fs.</description>
    </item>
    
    <item>
      <title>node js </title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/nodejs/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/nodejs/</guid>
      <description>node js #   Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时
 Linux 上安装 Node.js #   直接使用已编译好的包 Node 官网已经把 linux 下载版本更改为已编译好的版本了，我们可以直接下载解压后使用：  # wget https://nodejs.org/dist/v10.9.0/node-v10.9.0-linux-x64.tar.xz // 下载 # tar xf node-v10.9.0-linux-x64.tar.xz // 解压 # cd node-v10.9.0-linux-x64/ // 进入解压目录 # ./bin/node -v // 执行node命令 查看版本 v10.9.0  解压文件的 bin 目录底下包含了 node、npm 等命令，我们可以使用 ln 命令来设置软连接：  ln -s /usr/software/nodejs/bin/npm /usr/local/bin/ ln -s /usr/software/nodejs/bin/node /usr/local/bin/  Ubuntu 源码安装 Node.js   以下部分我们将介绍在 Ubuntu Linux 下使用源码安装 Node.</description>
    </item>
    
    <item>
      <title> Groovy 概述 </title>
      <link>https://huachengzhou.github.io/life/docs/javadir/groovy/groovy%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/groovy/groovy%E5%AD%A6%E4%B9%A0/</guid>
      <description>Groovy 概述 #   Groovy是一种基于Java平台的面向对象语言。 Groovy 1.0于2007年1月2日发布，其中Groovy 2.4是当前的主要版本。 Groovy通过Apache License v 2.0发布。  Groovy的特点 #   同时支持静态和动态类型。 支持运算符重载。 本地语法列表和关联数组。 对正则表达式的本地支持。 各种标记语言，如XML和HTML原生支持。 Groovy对于Java开发人员来说很简单，因为Java和Groovy的语法非常相似。 您可以使用现有的Java库。 Groovy扩展了java.lang.Object。  groovy-脚本和类 #    在groovy中定义类和java中是一样的。类的方法可以是static，也可以是非static的
  groovy中的方法可以是public, protected, private，同时也支持java中的修饰符，比如synchronized
  groovy自动导入的包有以下这些
   groovy.lang.* groovy.util.* java.lang.* java.util.* java.net.* java.io.* import java.math.BigInteger import java.math.BigDecimal    在groovy和java中不同的一点就是，groovy默认是public的
  每一个groovy类，在JVM层级，都是字节码形式的java code，所以在java代码中可以调用groovy中申明的方法，反之亦然
  你可以指定方法的参数和返回值，以便他们能够更好的和java代码相互调用。当然你也可以实现接口或者重载方法。但是需要你没有指定方法后者属性的类型的话，那么在JVM层级的字节码中，他们将会是 java.lang.Object 类型
  例如 Callee.</description>
    </item>
    
    <item>
      <title>DOS命令 基本介绍 </title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/windows/dos_start/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/windows/dos_start/</guid>
      <description>介绍 #   windows不区分大小写  C:\Users\noatn&amp;gt;echo &amp;#39;你好&amp;#39; &amp;#39;你好&amp;#39; C:\Users\noatn&amp;gt;ECHO &amp;#39;你好&amp;#39; &amp;#39;你好&amp;#39; 体验 #    体验1
  @echo off 关闭原始盘符
  C:\Users\noatn&amp;gt;echo &amp;#39;你好&amp;#39; &amp;#39;你好&amp;#39; C:\Users\noatn&amp;gt; C:\Users\noatn&amp;gt;@echo off Echo &amp;#39;hello world&amp;#39; &amp;#39;hello world&amp;#39;  pause 暂停  @echo off Echo &amp;#39;hello world&amp;#39; pause  查看ip地址  C:\Users\noatn&amp;gt;ipconfig Windows IP 配置 以太网适配器 以太网 2: 媒体状态 . . . . . . . . . . . . : 媒体已断开连接 连接特定的 DNS 后缀 .</description>
    </item>
    
    <item>
      <title>groovy 基本概念 </title>
      <link>https://huachengzhou.github.io/life/docs/javadir/groovy/groovy%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/groovy/groovy%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid>
      <description>groovy 基本概念 #  1、基本概念 #   Groovy是一种面向对象的动态类型语言，跟Java一样运行在JVM上。
（注：给Java静态世界带来动态能力的语言）
   与Java不同的语言特性：
  a) 函数字面值
  b) 对集合的一等支持
  c) 对正则表达式的一等支持
  d) 对XML处理的一等支持
  （注：所谓“一等”指的是内置到语言的语法中，不需要调用类库。）
  2:Groovy能解决包括： #    快速Web开发
  原型设计
  脚本处理
  等问题，这些使用Java不是解决动态层问题的理想语言。
  例如:
System.out.println(&amp;quot;It&#39;s a Groovy baby, yeah!&amp;quot;);def writer = new StringWriter();def xml = new groovy.xml.MarkupBuilder(writer);xml.person(id:2){name &#39;kobicc&#39;age 1}println writer.</description>
    </item>
    
    <item>
      <title>java_监听事件原理 </title>
      <link>https://huachengzhou.github.io/life/docs/javadir/basedir/jsp_dir/java_%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6%E5%8E%9F%E7%90%86/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/basedir/jsp_dir/java_%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6%E5%8E%9F%E7%90%86/</guid>
      <description>接口回调法 #  模拟输出监听事件 #  第一步先定义事件接口 #  public interface PrintListener {public void print();}第二步自定义输出类 #  public class Out {PrintListener listener=null;public Out() {}public Out(PrintListener listener) {this.listener=listener;}public void printlen(String s) {System.out.println(s);if(listener!=null) {listener.print();}}}第三步实现监听事件接口 #  public class PrintListenerDemo implements PrintListener {@Overridepublic void print() {System.out.println(&amp;quot;监听到输出事件&amp;quot;);}}测试 #  public class Test {public static void main(String[] args) {//新建一个默认输出类Out b=new Out();b.</description>
    </item>
    
    <item>
      <title>任务分类法</title>
      <link>https://huachengzhou.github.io/life/docs/plan/dir/jdkbatmmbr/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/plan/dir/jdkbatmmbr/</guid>
      <description>任务分类法 #  一:分类的目的是什么？ #   不知你会感到这样吗？有时候完成不了任务，可能是当下在犹豫做什么事之中放走了时间。分类可以避免这种情况，让你在需要时，二话不说就可以根据即刻的情况，迅速找到对应清单下的任务开干，减少因为找不到可做任务而拖延的现象。
 二:任务分类法 #   按照任务属性分类，可将事项分类为工作、学习、生活、娱乐…… 🉑这种分类方法最为常见、符合直觉、也适用于大多数人。  三:场景分类法 #   可以让你在某种特定的场景下，迅速找到自己当下要做的事情。比如工具场景和地点场景； 🉑任务不多或者在某种特定场景效率更高的人，可采取这种分类  四:四象限分类法 #   按照任务的重要紧急程度，将待办事项分类成四个象限：重要紧急、重要不紧急、不重要紧急、不重要不紧急。 🉑适合任务较多、事情繁琐的人使用  五:能量分类法 #    按照待办事项需要耗费多少能量，来进行分类。可将其分为：
  非常耗费能量、比较耗费能量
  不耗费能量、有助于恢复能量。
  🉑如果你常有这种差异很大的任务，那么可以试试能量分类法。✨
  六:时长分类法 #   按照任务需花费的时长，将其分类为： 10分钟以内、半个小时以内 30分钟到1个小时、一个小时以上。 🉑非常适合于碎片化时间较多的人。  总结 #    🌈分类方法没有好与不好，
  按照自己的实际情况和使用习惯去分类，才是最适合自己最好的分类方式呀
  也可以混搭来用💖💖
  参考1</description>
    </item>
    
    <item>
      <title>Apache Commons 工具类介绍及简单使用</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/tooldoc/apache-common%E5%B7%A5%E5%85%B7%E5%8C%85/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/tooldoc/apache-common%E5%B7%A5%E5%85%B7%E5%8C%85/</guid>
      <description>Apache Commons 工具类介绍及简单使用 #     组件 功能介绍     BeanUtils Commons-BeanUtils 提供对 Java 反射和自省API的包装, 提供了对于JavaBean进行各种操作，克隆对象,属性等等.   Betwixt XML与Java对象之间相互转换.   Codec 处理常用的编码方法的工具类包 例如DES、SHA1、MD5、Base64等.   Collections java集合框架操作.   Compress java提供文件打包 压缩类库.   Configuration Commons-Configuration 工具对各种各式的配置和参考文件提供读取帮助,java应用程序的配置管理类库.   DBCP 提供数据库连接池服务.   DbUtils DbUtils 是一个 JDBC helper 类库，完成数据库任务的简单的资源清除代码,提供对jdbc 的操作封装来简化数据查询和记录读取操作   Email java发送邮件 对javamail的封装.   FileUpload 提供文件上传功能.   HttpClient 提供HTTP客户端与服务器的各种通讯操作. 现在已改成HttpComponents   Lang Java基本对象方法的工具类包 如：StringUtils,ArrayUtils等等.</description>
    </item>
    
    <item>
      <title>git学习</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/linux/git_introduction/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/linux/git_introduction/</guid>
      <description>git学习 #  git 区域概念 #   git分为工作区(我们自己的file)和版本库这其中版本库又包含暂存区(Stage)和分支区(master)    git add ********** 把文件添加到仓库
  git reset README.md 取消提交到暂存区域
  git commmit -m &amp;lsquo;xxxx&amp;rsquo; 提交到仓库
  git diff 查看提交到仓库文件之后文件又被修改的变化
  git status 查看状态
  git rm -f gitS.md 强制删除
  git log 显示从最近到最远的提交日志
  git log &amp;ndash;pretty=oneline 只显示版本号
  关于版本回退问题 #    git reset &amp;ndash;hard HEAD^ 版本重置为上一个版本
  git 关于版本处理进行了设置</description>
    </item>
    
    <item>
      <title>git配置</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/linux/gitub_config/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/linux/gitub_config/</guid>
      <description>zhou@zhou-Lenovo-Z480:~$ git versiongit version 2.7.4zhou@zhou-Lenovo-Z480:~$ ssh -T git@github.comWarning: Permanently added the RSA host key for IP address &#39;192.30.255.112&#39; to the list of known hosts.Permission denied (publickey).zhou@zhou-Lenovo-Z480:~$ git config --global user.name &amp;quot;zhouchenhua&amp;quot;zhou@zhou-Lenovo-Z480:~$ git config --global user.email &amp;quot;noatnu@163.com&amp;quot;zhou@zhou-Lenovo-Z480:~$ git config --listuser.name=zhouchenhuauser.email=noatnu@163.comzhou@zhou-Lenovo-Z480:~$ ssh-keygen -C ‘noatnu@163.com’ -t rsaGenerating public/private rsa key pair.Enter file in which to save the key (/home/zhou/.ssh/id_rsa): america347191Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in america347191.</description>
    </item>
    
    <item>
      <title>host映射</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/linux/host%E6%98%A0%E5%B0%84/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/linux/host%E6%98%A0%E5%B0%84/</guid>
      <description>sudo vi hosts
127.0.0.1	localhost 127.0.1.1	zhou-Lenovo-Z480
The following lines are desirable for IPv6 capable hosts #  ::1 ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters
#pmcc dev 127.0.0.1 dev.pmcc.com</description>
    </item>
    
    <item>
      <title>Linux下设置和查看环境变量</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/linux/linux%E4%B8%8B%E8%AE%BE%E7%BD%AE%E5%92%8C%E6%9F%A5%E7%9C%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/linux/linux%E4%B8%8B%E8%AE%BE%E7%BD%AE%E5%92%8C%E6%9F%A5%E7%9C%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</guid>
      <description>Linux的变量种类 按变量的生存周期来划分，Linux变量可分为两类： 1 永久的：需要修改配置文件，变量永久生效。 2 临时的：使用export命令声明即可，变量在关闭shell时失效。
设置变量的三种方法 1 在/etc/profile文件中添加变量【对所有用户生效(永久的)】 用VI在文件/etc/profile文件中增加变量，该变量将会对Linux下所有用户有效，并且是“永久的”。 例如：编辑/etc/profile文件，添加CLASSPATH变量
vi /etc/profile #  export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib
注：修改文件后要想马上生效还要运行# source /etc/profile不然只能在下次重进此用户时生效。
2 在用户目录下的.bash_profile文件中增加变量【对单一用户生效(永久的)】 用VI在用户目录下的.bash_profile文件中增加变量，改变量仅会对当前用户有效，并且是“永久的”。 例如：编辑guok用户目录(/home/guok)下的.bash_profile $ vi /home/guok/.bash.profile 添加如下内容： export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib 注：修改文件后要想马上生效还要运行$ source /home/guok/.bash_profile不然只能在下次重进此用户时生效。
3 直接运行export命令定义变量【只对当前shell(BASH)有效(临时的)】 在shell的命令行下直接使用[export 变量名=变量值] 定义变量，
该变量只在当前的shell(BASH)或其子shell(BASH)下是有效的，
shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的话还需要重新定义。
环境变量的查看 1 使用echo命令查看单个环境变量。例如： echo $PATH 2 使用env查看所有环境变量。例如： env 3 使用set查看所有本地定义的环境变量。
使用unset删除指定的环境变量 set可以设置某个环境变量的值。清除环境变量的值用unset命令。如果未指定值，则该变量值将被设为NULL。示例如下： $ export TEST=&amp;ldquo;Test&amp;hellip;&amp;rdquo; #增加一个环境变量TEST $ env|grep TEST #此命令有输入，证明环境变量TEST已经存在了 TEST=Test&amp;hellip; unset TEST #删除环境变量TEST $ env|grep TEST #此命令没有输出，证明环境变量TEST已经删除
常用的环境变量 PATH 决定了shell将到哪些目录中寻找命令或程序 HOME 当前用户主目录 HISTSIZE　历史记录数 LOGNAME 当前用户的登录名 HOSTNAME　指主机的名称 SHELL 当前用户Shell类型 LANGUGE 语言相关的环境变量，多语言可以修改此环境变量 MAIL　当前用户的邮件存放目录 PS1　基本提示符，对于root用户是#，对于普通用户是$</description>
    </item>
    
    <item>
      <title>linux命令</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/linux/linux%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/linux/linux%E5%91%BD%E4%BB%A4/</guid>
      <description>linux命令 #  文件管理 #  文件基本操作 #    less命令 (Q退出less命令)([pagedown]： 向下翻动一页)([pageup]： 向上翻动一页) less ss.md
  cat命令 (cat -n ss.md &amp;gt; sdfsd.txt)把 ss.md 的文档内容加上行号后输入 sdfsd.txt 这个文档里, 这要注意假如sdfsd.txt先有文档会被清空,另外(cat ss.md)可以把消息打印到输出流中,cat 软盘功能暂时不予以考虑
  ls命令 (ls -a)显示所有文件及目录包括隐藏文件,相当于la命令,ll显示具体信息
  touch命令 主要用作创建文件如touch ss.md,(touch -m miss,touch -a miss)可以改变文件的读取时间,另外touch miss也可以改变文件的读取时间, 当且仅当miss不存在的时候会创建miss空文件
  mkdir命令 主要用作创建文件目录;(mkdir dd)创建一个dd目录,(mkdir -p dd/ffg)在当前目录下建立一个dd目录并且在dd下创建一个ffg目录,假如dd不存在会自动创建的
  mv命令 (mv missA miss.txt)把missA修改为miss.txt (mv sskg /home/zhou/fontconfig/dgsd/sdfg)把sskg移到sdfg目录 (mv ss.md ~)
  file命令 (file -c ss.</description>
    </item>
    
    <item>
      <title>nginx学习</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/linux/nginx/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/linux/nginx/</guid>
      <description>nginx学习 #  基础操作 #   start ./sbin/nginx stop ./sbin/nginx -s stop quite ./sbin/nginx -s quit   启动成功标志
 Welcome to nginx! 默认监听的端口是80 也就是说访问此端口就可以得到启动成功的标识符号
  简单的负载均衡配置    http 模块中配置  #配置开始 author zhouupstream myproject{server 127.0.0.1:8000 weight=3;server 127.0.0.1:8080 weight=10;server 127.0.0.1:8090;}#配置结束 author zhou location模块配置  proxy_pass http://myproject;注意:这的myproject要和上面的name一致测试结果 (这的测试用到了session的唯一性)
 http://localhost/nginx_test/ sessionId=8D9C4ACEE65EB24301B1C0D9E4CF3A6Ehttp://localhost:8080/nginx_test/ sessionId=8D9C4ACEE65EB24301B1C0D9E4CF3A6Ehttp://localhost:8090/nginx_test/ sessionId=7539B2C4AFD433ECEFAC8F2B2EBCC411 由于配置了权重 因此大部分是8080端口</description>
    </item>
    
    <item>
      <title>Notepad&#43;&#43; 学习与使用</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/linux/notepad&#43;&#43;%E5%AE%89%E8%A3%85/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/linux/notepad&#43;&#43;%E5%AE%89%E8%A3%85/</guid>
      <description>Notepad++是一套非常有特色的自由软件的纯文字编辑器(许可证:GPL)。有完整的中文化接口及支持多国语言编写的功能(UTF8 技术)。 它的功能比 Windows 中的 Notepad(记事本)强大，除了可以用来制作一般的纯文字说明文件，也十分适合当作编写电脑程序的编辑器。 Notepad++ 不仅有语法高亮度显示，也有语法折叠功能，并且支持宏以及扩充基本功能的外挂模组。但是可惜的是Notepad++只能在Windows平台下使用。 工作中必须使用Windows时，Notepad++是众多程序员最喜爱的文本编辑器，在Ubuntu下是否能够使用到相同的软件呢？Notepadqq就是这样一款与Notepad++非常接近的编辑器，拥有几乎相同的功能。 如果您是一个Notepad++粉丝，我们推荐您尝试下Notepadqq。
对于Ubuntu发行版本可以通过PPA安装，命令如下： sudo add-apt-repository ppa:notepadqq-team/notepadqq sudo apt-get update sudo apt-get install notepadqq 类似的，卸载命令如下：
sudo apt-get remove notepadqq sudo add-apt-repository &amp;ndash;remove ppa:notepadqq-team/notepadqq</description>
    </item>
    
    <item>
      <title>Redis 学习与使用</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/middleware/redis/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/middleware/redis/</guid>
      <description>一.Redis介绍 #  1.1引言 #   1:由于用户量大，请求了随之增大，数据压力过大。 2:多台服务器之间数据不同步 3:多台服务器之间的锁已经不存在互斥性了
 #  1.2 NOSQL #   redis就是nosql
  非关系数据库 &amp;gt; not only sql
 1:key-value redis 2:文档型 solr,Mongodb,ElasticSearch 3:面向列 Hbase(一般大数据) 4:图形化 Neo4j
  1.3 redis介绍 #   Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 Redis是一款基于Key-Value的NOSQL，而且Redis是基于内存存储数据的,Redis还提供了多种持久化机制，Redis还提供了主从、哨兵以及集群的搭建方式，可以更方便的横向扩展以及垂直扩展
  操作都是原子的
 所有 Redis 的操作都是原子的，从而确保当两个客户同时访问 Redis 服务器时，得到的是更新后的值（最新值）。在需要高并发的场合可以考虑使用 Redis 的事务，处理一些需要锁的业务。
  二.Redis安装 #  redis 注册服务 #  C:\Users\noatn&amp;gt;e:E:\&amp;gt;cd E:\CS\Redis-x64-3.</description>
    </item>
    
    <item>
      <title>Ubuntu 16.04修改hosts</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/linux/ubuntu16.04%E4%BF%AE%E6%94%B9hosts/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/linux/ubuntu16.04%E4%BF%AE%E6%94%B9hosts/</guid>
      <description>IntelliJ IDE运行Tomcat报错解决办法的相关资料,出现“Unable to ping server at localhost:1099”错误解决方法，需要的朋友可以参考下
sudo gedit /etc/hosts</description>
    </item>
    
    <item>
      <title>ubuntu安装chmsee</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/linux/ubuntu%E5%AE%89%E8%A3%85chmsee/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/linux/ubuntu%E5%AE%89%E8%A3%85chmsee/</guid>
      <description>垃圾的ubuntu 14.04 又一次去掉一些特别好用的软件, 官方给的解释是怕破坏他们系统. 只想说一句 我去年买了个本.
14.04 之前的版本,如13.10, 12.04 继续能够使用 sudo apt-get install chmsee 来安装.
14.04 需要下载安装包来安装:
sudo apt-get install libc6 libchm1 libgcrypt11 libgdk-pixbuf2.0-0 libglib2.0-0 libgtk2.0-0 libpango1.0-0 libwebkitgtk-1.0-0 libxml2 安装依赖包
(64位) sudo dpkg -i chmsee_1.3.0-2ubuntu2_amd64.deb 安装软件包,下载地址: http://kr.archive.ubuntu.com/ubuntu/pool/universe/c/chmsee/chmsee_1.3.0-2ubuntu2_amd64.deb Ubuntu的官方软件库放心下载.
(32位) sudo dpkg -i chmsee_1.3.0-2ubuntu2_i386.deb 安装软件包,下载地址: http://kr.archive.ubuntu.com/ubuntu/pool/universe/c/chmsee/chmsee_1.3.0-2ubuntu2_i386.deb Ubuntu的官方软件库放心下载.</description>
    </item>
    
    <item>
      <title>Ubuntu清理系统垃圾</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/linux/ubuntu%E6%B8%85%E7%90%86%E7%B3%BB%E7%BB%9F%E5%9E%83%E5%9C%BE/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/linux/ubuntu%E6%B8%85%E7%90%86%E7%B3%BB%E7%BB%9F%E5%9E%83%E5%9C%BE/</guid>
      <description>1，非常有用的清理命令： sudo apt-get autoclean &amp;ndash;清理旧版本的软件缓存 www.2cto.com
sudo apt-get clean&amp;ndash;清理所有软件缓存
sudo apt-get autoremove&amp;ndash;删除系统不再使用的孤立软件
这三个命令主要清理升级缓存以及无用包的。
2，清理opera firefox的缓存文件： ls ~/.opera/cache4 ls ~/.mozilla/firefox/*.default/Cache
3，清理Linux下孤立的包： 图形界面下我们可以用：gtkorphan sudo apt-get install gtkorphan -y 终端命令下我们可以用：deborphan sudo apt-get install deborphan -y
4，卸载：tracker 这个东西一般我只要安装Ubuntu就会第一删掉tracker 他不仅会产生大量的cache文件而且还会影响开机速度。所以在新得利里面删掉就行。 www.2cto.com
5，删除多余的内核：一定不要删错哦，切记！！ 打开终端敲命令：dpkg &amp;ndash;get-selections|grep linux 有image的就是内核文件 删除老的内核文件： sudo apt-get remove 内核文件名（例如：linux-image-2.6.27-2-generic） 内核删除，释放空间了，应该能释放130－140M空间。
最后不要忘了看看当前内核：uname -a 附录： 包管理的临时文件目录: 包在 /var/cache/apt/archives 没有下载完的在 /var/cache/apt/archives/partial</description>
    </item>
    
    <item>
      <title>ubuntu软件卸载</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/linux/ubuntu%E8%BD%AF%E4%BB%B6%E5%8D%B8%E8%BD%BD/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/linux/ubuntu%E8%BD%AF%E4%BB%B6%E5%8D%B8%E8%BD%BD/</guid>
      <description>ubuntu软件卸载
安装Synaptic
sudo apt-get install synaptic</description>
    </item>
    
    <item>
      <title>名词解释</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/glossary/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/glossary/</guid>
      <description>  FIFO队列 (先进先出队列)
  jni 远程调用 编译器代码
  LongAdder
  </description>
    </item>
    
    <item>
      <title>权限</title>
      <link>https://huachengzhou.github.io/life/docs/databases/postgresql/postgresql_create%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/postgresql/postgresql_create%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90/</guid>
      <description>权限 #   系统权限 role和user都是用户,只不过role属性不能登录当然也可以指定 超级权限 不做权限检查(实际中是很危险的)
 Pg权限分为两部分，一部分是“系统权限”或者数据库用户的属性，可以授予role或user（两者区别在于login权限）；一部分为数据库对象上的操作权限。对超级用户不做权限检查，其它走acl。对于数据库对象，开始只有所有者和超级用户可以做任何操作，其它走acl。在pg里，对acl模型做了简化，组和角色都是role，用户和角色的区别是角色没有login权限。超级权限 #   创建超级用户(create user alice with superuser password &amp;lsquo;123456&amp;rsquo;;)系统不会做权限操作校验,仅仅是不能够创建用户与删除用户  系统权限 #    (create role blake password &amp;lsquo;123456&amp;rsquo;;)(create user bob password &amp;lsquo;123456&amp;rsquo;;)(create database testdb;)
  (grant all on database testdb to bob;grant all on database testdb to blake;)
  测试如下 用户bob可以登录而blake不能登录直接抛出了FATL:role blake is not &amp;lsquo;permitted to log in&amp;rsquo;
  ( drop database testdb;drop role blake;drop user bob;)</description>
    </item>
    
    <item>
      <title>追女生</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/talk_theme/girl/ytaerczr7w/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/talk_theme/girl/ytaerczr7w/</guid>
      <description>男生圈子太小如何才能认识更多的女生 #  剧本杀 #   1 剧本杀圈子女多男少 2 剧本杀相处时间有好几个小时 3 剧本杀中你们会有很多东西可以聊 4 这是一位同玩剧本杀的漂亮小姐姐告诉我的答案 5 我是玩剧本杀找到我老婆的 PS 剧本杀出来前也有跑团和桌游（狼人杀）  陌生搭讪 #    认识女生最有效率的方式还是搭讪。但是很多男生一辈子都不敢搭讪女生，脸皮太薄注定会是单身狗。在路上看到喜欢的女生，也只敢远远的看一眼，连走近都不敢。
  其实在搭讪之前，你可以给自己一个暗示，搭讪成功了就是一段美妙的回忆，失败了也不会就是几秒钟的尴尬。你大胆的走上去就说：“美女，你好。我今天和朋友在这里玩，远远的看到你感觉好有气质，我们能加个微信认识一下吗？”只要你的形象得体，举止大方，70%的女生都不会拒绝你。
  找对象其实很简单，把自己打扮帅气一点，然后出去逛街，看到喜欢的类型女生就去要微信，别胆怯，一定要大胆上去加她好友
  首先反观自省，反思自己有没有问题，有问题修正自己，让自己变得更优秀一点，然后试着去找一找，找到合适的，或者喜欢的可以去处一处，多试几次慢慢就会找到合适的对象
  哪里女生多就去哪里！多参加各种活动！同时是你自己也要内外兼修！
  1、平价女装商城。
  2、网红打卡咖啡馆。
  3、学校附近的商业街。
  加入一个有趣的俱乐部
  多参加聚会
  培养兴趣爱好
  出去运动和购物
  图书馆吧
  追女生必须注意细节 #  追女生要注意仪式感 #    和女生在交往中要时刻注意情绪 时刻注意她是否累了 是否饿了 是否渴了 是否情绪不对 语气一定要平和 总之时刻注意</description>
    </item>
    
    <item>
      <title>操作系统的概念、功能</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/one_chapter/1_1_/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/one_chapter/1_1_/</guid>
      <description>一:大家熟悉的操作系统 #  二:知识总览 #   1:操作系统的概念（定义）   操作系统（Operating System， OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调 度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本 的系统软件。
   直观的例子：打开 Windows 操作系统的“任务管理器”（快捷键：Ctrl+Alt+Del）
  ①操作系统是系统资源的管理者
  ②向上层提供方便易用的服务
  ③是最接近硬件的一层软件
  一台电脑的诞生~Step 1：厂家组装一台裸机Step 2：出售前安装操作系统Step 3：用户安装应用程序（eg：QQ）Step 4：使用 QQ 聊天 2:操作系统的功能和目标——作为系统资源的管理者   操作系统的功能和目标——向上层提供方便易用的服务  </description>
    </item>
    
    <item>
      <title>数据通信基础知识 </title>
      <link>https://huachengzhou.github.io/life/docs/computer_network/physical_layer/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/computer_network/physical_layer/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>典型的数据通信模型 #  数据通信相关术语 #   通信的目的是传送消息(消息:语音、文字、图像、视频等)。
   信号:数据的电气/电磁的表现，是数据在传输过程中的存在形式。
  数字信号/离散信号:代表消息的参数的取值是离散的
   模拟信号/连续信号:代表消息的参数的取值是连续的   信源:产生和发送数据的源头。 信宿:接收数据的终点。 信道:信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。   信道  按传输信号分 模拟信道(传送模拟信号) 数字信道(传送数字信号) 按传输介质分 无线信道 有线信道    设计数据通信系统要考虑的三个问题 #  采用单工通信(只有一个方向)/半双工通信(回合制)/全双工通信(可以同时如擂台上拳击手打击) * #  采用串行通信/并行通信 #  采用同步通信/异步通信 #  串行传输&amp;amp;并行传输 #  同步传输&amp;amp;异步传输 #  </description>
    </item>
    
    <item>
      <title>物理层基本概念 </title>
      <link>https://huachengzhou.github.io/life/docs/computer_network/physical_layer/%E7%89%A9%E7%90%86%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/computer_network/physical_layer/%E7%89%A9%E7%90%86%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid>
      <description>物理层接口特性 #   物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。 物理层主要任务：确定与传输媒体接口有关的一些特性 ==&amp;gt; 定义标准
  1.机械特性 定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量、排列情况  2.电器特性 规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制。 某网络在物理层规定，信号的电平用+10V~+15V表示二进制0，用-10V~-15V表示二进制1，电线长度限于15m以内 3.功能特性 指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途。 描述一个物理层接口引脚处于高电平时的含义 4.过程特性 定义各条物理线路的工作规程和时序关系。  </description>
    </item>
    
    <item>
      <title>计算机概念 组成 功能 分类 * </title>
      <link>https://huachengzhou.github.io/life/docs/computer_network/network_architecture/1.1.1%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E5%BF%B5-%E7%BB%84%E6%88%90-%E5%8A%9F%E8%83%BD-%E5%88%86%E7%B1%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/computer_network/network_architecture/1.1.1%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E5%BF%B5-%E7%BB%84%E6%88%90-%E5%8A%9F%E8%83%BD-%E5%88%86%E7%B1%BB/</guid>
      <description>计算机网络 #  概念 #   计算机网络是互连的、自治的计算机集合。  组成 #   组成部分:硬件、软件、协议 1 工作方式:边缘部分、核心部分 2 功能组成:通信子网、资源子网  分类 #   1 分布范围:广域网、城域网、局域网、个人区域网 2 使用者: 公用网、专用网 3 交换技术:电路交换、报文交换、分组交换 4 拓扑结构:总线型、星型、环型、网状型 5 传输技术:广播式、点对点  功能 #   1:数据通信 2:资源共享 3:分布式处理、提高可靠性、负载均衡  </description>
    </item>
    
    <item>
      <title>进程的概念、组成、特征</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_1_1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_1_1/</guid>
      <description></description>
    </item>
    
    <item>
      <title>python pyinstaller </title>
      <link>https://huachengzhou.github.io/life/docs/python/install/pyinstaller/</link>
      <pubDate>Thu, 02 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/python/install/pyinstaller/</guid>
      <description>pyinstaller #  安装 #   安装  pip install pyinstaller  验证安装  C:\Users\noatn&amp;gt;pyinstaller -v 5.8.0  更新PyInstaller  pip install --upgrade pyinstaller  下载PyInstaller开发版本   如果你认为当前发行版本无法满足你的要求，或者你发现了bug的话，可以尝试用一下最新的开发版本
 pip install https://github.com/pyinstaller/pyinstaller/tarball/develop 打包 #  打包为单文件 #   平时我们见到很多便携的单文件程序，假如我们写了一个小脚本，寥寥数行代码，打包成一个文件夹显然不合适，这就可使用Pyinstaller打包成一个exe
 # 将 xx.py 打包为 xx.exe pyinstaller -F xx.py 打包资源文件夹 #  # 将 xx.py 打包 pyinstaller xx.py  打包的时候，程序同路径下会生成一个同名的.spec文件，这个文件是打包的 “中间文件”，我们可以通过修改这个文件来添加我们需要添加资源的文件
 Spec文件分析 #  .spec文件中主要包含4部分：Analysis、PYZ、EXE、COLLECT
  Analysis：主要是分析py文件的依赖信息</description>
    </item>
    
    <item>
      <title>python pip</title>
      <link>https://huachengzhou.github.io/life/docs/python/base/pip/</link>
      <pubDate>Wed, 15 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/python/base/pip/</guid>
      <description>安装 #  目前如果你在Python官网下载最新版本的安装包，都已经自带了该工具
Python 2.7.9 + 或 Python 3.4+ 以上版本都自带 pip 工具。
 检测安装  C:\Users\noatn&amp;gt; pip --version pip 23.0.1 from c:\soft\python\lib\site-packages\pip (python 3.7) C:\Users\noatn&amp;gt;  下载安装  可以通过命令 pip &amp;ndash;version 来判断是否已安装： pip &amp;ndash;version
如果你还未安装，则可以使用以下两种方法来安装：
1、Python附带了一个ensurepip模块，可以在Python环境中安装pip。cmd输入以下命令
py -m ensurepip --upgrade 2、还可以下载一个Python脚本，使用命令行引导逻辑来安装pip
下载脚本 到你的Python文件夹下 win+cmd打开终端，切换至你脚本的目录 输入命令回车
py get-pip.py 最常用命令 #   升级pip  python -m pip install --upgrade pip  显示版本和路径  C:\Users\noatn&amp;gt;pip --version pip 23.0.1 from c:\soft\python\lib\site-packages\pip (python 3.</description>
    </item>
    
    <item>
      <title>我无所畏惧，因为</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/iqcs36rgjy/j74dbsrtzw/</link>
      <pubDate>Sun, 29 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/iqcs36rgjy/j74dbsrtzw/</guid>
      <description>我无所畏惧，因为 #  稀缺性
构建自身稀缺性的五个维度：信息、知识、能力、认知和资源 #   1、信息﻿  ﻿
生活中存在信息差。
搜集高质量信息的能力
对重要信息的理解
 2、知识﻿  ﻿
长期积累，知识体系化，形成跨学科理解
 3、能力﻿  ﻿ 输出能力、综合能力
能力是在实践中练习出来的。
 4、认知﻿  认知就是高维度思想——指路社哲讲堂23、24、30
认知类型如：站在对方的角度/全局想问题、跳出当下的维度（时间）从你未来的目标逆推现在的行动、站在现在的时间维度预判未来的趋势和风口
提升认知的方法就是多接触人，尤其是高人
历史高人：阅读其著作、研究其传记。
现在高人：花钱买其时间。
重要的是同领域头部，如果想在这个领域做大做强，就需要将头部研究透彻。
 5、资源﻿  商业资源：供应商、渠道、客户
个人资源：钱、人脉、修养/谈资
只有你能帮到对方的地方才叫做人脉。
二、其他构成魅力的要素：真实、神性和兽性 #  ﻿
 真实 ﻿  真实的力量是最强大的
﻿
 神性和兽性 ﻿  每个人都有神性和兽性，要利用好这些智慧，就是要记住我们从哪里来（兽性：初始状态、无所畏惧）、去哪里（神性：愿景、目标、使命）
行动上没必要那么聪明，敢去做行动上的傻子
当你在行动你所得到的都是答案 ﻿
 主场 ﻿ 实际上就是环境。  主场能给人力量。
链接</description>
    </item>
    
    <item>
      <title>Nginx 学习与使用</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/middleware/nginx/</link>
      <pubDate>Mon, 10 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/middleware/nginx/</guid>
      <description>一、Nginx 简介 #  Nginx (engine x) 是一款轻量级的 Web 服务器 、反向代理服务器及电子邮件（IMAP/POP3）代理服务器。
前辈总结 #    nginx 是一款自由的、开源的、高性能的 HTTP 服务器和反向代理服务器；
  同时也是一个 IMAP、POP3、SMTP 代理服务器；
  nginx 可以作为一个 HTTP 服务器进行网站的发布处理，
  另外 nginx 可以作为反向代理进行负载均衡的实现。
  二、反向代理 #   反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器
 要解释反向代理，我们就不得不先说下什么是代理？
那么什么是代理呢？
举个例子：代理 就如同生活中的专卖店～客人到 adidas 专卖店买了一双鞋，这个专卖店就是代理，被代理角色就是 adidas 厂家，目标角色就是用户。
那么什么是反向代理呢？
我们很多人应该都用过淘宝，要知道每天同时连接到淘宝网站的访问人数已经爆表，单个服务器远远不能满足人民日益增长的购买欲望了，此时就出现了一个大家耳熟能详的名词：分布式部署；
也就是通过部署多台服务器来解决访问人数限制的问题；淘宝网站中大部分功能也是直接使用 nginx 进行反向代理实现的，并且通过封装 nginx 和其他的组件之后起了个高大上的名字： Tengine
然后我们一起看个图： 上图表示的是全国各地的用户在淘宝客户端发出请求，经过了 Nginx 反向代理服务器，nginx 服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理。</description>
    </item>
    
    <item>
      <title>cdn</title>
      <link>https://huachengzhou.github.io/life/docs/http/cdn/</link>
      <pubDate>Wed, 05 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/http/cdn/</guid>
      <description>CDN #   CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输得更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。
  CDN的中文名字叫内容分发网络。字面理解就是用来做内容分发的一套网络体系，它是用来提升文件下载速度的一种机制。让用户能够从离自己最近的CDN服务器进行下载，减少路由次数，提升下载速度，缩短传输时间，提升用户使用体验
 CDN的好处 #     不用担心自己网站访客，在任何时间，任何地点，任何网络运营商，都能快速打开网站。    各种服务器虚拟主机带宽等采购成本，包括后期运维成本都会大大减少。    给网站直接带来的好处就是：流量，咨询量，客户量，成单量，都会得到大幅度提升。    CDN的价格 #  提起CDN，一般人都会望而却步，因为CDN太贵，都是大企业才能用得起的贵族式服务，而如今面对中小企业的CDN技术开发已经实现，并进入市场开始运营。
市面上CDN提供商计费方式多样，有按每月最低消费的，有按带宽收费的，有按请求数收费的，有包月包季包年限制的，还有些大多人看不懂的技术指标收费的，总之比较复杂，CDN服务在所有计费方式中，中小企业一致认为按流量收费最为合理，另外大多按流量计费方式中会有时间限制，规定时间内用不完就会全部作废，对于流量把握不好的中小企业，存在相当一部分浪费。
技术原理 #  CDN服务只可以用于静态数据的加速，动态接口不能使用CDN服务。
CDN的基本原理为反向代理，反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个节点服务器。通过部署更多的反向代理服务器，来达到实现多节点CDN的效果。 在描述CDN的实现原理，让我们先看传统的未加缓存服务的访问过程，以便了解CDN缓存访问方式与未加缓存访问方式的差别： [1] 用户提交域名→浏览器对域名进行解析→得到目的主机的IP地址→根据IP地址访问发出请求→得到请求数据并回复 由上可见，用户访问未使用CDN缓存网站的过程为: 1)、用户向浏览器提供要访问的域名； 2)、浏览器调用域名解析函数库对域名进行解析，以得到此域名对应的IP地址； 3)、浏览器使用所得到的IP地址，向域名的服务主机发出数据访问请求； 4)、浏览器根据域名主机返回的数据显示网页的内容。 通过以上四个步骤，浏览器完成从用户处接收用户要访问的域名到从域名服务主机处获取数据的整个过程。CDN网络是在用户和服务器之间增加Cache层，如何将用户的请求引导到Cache上获得源服务器的数据，主要是通过接管DNS实现，下面让我们看看访问使用CDN缓存后的网站的过程：
通过上图，我们可以了解到，使用了CDN缓存后的网站的访问过程变为： 1)、用户向浏览器提供要访问的域名； 2)、浏览器调用域名解析库对域名进行解析，由于CDN对域名解析过程进行了调整，所以解析函数库一般得到的是该域名对应的CNAME记录，为了得到实际IP地址，浏览器需要再次对获得的CNAME域名进行解析以得到实际的IP地址；在此过程中，使用的全局负载均衡DNS解析，如根据地理位置信息解析对应的IP地址，使得用户能就近访问。 3)、此次解析得到CDN缓存服务器的IP地址，浏览器在得到实际的IP地址以后，向缓存服务器发出访问请求； 4)、缓存服务器根据浏览器提供的要访问的域名，通过Cache内部专用DNS解析得到此域名的实际IP地址，再由缓存服务器向此实际IP地址提交访问请求； 5)、缓存服务器从实际IP地址得得到内容以后，一方面在本地进行保存，以备以后使用，另一方面把获取的数据返回给客户端，完成数据服务过程； 6)、客户端得到由缓存服务器返回的数据以后显示出来并完成整个浏览的数据请求过程。 通过以上的分析我们可以得到，为了实现既要对普通用户透明(即加入缓存以后用户客户端无需进行任何设置，直接使用被加速网站原有的域名即可访问，又要在为指定的网站提供加速服务的同时降低对ICP的影响，只要修改整个访问过程中的域名解析部分，以实现透明的加速服务，下面是CDN网络实现的具体操作过程。 1)、作为ICP，只需要把域名解释权交给CDN运营商，其他方面不需要进行任何的修改；操作时，ICP修改自己域名的解析记录，一般用cname方式指向CDN网络Cache服务器的地址。 2)、作为CDN运营商，首先需要为ICP的域名提供公开的解析，为了实现sortlist，一般是把ICP的域名解释结果指向一个CNAME记录； 3)、当需要进行sortlist时，CDN运营商可以利用DNS对CNAME指向的域名解析过程进行特殊处理，使DNS服务器在接收到客户端请求时可以根据客户端的IP地址，返回相同域名的不同IP地址； 4)、由于从cname获得的IP地址，并且带有hostname信息，请求到达Cache之后，Cache必须知道源服务器的IP地址，所以在CDN运营商内部维护一个内部DNS服务器，用于解释用户所访问的域名的真实IP地址； 5)、在维护内部DNS服务器时，还需要维护一台授权服务器，控制哪些域名可以进行缓存，而哪些又不进行缓存，以免发生开放代理的情况。</description>
    </item>
    
    <item>
      <title>java类型转换,构造,重要语法</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/basedir/dw7668daxw/</link>
      <pubDate>Wed, 05 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/basedir/dw7668daxw/</guid>
      <description>基本类型 #   八个基本类型:     基本类型 位数 字节 默认值 取值范围     byte 8 1 0 -128 ~ 127   short 16 2 0 -32768 ~ 32767   int 32 4 0 -2147483648 ~ 2147483647   long 64 8 0l -9223372036854775808 ~ 9223372036854775807   char 16 2 &amp;lsquo;u0000&amp;rsquo; 0 ~ 65535   float 32 4 0f 1.4E-45 ~ 3.4028235E38   double 64 8 0d 4.</description>
    </item>
    
    <item>
      <title>如何说话好听</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/good_voice/</link>
      <pubDate>Wed, 05 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/good_voice/</guid>
      <description>case 1 #  那就说说大多数人都喜欢的温柔通透的声音怎么发吧
第一你不要端着说话 像没有人自言自语一样放松的说话 声音像沉在腹部
第二感觉是用声带靠前的位置在发声 找不到就说Mi这个音 熟悉了用这个声带感觉说所有字
第三你发声时要感觉情绪上升 身体向外伸展 而身体内部是空的
第四感觉你的声音打在眉心位置 出来 从腹部直接跳到眉心 声带和嘴被忽视 没有任何意识和力量
第五说话时感觉字是竖起来的 不要咧嘴 要轻柔自然
第六 学好普通话&amp;hellip;.方言大多数会阻碍唱歌音色很容易改变 发声位置结构改变音色就一定会变
视频 建立自信 #  播音系师哥教你如何让“声音变得更加好听”，一学就会！一用就灵，不灵不要币
表情管理｜变美干货｜纵向微笑vs横向微笑｜如何拥有上镜显瘦的微笑｜播音生
下面的最靠谱 30天让你拥有好声音（完结）
说话很累 #  ①憋气，气息不通当我们的气息不顺畅时，我们的传声就会收到阻碍，使得我们口腔里面的部位造成紧张，从而引发一些列的声音问题。
②咬字器官紧张我们的咬字器官主要有唇、齿、舌、喉、牙等等&amp;hellip;，当我们在咬字的时候，如果出现唇部紧张或者说是舌根紧张等情况，会对我们的发声造成压力，使得我们的声音就会变得僵硬。
③喉咙没打开，捏着嗓子说话。我们的声带在喉咙里面，如果我们的声带没有合适的工作空间，那么会大大影响声带的振动发声哦！
④声音虚弱无力，声音漏气。当我们的声带漏气，我们的气息就会没办法高效利用起来，从而浪费掉，产生气息不够用等情况。</description>
    </item>
    
    <item>
      <title>零基础如何开始着手学习英语</title>
      <link>https://huachengzhou.github.io/life/docs/english_study/jkdy8dwywm/</link>
      <pubDate>Wed, 05 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/english_study/jkdy8dwywm/</guid>
      <description>只要你坚持学 哪怕不能一次性通过考试 但是你的成绩一定会进步的
  观点1  心态要做好准备，单词是学英语的基础，学一门语言是循序渐进的过程），见效慢，不要总想着一夜之间就能背下所有单词、一个月就能把英语说成母语。保持平常心。我说汉语这么多年，有时候还是会写错别字呀~
1.这个视频只适合真英语零基础的朋友，向他们提供一个可执行的自学英语。（零基础：不认识音标、看不进语法书，单词量很少）
2.学习的次序：先背单词，有一定单词量后（两三个月即可），再学语法（看语法书的同时，通过练习题或阅读文章巩固能力）。也有人边阅读边学单词，但在我不认识单词的时候，阅读效率很低；在有单词基础后，阅读效率更高。
3.是否看网课：可以先看着试试，如果发觉自己无法理解老师的话，还是回归到最基础的单词，先积累单词才能更好地理解课程讲解。（我在背完单词，看了一点点语法书后，再在B站看了一些语法视频，感觉效果更好）
4.零基础的学生：以12月的四级/六级考试为目标，设定150-200个/天的单词，坚持到考前，如果有收获就继续下去。
5.不要因为“害怕自己学不好、背单词总是记不住”的焦虑影响自己学习，记住一个单词都是收获。
6.遵循记忆的客观规律：遗忘是正常的，短时记忆的内容要通过反复编码才能存入长时记忆，所以坚持复习，不要轻易终止。（背单词难的不是“单词”，难的是坚持）
单词软件：扇贝单词（墨墨、百词斩都还可以）
语法书：《赖世雄经典语法》（我在16年买的，现在封面换了。这本书讲得很细，起点很低，但“缺点”也是太厚啦！）
文章阅读软件：扇贝系列的软件都不错（我也没用过别的）
方法没有好坏，每个人的认知风格都不同，没有优劣之分，适合自己的才是最好的。但学习有一个原则：任何方法，必须执行、坚持执行才可以见效。
  观点3
  新概念英语1 和新概念2 也是重复学习反复复习
  观点2
   着重点：从音标&amp;amp;单词开始； - 每天学习1~2小时； - 学习时常：1～2个月。  音标怎么练？  网上找音标视频or app； 熟悉音标，熟悉到看到一个陌生单词就能把它念出来。   词汇怎么练？  1.单独时间专门背单词；碎片化时间反复温习； 2.使用UP推荐的词根词缀去背单词 or 使用app背单词； 3.背单词时，最好边念边背，根据音节进行记忆，有辅助效果； 4.高频背单词(如一天复习个56次)，而不是长时间死磕在一个单词上； 5.生活中碰到不会的单词，记下来，拿回去背。身边软件改成英文版的。 6.推荐使用阅读记忆法。即可以巩固语法，也可巩固单词。        自己总结
  不管什么方法都尽量去围绕 语音 单词 语法 这三个方面(前期)</description>
    </item>
    
    <item>
      <title>Semaphore和Exchanger</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/semaphore_exchanger/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/semaphore_exchanger/</guid>
      <description>Semaphore #  1、Semaphore 是什么 #   Semaphore 通常我们叫它信号量， 可以用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源
  可以把它简单的理解成我们停车场入口立着的那个显示屏，每有一辆车进入停车场显示屏就会显示剩余车位减1，每有一辆车从停车场出去，显示屏上显示的剩余车辆就会加1，当显示屏上的剩余车位为0时，停车场入口的栏杆就不会再打开，车辆就无法进入停车场了，直到有一辆车从停车场出去为止
 2、使用场景 #   通常用于那些资源有明确访问数量限制的场景，常用于限流
  比如：数据库连接池，同时进行连接的线程有数量限制，连接不能超过一定的数量，当连接达到了限制数量后，后面的线程只能排队等前面的线程释放了数据库连接才能获得数据库连接。
  比如：停车场场景，车位数量有限，同时只能容纳多少台车，车位满了之后只有等里面的车离开停车场外面的车才可以进入
  20辆小轿车 3个车位 当车停入车位算抢占成功到释放出车位完成一个完整动作 锁定的位数 必然使用车位才合理 餐厅能够容纳16个人同时吃饭 但是吃饭的人总数有200个人 同意锁定的位数 也必然是16个餐位
 3、Semaphore常用方法说明 #  acquire() 获取一个令牌，在获取到令牌、或者被其他线程调用中断之前线程一直处于阻塞状态。 ​ acquire(int permits) 从此信号量获取给定数目的令牌，在提供这些许可前一直将线程阻塞，或者线程已被中断。 acquireUninterruptibly() 获取一个令牌，在获取到令牌之前线程一直处于阻塞状态（忽略中断）。 tryAcquire() 尝试获得令牌，返回获取令牌成功或失败，不阻塞线程。 ​ tryAcquire(long timeout, TimeUnit unit) 尝试获得令牌，在超时时间内循环尝试获取，直到尝试获取成功或超时返回，不阻塞线程。 ​ release() 释放一个令牌，唤醒一个获取令牌不成功的阻塞线程。 ​release(int permits) 释放给定数目的令牌，将其返回到信号量。 hasQueuedThreads() 等待队列里是否还存在等待线程。 ​ getQueueLength() 获取等待队列里阻塞的线程数。 ​ drainPermits() 清空令牌把可用令牌数置为0，返回清空令牌的数量。 ​ availablePermits() 返回可用的令牌数量。 4、用semaphore 实现停车场提示牌功能 #   每个停车场入口都有一个提示牌，上面显示着停车场的剩余车位还有多少，当剩余车位为0时，不允许车辆进入停车场，直到停车场里面有车离开停车场，这时提示牌上会显示新的剩余车位数</description>
    </item>
    
    <item>
      <title>node js - npm </title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/npm%E6%A8%A1%E5%9D%97%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/npm%E6%A8%A1%E5%9D%97%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6%E7%AE%80%E4%BB%8B/</guid>
      <description>npm 是 Node 的模块管理器，功能极其强大。它是 Node 获得成功的重要原因之一
  假如是nodejs 高版本 那么不需要再安装npm了因为node js已经包含了npm  一、从 npm install 说起 #   npm install 命令用来安装模块到node_modules目录。  $ npm install &amp;lt;packageName&amp;gt;   安装之前，npm install会先检查，node_modules目录之中是否已经存在指定模块。如果存在，就不再重新安装了，即使远程仓库已经有了一个新版本，也是如此。
  如果你希望，一个模块不管是否安装过，npm 都要强制重新安装，可以使用-f 或 &amp;ndash;force 参数。
  $ npm install &amp;lt;packageName&amp;gt; --force 二、npm update #   如果想更新已安装模块，就要用到npm update命令。  $ npm update &amp;lt;packageName&amp;gt;  它会先到远程仓库查询最新版本，然后查询本地版本。如果本地版本不存在，或者远程版本较新，就会安装。  三、registry #    npm update命令怎么知道每个模块的最新版本呢？
  答案是 npm 模块仓库提供了一个查询服务，叫做 registry 。以 npmjs.</description>
    </item>
    
    <item>
      <title>2022-10-25计划</title>
      <link>https://huachengzhou.github.io/life/docs/plan/dir/saxr6jwscz/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/plan/dir/saxr6jwscz/</guid>
      <description> 运动方面     星期一 星期二 星期三 星期四 星期五 星期六 星期天     在家做运动 在家做运动 在家做运动 在家做运动 外面跑步 外面跑步 外面跑步     朗读     星期一 星期二 星期三 星期四 星期五 星期六 星期天     每天十分钟 每天十分钟 每天十分钟 每天十分钟 每天十分钟 每天十分钟 每天十分钟    </description>
    </item>
    
    <item>
      <title>DOS基本命令 </title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/windows/dos_basic/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/windows/dos_basic/</guid>
      <description>DOS基本命令 #   wing+r ==&amp;gt; cmd 进入dos控制台   打开屏幕键盘  C:\Users\noatn&amp;gt;osk; dos各种操作查看参数用法 command params ==? command /?  C:\Users\noatn&amp;gt;cd /?显示当前目录名或改变当前目录。CHDIR [/D] [drive:][path]CHDIR [..]CD [/D] [drive:][path]CD [..].. 指定要改成父目录。键入 CD drive: 显示指定驱动器中的当前目录。不带参数只键入 CD，则显示当前驱动器和目录。使用 /D 开关，除了改变驱动器的当前目录之外，还可改变当前驱动器。如果命令扩展被启用，CHDIR 会如下改变:当前的目录字符串会被转换成使用磁盘名上的大小写。所以，如果磁盘上的大小写如此，CD C:\TEMP 会将当前目录设为C:\Temp。CHDIR 命令不把空格当作分隔符，因此有可能将目录名改为一个带有空格但不带有引号的子目录名。例如:cd \winnt\profiles\username\programs\start menu与下列相同:cd &amp;quot;\winnt\profiles\username\programs\start menu&amp;quot;在扩展停用的情况下，你必须键入以上命令。  显示文件夹列表 dir
  改变目录 cd</description>
    </item>
    
    <item>
      <title>DOS基本命令 (新) </title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/windows/hksdjahjra/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/windows/hksdjahjra/</guid>
      <description>命令格式 #    命令 子命令 参数 操作 选项
  /? /help 获取详细的帮助信息
  D:\data\game\temp&amp;gt;net user /help 此命令的语法是: NET USER [username [password | *] [options]] [/DOMAIN] username {password | *} /ADD [options] [/DOMAIN] username [/DELETE] [/DOMAIN] username [/TIMES:{times | ALL}] username [/ACTIVE: {YES | NO}] NET USER 将创建并修改计算机上的用户帐户。在不使用命令开关的情况下， 将列出计算机的用户帐户。用户帐户信息存储在用户帐户数据库中。 username 为可添加、删除、修改或查看的用户帐户的名称。用户帐户名称 最多可以有 20 个字符。 password 指定或更改用户帐户的密码。密码的长度必须符合 NET ACCOUNTS 命令的 /MINPWLEN 选项所设置的最小长度。 最多可以有 14 个字符。 * 生成密码提示。在密码提示下键入密码时，将不会显示密码。 /DOMAIN 在当前域的域控制器上执行此操作。 /ADD 向用户帐户数据库添加用户帐户。 /DELETE 从用户帐户数据库删除用户帐户。 选项 如下所示: 选项 描述 -------------------------------------------------------------------- /ACTIVE:{YES | NO} 激活或取消激活帐户。如果该帐户处于非激活状态， 用户将无法访问服务器。默认设置为“YES”。 /COMMENT:&amp;#34;text&amp;#34; 提供有关用户帐户的描述性注释。请将文本用引号 括起来。 /COUNTRYCODE:nnn 使用操作系统国家/地区代码执行指定的语言文件， 以显示用户帮助和错误消息。值 0 表示使用默认 的国家/地区代码。 /EXPIRES:{date | NEVER} 如果设置了日期，可导致帐户过期。 NEVER 将帐户设置为无时间限制。 过期日期采用格式 mm/dd/yy(yy)。 月份可以是一个数字、完整字母拼写， 或使用三个字母的缩写。年份可以使用两位数字 或四位数字。使用斜线(/)(不留空格) 将日期的各个部分隔开。 /FULLNAME:&amp;#34;name&amp;#34; 用户的全名(而不是用户名)。请将该名称用引号 括起来。 /HOMEDIR:pathname 用户的主目录设置路径。该路径必须存在。 /PASSWORDCHG:{YES | NO} 指定用户是否可以更改其密码。默认设置 为“YES”。 /PASSWORDREQ:{YES | NO} 指定用户帐户是否必须拥有密码。 默认设置为“YES”。 /LOGONPASSWORDCHG:{YES|NO} 指定用户是否应在下次登录时更改其密码。 默认设置为“NO”。 /PROFILEPATH[:path] 为用户登录配置文件设置路径。 /SCRIPTPATH:pathname 用户登录脚本的位置。 /TIMES:{times | ALL} 登录小时数。TIMES 表示为 day[-day][,day[-day]],time[-time][,time [-time]]，增量限制为 1 小时。 日期可以是完整拼写，也可以是缩写。 小时可以是 12 或 24 小时表示法。对于 12 小时表示法，请使用 am、pm、a.</description>
    </item>
    
    <item>
      <title>EL基础教程 </title>
      <link>https://huachengzhou.github.io/life/docs/javadir/basedir/jsp_dir/jsp_el%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/basedir/jsp_dir/jsp_el%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</guid>
      <description>EL基础教程 #  El标签语法 #   ${参数名}
 EL标签的功能 #    可以访问JSP中不同的域的对象    可以访问JavaBean中的属性    可以访问集合元素    支持简单的运算操作   访问JSP中不同的域的对象 #  &amp;lt;%pageContext.setAttribute(&amp;quot;name1&amp;quot;, &amp;quot;zhangsan&amp;quot;);request.setAttribute(&amp;quot;name2&amp;quot;, &amp;quot;lisi&amp;quot;);session.setAttribute(&amp;quot;name3&amp;quot;, &amp;quot;wangwu&amp;quot;);application.setAttribute(&amp;quot;name4&amp;quot;, &amp;quot;liuliu&amp;quot;);%&amp;gt;&amp;lt;!--范围.参数名 --&amp;gt;${pageScope.name1 } ${requestScope.name2 } ${sessionScope.name3 }${applicationScope.name4 }&amp;lt;br&amp;gt;&amp;lt;!-- 直接写参数名称 --&amp;gt;${name1 } ${name2 } ${name3 } ${name4 } 访问JavaBean中的属性 #  &amp;lt;%User user=new User(&amp;quot;zhangsan&amp;quot;,20,&amp;quot;北京&amp;quot;);request.</description>
    </item>
    
    <item>
      <title>groovy 数据类型 </title>
      <link>https://huachengzhou.github.io/life/docs/javadir/groovy/groovy%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/groovy/groovy%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>Groovy 数据类型 #   在任何编程语言中，需要使用各种变量来存储各种类型的信息。变量只是保留值的存储位置,这意味着，当你创建一个变量，你保留在内存中的一些空间来存储与变量相关的值。
  您可能喜欢存储各种数据类型的信息，如字符串，字符，宽字符，整数，浮点数，布尔值等。基于变量的数据类型，操作系统分配内存并决定什么可以存储在保留的存储器中。
 内置数据类型 #   byte -这是用来表示字节值。例如2。 short -这是用来表示一个短整型。例如10。 int -这是用来表示整数。例如1234。 long -这是用来表示一个长整型。例如10000090。 float -这是用来表示32位浮点数。例如12.34。 double -这是用来表示64位浮点数，这些数字是有时可能需要的更长的十进制数表示。例如12.3456565。 char -这定义了单个字符文字。例如“A”。 Boolean -这表示一个布尔值，可以是true或false。 String -这些是以字符串的形式表示的文本。例如，“Hello World”的  绑定值 #     类型 值     byte -128到127   short -32,768到32,767   int 2,147,483,648 到,147,483,647   long -9,223,372,036,854,775,808到+9,223,372,036,854,775,807   float 1.40129846432481707e-45到3.40282346638528860e + 38   double 4.</description>
    </item>
    
    <item>
      <title>python 函数</title>
      <link>https://huachengzhou.github.io/life/docs/python/base/lambda_or_function/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/python/base/lambda_or_function/</guid>
      <description>function #   函数是一种仅在调用时运行的代码块
  创建函数  在 Python 中，使用 def 关键字定义函数
def fun1(): print(&amp;#34;这是一个函数&amp;#34;) def fun2 (): pass fun2() fun1()  默认参数值  def funX(a = &amp;#39;zkdsh&amp;#39;): print(a) funX()  返回值  def addFun(x,y): return x + y print(f&amp;#34;addFun 调用 {addFun(2,3)}&amp;#34;) Lambda #  lambda 函数是一种小的匿名函数。
lambda 函数可接受任意数量的参数，但只能有一个表达式
 语法  lambda arguments : expression 简单尝试  import random import math fun1 = lambda a, b: print(a + b) fun1(random.</description>
    </item>
    
    <item>
      <title>学习计划</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/2021-04%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</link>
      <pubDate>Sun, 17 Jan 2021 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/2021-04%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</guid>
      <description>  Java 消息中间件 RabbitMq 和 kafka (建议学习RabbitMq)
  web socket or spring socket
  springboot (spring cloud考虑)
  redis (深入使用)
  mysql 这次复习以往 突破 存储和锁 如行锁
  java 并发(深入)
  nio netty
  </description>
    </item>
    
    <item>
      <title>Aspose</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/tooldoc/aspose/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/tooldoc/aspose/</guid>
      <description>Aspose.word组件介绍 #  1.基本介绍 #   Aspose.Words是一个商业.NET类库，可以使得应用程序处理大量的文件任务。Aspose.Words支持Doc，Docx，RTF，HTML，OpenDocument，PDF，XPS，EPUB和其他格式。使用Aspose.Words可以在不使用Microsoft.Word的情况下生成、修改、转换和打印文档。在项目中使用Aspose.Words可以有以下好处。
 1.1丰富的功能集 #   其丰富的功能特性主要有以下4个方面:
   格式转换。Aspose.Words具有高质量的文件格式转换功能，可以和Doc，OOXL，RTF，TXT等格式互相转换。
  文档对象模型。通过丰富的API以编程方式访问所有的文档元素和格式，允许创建，修改，提取，复制，分割，加入，和替换文件内容。
  文件渲染。可以在服务器端转换整个文档或者页面为PDF，XPS，SWF格式，同样可以转换文档页面为图像格式，或者.NET Graphics对象，这些功能和Microsoft.Word是一样的。
  报表。可以从对象或者数据源填充模版生成文件。
  1.2不需要Microsoft.Word #   Aspose.Words可以在没有安装Microsoft Office的机器上工作。所有的Aspose组件都是独立，不需要微软公司的授权。总之， Aspose.Words在安全性、稳定性、可扩展性、速度、价格和自动化功能方面，是一个很不错的选择。
 1.3独立的平台 #   Aspose.Words可以运行在Windows，Linux和Mac OS操作系统上面。可以使用Aspose.Words去创建32位或者64位的.NET应用程序，包括Asp.NET、WCF、WinForm等等，还可以使用Com组件在Asp、Perl、PHP和Python语言中使用，同样可以在Mono平台上使用Aspose.Words建立.NET应用程序。
 1.4性能和可伸缩性 #   Aspose.Words可以运行在服务器和客户端，它是一个独立的.NET程序集，可以被任何.NET应用程序复制和部署。使用Aspose.Words可以在短时间内产生成千上万的文档，可以打开文档，并修改格式和内容，填充数据并保存。Aspose.Words是多线程安全的，不同的线程在同一时间处理不同的文档。
 1.5最小的学习曲线 #   虽然Aspose.Words拥有150多个公共类和枚举类型，但是Aspose.Words的学习曲线很小因为Aspose.Words的API是围绕下列目标精心设计的：
   借鉴一些著名的API设计经验，如Microsoft Word。
  借鉴.NET框架设计指南的经验。
  提供易于使用的详细的文档元素操作文档。
   以前在项目中使用Microsoft Word的开发者，可以在Aspose.</description>
    </item>
    
    <item>
      <title>关键名词解释</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/essential_glossary/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/essential_glossary/</guid>
      <description>锁分类 #  轻量级锁 #   Displaced Mark Word(置换标记字)   线程在执行同步块之前,JVM会先在当前线程的栈帧中创建用于存储记录的空间,并将对象头中的Mark Word复制到锁记录中,官方称为Displaced Mark Word 。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功,当前线程获得锁,如果失败,表示其他线程竞争锁,当前线程便尝试 使用自旋来获取锁。
 白话 #  在进入同步块之前JVM会在当前线程的&amp;#34;栈帧中申请并创建锁记录的空间,接着把对象头的标识符写到锁记录中&amp;#34; 然后使用CAS将当前线程的锁记录的地址(指针)替换掉锁对应的对象中的标识符,CAS操作成功表示获得锁CAS 操作失败尝试使用自旋(就是在当前进程并且执行代码块的线程内的时间片下空循环烧CPU反正现代计算机大多都是多核处理器在短时间内不会太影响其他任务处理)来获取锁 锁的撤销 #  要想撤销轻量级锁(解锁) 对象头中标识符必须设回为Displaced Mark Word 因此使用CAS操作将Displaced Mark Word替换回到对象头里面,成功那么撤销成功,失败说明有其它线程还在竞争此对象的锁这个时候 锁就会立即膨胀成重量级锁,后续的加锁和解锁都按照重量级锁的操作来 偏向锁 #   当一个线程访问同步块(部分文档和解释说也包括同步方法)并获取锁时,会在对象头和栈帧中的锁记录里存在存储偏向锁的线程ID, 以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁,只需要简单测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁 .如果测试成功,表示已经获取到了锁。如果测试失败,则需要再测试一下Mark word中偏向锁的标识符是否设置成1:如果没有设置,则使用CAS竞争锁; 如果设置了,则尝试使用CAS将对象头的偏向锁指向当前线程(实际就是在对象头锁记录存入线程标识的数据,当然顺带栈帧记录也得存入有关的锁记录数据)
 白话 #  当只有一个线程或者多个线程中最先执行到同步块的时候 这个时候测试完没有偏向锁立即设置完对应的标识记录和锁记录就开始执行同步代码了, 假如下次再进入并且锁没有升级那么仅仅简单测试通过又继续执行了 在这最开始到结束全程没有各种加锁操作甚至连CAS都很有可能没有(是有可能有CASC操作的这涉及到偏向锁的撤销机制) 相比同步操作消耗很少 因此很划算的 当有多个线程竞争锁的时候 这个时候系统检测到了并且达到了锁升级的约束条件那么就会立即执行升级操作即便获得执行条件正在的线程 (当然必须等执行线程中的某个原子操作或者若干原子操作组成的原语)也要对锁记录进行升级然后才开始升级 优点: 把整个同步都消除掉，连CAS操作都不去做了，优于轻量级锁 缺点: 如果程序中大多数的锁都总是被多个不同的线程访问，那偏向锁就是多余的   偏向锁是JDK6时加入的一种锁优化机制
  锁的撤销</description>
    </item>
    
    <item>
      <title>操作系统的特征</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/one_chapter/1_2_/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/one_chapter/1_2_/</guid>
      <description>一:知识总览 #  二:分类描述 #   1:操作系统的特征——并发   2:操作系统的特征——共享   3:操作系统的特征——并发和共享的关系   4:操作系统的特征——虚拟   5:操作系统的特征——异步   总结  </description>
    </item>
    
    <item>
      <title>标准的分类</title>
      <link>https://huachengzhou.github.io/life/docs/computer_network/network_architecture/1.1.2%E6%A0%87%E5%87%86%E5%8C%96%E5%B7%A5%E4%BD%9C%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%BB%84%E7%BB%87/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/computer_network/network_architecture/1.1.2%E6%A0%87%E5%87%86%E5%8C%96%E5%B7%A5%E4%BD%9C%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%BB%84%E7%BB%87/</guid>
      <description>标准的分类 #  法定标准 #   由权威机构制定的正式的、合法的标准 OSI  事实标准 #   某些公司的产品在竞争中占据了主流 ， TCP/IP 时间长了，这些产品中的协议和技术就成了标准  RFC #    因特网标准的形式 (4个阶段)
  1:因特网草案
  2:建议标准
  3:草案标准
  4:因特网标准
  国际标准化组织 ISO (最重要) #  国际电信联盟 ITU #  国际电气电子工程协会 IEEE #  </description>
    </item>
    
    <item>
      <title>进程的状态与转换</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_1_2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_1_2/</guid>
      <description></description>
    </item>
    
    <item>
      <title>python NumPy  </title>
      <link>https://huachengzhou.github.io/life/docs/python/install/numpy/</link>
      <pubDate>Thu, 02 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/python/install/numpy/</guid>
      <description>NumPy #  什么是 NumPy #  NumPy 是用于处理数组的 python 库。
它还拥有在线性代数、傅立叶变换和矩阵领域中工作的函数。
NumPy 由 Travis Oliphant 于 2005 年创建。它是一个开源项目，您可以自由使用它。
NumPy 指的是数值 Python（Numerical Python）
为何使用 NumPy？ #  在 Python 中，我们有满足数组功能的列表，但是处理起来很慢。
NumPy 旨在提供一个比传统 Python 列表快 50 倍的数组对象。
NumPy 中的数组对象称为 ndarray，它提供了许多支持函数，使得利用 ndarray 非常容易。
数组在数据科学中非常常用，因为速度和资源非常重要。
数据科学：计算机科学的一个分支，研究如何存储、使用和分析数据以从中获取信息。</description>
    </item>
    
    <item>
      <title>从此你不再受伤害</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/iqcs36rgjy/tbwyjex4gc/</link>
      <pubDate>Sun, 29 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/iqcs36rgjy/tbwyjex4gc/</guid>
      <description>从此你不再受伤害 #  一:痛苦的本质是什么 #  没有痛苦就没有快乐 如果我从来都不饿,那么对我来说就不是快乐
痛苦越大,快乐也就越大; 莫大的快乐一定是因为,你之前莫大的痛苦而这个痛苦被解决的那一瞬间你感到莫大的快乐 所以快乐和痛苦相互转化 或者说它们本身就是同一件事情
痛苦不就是需求得到满足吗 那么如果你的需求很容易或者很快就得到满足 这不就是快乐吗 当你的需求能够很容易就得到满足 你不会陷入快乐,你会陷入无聊,然后你无聊之后你又会想找刺激,刺激里面一定包含痛苦 所以我们人就是不断在无聊和痛苦之间相互摇摆,然后在这个相互摇摆之间 某个微妙的平衡点 我们感到一瞬间的快乐 当你真正理解快乐就是瞬间,并且它只能是瞬间,而痛苦才是常态,你会很神奇地发现 你的人生就会变得不那么痛苦 有一些人活得非常痛苦 他们整天抱怨 觉得命运对他们非常不公平 为什么别人都活得那么快乐 但是自己却总是那么痛苦 但是你所理解地别人活得快乐,也是因为你从朋友圈里面 看到了别人分享的那些瞬间
二:如何应对他人的攻击和批评 #  从此你的境界会永远高于那些骂你的人,而你不会被他们的言辞所伤害 这并不意味着我们不回击,我们可以和他们吵 ,但是我们回击是为了教会他人和我们相处的正确方式 也就是我们利用我们的愤怒 来让他人知道 他们和我们原先交流的方式是有问题的 但是并不意味着我们内心真正地破碎或者失控 在这个部分也会阐述所谓地“情商”
三:攻击与指责 #  当他人批评攻击我们 我们该怎样应对 首先百分之八十情况下 大部分都对我们构成不了实质伤害,而是我们自己加于自己的一些伤害 比如说有些人非常在意他人的看法,但是很多时候他人 对你的负面看法是你自己想象出来的 而他人实际上并没有那个意思,我唱歌唱得不好听我还上台去唱,那我就是丢人现眼 但是其实很多时候观众根本就不care,你唱得还不好 他们只是想被娱乐而已 好,就算有人不喜欢你 不喜欢 它其实是一种非常私人得、内心得想法 你是管不到这种事情 或者说你也没有权力去管 别人喜不喜欢你 如果他不喜欢你 导致他做出了对你伤害性得行为 这种事情我们另谈,但是你没有必要管得这么宽,管道别人心里 究竟是对你什么样的看法 因为他确实有这样的自由
扮演角色 #  当一个人在攻击和批评你的时候,他到底攻击 批评的是什么
在你的认知里一个封闭的高铁空间内,大家都是奔波的旅人 需要一个舒适的休息环境 在这个环境内 其实大家都需要扮演好&amp;quot;有素质的乘客&amp;quot; 这个角色,也就意味着你不能抽烟 不能在车厢内大声喧哗或者发出给其他乘客 带来困扰性的声音,当有人没有扮演好这个角色 你会感到生气 所以其实你的攻击并不上升到对那个人 本身的攻击 而只停留于对他这个角色的攻击 而你希望的 也仅仅是他扮演好他的角色 其实 放眼到其他所有的场景都是一样的 , 就是他人在攻击或者批评你的时候 他们都不是在攻击你的本人,而是在攻击你没有扮演好你的角色, 他们想要的也只是你扮演好你的角色 他们 攻击不到你 因为他们并不知道真正的你是谁 真正的你是你所有角色的总和 但是我们在不同人或者不同场景中 势必要扮演不同的角色</description>
    </item>
    
    <item>
      <title>看书看到大脑疲劳以后，应如何快速恢复大脑状态</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/gsmgajphs7/</link>
      <pubDate>Sun, 09 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/gsmgajphs7/</guid>
      <description>看书看到大脑疲劳以后，应如何快速恢复大脑状态  参考1 #   很多工作狂人都希望能够不浪费生命里的每一分钟，但从神经生物学的角度这是不实际的，就和CPU在高速运转时会发热一样，大脑在学习思考的时候也会产生大量的代谢废物，这些有害的蛋白如果不被及时清理，想要继续高效工作就很困难，而脑脊液会在大脑中循环，通过和脑间液交换物质，把废物带走，但是这个过程在清醒时并不快，睡眠时会清理得更快
   一些可行的建议
  运动 有研究表明，运动会促进大脑和外围组织发生细胞自噬，就是说，运动可以促进神经元自己把废物给吞掉，然后降解，所以你可以在学习疲劳后运动一会儿再接着学习。
  睡觉 之前说了，睡觉时清除代谢废物的速度是比醒着的时候快的，所以你可以小睡一会儿再接着学习。
  营养 大脑是一个非常昂贵的器官，消耗大量能量，所以保证充足的营养也是高效学习的一个基本条件。
  咖啡及类似的提高神经系统兴奋性的药物 咖啡因和腺嘌呤核苷类似，都可以和腺嘌呤核苷受体结合，而当腺嘌呤核苷与它的受体结合后可以减缓神经细胞的活动，一般在睡眠时两者结合。咖啡因与腺嘌呤核苷受体结合后不促使细胞活动降低，相反地，它阻止腺嘌呤核苷与它的接受器结合，其结果是神经细胞活动增高。不过它的作用很短暂，而且会对腺嘌呤核苷更加敏感，也就会越来越困，并不是持久之计。
  参考2 #   大脑一直刻意地紧着一根弦看书，很累，并并不是专注地读书时进入的精神内敛的状态，用坏脑子，用坏眼睛。而大脑疲惫的时候，是需要通过脑脊液冲刷掉有害蛋白，去修复大脑
 最常用的办法就是呼吸和冥想 ，我记得最重要的事：呼吸是正念的矛，不要评判自己，不要过度批判自己。
静坐，步行冥想，这是解决自动运行状态的，仔细感受脚底与地面接触的感觉，试着感受走路身体的每一位的感觉，这种将注意力集中在自己身体每个部位，给自己做的每个动作贴标签，这是一种非常简单的脱离自动驾驶的办法，如果你要想养成一个习惯，给自己一个板机，我一洗澡就要睡觉，一戴上手表就学习，这是一种非常重要的办法
学会睡觉，就寝和睡觉的时间要确定
上床之前把一天的担心写在纸上，不然要一直记在心里，可以轻松很多
早上起来要晒太阳，会很大程度解决你的疲劳感，中午可以睡觉，不要超过半小时，不然会进入深度睡眠区
避免睡前一小时吃东西，不要在床上看手机看电脑，要让大脑记住床是睡觉的地方
心里很烦睡不着觉，慈悲心正念能够有效地给变你跟别人的关系，先呼吸十分钟，想象自己要关心的人的对象，注意的感觉，感受你的心跳加速，希望你能避开风险，希望你幸福安心，希望你健健康康，你需要更多地观爱，这个办法很有效地放松大脑，有效地释放善意很有办法
疲劳会以缺乏善意的方式来表现
学会接触大自然，能够把自己从日常工作学习中解放出来，接触非人工产物
接触美的事物
压力呼吸化法。这是消解焦虑很好的办法。内心的反映，身体的变化，用一句话来描述压力的成因。像平常一样把注意力集中在呼吸上，你试着把集中在呼吸上的扩散出来，想象自己身体每个部位呼吸，无精打采，你的身体会撞到平常不会撞的地方，注意力不集中，治疗身体疲劳，终究是大脑和内心的恶问题
参考</description>
    </item>
    
    <item>
      <title>100篇锻炼口才表达能力的绕口令（精选版）</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/hw2jindwcd/</link>
      <pubDate>Wed, 05 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/hw2jindwcd/</guid>
      <description>1、初入江湖：化肥会挥发
2、小有名气：黑化肥发灰，灰化肥发黑
3、名动一方：黑化肥发灰会挥发；灰化肥挥发会发黑
4、天下闻名：黑化肥挥发发灰会花飞；灰化肥挥发发黑会飞花
5、一代宗师：黑灰化肥会挥发发灰黑讳为花飞；灰黑化肥会挥发发黑灰为讳飞花
6、超凡入圣：黑灰化肥灰会挥发发灰黑讳为黑灰花会飞；灰黑化肥会会挥发发黑灰为讳飞花化为灰　7、天外飞仙：黑化黑灰化肥灰会挥发发灰黑讳为黑灰花会回飞；灰化灰黑化肥会会挥发发黑灰为讳飞花回化为灰
8、喇嘛和哑巴
打南边来了个喇嘛，手里提拉着五斤鳎(tǎ) 目。打北边来了个哑巴，腰里别着个喇叭。
南边提拉着鳎目的喇嘛要拿鳎目换北边别喇叭哑巴的喇叭。
哑巴不愿意拿喇叭换喇嘛的鳎目，喇嘛非要换别喇叭哑巴的喇叭。
喇嘛抡起鳎目抽了别喇叭哑巴一鳎目，哑巴摘下喇叭打了提拉着鳎目的喇嘛一喇叭。也不知是提拉着鳎目的喇嘛抽了别喇叭哑巴一鳎目，还是别喇叭哑巴打了提拉着鳎目的喇嘛一喇叭。
喇嘛炖鳎目，哑巴嘀嘀哒哒吹喇叭。
9、六十六头牛
六十六岁的陆老头，盖了六十六间楼，买了六十六篓油，养了六十六头牛，栽了六十六棵垂杨柳。
六十六篓油，堆在六十六间楼；六十六头牛，扣在六十六棵垂杨柳。
忽然一阵狂风起，吹倒了六十六间楼，翻倒了六十六篓油，折断了六十六棵垂杨柳，砸死了六十六头牛，急煞了六十六岁的陆老头。
10、老六放牛
柳林镇有个六号楼，刘老六住在六号楼。
有一天，来了牛老六，牵了六只猴；来了侯老六，拉了六头牛；来了仇老六，提了六篓油；来了尤老六，背了六匹绸。
牛老六、侯老六、仇老六、尤老六，住上刘老六的六号楼，半夜里，牛抵猴，猴斗牛，撞倒了仇老六的油，油坏了尤老六的绸。
牛老六帮仇老六收起油，侯老六帮尤老六洗掉绸上油，拴好牛，看好猴，一同上楼去喝酒。
11、天上七颗星
天上七颗星，地上七块冰，台上七盏灯，树上七只莺，墙上七枚钉。
吭唷吭唷拔脱七枚钉。喔嘘喔嘘赶走七只莺。乒乒乓乓踏坏七块冰。一阵风来吹来七盏灯。一片乌云遮掉七颗星。
12、连念七遍就聪明
天上七颗星，地下七块冰，树上七只鹰，梁上七根钉，台上七盏灯。
呼噜呼噜扇灭七盏灯，噯唷噯唷拔掉七根钉，呀嘘呀嘘赶走七只鹰，抬起一脚踢碎七块冰，飞来乌云盖没七颗星。一连念七遍就聪明。
13、司小四和史小世
司小四和史小世，四月十四日十四时四十上集市，司小四买了四十四斤四两西红柿，史小世买了十四斤四两细蚕丝。
司小四要拿四十四斤四两西红柿换史小世十四斤四两细蚕丝。
史小世十四斤四两细蚕丝不换司小四四十四斤四两西红柿。
司小四说我四十四斤四两西红柿可以增加营养防近视，
史小世说我十四斤四两细蚕丝可以织绸织缎又抽丝。
14、酸枣子
山上住着三老子，山下住着三小子，山腰住着三哥三嫂子。
山下三小子，找山腰三哥三嫂子，借三斗三升酸枣子，
山腰三哥三嫂子，借给山下三小子三斗三升酸枣子。
山下三小子，又找山上三老子，借三斗三升酸枣子，
山上三老子，还没有三斗三升酸枣子，
只好到山腰找三哥三嫂子，给山下三小子借了三斗三升酸枣子。
过年山下三小子打下酸枣子，还了山腰三哥三嫂子，两个三斗三升酸枣子。
15、墙上一根钉
墙上一根钉，钉上挂条绳，绳下吊个瓶，瓶下放盏灯。
掉下墙上钉，脱掉钉上绳。滑落绳下瓶，打碎瓶下灯。
瓶打灯，灯打瓶，瓶说灯，灯骂绳，瓶说绳，绳说钉，丁丁当当，乒乓乓乓。
16、板凳与扁担
板凳宽，扁担长。
扁担没有板凳宽，
板凳没有扁担长。
扁担在绑在板凳上，
板凳不让扁担绑在板凳上，
扁担偏要扁担绑在板凳上。
17、白老八
白老八门前栽了八颗白果树，
从北边飞来了八个白八哥儿不知在哪住。
白老八拿了八个巴达棍儿要打八个白八哥儿，
八个八哥儿飞上了八颗白果树，
不知道白老八拿这八个巴达棍儿打着了八个白八哥儿，
还是打着了八颗白果树。
18、鹅和鸽
天上一群大白鸽，河里一群大白鹅。
白鸽尖尖红嘴壳，白鹅曲项向天歌。
白鸽剪开云朵朵，白鹅拨开浪波波。
鸽乐呵呵，鹅活泼波，
白鹅白鸽碧波男天真快乐。
19、水连天
天连水，水连天，
水天一色望无边，</description>
    </item>
    
    <item>
      <title>DNS</title>
      <link>https://huachengzhou.github.io/life/docs/http/dns/</link>
      <pubDate>Wed, 05 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/http/dns/</guid>
      <description>DNS #  DNS 是互联网核心协议之一。不管是上网浏览，还是编程开发，都需要了解一点它的知识。
本文详细介绍DNS的原理，以及如何运用工具软件观察它的运作。我的目标是，读完此文后，你就能完全理解DNS
一、DNS 是什么？ #  DNS （Domain Name System 的缩写）的作用非常简单，就是根据域名查出IP地址。你可以把它想象成一本巨大的电话本。
举例来说，如果你要访问域名math.stackexchange.com，首先要通过DNS查出它的IP地址是151.101.129.69。
二、查询过程 #  虽然只需要返回一个IP地址，但是DNS的查询过程非常复杂，分成多个步骤。
工具软件dig可以显示整个查询过程。
$ dig math.stackexchange.com DNS大全 #   公共DNS服务器地址大全     服务商 云公共DNS服务器IP大全 云公共DNS服务器IP大全     114DNS 114.114.114.114 114.114.115.115   DNSPod DNS+ 119.29.29.29 182.254.116.116   电信/移动/铁通 101.226.4.6 218.30.118.6   DNS 派 联通 123.125.81.6 140.207.198.6   cnnicDNS 1.2.4.8 210.2.4.8   2001:dc7:1000::1     GoogleDNS 8.</description>
    </item>
    
    <item>
      <title>异常机制详解</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/basedir/java-basic-x-exception/</link>
      <pubDate>Wed, 05 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/basedir/java-basic-x-exception/</guid>
      <description>demo #  </description>
    </item>
    
    <item>
      <title>cas</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/cas/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/cas/</guid>
      <description>概念 #   CAS即Compare and Swap，是基于硬件级别的指令实现的同步原语，Java并发包java.utile.concurrent许多同步类基于CAS构建，因此可见CAS的重要性  模拟 #   有安全问题的一段code  public class Demo1 { public static void main(String[] args) throws Exception { long startTime = System.currentTimeMillis(); Demo_B demo_b = new Demo_B(); final int len = 10000000; Thread t1 = new Thread(() -&amp;gt; { for (int i = 0; i &amp;lt; len; i++) { demo_b.increase(); } }); t1.start(); for (int i = 0; i &amp;lt; len; i++) { demo_b.</description>
    </item>
    
    <item>
      <title>CountDownLatch 和 CyclicBarrier</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/countdownlatch_cyclicbarrier/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/countdownlatch_cyclicbarrier/</guid>
      <description>CountDownLatch是减法操作 CyclicBarrier具有CountDownLatch的所有功能
 CountDownLatch #    CountDownLatch中count down是倒数的意思，latch则是门闩的含义。整体含义可以理解为倒数的门栓,所以当门打开时,N个人是不能进屋的,也就是N个线程是不能继续向下运行的,支持这样的特性可以控制线程执行任务的时机,使线程以 &amp;ldquo;组团&amp;quot;的方式一起执行任务
   CountDownLatch中count down是倒数的意思，latch则是门闩的含义。整体含义可以理解为倒数的门栓，似乎有一点“三二一，芝麻开门”的感觉。CountDownLatch的作用也是如此，在构造CountDownLatch的时候需要传入一个整数n，在这个整数“倒数”到0之前，主线程需要等待在门口，而这个“倒数”过程则是由各个执行线程驱动的，每个线程执行完一个任务“倒数”一次。总结来说，CountDownLatch的作用就是等待其他的线程都执行完任务，必要时可以对各个任务的执行结果进行汇总，然后主线程才继续往下执行
   CountDownLatch主要有两个方法：countDown()和await()。countDown()方法用于使计数器减一，其一般是执行任务的线程调用，await()方法则使调用该方法的线程处于等待状态，其一般是主线程调用。这里需要注意的是，countDown()方法并没有规定一个线程只能调用一次，当同一个线程调用多次countDown()方法时，每次都会使计数器减一；另外，await()方法也并没有规定只能有一个线程执行该方法，如果多个线程同时执行await()方法，那么这几个线程都将处于等待状态，并且以共享模式享有同一个锁。
   await()方法 一般是使用者或者主线程调用 countDown()方法 子任务线程组调用
  第一个例子
  import java.util.concurrent.CountDownLatch; public class CountDownLatchExample2 { public static class MyService { private CountDownLatch downLatch = new CountDownLatch(1) ; public void testMethod(){ try { System.out.println(&amp;#34;任务执行开始前!&amp;#34;); //await()方法则使调用该方法的线程处于等待状态，其一般是主线程调用  downLatch.await(); System.out.println(&amp;#34;任务执行结束!&amp;#34;); } catch (InterruptedException e) { e.printStackTrace(); } } public void downMethod(){ System.</description>
    </item>
    
    <item>
      <title>2023-01-18待处理任务清单</title>
      <link>https://huachengzhou.github.io/life/docs/plan/dir/cahh4sbqzx/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/plan/dir/cahh4sbqzx/</guid>
      <description>待处理任务清单 #    java类型转换,构造,重要语法
  异常机制详解
  反射机制详解
  注解机制详解
  泛型机制详解
  nginx 学习
  mycat学习
  RocketMQ 学习
  python学习
  英语学习
  c++学习
  科目三学习
  科目四学习
  口才练习
  锻炼身体
  dos学习
  linux shell centos安装软件学习
  人际关系 剖析 笔记撰写
  社哲讲堂 剖析 笔记撰写
  计算机网络 笔记撰写</description>
    </item>
    
    <item>
      <title>DOS基本文件操作命令 </title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/windows/dos_file/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/windows/dos_file/</guid>
      <description>DOS基本文件操作命令 #    wing+r ==&amp;gt; cmd 进入dos控制台
  D:
  进入D盘 cd命令  CD命令是更改目录命令 如果要进入D盘不用这个命令直接输入 D: 回车 即可例如:C:\Users\HP&amp;gt;D:D:\&amp;gt;D:\&amp;gt;dir驱动器 D 中的卷是 新加卷卷的序列号是 DAB4-11FED:\ 的目录2019-10-10 14:15 &amp;lt;DIR&amp;gt; 360极速浏览器下载2020-01-13 13:47 &amp;lt;DIR&amp;gt; BaiduNetdiskDownload2020-01-20 13:59 &amp;lt;DIR&amp;gt; CS2019-12-13 16:53 &amp;lt;DIR&amp;gt; data2020-02-10 15:55 &amp;lt;DIR&amp;gt; IdeaProjects2019-12-06 15:01 &amp;lt;DIR&amp;gt; log2019-10-23 10:40 &amp;lt;DIR&amp;gt; MailMasterData2019-09-29 10:43 &amp;lt;DIR&amp;gt; output2020-01-13 13:40 &amp;lt;DIR&amp;gt; soft2020-02-04 17:43 &amp;lt;DIR&amp;gt; temp2020-01-15 18:05 &amp;lt;DIR&amp;gt; ultraeditWork2019-12-10 09:47 &amp;lt;DIR&amp;gt; workspace0 个文件 0 字节12 个目录 463,738,040,320 可用字节D:\&amp;gt;cd CSD:\CS&amp;gt; /*进入了CS目录**/ cd .</description>
    </item>
    
    <item>
      <title>jsp jstl core 标签库 </title>
      <link>https://huachengzhou.github.io/life/docs/javadir/basedir/jsp_dir/jsp_jstl_core%E6%A0%87%E7%AD%BE%E5%BA%93/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/basedir/jsp_dir/jsp_jstl_core%E6%A0%87%E7%AD%BE%E5%BA%93/</guid>
      <description>JSTL标签库 #  JSTL主要有五大类标签库
 core标签库(核心标签库),包括通用标签(输出标签),流程控制和循环控制标签 fmt标签库,包括格式化,国际格式化标签等 fn标签库,函数标签库 XML标签库,关于XML操作的标签库 SQL标签库,操作数据库标签  core标签库用法 #  使用core标签前必须添加taglie指令
 %@ taglib prefix=&amp;ldquo;c&amp;rdquo; uri=&amp;ldquo;http://java.sun.com/jsp/jstl/core&amp;quot; %&amp;gt;
  &amp;lt;c:set&amp;gt;在某个范围设定某个值   &amp;lt;c:set value=&amp;ldquo;表达式&amp;rdquo; var=&amp;ldquo;varname&amp;rdquo; [scope=&amp;ldquo;request|page|session|application&amp;rdquo;]&amp;gt;&amp;lt;/c:set&amp;gt;
 &amp;lt;c:set value=&amp;quot;${1+2 }&amp;quot; var=&amp;quot;variable&amp;quot;&amp;gt;&amp;lt;/c:set&amp;gt;${variable } &amp;lt;c:out&amp;gt;把表达式的结构输出到页面中   &amp;lt;c:out value=&amp;ldquo;表达式&amp;rdquo; [escapeXml=&amp;ldquo;true|false&amp;rdquo;]&amp;gt;&amp;lt;/c:out&amp;gt;
 &amp;lt;c:set value=&amp;quot;${1+2 }&amp;quot; var=&amp;quot;variable&amp;quot;&amp;gt;&amp;lt;/c:set&amp;gt;&amp;lt;c:out value=&amp;quot;${variable }&amp;quot;&amp;gt;&amp;lt;/c:out&amp;gt; &amp;lt;c:if&amp;gt;条件判断   &amp;lt;c:if test=&amp;ldquo;判断条件&amp;rdquo; [var=&amp;ldquo;varname&amp;rdquo;] [scope=&amp;ldquo;request|page|session|application&amp;rdquo;]&amp;gt; 条件为真执行的语句 &amp;lt;/c:if&amp;gt;
 &amp;lt;c:if test=&amp;quot;${1&amp;lt;2 }&amp;quot; var=&amp;quot;result&amp;quot;&amp;gt;&amp;lt;c:out value=&amp;quot;${result }&amp;quot;&amp;gt;&amp;lt;/c:out&amp;gt;&amp;lt;/c:if&amp;gt; &amp;lt;c:choose&amp;gt;,&amp;lt;c:when&amp;gt;,&amp;lt;c:otherwise&amp;gt;流程控制标签   &amp;lt;c:choose&amp;gt; &amp;lt;c:when test=&amp;ldquo;表达式&amp;rdquo;&amp;gt; 表达式为真执行的语句 &amp;lt;/c:when&amp;gt; [&amp;lt;c:otherwise&amp;gt; 表达式为假执行的语句 &amp;lt;/c:otherwise&amp;gt;] &amp;lt;/c:choose&amp;gt;</description>
    </item>
    
    <item>
      <title>python set</title>
      <link>https://huachengzhou.github.io/life/docs/python/base/set/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/python/base/set/</guid>
      <description>集合（Set） #   集合是无序和无索引的集合。在 Python 中，集合用花括号编写
  无法通过引用索引来访问 set 中的项目，因为 set 是无序的，项目没有索引
  集合一旦创建，无法更改项目，但是可以添加新项目
 import random import time import datetime set1 = {random.random() * 100, time.time_ns(), datetime.datetime.year, datetime.datetime.month, datetime.datetime.day} print(f&amp;#34;set1:{set1}&amp;#34;) for x in set1: print(x) # print(set1[0]) # del set1[0] 添加 / 添加多个 #   集合不能空 否则add会出问题的
 import datetime import random nowDate = datetime.datetime.now() set2 = {nowDate.year, nowDate.month, nowDate.day} print(set2) set2.add(&amp;#34;kk&amp;#34;) print(set2) set3 = {random.</description>
    </item>
    
    <item>
      <title>python 模块介绍</title>
      <link>https://huachengzhou.github.io/life/docs/python/base/module/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/python/base/module/</guid>
      <description>模块介绍 #  time模块 #  datetime模块 #  random 模块 #  os 模块 #  sys 模块 #  json 和 pickle 模块 #  hashlib和hmac 模块 #  logging 模块 #  numpy 模块 #  pandas 模块 #  matplotlib 模块 #  re 模块 #  typing 模块 #  collections 模块 #  pathlib 模块 #  pathlib 是 Python 内置库，Python 文档给它的定义是 Object-oriented filesystem paths（面向对象的文件系统路径）。pathlib 提供表示文件系统路径的类，其语义适用于不同的操作系统。路径类在纯路径之间划分，纯路径提供纯粹的计算操作而没有 I / O，以及具体路径，它继承纯路径但也提供 I / O 操作。</description>
    </item>
    
    <item>
      <title>apache FilenameUtils 文件名称操作</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/tooldoc/commons_io/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/tooldoc/commons_io/</guid>
      <description>org.apache.commons.io.FilenameUtils 文件名称操作 #    FilenameUtils.getExtension(fileName) 获取文件后缀 //text
  FilenameUtils.getName(fileName) 获取文件完整名称 //c.text
  FilenameUtils.getBaseName(fileName) 获取文件名称 //c
  FilenameUtils.getFullPath(fileName) 获取文件的完整路径 //D:\data\
  String path = &amp;quot;D:\\data\\假设开发法土地模板.docx&amp;quot; ;String fullPath = FilenameUtils.getFullPath(path);System.out.println(&amp;quot;fullPath:&amp;quot;+fullPath);//D:\data\String name = FilenameUtils.getName(path);System.out.println(&amp;quot;name:&amp;quot;+name); //假设开发法土地模板.docxString prefix = FilenameUtils.getPrefix(path);System.out.println(&amp;quot;prefix:&amp;quot;+prefix); //D:\int prefixLength = FilenameUtils.getPrefixLength(path);System.out.println(&amp;quot;prefixLength:&amp;quot;+prefixLength); //3String path1 = FilenameUtils.getPath(path);System.out.println(&amp;quot;path:&amp;quot;+path1); //data\String baseName = FilenameUtils.getBaseName(path);System.out.println(&amp;quot;baseName:&amp;quot;+baseName); //假设开发法土地模板String extension = FilenameUtils.getExtension(path);System.</description>
    </item>
    
    <item>
      <title>testng 学习与使用</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/middleware/testng/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/middleware/testng/</guid>
      <description>TestNG介绍 #   TestNG是Java中的一个测试框架， 类似于JUnit 和NUnit, 功能都差不多， 只是功能更加强大，使用也更方便Java中已经有一个JUnit的测试框架了。 TestNG比JUnit功能强大的多。 测试人员一般用TestNG来写自动化测试。 开发人员一般用JUnit写单元测试。
 TestNG的基本注解 #     说明 示 例     @BeforeSuite 在该套件的所有测试都运行在注释的方法之前，仅运行一次。   @AfterSuite 在该套件的所有测试都运行在注释方法之后，仅运行一次。   @BeforeClass 在调用当前类的第一个测试方法之前运行，注释方法仅运行一次。   @AfterClass 在调用当前类的第一个测试方法之后运行，注释方法仅运行一次   @BeforeTest 注释的方法将在属于标签内的类的所有测试方法运行之前运行。   @AfterTest 注释的方法将在属于标签内的类的所有测试方法运行之后运行。   @BeforeGroups 配置方法将在之前运行组列表。 此方法保证在调用属于这些组中的任何一个的第一个测试方法之前不久运行。   @AfterGroups 此配置方法将在之后运行组列表。该方法保证在调用属于任何这些组的最后一个测试方法之后不久运行。   @BeforeMethod 注释方法将在每个测试方法之前运行。   @AfterMethod 注释方法将在每个测试方法之后运行。   @DataProvider 标记一种方法来提供测试方法的数据。 注释方法必须返回一个Object [] []，其中每个Object []可以被分配给测试方法的参数列表。 要从该DataProvider接收数据的@Test方法需要使用与此注释名称相等的dataProvider名称。   @Factory 将一个方法标记为工厂，返回TestNG将被用作测试类的对象。 该方法必须返回Object []。   @Listeners 定义测试类上的侦听器。   @Parameters 描述如何将参数传递给@Test方法。   @Test 将类或方法标记为测试的一部分。    Testng翻译 #   org.</description>
    </item>
    
    <item>
      <title>基本命令</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_basis/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_basis/</guid>
      <description>停止命令：net stop mysql
  启动命令：net start mysql
  登陆 mysql -u 用户名 -p
  查看数据库版本: mysql &amp;ndash;version：用于在未登录情况下，查看本机mysql版本,select version();：登录情况下，查看链接的库版本
  显示所有数据库：show databases;
  进入指定的库：use 库名;
  显示当前库中所有的表：show tables;
  查看其他库中所有的表：show tables from 库名;
  查看表的创建语句：show create table 表名;
  查看表结构：desc 表名;
  SQL的语言分类 #  DQL（Data Query Language）：数据查询语言select 相关语句DML（Data Manipulate Language）：数据操作语言insert 、update、delete 语句DDL（Data Define Languge）：数据定义语言create、drop、alter 语句TCL（Transaction Control Language）：事务控制语言set autocommit=0、start transaction、savepoint、commit、rollbackmysql语法规范 #  不区分大小写，但建议关键字大写，表名、列名小写每条命令最好用英文分号结尾每条命令根据需要，可以进行缩进或换行注释单行注释：#注释文字单行注释：-- 注释文字 ，注意， 这里需要加空格多行注释：/* 注释文字 */MySQL删除数据库中的所有表 #  SELECT CONCAT(&#39;drop table &#39;,table_name,&#39;;&#39;) FROM information_schema.</description>
    </item>
    
    <item>
      <title> 操作系统的发展与分类 </title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/one_chapter/1_3_/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/one_chapter/1_3_/</guid>
      <description>一:知识总览 #  二:分类描述 #   1:手工操作阶段   2:批处理阶段——单道批处理系统   引入脱机输入/输出技术（用外围机+磁带完成），并由监督程序负责控制作业的输入、输出
  和上面不同的是不必等结果输出在执行而是计算机执行完毕马上将结果输入磁带中并在同事已经开始执行其它数据程序
  3:批处理阶段——多道批处理系统   4:分时操作系统   5:实时操作系统   主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性  三:其他几种操作系统 #   网络操作系统：是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信。（如：Windows NT 就是一种典型的网络操作系统，网站服务器就可以使用） 分布式操作系统：主要特点是分布性和并行性。系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务。 个人计算机操作系统：如 Windows XP、MacOS，方便个人使用。  四:知识回顾与重要考点 #  </description>
    </item>
    
    <item>
      <title>进程控制</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_1_3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_1_3/</guid>
      <description></description>
    </item>
    
    <item>
      <title>速率</title>
      <link>https://huachengzhou.github.io/life/docs/computer_network/network_architecture/1.1.3%E9%80%9F%E7%8E%87%E7%9B%B8%E5%85%B3%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/computer_network/network_architecture/1.1.3%E9%80%9F%E7%8E%87%E7%9B%B8%E5%85%B3%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</guid>
      <description>速率 #   速率即数据率或称数据传输率或比特率
  速率即数据率或称数据传输率或比特率 比特 1/0 位 连接在计算机网络上的主机在数字信道上传输数据位数的速率 单位是b/s , kb/s,Gb/s,Gb/s ,Tb/s 发送端 ==&amp;gt; 接收端 速率是10b/s 0101010101  宽带 #   &amp;ldquo;带宽&amp;quot;原本指某个信号具有的频道宽度，即最高频率与最低频率之差，单位是赫兹(Hz) 计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一点到另一点所能通过的&amp;quot;最高数据率&amp;rdquo;。单位是&amp;quot;比特/秒&amp;quot;  吞吐量 #   表示在单位时间内通过某个网络(或信道、接口)的数据量。单位b/s,kb/s,Mb/s 吞吐量受网络的带宽或网络的额定速率的限制   时延 #    时延 = 发送时延 + 传播时延 + 排队时延 + 处理时延
  发送时延 : 从发送分组的第一个比特算起，到分组的最后一个比特发送完毕所需的时间(分组交换/路由器将数据推到信道上的时间)
  传播时延 : 这里看什么介质来传播数据 计算机网络中是 数字信号 -&amp;gt; 模拟信号 因此假如是光纤那么传播速度非常快2x⑩9 当然也有用无线电波我个人不知道无限电波是怎样模拟的无法知道速度究竟怎样,公示 传播时间 = 数据长度 / 传播速率(发送速率,带宽)</description>
    </item>
    
    <item>
      <title>python 环境变量</title>
      <link>https://huachengzhou.github.io/life/docs/python/base/venv/</link>
      <pubDate>Wed, 15 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/python/base/venv/</guid>
      <description>创建虚拟环境 : python -m venv 项目名  noatn@DESKTOP-CCD057N MINGW64 /d/CS/python_venv $ python -m venv my_venv  检查创建的环境变量  \my_venv\Lib\site-packages\easy_install.py \my_venv\Lib\site-packages\pip\_internal\build_env.py \my_venv\Lib\site-packages\pip\_internal\cache.py \my_venv\Lib\site-packages\pip\_internal\cli\autocompletion.py \my_venv\Lib\site-packages\pip\_internal\cli\base_command.py \my_venv\Lib\site-packages\pip\_internal\cli\cmdoptions.py \my_venv\Lib\site-packages\pip\_internal\cli\main_parser.py \my_venv\Lib\site-packages\pip\_internal\cli\parser.py \my_venv\Lib\site-packages\pip\_internal\cli\status_codes.py \my_venv\Lib\site-packages\pip\_internal\cli\__init__.py \my_venv\Lib\site-packages\pip\_internal\cli\__pycache__\autocompletion.cpython-38.pyc \my_venv\Lib\site-packages\pip\_internal\cli\__pycache__\base_command.cpython-38.pyc \my_venv\Lib\site-packages\pip\_internal\cli\__pycache__\cmdoptions.cpython-38.pyc \my_venv\Lib\site-packages\pip\_internal\cli\__pycache__\main_parser.cpython-38.pyc \my_venv\Lib\site-packages\pip\_internal\cli\__pycache__\parser.cpython-38.pyc \my_venv\Lib\site-packages\pip\_internal\cli\__pycache__\status_codes.cpython-38.pyc \my_venv\Lib\site-packages\pip\_internal\cli\__pycache__\__init__.cpython-38.pyc \my_venv\Lib\site-packages\pip\_internal\commands\check.py \my_venv\Lib\site-packages\pip\_internal\commands\completion.py \my_venv\Lib\site-packages\pip\_internal\commands\configuration.py \my_venv\Lib\site-packages\pip\_internal\commands\debug.py \my_venv\Lib\site-packages\pip\_internal\commands\download.py \my_venv\Lib\site-packages\pip\_internal\commands\freeze.py \my_venv\Lib\site-packages\pip\_internal\commands\hash.py \my_venv\Lib\site-packages\pip\_internal\commands\help.py \my_venv\Lib\site-packages\pip\_internal\commands\install.py \my_venv\Lib\site-packages\pip\_internal\commands\list.py \my_venv\Lib\site-packages\pip\_internal\commands\search.py \my_venv\Lib\site-packages\pip\_internal\commands\show.py \my_venv\Lib\site-packages\pip\_internal\commands\uninstall.py \my_venv\Lib\site-packages\pip\_internal\commands\wheel.py \my_venv\Lib\site-packages\pip\_internal\commands\__init__.py \my_venv\Lib\site-packages\pip\_internal\commands\__pycache__\check.cpython-38.pyc \my_venv\Lib\site-packages\pip\_internal\commands\__pycache__\completion.cpython-38.pyc \my_venv\Lib\site-packages\pip\_internal\commands\__pycache__\configuration.cpython-38.pyc \my_venv\Lib\site-packages\pip\_internal\commands\__pycache__\debug.cpython-38.pyc \my_venv\Lib\site-packages\pip\_internal\commands\__pycache__\download.cpython-38.pyc \my_venv\Lib\site-packages\pip\_internal\commands\__pycache__\freeze.cpython-38.pyc \my_venv\Lib\site-packages\pip\_internal\commands\__pycache__\hash.cpython-38.pyc \my_venv\Lib\site-packages\pip\_internal\commands\__pycache__\help.cpython-38.pyc \my_venv\Lib\site-packages\pip\_internal\commands\__pycache__\install.cpython-38.pyc \my_venv\Lib\site-packages\pip\_internal\commands\__pycache__\list.cpython-38.pyc \my_venv\Lib\site-packages\pip\_internal\commands\__pycache__\search.cpython-38.pyc \my_venv\Lib\site-packages\pip\_internal\commands\__pycache__\show.cpython-38.pyc \my_venv\Lib\site-packages\pip\_internal\commands\__pycache__\uninstall.cpython-38.pyc \my_venv\Lib\site-packages\pip\_internal\commands\__pycache__\wheel.cpython-38.pyc \my_venv\Lib\site-packages\pip\_internal\commands\__pycache__\__init__.cpython-38.pyc \my_venv\Lib\site-packages\pip\_internal\configuration.py \my_venv\Lib\site-packages\pip\_internal\distributions\base.py \my_venv\Lib\site-packages\pip\_internal\distributions\installed.py \my_venv\Lib\site-packages\pip\_internal\distributions\source.py \my_venv\Lib\site-packages\pip\_internal\distributions\wheel.</description>
    </item>
    
    <item>
      <title>关于爱情令人不解的一切</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/iqcs36rgjy/x8benctsak/</link>
      <pubDate>Sun, 29 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/iqcs36rgjy/x8benctsak/</guid>
      <description>关于爱情令人不解的一切 #  </description>
    </item>
    
    <item>
      <title>男生 穿着 和 仪态</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/x5ws5dsp8a/</link>
      <pubDate>Sun, 09 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/x5ws5dsp8a/</guid>
      <description>这方面我再考虑 是不是可以去咨询一下那些专业的人员 现在不是有很多信息咨询分析师吗
 发型 #  参考</description>
    </item>
    
    <item>
      <title>反射机制详解</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/basedir/java-basic-x-reflection/</link>
      <pubDate>Wed, 05 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/basedir/java-basic-x-reflection/</guid>
      <description>demo #  </description>
    </item>
    
    <item>
      <title>发声 具体训练方法</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/2bm8trpqzx/</link>
      <pubDate>Wed, 05 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/2bm8trpqzx/</guid>
      <description>先简单了解一下我们的语音产生原理：人的发音是由多个系统协作完成的 #   人的发音是由多个系统协作完成的   1、众所周知，肺储存空气。通过呼吸系统，空气进入肺部，在说话时腹肌收缩使横膈膜向上，挤出肺部的空气，形成气流。肺部呼出的气流是语音产生的原动力，依靠呼吸系统构建的动力系统，产生气流及声门下压力。 2、气流来到振动系统，在动力作用下，声带产生振动，形成基础的声音。 3、声音通过咽腔、口腔、鼻腔、胸腔等共鸣腔体对声音进行调制，最后经过唇、齿、舌、腭构音器官的精细加工形成最终的语音。  【以下是一些具体训练方法】 #  一、练共鸣腔让你的声音浑厚。 #  二、练气息，为你说话提供动力 #  三、练咬字器官，助你发音清晰响亮。 #  四、练好普通话的声调，增强你的语言魅力。参考以下的方法感受一下发音时胸腔的震动，以及声音的浑厚度。 #  1、用非常低沉的声音叹气：哎&amp;hellip;&amp;hellip;（练习15次以上）
2、闭着嘴巴发音：嗯——（延长音，一口气一次，练15次以上）
3、发延长的音：yu——（一口气一次，练15次以上）
如果你想要更稳定有力的胸腔共鸣，可以扩展咽腔。方法如下：
1、闭着嘴打哈欠，注意要挺软腭，咽壁绷紧，放松下巴，舌尖轻轻抵住下齿，尽量把舌根往下压，体会咽腔的扩张感。（至少做20个）
2、深吸气，吸气时不要耸肩，不能抬胸，小声地持续发“yu”，最好一口气坚持发音15秒以上。同时应该注意：舌根降下去，舌面呈凹槽状，软腭提起，嘴巴搓圆，把力量集中在唇部的中间。
注：要特意训练口腔，加大口腔后部的空间，提起颧肌，打开牙关，挺起软腭，放松下巴 ，这些要经常训练。 说话的时候尽量把口咽腔扩展开，不然，舌骨向后上方移动，牵动喉头上起，声音通道变窄，咬字就会紧，喉部肌肉没有弹性，就会造成发声的紧张吃力，发音不仅暗沉，还很扁。
练气息丹田是气的泵。
《难经.六十六难》云:“丹田者，人之根本也。”又说:“脐下动气者，人之生命也。 ”脐下就是指丹田，丹田是生命的大本营，是气的工厂和仓库，是人体全身“气”的营运供应中心。
丹田是气的泵，气息聚集在丹田，随时可以供输全身，当然也为我们的播音或平时健康用嗓提供良好的服务。
其实，刚刚开始学习的时候，对丹田的感受不是很强烈的。我们可以先用腹式呼吸， 牵动你的丹田，让你有丹田位置的感受。经常有意识地训练，感受就会越来越明显，然后才会有丹田运气的表现，精气会越来越足，够支撑你的发声。
腹式呼吸： #  放松肩部，鼻子吸气，嘴巴呼气，横膈膜会下降，腹压增加，感觉好像是空气直接进入腹部，腹部会自动隆起，隆起的幅度要尽当时的能力，尽量达到极限量。 然后用口慢慢呼气，腹壁下陷恢复自然状态。
具体练习方法： #  1、憋气吸气下沉，憋住，看看能不能憋1—2分钟，实在忍不住的时候，连接胸部和腹部的肌肉会颤抖，那里是横膈膜所在地。这个要大量练习。
2、假装擤鼻涕只用鼻子吸气下沉，憋一会儿，然后快速地用鼻子把气“擤”出去，同时感受横膈膜的上下弹动。这个环节的练习可以增强对横膈膜的敏感度。
3、吸气下沉，一口气不断，发“si”音。这个过程一定要慢，气息输出要均匀，同时计算一下时间，看看自己一口气可以坚持多久。多练几次，循序渐进。
进阶：保持气息，形成支撑。 #  鼻子吸入气息，横膈膜下降，保持气息，憋几秒钟，然后嘴巴微张，很慢很慢地吹出气息，看看一口气是否可以平稳地输出15秒，同时体会气流被拉住的感觉。
进阶：气息和声音结合，练气为主，发声为辅。 #  1、提起颧肌，打开牙关，挺软腭放松下巴的前提下，轻柔舒服地发a音，感受热气从嘴巴呼出，声音稳定、小声地发出，一口气一次，尽量拉长发音，反复练习。
2、双手插腰，一口气快速用力的小声发“hu”的音，体会气息从小腹到额咽处冲出的感觉，腹部及横膈膜会弹动。反复练习。
练唇舌 #  唇部操可以增强唇部的力量和灵活性
撅唇咧唇：
在提颧肌的情况下，唇部沿着牙齿向中间撮合，再慢慢展开。这样反复练习20-30次，颧肌发酸，嘴唇酸麻发热都是正常的副作用。
绕唇：
嘴巴合拢撅起来顺时针绕15圈，逆时针绕15圈。
喷唇：</description>
    </item>
    
    <item>
      <title>Phaser</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/phaser/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/phaser/</guid>
      <description>Phaser #  java7中引入了一种新的可重复使用的同步屏障,称为移相器Phaser
Phaser拥有与CyclicBarrier和CountDownLatch类似的功劳.但是这个类提供了更加灵活的应用.CountDownLatch和CyclicBarrier都是只适用于固定数量的参与者.移相器适用于可变数目的屏障,在这个意义上,可以在任何时间注册新的参与者.并且在抵达屏障是可以注销已经注册的参与者.因此,注册到同步移相器的参与者的数目可能会随着时间的推移而变化
如CyclicBarrier一样,移相器可以重复使用,这意味着当前参与者到达移相器后,可以再一次注册自己并等待另一次到达.因此,移相器会有多代.一旦为某个特定相位注册的所有参与者都到达移相器,就增加相数.相数从零开始,在达到Integer.MAX_VALUE后,再次绕回0.当移相器发生变化时,通过重写onAdvance方法,可以自行可选操作.这个方法也可用于终止移相器.移相器一旦被终止,所有的同步方法就会立即返回,并尝试注册新的失败的参与者
移相器的另一个重要特征是:移相器可能是分层的,这允许你以树形结构来安排移相器以减少竞争.很明显,更小的组将拥有更少的竞争同步的参与者.因此,将大量的参与者分成较小的组可以减少竞争.虽然创建移相器能增加中的吞吐量,但是这需要更多的开销.最后,移相器的另一个重要的特征在于监控功能,使用独立的对象可以监视移相器的当前状态.监视器可以查询注册到移相器的参与者的数量,以及已经到达和还没有到达某个特定相数的参与者的数量
Phaser中是通过计数器来控制。在Phaser中计数器叫做parties， 我们可以通过Phaser的构造函数或者register()方法来注册
通过调用register()方法，我们可以动态的控制phaser的个数。如果我们需要取消注册，则可以调用arriveAndDeregister()方法
方法 #    register()
  注册一个需要协作的线程。
  bulkRegister(int parties)
  批量注册需要协作的线程。
  arrive()
  到达屏障直接执行，无需等待其他线程。
  arriveAndAwaitAdvance()
  到达屏障，必须等待其他线程。
  arriveAndDeregister()
  到达屏障，注销自己，无需等待其他线程到达。
  onAdvance(int phase, int registeredParties)
  参与协作的线程都到达屏障后，会调用该方法。
  例子 #   case 1  final Phaser phaser = new Phaser(3) { @Override protected boolean onAdvance(int phase, int registeredParties) { System.</description>
    </item>
    
    <item>
      <title> DOS网络操作命令 </title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/windows/dos_network/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/windows/dos_network/</guid>
      <description>DOS网络操作命令 #   netstat -ano (列出所有端口的情况)  PS C:\Users\noatn&amp;gt; netstat -ano活动连接协议 本地地址 外部地址 状态 PIDTCP 0.0.0.0:135 0.0.0.0:0 LISTENING 1028TCP 0.0.0.0:445 0.0.0.0:0 LISTENING 4TCP 0.0.0.0:1024 0.0.0.0:0 LISTENING 852TCP 0.0.0.0:1025 0.0.0.0:0 LISTENING 2232TCP 0.0.0.0:3306 0.0.0.0:0 LISTENING 3672TCP 0.0.0.0:5040 0.0.0.0:0 LISTENING 5660TCP 0.0.0.0:7680 0.0.0.0:0 LISTENING 6628TCP 0.0.0.0:49664 0.0.0.0:0 LISTENING 868TCP 0.0.0.0:49665 0.0.0.0:0 LISTENING 784TCP 0.0.0.0:49666 0.0.0.0:0 LISTENING 1580TCP 0.0.0.0:49667 0.</description>
    </item>
    
    <item>
      <title> groovy变量和数据类型 </title>
      <link>https://huachengzhou.github.io/life/docs/javadir/groovy/groovy%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8A%A0%E5%BC%BA/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/groovy/groovy%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8A%A0%E5%BC%BA/</guid>
      <description>groovy 变量和数据类型 #  groovy类型自动推断 #   先看有一段代码  def a = 12;def int a1 = 12;def a_type = a instanceof Integer ;def a1_type = a1 instanceof Integer ;println(a_type) ;println(a1_type) ;//打印结果如下truetrue 从上面我们可以看出a和a1实际推导出的类型是一样的,但是有哪些不同呢 接着我把上面的例子改了  def a = 12;def int a1 = 12;def a_type = a instanceof Integer ;def a1_type = a1 instanceof Integer ;println(a_type) ;println(a1_type) ;a = 52253.</description>
    </item>
    
    <item>
      <title> 操作系统的运行机制与体系结构 </title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/one_chapter/1_4_/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/one_chapter/1_4_/</guid>
      <description>运行机制 #  一: 知识总览 #  二: 预备知识：程序是如何运行的？ #  三:内核程序 v.s. 应用程序 #  四:特权指令 v.s. 非特权指令 #  五:内核态 v.s. 用户态 #  六:内核态、用户态 的切换 #  知识回顾与重要考点 #  体系结构 #  两种指令、两种处理器状态、两种程序 #  操作系统的内核 #   Yo~生活经验：我们安装完 Windows 操作系统后，会发现操作系统提供了多种多样的功能，比如“记事本”、 “任务管理器”。然而，这些功能并不是必不可少的。即使没有“任务管理器”，我们仍然可以使用计算机。
  内核是计算机上配置的底层软件，是操作系统最基本、最核心的部分。实现操作系统内核功能的那些程序就是内核程序。   计算机系统的层次结构  知识回顾与重要考点 #  </description>
    </item>
    
    <item>
      <title>JOL工具 </title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/jol/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/jol/</guid>
      <description>引入jol依赖 #  &amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;org.openjdk.jol&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;jol-core&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;0.9&amp;lt;/version&amp;gt;&amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;&amp;lt;/dependency&amp;gt;相关方法 #    1.使用jol计算对象的大小（单位为字节）：ClassLayout.parseInstance(obj).instanceSize()
  2.使用jol查看对象内部的内存布局：ClassLayout.parseInstance(obj).toPrintable()
  3.查看对象外部信息：包括引用的对象：GraphLayout.parseInstance(obj).toPrintable()
  4.查看对象占用空间总大小：GraphLayout.parseInstance(obj).totalSize()
  对象布局 空属性 #  import org.openjdk.jol.info.ClassLayout; public class Entity { public static void main(String[] args) { Entity entity = new Entity(); // 打印java 对象内存布局  System.out.println(ClassLayout.parseInstance(entity).toPrintable()); } } // 输出结果 com.brown.Entity object internals: // Entity对象内存布局  OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) 05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315) 12 4 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 4 bytes external = 4 bytes total OFFSET：偏移地址，单位字节 SIZE：占用的内存大小，单位为字节 TYPE DESCRIPTION： 类型描述，其中object header为对象头； object header：对象头 loss due to the next object alignment：由于下一个对象对齐而导致的丢失（有4Byte是对齐的字节（因为在64位虚拟机上对象的大小必须是8的倍数）,由于这个对象里面没有任何字段，故而对象的实例数据为0Byte）。 VALUE : 对应内存中当前存储的值； Instance size：实例字节数值大小（**此处一个空的java对象（不包含任意字段属性）实例，其实例大小为``16Byte**） 对象布局 有属性 #  /** * 带有属性的 实体类 */ public class Student { private String name; private Integer age; } public class DemoT1 { public static void main(String[] args) { Student o = new Student(); System.</description>
    </item>
    
    <item>
      <title>jsp jstl session </title>
      <link>https://huachengzhou.github.io/life/docs/javadir/basedir/jsp_dir/jsp_jstl_session/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/basedir/jsp_dir/jsp_jstl_session/</guid>
      <description>Session #   HTTP是无状态协议，这意味着每次客户端检索网页时，都要单独打开一个服务器连接，因此服务器不会记录下先前客户端请求的任何信息 #    会话,当用户打开一个浏览器连接到web应用或者打开某个页面,直到关闭浏览器这个过程叫做会话 #    Session是保存在服务器上的数据结构，用于跟踪用户的状态。此数据可以保存在群集、数据库、文件中 #   Session常用方法 #    public boolean isNew()
返回是否为一个新的客户端，或者客户端是否拒绝加入session     public Enumeration getAttributeNames()
返回session对象中所有的对象名称     public int getMaxInactiveInterval()
返回最大时间间隔，以秒为单位，servlet 容器将会在这段时间内保持会话打开     public long getCreationTime()
返回session对象被创建的时间， 以毫秒为单位，从1970年1月1号凌晨开始算起     public long getLastAccessedTime()
返回客户端最后访问的时间，以毫秒为单位，从1970年1月1号凌晨开始算起     public Object getAttribute(String name)
返回session对象中与指定名称绑定的对象，如果不存在则返回null     public Object getAttribute(String name)</description>
    </item>
    
    <item>
      <title>python 字典</title>
      <link>https://huachengzhou.github.io/life/docs/python/base/dictionary/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/python/base/dictionary/</guid>
      <description>字典（Dictionary） #   字典有点像一个json对象 且不是json数组对象
  简单举例  dic1 = {&amp;#39;a&amp;#39;: &amp;#39;dsgs&amp;#39;} print(dic1) print(dic1.get(&amp;#34;a&amp;#34;)) 创建并打印字典 #  import random dicX = {} for x in range(1,10): dicX[str(x)] = random.randrange(int(&amp;#34;10&amp;#34;) , int(&amp;#34;10&amp;#34;+str(x))) print(dicX) 检查键是否存在 #  import random dic1 = {&amp;#39;x&amp;#39;:random.randrange(1,3000),&amp;#39;y&amp;#39;:random.randrange(1,3000)} print(dic1) print(f&amp;#34;x in dic1 :{&amp;#39;x&amp;#39; in dic1}&amp;#34;) 访问字典 #  dic20 = {&amp;#39;a&amp;#39;:&amp;#39;zxc&amp;#39;} print(dic20[&amp;#39;a&amp;#39;]) print(dic20.get(&amp;#34;a&amp;#34;)) 更改值 #  set2 = {&amp;#34;x&amp;#34;:1,&amp;#39;y&amp;#39;:2000} print(set2) set2[&amp;#39;x&amp;#39;] = 2 print(set2) values() #  import random dicX = {} for x in range(1,10): dicX[str(x)] = random.</description>
    </item>
    
    <item>
      <title>mycat 学习与使用</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/middleware/mycat/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/middleware/mycat/</guid>
      <description>一:MyCat是什么 #  一个彻底开源的，面向企业应用开发的大数据库集群
支持事务、ACID、可以替代MySQL的加强版数据库
一个可以视为MySQL集群的企业级数据库，用来替代昂贵的Oracle集群
一个融合内存缓存技术、NoSQL技术、HDFS大数据的新型SQL Server
结合传统数据库和新型分布式数据仓库的新一代企业级数据库产品
一个新颖的数据库中间件产品
目前仅仅实现了mysql协议
二:MyCat能做什么 #   1:数据库读写分离   2:数据分片   3:多数据源整合  三:MyCat原理 #  Mycat 的原理中最重要的一个动词是“拦截”，它拦截了用户发送过来的 SQL 语句，首先对 SQL语句做了一些特定的分析：如分片分析、路由分析、读写分离分析、缓存分析等，然后将此 SQL 发往后端的真实数据库，并将返回的结果做适当的处理，最终再返回给用户。
这种方式把数据库的分布式从代码中解耦出来，程序员察觉不出来后台使用 Mycat 还是MySQL。
四:MyCat实战 #  参考1 参考2</description>
    </item>
    
    <item>
      <title>数据准备</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_data/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_data/</guid>
      <description>数据准备  数据准备
drop datbase ch10; create database ch10; use ch10; drop table if EXISTS fruits ; CREATE TABLE fruits ( f_id char(10) NOT NULL, s_id INT NOT NULL, f_name char(255) NOT NULL, f_price decimal(8,2) NOT NULL, PRIMARY KEY(f_id) ); INSERT INTO fruits (f_id, s_id, f_name, f_price) VALUES(&amp;#39;a1&amp;#39;, 101,&amp;#39;apple&amp;#39;,5.2), (&amp;#39;b1&amp;#39;,101,&amp;#39;blackberry&amp;#39;, 10.2), (&amp;#39;bs1&amp;#39;,102,&amp;#39;orange&amp;#39;, 11.2), (&amp;#39;bs2&amp;#39;,105,&amp;#39;melon&amp;#39;,8.2), (&amp;#39;t1&amp;#39;,102,&amp;#39;banana&amp;#39;, 10.3), (&amp;#39;t2&amp;#39;,102,&amp;#39;grape&amp;#39;, 5.3), (&amp;#39;o2&amp;#39;,103,&amp;#39;coconut&amp;#39;, 9.2), (&amp;#39;c0&amp;#39;,101,&amp;#39;cherry&amp;#39;, 3.2), (&amp;#39;a2&amp;#39;,103, &amp;#39;apricot&amp;#39;,2.2), (&amp;#39;l2&amp;#39;,104,&amp;#39;lemon&amp;#39;, 6.4), (&amp;#39;b2&amp;#39;,104,&amp;#39;berry&amp;#39;, 7.6), (&amp;#39;m1&amp;#39;,106,&amp;#39;mango&amp;#39;, 15.</description>
    </item>
    
    <item>
      <title>分层结构</title>
      <link>https://huachengzhou.github.io/life/docs/computer_network/network_architecture/%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/computer_network/network_architecture/%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84/</guid>
      <description>为什么要分层，分层要做什么 #   （1）发起通信的计算机必须将数据通信的通路进行激活。 （2）要告诉网络如何识别目的主机。 （3）发起通信的计算机要查明目的主机是否开机，并且与网络连接正常。 （4）发起通信的计算机要弄清楚，对方计算机中文件管理程序是否已经做好准备工作。 （5）确保差错和意外可以解决。  正式认识分层结构 #   使用 协议 ，服务， 接口 来完成分层
 总结 #   网络体系结构是从功能上描述计算机网络结构 计算机网络体系结构简称网络体系结构是分层结构 每层遵循某个/多个网络协议以完成本层功能 计算机网络体系结构是计算机网络的各层及其协议的集合 上层要求服务 下层提供服务 实际是上层制定接口标准，下层实现接口标准  </description>
    </item>
    
    <item>
      <title>进程通信</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_1_4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_1_4/</guid>
      <description></description>
    </item>
    
    <item>
      <title>如何系统地训练口才</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/idx4etcwwy/</link>
      <pubDate>Wed, 05 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/idx4etcwwy/</guid>
      <description>如何系统地训练口才 #   从不敢在人前讲话到学院迎新晚会主持人，说说我的练习经历。
 一、首先练习自己的声音 #  因为人家听你讲话，第一注意到的就是声音，而后才是内容。
发音最重要的就是唇舌，唇舌力度够了，发音就会准确，字音会拉开，使自己的声音饱满动听一些。另外还要练习自己的气息，不然声音发不出去，嗓子会很难受。
△唇：八百标兵奔北坡，炮兵并排北边跑，炮兵怕把标兵碰，标兵怕把炮兵炮。
△舌：牛郎年年恋刘娘，刘娘连连恋牛郎。牛郎恋刘娘，刘娘念牛郎，郎念娘来，娘恋郎。
△气息：出东门,过大桥,大桥前面一树枣,拿着竿子去打枣,青的多,红的少,一个枣,两个枣,三个枣,四个枣,五个枣,六个枣,七个枣,八个枣,九个枣,十个枣;十个枣,九个枣,八个枣,七个枣,六个枣,五个枣,四个枣,三个枣,两个枣,一个枣,这是一个绕口令,一口气说完才算好。
△躺下来朗读：躺下来时，用的是腹式呼吸，这是练声练气的最好方法。每天睡觉之前，躺着大声朗读十分钟，每天起床之前，先唱首歌。坚持一两个月，觉会感觉自己的呼吸流畅了，声音洪亮，音质也好听了。
二、模仿名人的演讲 (快速的学习一个新的技能最好的就是模仿) #  刚开始的时候，很难找到自己演讲，发言的风格，所以先从模仿开始。看看名人演讲有什么优点自己可以利用，就记录下来，慢慢的就会有自己的风格。
我最开始看的是马云的演讲，后开看《奇葩说》去模仿了里边很多人的风格。
你要注意他们的说话方式，语气，动作，有哪些好的词汇可以利用。
三、给自己录视频和音频 (角色扮演法) #  前边我们说去模仿名人演讲，这是输入，然后给自己录就是输出。
看自己的视频时，多注意神情，动作，站姿之类的别人很容易注意到的地方。哪里不满意就再去看看名人是怎么做的，反复纠正，直到满意。
听音频，听自己说话的感觉，自己讲的当下，自己是感觉不出来的，就得事后反复听。那些细节没有处理好，比如情绪，语气，停顿的地方以及停顿时间的长短。
可以找别看看自己录的视频和音频，倾听别人的意见。
四、每天读五篇以上的文章并适量背诵 #  可以读短片散文，用来练习自己的感情和情绪的控制。读新闻来练习自己的发音，和语气等。
但你千万别给自己设限，每天必须读多少散文或者新闻之类的。就平时闲下来的时候，手边有任何文字类的东西，都可以拿来读。
背诵一些好的文章，不仅可以锻炼记忆能力，天长日久，那些文章自己就自然而然的转化为自己的词语了，熟到一定程度，就能张口就来了。
如果读新闻，最好在读完之后，用自己的语言复述给别人听，要简单明了，可以锻炼自己的逻辑思维能力。
朗读时，多做一些速读训练。这旨在锻炼人的口齿伶俐，语音准确，吐字清晰。但是快而不乱，每个字，每个音都要发得十分清楚，准确，没有含混不清的地方。
五、描述法 (对于内向的人来说很好的练习方法) #  就是把你看到的景、事、物、人用描述性的语言表达出来。
描述法可以说是最有效的一种练习方法。因为这里没有现成的演讲稿、散文、诗歌等材料，而是要求你自己去组织语言进行描述。
所以描述法训练的主要目的就在于训练你的语言组织能力和语言条理性。在描述时，要抓住特点进行描述。语言要清楚明白，尽量生动一些，活泼一些。
六、找机会上台 #  自己练习千百次，不如上台一次。自己练的再好，一些舞台上的突发情况也是遇不到的。每一次上台都是突破自己的机会，不管说得如何，都要去尝试，积累经验。
另外的一些小技巧： #  1、抑是拖气，让表达更清楚。扬是爆破音，引起听众的注意。停顿最重要，讲短句，不讲长句。
2、一口气一句话，一句话一个人。
3、讲故事是训练事理逻辑的好方法。把故事讲好就是讲心理活动和对话。
4、先讲结果，在简单解释清楚过程。
5、即兴讲话，要记结构，少记内容。熟悉场合，讲我和你的故事。
6、结构是表达逻辑的核心，上台前，要设计一个好的结构。
推荐提升口才的书单 #   1、《高效对话》  “高效沟通才能得到你想要的结果，而其他一切沟通仅是说话而已。”这本书会告诉你，如何突破喋喋不休，用策略来解释自己的想法，并让对方听明白。
 2、《精准表达》  这本书会教会你，如何克服“语无论次、颠三倒四、词不达意、不知所云”、学会用精准的语言和方式，精准的向对方表达，快速提升表达能力。
 3、《口才三绝》  这本书教你如何恰当的赞美他人，而不是一听就知道是在拍马屁，如何巧妙地体现幽默，如何有效的拒绝他人，从而避免误会和困扰。</description>
    </item>
    
    <item>
      <title>注解机制详解</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/basedir/java-basic-x-annotation/</link>
      <pubDate>Wed, 05 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/basedir/java-basic-x-annotation/</guid>
      <description>demo #  </description>
    </item>
    
    <item>
      <title>unsafe</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/unsafe/</link>
      <pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/unsafe/</guid>
      <description>前言 #   Unsafe类位于sun.misc包下，它是java实现高并发的基础，通过它可以执行一些不安全的操作，如像C语言一样直接操作内存资源，它提供的这些方法增强了java对底层资源的操作能力，但同时也增加了程序出错的风险，所以对它的使用一定要慎重  核心功能介绍 #   Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障相关、数组相关等。下面介绍几个方法的使用。  获取Unsafe对象 #  import sun.misc.Unsafe; import java.lang.reflect.Field; public final class UnsafeAccessor { private static Unsafe unsafe; //Unsafe提供的getUnsafe()方法只能被根类加载器加载的类所调用，也就是jdk内部的类。我们可以通过反射来获取Unsafe对象  static { try { //这个名字是 theUnsafe 里面的不要随便写  Field unsafeFile = Unsafe.class.getDeclaredField(&amp;#34;theUnsafe&amp;#34;); unsafeFile.setAccessible(true); //因为是静态属性  unsafe = (Unsafe) unsafeFile.get(null); } catch (Exception e) { } } public static Unsafe getUnsafe() { return unsafe; } } AtomicInteger实现 #   在AtomicInteger的实现中，静态属性valueOffset即为属性value的内存偏移地址，在静态代码块中通过Unsafe的objectFieldOffset方法对valueOffset赋值。在AtomicInteger中提供的线程安全方法中，通过属性valueOffset可以定位到属性value的内存地址，从而可以根据CAS实现对value属性的原子操作。   上图为某个AtomicInteger对象自增操作前后的内存示意图，对象的基地址baseAddress=“0x110000”，通过baseAddress+valueOffset得到value的内存地址valueAddress=“0x11000c”；然后通过CAS进行原子性的更新操作，成功则返回，否则继续重试，直到更新成功为止。  CAS #   CAS(compareAndSwap)即比较并替换，是实现并发算法时常用到的一种技术，CAS操作包含三个参数，要修改变量的内存位置、预期原值、要修改为的值，如果变量的值和预期原值相等，就修改为新值，否则不做处理。CAS底层为一条原子指令cmpxchg，可以保证原子性，Unsafe提供的CAS方法如compareAndSwapInt底层就是CPU指令cmpxchg  /** * CAS * @param o 包含要修改field的对象 * @param offset 对象中某field的偏移量 * @param expected 期望值 * @param update 更新值 * @return true | false */ public final native boolean compareAndSwapObject(Object o, long offset, Object expected, Object update); public final native boolean compareAndSwapInt(Object o, long offset, int expected,int update); public final native boolean compareAndSwapLong(Object o, long offset, long expected, long update);  compareAndSwapInt 使用 (AtomicInteger中也是使用这个)  public class Demo2 { public static void main(String[] args) throws Exception { long startTime = System.</description>
    </item>
    
    <item>
      <title>Executor</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/executor/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/executor/</guid>
      <description>Executor #  </description>
    </item>
    
    <item>
      <title>uniapp基础知识 </title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/uniapp%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/uniapp%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>uni-app的基本使用 #  课程介绍：
基础部分：
 环境搭建 页面外观配置 数据绑定 uni-app的生命周期 组件的使用 uni-app中样式学习 在uni-app中使用字体图标和开启scss 条件注释跨端兼容 uni中的事件 导航跳转 组件创建和通讯，及组件的生命周期 uni-app中使用uni-ui库  项目：xxxx
uni-app介绍 官方网页 #  uni-app view uni-app view #  uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台。
即使不跨端，uni-app同时也是更好的小程序开发框架。
具有vue和微信小程序的开发经验，可快速上手uni-app
为什么要去学习uni-app？
相对开发者来说，减少了学习成本，因为只学会uni-app之后，即可开发出iOS、Android、H5、以及各种小程序的应用，不需要再去学习开发其他应用的框架，相对公司而言，也大大减少了开发成本。
环境搭建 #  安装编辑器HbuilderX 下载地址
HBuilderX是通用的前端开发工具，但为uni-app做了特别强化。
下载App开发版，可开箱即用
安装微信开发者工具 下载地址
利用HbuilderX初始化项目 #    点击HbuilderX菜单栏文件&amp;gt;项目&amp;gt;新建
  选择uni-app,填写项目名称，项目创建的目录
  运行项目 #  在菜单栏中点击运行，运行到浏览器，选择浏览器即可运行
在微信开发者工具里运行：进入hello-uniapp项目，点击工具栏的运行 -&amp;gt; 运行到小程序模拟器 -&amp;gt; 微信开发者工具，即可在微信开发者工具里面体验uni-app
在微信开发者工具里运行：进入hello-uniapp项目，点击工具栏的运行 -&amp;gt; 运行到手机或模拟器 -&amp;gt; 选择调式的手机</description>
    </item>
    
    <item>
      <title> FTP </title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/windows/ftp/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/windows/ftp/</guid>
      <description>本地设置FTP服务器 #  步骤1：在计算机上打开“控制面板”，然后单击“程序和功能”。 #  步骤2：在“程序和功能”窗口中，单击“控制面板”窗口左侧的“打开或关闭Windows功能”。 #  第3步：现在等待一段时间并向下滚动以找出“Internet信息服务”。 只需展开它，打开“FTP服务器”，“Web管理工具”和“万维网服务”下的所有内容，与下面的屏幕截图相同。 完成所有服务后，单击“确定” #  第4步：应用更改需要一些时间，完成后，单击“立即重新启动”以重新启动计算机并应用所做的更改 #  步骤5：重新启动计算机后，再次打开“控制面板”，然后单击“管理工具”将其打开 #  步骤7：在IIS管理器窗口的左侧，展开窗口左侧的计算机名称，除非您找到“站点”。 只需右键单击“站点”，然后单击“添加FTP站点&amp;hellip;” #  第8步：这里给FTP站点命名。 我将&amp;rsquo;sampleftp&amp;rsquo;赋予FTP站点名称。 现在单击“&amp;hellip;”按钮以找到要通过FTP服务器访问的文件夹或驱动程序。 我为本教程选择了“C：FTP_Path”。 完成所有操作后，单击“下一步” #  步骤9：在下一个窗口中，单击与“IP Address：”对应的下拉菜单，然后在本地网络上选择计算机的IP地址。 #   将端口号保留为“21”，默认情况下是这样。  步骤10：选择“No SSL”并启用“自动启动FTP站点”，然后单击“下一步”。 #   *由于这是一个教程，我不允许使用SSL。 但是，如果您想通过FTP服务器访问敏感数据，我建议您使用SSL  步骤11：现在选择“基本”的身份验证方法，并向“所有用户”提供“授权”。 用户必须输入您的Windows用户名和密码才能使用此身份验证方法访问FTP服务器上的文件 #   现在，根据您要如何设置FTP服务器，将权限设置为“读取”和“写入”或仅设置为“读取”。 之后，单击“完成”以完成站点设置并在Windows计算机上启动FTP服务器  配置防火墙 #   您的FTP服务器已准备就绪并且正在运行 但是，您需要配置Windows防火墙以允许与您的计算机进行FTP通信的事务处理。  步骤12：打开“控制面板”并在Windows 10上单击“Windows Defender Firewall”或在Windows 7上单击“Windows防火墙” #  步骤13：单击窗口左侧的“允许通过Windows Defender防火墙的应用程序或功能” #  步骤14：在新窗口中，单击“更改设置”并标记“FTP服务器”的“公共”和“私人”对应的复选框，然后单击“确定”。 #    现在，您可以使用适当的应用程序轻松地从本地网络中的任何其他计算机或移动设备访问FTP服务器，或者只需从浏览器访问即可。</description>
    </item>
    
    <item>
      <title> groovy变量值获取 </title>
      <link>https://huachengzhou.github.io/life/docs/javadir/groovy/%E5%A6%82%E4%BD%95%E5%9C%A8groovy%E4%B8%AD%E8%8E%B7%E5%8F%96%E4%BB%A5%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E7%9A%84%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/groovy/%E5%A6%82%E4%BD%95%E5%9C%A8groovy%E4%B8%AD%E8%8E%B7%E5%8F%96%E4%BB%A5%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E7%9A%84%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC/</guid>
      <description>groovy变量值获取 #  `
https://www.codenong.com/34288451/
`</description>
    </item>
    
    <item>
      <title> 中断和异常 </title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/one_chapter/1_5_/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/one_chapter/1_5_/</guid>
      <description>一:知识总览 #  中断的作用 #   “中断”会使CPU由用户态变为内核态，使操作系统重新夺回对CPU的控制权
   CPU 上会运行两种程序，一种是操作系统内核程序，一种是应用程序
  在合适的情况下，操作系统内核会把CPU的使用权主动让给应用程序(进程管理相关内容)
  如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序
    内核态à用户态：执行一条特权指令——修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权
  用户态à内核态：由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权
  中断的类型 #  中断机制的基本原理 #  二:知识回顾与重要考点 #  </description>
    </item>
    
    <item>
      <title>python 类型转换</title>
      <link>https://huachengzhou.github.io/life/docs/python/base/casting/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/python/base/casting/</guid>
      <description>Casting #   int() - 用整数字面量、浮点字面量构造整数（通过对数进行下舍入），或者用表示完整数字的字符串字面量 float() - 用整数字面量、浮点字面量，或字符串字面量构造浮点数（提供表示浮点数或整数的字符串） str() - 用各种数据类型构造字符串，包括字符串，整数字面量和浮点字面量  import random import time str1 = str(random.random() * 100) print(f&amp;#34;str1 类型: {type(str1)}&amp;#34;,str1) int1 = int(random.random() * 100) print(f&amp;#34;int1 类型: {type(int1)}&amp;#34;,int1) float1 = float(random.random() * 100) print(f&amp;#34;float1 类型: {type(float1)}&amp;#34;,float1) </description>
    </item>
    
    <item>
      <title>字符串el表达式 </title>
      <link>https://huachengzhou.github.io/life/docs/javadir/basedir/jsp_dir/jsp_%E5%AD%97%E7%AC%A6%E4%B8%B2el%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/basedir/jsp_dir/jsp_%E5%AD%97%E7%AC%A6%E4%B8%B2el%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>字符串el表达式 #  fn:contains 判断字符串是否包含另外一个字符串 &amp;lt;c:if test=&amp;quot;${fn:contains(name, searchString)}&amp;quot;&amp;gt;fn:containsIgnoreCase 判断字符串是否包含另外一个字符串(大小写无关) &amp;lt;c:if test=&amp;quot;${fn:containsIgnoreCase(name, searchString)}&amp;quot;&amp;gt;fn:endsWith 判断字符串是否以另外字符串结束 &amp;lt;c:if test=&amp;quot;${fn:endsWith(filename, &amp;quot;.txt&amp;quot;)}&amp;quot;&amp;gt;fn:escapeXml 把一些字符转成XML表示，例如 &amp;lt;字符应该转为&amp;lt; ${fn:escapeXml(param:info)}fn:indexOf 子字符串在母字符串中出现的位置 ${fn:indexOf(name, &amp;quot;-&amp;quot;)}fn:join 将数组中的数据联合成一个新字符串，并使用指定字符格开 ${fn:join(array, &amp;quot;;&amp;quot;)}fn:length 获取字符串的长度，或者数组的大小 ${fn:length(shoppingCart.products)}fn:replace 替换字符串中指定的字符 ${fn:replace(text, &amp;quot;-&amp;quot;, &amp;quot;?&amp;quot;)}fn:split 把字符串按照指定字符切分 ${fn:split(customerNames, &amp;quot;;&amp;quot;)}fn:startsWith 判断字符串是否以某个子串开始 &amp;lt;c:if test=&amp;quot;${fn:startsWith(product.id, &amp;quot;100-&amp;quot;)}&amp;quot;&amp;gt;fn:substring 获取子串 ${fn:substring(zip, 6, -1)}fn:substringAfter 获取从某个字符所在位置开始的子串 ${fn:substringAfter(zip, &amp;quot;-&amp;quot;)}fn:substringBefore 获取从开始到某个字符所在位置的子串 ${fn:substringBefore(zip, &amp;quot;-&amp;quot;)}fn:toLowerCase 转为小写 ${fn.toLowerCase(product.name)}fn:toUpperCase 转为大写字符 ${fn.UpperCase(product.name)}fn:trim 去除字符串前后的空格 ${fn.trim(name)}函数 描述fn:contains(string, substring)如果参数string中包含参数substring，返回truefn:containsIgnoreCase(string, substring)如果参数string中包含参数substring（忽略大小写），返回truefn:endsWith(string, suffix)如果参数 string 以参数suffix结尾，返回truefn:escapeXml(string)将有特殊意义的XML (和HTML)转换为对应的XML character entity code，并返回fn:indexOf(string, substring)返回参数substring在参数string中第一次出现的位置fn:join(array, separator)将一个给定的数组array用给定的间隔符separator串在一起，组成一个新的字符串并返回。fn:length(item)返回参数item中包含元素的数量。参数Item类型是数组、collection或者String。如果是String类型,返回值是String中的字符数。fn:replace(string, before, after)返回一个String对象。用参数after字符串替换参数string中所有出现参数before字符串的地方，并返回替换后的结果 fn:split(string, separator)返回一个数组，以参数separator 为分割符分割参数string，分割后的每一部分就是数组的一个元素fn:startsWith(string, prefix)如果参数string以参数prefix开头，返回truefn:substring(string, begin, end)返回参数string部分字符串, 从参数begin开始到参数end位置，包括end位置的字符fn:substringAfter(string, substring)返回参数substring在参数string中后面的那一部分字符串?</description>
    </item>
    
    <item>
      <title>dom4j</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/tooldoc/dom4j/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/tooldoc/dom4j/</guid>
      <description>dom4j #   选取节点
   nodename 选取当前节点的所有子节点
  / 从根节点选取
  // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置
  . 选取当前节点
  .. 选取当前节点的父节点
  @ 选取属性
   实例
   路径表达式 结果
  bookstore 选取 bookstore 元素的所有子节点
  /bookstore 选取根元素 bookstore
  bookstore/book 选取bookstore 下名字为 book的所有子元素。
  //book 选取所有 book 子元素，而不管它们在文档中的位置。
  bookstore//book 选取bookstore 下名字为 book的所有后代元素，而不管它们位于 bookstore 之下的什么位置。</description>
    </item>
    
    <item>
      <title>MySQL分库分表原理</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_distinguish/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_distinguish/</guid>
      <description>前言 #  在互联网还未崛起的时代,我们的传统应用都有这样一个特点：访问量、数据量都比较小，单库单表都完全可以支撑整个业务。随着互联网的发展和用户规模的迅速扩大,对系统的要求也越来越高。因此传统的MySQL单库单表架构的性能问题就暴露出来了。而有下面几个因素会影响数据库性能: 数据量  MySQL单库数据量在5000万以内性能比较好,超过阈值后性能会随着数据量的增大而变弱。MySQL单表的数据量是500w-1000w之间性能比较好,超过1000w性能也会下降。 磁盘  因为单个服务的磁盘空间是有限制的,如果并发压力下,所有的请求都访问同一个节点,肯定会对磁盘IO造成非常大的影响。 数据库连接  数据库连接是非常稀少的资源,如果一个库里既有用户、商品、订单相关的数据,当海量用户同时操作时,数据库连接就很可能成为瓶颈。为了提升性能,所以我们必须要解决上述几个问题,那就有必要引进分库分表。垂直拆分 or 水平拆分？ #  当我们单个库太大时,我们先要看一下是因为表太多还是数据量太大，如果是表太多,则应该将部分表进行迁移(可以按业务区分),这就是所谓的垂直切分。如果是数据量太大,则需要将表拆成更多的小表,来减少单表的数据量,这就是所谓的水平拆分。垂直拆分 #   垂直分库  垂直分库针对的是一个系统中的不同业务进行拆分,比如用户一个库,商品一个库,订单一个库。 一个购物网站对外提供服务时,会同时对用户、商品、订单表进行操作。没拆分之前, 全部都是落到单一的库上的,这会让数据库的单库处理能力成为瓶颈。如果垂直分库后还是将用户、商品、订单放到同一个服务器上,只是分到了不同的库,这样虽然会减少单库的压力,但是随着用户量增大,这会让整个数据库的处理能力成为瓶颈,还有单个服务器的磁盘空间、内存也会受非常大的影响。 所以我们要将其拆分到多个服务器上，这样上面的问题都解决了，以后也不会面对单机资源问题。 垂直分表  也就是“大表拆小表”，基于列字段进行的。一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的拆分到“扩展表“。一般是针对那种几百列的大表，也避免查询时，数据量太大造成的“跨页”问题。水平拆分 #   水平分表  和垂直分表有一点类似,不过垂直分表是基于列的,而水平分表是基于全表的。水平拆分可以大大减少单表数据量,提升查询效率。 水平分库分表  将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。几种常用的分库分表的策略 #   HASH取模  假设有用户表user,将其分成3个表user0,user1,user2.路由规则是对3取模,当uid=1时,对应到的是user1,uid=2时,对应的是user2。 范围分片  从1-10000一个表,10001-20000一个表。 地理位置分片  华南区一个表,华北一个表。 时间分片  按月分片，按季度分片等等,可以做到冷热数据。分库分表后引入的问题 #   分布式事务问题  如果我们做了垂直分库或者水平分库以后,就必然会涉及到跨库执行SQL的问题,这样就引发了互联网界的老大难问题-&amp;quot;分布式事务&amp;quot;。那要如何解决这个问题呢？1.</description>
    </item>
    
    <item>
      <title>uml 学习与使用</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/middleware/uml/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/middleware/uml/</guid>
      <description>最重要的放最前面 #  UML类图几种关系的总结 #  在UML类图中，常见的有以下几种关系:
 泛化（Generalization）：继承的关系，实线带三角形箭头，指向父类。 实现（Realization）：实现的关系，虚线带三角形箭头，指向接口。 关联（Association）：拥有的关系，实线带普通箭头，指向被拥有者。 聚合（Aggregation）：整体与部分的关系。实线带空心菱形，指向整体。 组合（Composition）：整体与部分的关系，但不能离开整体而单独存在。实线实心菱形，指向整体。 依赖（Dependency）：使用的关系，即一个类的实线需要另一个类的协助。虚线普通箭头，指向被使用者。  1.泛化(Generalization) #  【泛化关系】：是一种继承关系,它指定了子类如何特化父类的所有特征和行为。例如：老虎是动物的一种。
【箭头指向】：带三角箭头的实线，箭头指向父类。
2.实现（Realization) #  【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现。
【箭头指向】：带三角箭头的虚线，箭头指向接口。
3.关联（Association） #  【关联关系】：是一种拥有的关系,它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子。关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。
【代码体现】：成员变量
【箭头及指向】：带普通箭头的实心线，指向被拥有者。
上图中，老师与学生是双向关联，老师有多名学生，学生也可能有多名老师。但学生与某课程间的关系为单向关联，一名学生可能要上多门课程，课程是个抽象的东西他不拥有学生。
上图为自身关联。
4.聚合（Aggregation） #  【聚合关系】：是整体与部分的关系。如车和轮胎是整体和部分的关系。聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。
【代码体现】：成员变量
【箭头及指向】：带空心菱形的实心线，菱形指向整体。
5.组合(Composition) #  【组合关系】：是整体与部分的关系。没有公司就不存在部门，组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。
【代码体现】：成员变量
【箭头及指向】：带实心菱形的实线，菱形指向整体。
6.依赖(Dependency) #  【依赖关系】：是一种使用的关系,所以要尽量不使用双向的互相依赖。
【代码表现】：局部变量、方法的参数或者对静态方法的调用。
【箭头及指向】：带箭头的虚线，指向被使用者。
总结 #  各种关系的强弱顺序：
泛化= 实现&amp;gt; 组合&amp;gt; 聚合&amp;gt; 关联&amp;gt; 依赖
下面这张UML图，比较形象地展示了各种类图关系：
startUML #  一:什么是UML #   UML是Unified Model Language的缩写，中文是统一建模语言，是由一整套图表组成的标准化建模语言</description>
    </item>
    
    <item>
      <title>分层参考模型</title>
      <link>https://huachengzhou.github.io/life/docs/computer_network/network_architecture/%E5%88%86%E5%B1%82%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/computer_network/network_architecture/%E5%88%86%E5%B1%82%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/</guid>
      <description>   名称 英文 作用     应用层 Application Layer 直接为用户的应用进程（例如电子邮件、文件传输和终端仿真）提供服务。如HTTP、SMTP、FTP、DNS等   表示层 Presentation Layer 把数据转换为能与接收者的系统格式兼容并适合传输的格式，即让两个系统可以交换信息   会话层 Session Layer 负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接   传输层 Transport Layer 负责端到端通讯，可靠传输，不可靠传输 ，流量控制，复用分用   网络层 Network Layer 负责选择路由最佳路径，规划IP地址(ipv4和ipv6变化只会影响网络层)，拥塞控制   数据链路层 Data Link Layer 帧的开始和结束，还有透明传输，差错校验(纠错由传输层解决)   物理层 Physical Layer 定义网络设备接口标准，电气标准(电压)，如何在物理链路上传输的更快    </description>
    </item>
    
    <item>
      <title>线程概念与多线程模型</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_1_5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_1_5/</guid>
      <description></description>
    </item>
    
    <item>
      <title>泛型机制详解</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/basedir/java-basic-x-generic/</link>
      <pubDate>Wed, 05 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/basedir/java-basic-x-generic/</guid>
      <description>demo #  </description>
    </item>
    
    <item>
      <title>生活中常用的客套话</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/awb8ggwzn2/</link>
      <pubDate>Wed, 05 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/awb8ggwzn2/</guid>
      <description>人际交往中往往需要客套话，客套话会使我们彼此之间的关系更加和谐。要把“谢谢你、对不起、请” 常挂嘴上。请人办事，说一声“劳驾”，送客临别，讲一句“慢走”。这些都能显示出你礼貌周到、谈吐文雅。擅长外交的人们像精通交通规则一般精于客套，得体的客套话同我们美好的仪表一样，是人际交往的推荐书。以下是总结出的一些日常生活中常用的客套话
 初次见面说“久仰”，好久不见说“久违”。
请人评论说“指教”，求人原谅说“包涵”。
求人帮忙说“劳驾”，求给方便说“借光”。
麻烦别人说“打扰”，向人祝贺说“恭喜”。
请人改稿称“斧正”，请人指点用“赐教”。
求人解答用“请问”，赞人见解用“高见”。
看望别人用“拜访”，托人办事用“拜托”。
宾客来到用“光临”，送客出门称“慢走”。
招待远客称“洗尘”，陪伴朋有用“奉陪”。
请人勿送用“留步”，欢迎购买叫“光顾”。
与客作别称“再见”，归还原物叫“奉还”。
对方来信叫“慧书”，老人年龄叫“高寿”。
得体的客套话会温暖对方的心窝，也能使你的语言更加充满魅力。</description>
    </item>
    
    <item>
      <title>ReentrantLock</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/reentrantlock/</link>
      <pubDate>Sun, 11 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/reentrantlock/</guid>
      <description>ReentrantLock #  ReentrantLock 介绍 #    ReentrantLock是Java中常用的锁，属于乐观锁类型，多线程并发情况下。能保证共享数据安全性，线程间有序性
  ReentrantLock通过原子操作和阻塞实现锁原理，一般使用lock获取锁，unlock释放锁，
  下面说一下锁的基本使用和底层基本实现原理，lock和unlock底层
  lock的时候可能被其他线程获得所，那么此线程会阻塞自己，关键原理底层用到Unsafe类的API: CAS和park
  ReentrantLock是一个可重入的互斥锁，又被称为“独占锁”
  简单模拟 ReentrantLock #   不安全的例子  public class ReentrantLockDemo1 { public static void main(String[] args) { new Thread(() -&amp;gt; { drawMoney() ; },&amp;#34;线程1&amp;#34;).start(); new Thread(() -&amp;gt; { drawMoney() ; },&amp;#34;线程2&amp;#34;).start(); } private static void drawMoney(){ System.out.println(Thread.currentThread().getName()+&amp;#34;......&amp;#34;+&amp;#34;正在取钱!&amp;#34;); try { Thread.sleep(3000); } catch (InterruptedException e) { e.</description>
    </item>
    
    <item>
      <title>Future 和 callable</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/future_callable/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/future_callable/</guid>
      <description>Future #  callable #  </description>
    </item>
    
    <item>
      <title>webpack </title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/webpack/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/webpack/</guid>
      <description>（十五）webpack #  15.1	webpack起步 #  15.1.1	什么是webpack #  webpack是一个JavaScript应用的静态模块打包工具。
从这句话中有两个要点，模块和打包需要关注。grunt/gulp都可以打包，那有什么区别。
 模块化
 webpack可以支持前端模块化的一些方案，例如AMD、CMD、CommonJS、ES6。可以处理模块之间的依赖关系。不仅仅是js文件可以模块化，图片、css、json文件等等都可以模块化。
 打包
 webpack可以将模块资源打包成一个或者多个包，并且在打包过程中可以处理资源，例如压缩图片，将scss转成css，ES6语法转成ES5语法，将TypeScript转成JavaScript等等操作。grunt/gulp也可以打包。
和grunt/glup的对比
 grunt/glup的核心是Task  我们可以配置一系列的task，并且定义task要处理的事务（例如ES6/TS转化，图片压缩，scss转css） 之后可以让grunt/glup来执行依次这些任务，让整个流程自动化 所以grunt/glup也被称为前端自动化任务管理工具   看一个gulp例子  task将src下的js文件转化为ES5语法 并输入到dist文件夹中     什么时候使用grunt/gulp呢？  如果工程依赖简单，甚至没有模块化 只需要进行简单的合并/压缩 如果模块复杂，相互依赖性强，我们需要使用webpack   grunt/glup和webpack区别  grunt/glup更加强调的是前端自动化流程，模块化不是其核心 webpack加强模块化开发管理，而文件压缩/合并/预处理等功能，是附带功能    webpack就是前端模块化打包工具
15.1.2	webpack的安装 #   webpack依赖node环境。 node环境依赖众多包，所以需要npm，npm（node packages manager）node包管理工具 nvm是node管理工具可以自由切换node环境版本  全局安装webpack
npm install webpack -g //指定版本安装 npm install webpack@3.</description>
    </item>
    
    <item>
      <title>webpack simple</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/simple-webpack/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/simple-webpack/</guid>
      <description>webpack #  一:卸载 #   全局卸载  D:\IdeaProjects\cycle\docs\webc\web\webpack-study\one&amp;gt;npm uninstall webpack webpack-cli -g removed 73 packages in 0.726s  本地卸载  D:\IdeaProjects\cycle\docs\webc\web\webpack-study\one&amp;gt;npm uninstall webpack webpack-cli -D npm WARN saveError ENOENT: no such file or directory, open &amp;#39;D:\IdeaProjects\package.json&amp;#39; npm WARN enoent ENOENT: no such file or directory, open &amp;#39;D:\IdeaProjects\package.json&amp;#39; npm WARN IdeaProjects No description npm WARN IdeaProjects No repository field. npm WARN IdeaProjects No README data npm WARN IdeaProjects No license field.</description>
    </item>
    
    <item>
      <title> groovy对象比较以及空判断 </title>
      <link>https://huachengzhou.github.io/life/docs/javadir/groovy/groovy%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83%E4%BB%A5%E5%8F%8A%E9%9D%9E%E7%A9%BA%E5%88%A4%E6%96%AD/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/groovy/groovy%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83%E4%BB%A5%E5%8F%8A%E9%9D%9E%E7%A9%BA%E5%88%A4%E6%96%AD/</guid>
      <description>groovy 对象比较以及空判断 #   目前测试得知 groovy的比较貌似很多直接可以使用==来比较
 groovy对象的比较 #  1.字符串比较 #  def str1 = &amp;quot;Hello World1&amp;quot;if (&amp;quot;Hello World&amp;quot; == str1) {println &amp;quot;Hello World&amp;quot;} else {println &amp;quot;不匹配&amp;quot;}2.map集合的比较（list集合也可以这样比较） #  	def m1=[&amp;quot;name&amp;quot;:&amp;quot;李明&amp;quot;,&amp;quot;age&amp;quot;:20]def m2=[&amp;quot;name&amp;quot;:&amp;quot;李明&amp;quot;,&amp;quot;age&amp;quot;:21]def m3=[&amp;quot;name&amp;quot;:&amp;quot;李明&amp;quot;,&amp;quot;age&amp;quot;:21]if(m1==m2){println &amp;quot;m1和m2匹配&amp;quot;}else{println &amp;quot;m1和m2不匹配&amp;quot;}  特别是字符串的比较，是不是比java要简洁的多呢
  如果要比较两个对象的引用是否相同在groovy中可以使用is
  def list1 = []def list2 = [1,2,3,4]boolean check = list1.</description>
    </item>
    
    <item>
      <title> windows 问题 </title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/windows/windows_question/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/windows/windows_question/</guid>
      <description> 磁盘变为了动态磁盘解决办法 最好是找软件解决 如DiskGenius 或者 傲梅分区助手 暴力解决办法  1、diskpart2、list disk3、select disk n4、convert basicSTEP 1：打开命令提示符窗口，在其中键入：“diskpart”命令并按下回车键。 STEP 2：在DISKPART命令提示符下，键入“list disk”命令并按下回车键后，能够查看到电脑中的磁盘情况。 STEP 3：在DISKPART命令提示符下，继续键入“select disk n”命令并按下回车键，其中n代表磁盘的序号。 STEP 4：在DISKPART命令提示符下，键入“convert dynamic”命令并按下回车键后，开始转换的工作。</description>
    </item>
    
    <item>
      <title> 系统调用 </title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/one_chapter/1_6_/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/one_chapter/1_6_/</guid>
      <description>一:知识总览 #  什么是系统调用，有何作用？ #   知识点回顾：操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组系统调用组成。
  “系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务
 系统调用与库函数的区别 #  小例子：为什么系统调用是必须的？ #  什么功能要用到系统调用？ #   应用程序通过系统调用请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此凡是与共享资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。
 系统调用的过程 #  二:知识回顾与重要考点 #  </description>
    </item>
    
    <item>
      <title>python print</title>
      <link>https://huachengzhou.github.io/life/docs/python/base/print/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/python/base/print/</guid>
      <description>print用法 #   简单使用  print(&amp;#39;hello world&amp;#39;)  表达式用法 print(f&amp;quot;{expression}&amp;quot;)  print(f&amp;#34;lista: {lista}&amp;#34;) print(f&amp;#34;1+1 : {1+1}&amp;#34;) </description>
    </item>
    
    <item>
      <title>Guava 基于java1.6的类库集合的扩展项目</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/tooldoc/guava-common/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/tooldoc/guava-common/</guid>
      <description>Guava 基于java1.6的类库集合的扩展项目 #   com.google.common.annotations：普通注解类型。 com.google.common.base：基本工具类库和接口。 com.google.common.cache：缓存工具包，非常简单易用且功能强大的JVM内缓存。 com.google.common.collect：带泛型的集合接口扩展和实现，以及工具类，这里你会发现很多好玩的集合。 com.google.common.eventbus：发布订阅风格的事件总线。 com.google.common.hash： 哈希工具包。 com.google.common.io：I/O工具包。 com.google.common.math：原始算术类型和超大数的运算工具包。 com.google.common.net：网络工具包。 com.google.common.primitives：八种原始类型和无符号类型的静态工具包。 com.google.common.reflect：反射工具包。 com.google.common.util.concurrent：多线程工具包。 常见Object方法   hashCode compare/compareTo 实现一个比较器[Comparator]，或者直接实现Comparable接口有时也伤不起
 public class ProjectInfo implements Serializable,Comparable&amp;lt;ProjectInfo&amp;gt; {private int id;private String name;public int getId() {return id;}public String getName() {return name;}public void setId(int id) {this.id = id;}public void setName(String name) {this.name = name;}@Overridepublic int compareTo(ProjectInfo o) {return ComparisonChain.</description>
    </item>
    
    <item>
      <title>mysql安装</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_install/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_install/</guid>
      <description>mysql安装 #   这里我们不再采用exe的安装的方式,我们使用压缩包的方式安装
   地址 https://downloads.mysql.com/archives/community/
  将页面拉到最下面选择选择操作系统后，选择要下载的版本点击 Downloads
  我选择安装的版本为8.0.13。如果不想要最新的版本也可以进Archives页面选择其他版本
  选择压缩包的版本哦
  一:配置环境变量 #    因为下载的mysql数据库包的格式是zip的，下载完成后直接解压就可以用，但解压后需要进行配置。
  首先进行环境变量的配置：右击计算机-&amp;gt;属性-&amp;gt;高级系统设置-&amp;gt;环境变量，选择双击Path，在最后面添加你的mysql bin文件夹的路径
  我的目录是：D:\databases\mysql-8.0.13-winx64
   必须设置这个才行,因为后面我们要在控制台运行命令,假如你不设置这个环境变量那么在控制台根本识别不了,exe安装会自动在环境中设置,而压缩包没有设置  二:在 D:\databases\mysql-8.0.13-winx64 目录下新建一个my.ini的文件 #  [mysqld]# skip-grant-tables 暂时注释了 容易引起 mysql服务启动后立马关闭 这个错误# 设置3306端口port=3306# 自定义设置mysql的安装目录，即解压mysql压缩包的目录# 切记此处一定要用双斜杠\\，单斜杠这里会出错。basedir=D:\\databases\\mysql-8.0.13-winx64# 自定义设置mysql数据库的数据存放目录datadir=D:\\databases\\mysql-8.0.13-winx64\\data# 允许最大连接数max_connections=200# 允许连接失败的次数，这是为了防止有人从该主机试图攻击数据库系统max_connect_errors=10# 服务端使用的字符集默认为UTF8character-set-server=utf8mb4# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证default_authentication_plugin=mysql_native_password# 开启慢sqlslow_query_log=ON# 慢sql存的文职slow_query_log_file=D:\CS\databases\mysql_8.</description>
    </item>
    
    <item>
      <title>Win10一台电脑安装多个版本的Mysql</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_install_more/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_install_more/</guid>
      <description>mysql安装 #   这里我们不再采用exe的安装的方式,我们使用压缩包的方式安装
   地址 https://downloads.mysql.com/archives/community/
  将页面拉到最下面选择选择操作系统后，选择要下载的版本点击 Downloads
  我选择安装的版本为8.0.22。如果不想要最新的版本也可以进Archives页面选择其他版本
  选择压缩包的版本哦
  一:配置环境变量 #    因为下载的mysql数据库包的格式是zip的，下载完成后直接解压就可以用，但解压后需要进行配置。
  首先进行环境变量的配置：右击计算机-&amp;gt;属性-&amp;gt;高级系统设置-&amp;gt;环境变量，选择双击Path，在最后面添加你的mysql bin文件夹的路径
  我的目录是：D:\CS\databases\mysql-8.0.22-winx64   必须设置这个才行,因为后面我们要在控制台运行命令,假如你不设置这个环境变量那么在控制台根本识别不了,exe安装会自动在环境中设置,而压缩包没有设置
  二:在D:\CS\databases\mysql-8.0.22-winx64 目录下新建一个my.ini的文件 #  [mysqld] # skip-grant-tables 暂时注释了 容易引起 mysql服务启动后立马关闭 这个错误 # 设置3307端口 port=3307 # 自定义设置mysql的安装目录，即解压mysql压缩包的目录 # 切记此处一定要用双斜杠\\，单斜杠这里会出错。 basedir=D:\\CS\\databases\\mysql-8.0.22-winx64 # 自定义设置mysql数据库的数据存放目录 datadir=D:\\CS\\databases\\mysql-8.0.22-winx64\\data # 允许最大连接数 max_connections=200 # 允许连接失败的次数，这是为了防止有人从该主机试图攻击数据库系统 max_connect_errors=10 # 服务端使用的字符集默认为UTF8 character-set-server=utf8mb4 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB # 默认使用“mysql_native_password”插件认证 default_authentication_plugin=mysql_native_password [mysql] # 设置mysql客户端默认字符集 default-character-set=utf8mb4 [client] # 设置mysql客户端连接服务端时默认使用的端口和默认字符集 port=3307 default-character-set=utf8mb4 三:windows下运行控制台程序 #   进入 C:\Windows\System32 中搜索   右键用管理员权限执行  四:mysql执行核心插件服务 #  D:\CS\databases\mysql-8.</description>
    </item>
    
    <item>
      <title>处理机调度的概念、层次</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_2_1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_2_1/</guid>
      <description></description>
    </item>
    
    <item>
      <title>模型层次详解</title>
      <link>https://huachengzhou.github.io/life/docs/computer_network/network_architecture/%E6%A8%A1%E5%9E%8B%E5%B1%82%E6%AC%A1%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/computer_network/network_architecture/%E6%A8%A1%E5%9E%8B%E5%B1%82%E6%AC%A1%E8%AF%A6%E8%A7%A3/</guid>
      <description>计算机网络分成结构 #  7层OSI参考模型 #  4层TCP/IP参考模型 #  5层体系结构 #  ISO/OSI模型怎么来的 #  ISO/OSI参考模型 #  ISO/OSI参考模型解释通信过程 #  应用层 #  表示层 #  会话层 #  传输层 #  网络层 #  数据链路层 #  物理层 #  OSI参考模型 与 TCP/IP参考模型 #  OSI参考模型与TCP/IP参考模型 #  相同点 #   1:都分层 2:基于独立的协议栈的概念 3:可以实现异构网络互联  不同点 #  面向连接分为三个阶段，第一是建立连接，在此阶段，发出一个建立连接的请求。只有在连接成功建立之后，才能开始数据传输，这是第二阶段。接着，当数据传输完毕，必须释放连接。而面向无连接没有这么多阶段，它直接进行数据传输。    ISO/OSI参考模型 TCP/IP模型     网络层 无连接 + 面向连接 无连接   传输层 面向连接 无连接 + 面向连接    五层参考模型 #   综合了OSI和TCP/IP的优点</description>
    </item>
    
    <item>
      <title>python 元组</title>
      <link>https://huachengzhou.github.io/life/docs/python/base/tuple/</link>
      <pubDate>Mon, 06 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/python/base/tuple/</guid>
      <description>元组 #   元组（Tuple）   元组是有序且不可更改的集合。在 Python 中，元组是用圆括号编写的
 import time tupleX = (time.time(),time.time_ns()) print(tupleX)  访问元组项目  tupleIndex = (2, 3, &amp;#39;a&amp;#39;, &amp;#39;c&amp;#39;) print(f&amp;#34;倒数第一项:{tupleIndex[-1]}&amp;#34;) print(f&amp;#34;倒数第二项:{tupleIndex[-2]}&amp;#34;) print(f&amp;#34;第一项:{tupleIndex[0]}&amp;#34;)   关于索引范围 -1就说倒数第一项 -2就是倒数第二项 0就第一项
  检查项目是否存在
  betweenTuple = (&amp;#39;a&amp;#39;,&amp;#39;k&amp;#39;,&amp;#39;4&amp;#39;,&amp;#39;7&amp;#39;) print(f&amp;#34;a属于元组:{&amp;#39;a&amp;#39; in betweenTuple}&amp;#34;) print(f&amp;#34;b不属于元组:{&amp;#39;a&amp;#39; in betweenTuple}&amp;#34;)  元组长度  betweenTuple = (&amp;#39;a&amp;#39;,&amp;#39;k&amp;#39;,&amp;#39;4&amp;#39;,&amp;#39;7&amp;#39;) print(f&amp;#34;a属于元组:{&amp;#39;a&amp;#39; in betweenTuple}&amp;#34;) print(f&amp;#34;b不属于元组:{&amp;#39;a&amp;#39; in betweenTuple}&amp;#34;) print(f&amp;#34;元组长度:{len(betweenTuple)}&amp;#34;) </description>
    </item>
    
    <item>
      <title>高情商的聊天技巧</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/hweaprcifa/</link>
      <pubDate>Wed, 05 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/hweaprcifa/</guid>
      <description>技巧一 #  五个黄金公式和一个基本原则，轻轻松松提升情商。 #  公式1：不要在比你_____的人面前说你很_____ #  举个栗子。不要在比你胖的人面前说你很胖，不要在比你穷的人面前说你很穷……
 曾经有个妹子，吃饱后摸着肚子对我说：“天啊！我都快胖成猪了！” 你以为她真很胖吗？事实上，当时的她，95斤。而当时的我，160斤。
 Hbnes&amp;quot;&amp;gt;我的内心os是：你是猪的话我是什么？猛犸象吗？！！
在别人吃不起饭的时候，去跟他抱怨自己家的红烧肉不够入味，是件很不人道的事情。
公式2： 认可情绪＞分析事实 #  举个栗子。同事说：“最近觉得工作好烦。”与其说：“每个人工作都烦，很正常。”不如说：“你最近总是熬夜，这么辛苦，真的很理解你为什么烦。”
 上个月，在某众点评里给一家烤肉店打了三星。原因是店家环境一般且用的合成肉。结果评论里被店家人身攻击。生气的我找朋友吐槽。
 A听了以后，分析到：你打三颗星，店家肯定会不开心啊，所以他反驳你也是人之常情。虽然他言辞过于激烈，你也没必要跟陌生人计较，下次不去那家店就好。
听完这些， 虽然知道他说得对，但我还是好生气啊！
于是又跟B说了这件事，B立马回复：天啊！气死我了！这个店家太过分了！我现在就要去给他打一星！凭什么这么骂你啊！你的评论写得有理有据他作为商家不改正还口出狂言？我要叫大家一起来喷他！
听完他说这些，心情立马好转。
为什么A虽然说了事实，却没有什么安慰效果呢？
因为人的情绪是没办法被冷冰冰的道理消化的。
所以当B设身处地理解了我的委屈后，让我感受到了认同接纳，坏心情才随之消散。
看见对方的情绪，是有效沟通的第一步。
针没扎在自己身上的时候，不要着急说不疼。
认可情绪比分析事实更能拉近我们的距离。
公式3：我想_______,因为_______ #  举个栗子。“我想跟你一起吃晚饭，因为朋友推荐了一家超好吃的火锅店。”
人是需要理由的动物，有目的，会让行动容易很多。
提出自己的想法和需求的时加一个“因为”，被接受的概率会大大提升。
 美国著名社会心理学家 罗伯特·西奥迪尼 在《影响力》这本书里举过一个例子。在买票的时候说：“我想插队，因为我要买票”比只说“我想插队”成功率要高出93%！ 这本书是我的心理学启蒙，不仅读起来很有意思，并且非常实用~没读过的小伙伴千万不要错过。
 当然，理由得是合理的才行。
如果你说“我想插队，因为我没素质”，那可能会被打。
同理，拒绝人的时候也最好加个理由。“我不能借钱给你，因为我只帮助长得丑的人。”
公式4：选A还是B？可以选C #  当面对两难选择的时候，可以回答题目之外的选项。
举个栗子。女朋友问：“以后生孩子，你保大还是保小？”你可以回答：“那就都不保吧”。这样你在喜提幽默感的同时还能收获一顿小粉拳。
 N年前，在芒果卫视做节目嘉宾，有一期节目邀请到了台湾艺术作家曲家瑞，以及新东方知名英语老师英语老师周思成
  主持人问我：你作为学生，比较喜欢火辣大胆的周老师，还是直爽可爱的曲老师？弱小的我当时很为难。毕竟两个老师各有特色，回答A或者B都会得罪另一个人！所以我当时回答：“我是个肤浅的学生，喜欢长得好看的老师。所以这两个我都喜欢！”
 有人说：你好狡猾啊！那如果必须选择一个呢？
老板问“A方案还是B方案？”怎么回答呢？
记得我们刚刚说的“我想____,因为____”公式吗？说出理由，让你的选择合理化就好了。
“我想选A方案，因为我觉得A更适合现在公司的处境。”
公式5：提问的效果＞陈述 #  疑问句比陈述句更能让对话继续下去，同时更强烈的表达自己的想法。
举个栗子。客户对你说：“周末一般会踢踢球。”如果你只回答一句：“我也是。”认同感不强烈，而且很难继续聊下去。所以可以问对方：“我也爱踢球！您一般踢哪个位置呀？”引导对话更深入。</description>
    </item>
    
    <item>
      <title>java重复加锁</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/repeat_lock/</link>
      <pubDate>Sun, 11 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/repeat_lock/</guid>
      <description>可重入锁，从字面来理解，就是可以重复进入的锁
   可重入锁，也叫做递归锁，指的是同一线程外层函数获得锁之后，内层递归函数仍然有获取该锁的代码，但不受影响
  在java环境下reentrantlock和synchronized都是可重入锁
  可重入锁的实现原理 #    加锁时，需要判断锁是否已经被获取。如果已经被获取，则判断获取锁的线程是否是当前线程。如果是当前线程，则给获取次数加1。如果不是当前线程，则需要等待
  释放锁时，需要给锁的获取次数减1，然后判断，次数是否为0了。如果次数为0了，则需要调用锁的唤醒方法，让锁上阻塞的其他线程得到执行的机会
  模拟实现简单的可重入锁 #  public class RepeatLock { //private UnreentrantLock unreentrantLock = new UnreentrantLock();  private ReentrantLock reentrantLock = new ReentrantLock(); //加锁建议在try里面，解锁建议在finally  public void methodA() throws InterruptedException { try { reentrantLock.lock(); System.out.println(&amp;#34;methodA方法被调用&amp;#34;); methodB(); } finally { reentrantLock.unlock(); } } public void methodB() { try { reentrantLock.lock(); System.out.println(&amp;#34;methodB方法被调用&amp;#34;); } catch (InterruptedException e) { e.</description>
    </item>
    
    <item>
      <title>CompletionService</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/completionservice/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/completionservice/</guid>
      <description>CompletionService #  </description>
    </item>
    
    <item>
      <title>webpack和nodejs关系 </title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/webpack%E5%92%8Cnodejs%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/webpack%E5%92%8Cnodejs%E5%85%B3%E7%B3%BB/</guid>
      <description>webpack和nodejs关系 #   webpack可以将 .vue 文件转换为 .js 文件，而这个转换需要借助打包器vue-loader，这个打包器的下载是在node环境使用 npm 下载的（npm类似与一个应用商店，里面有很多包）；这样webpack在打包的时候是在node环境中运行的。
  nodejs是js后端运行平台，可以把它看成java体系中对应的jdk，是三个里面最基础的。 npm是nodejs的包管理工具，可以把它看成maven中包依赖管理那部分。 webpack是前端工程化打包工具，可以把它看成maven中工程自动化那部分  npm #  npm是什么 #  是Node.js的包管理工具，是全球最大的开发库生态系统（注册表）为何产生？ #  当网站的依赖的js越来越多，程序员发现这是一件麻烦事：去JQuery官网下载JQuery，去 BootStrap 官网下载 BootStrap ，去 Underscore 官网下载 Underscore .......没完没了于是npm就出来了（全称 Node Package Manager 包管理工具），大家把自己写好的源码上传到npm官网上，如果要用某个或某些个，直接通过npm安装就可以了，并且模块A依赖B，B依赖C、D，此时只需安装A即可，因为此时npm会根据依赖关系，把所有依赖的包都下载下来并且管理起来；这一点和maven、gradle十分相似，只不过maven、gradle是用来管理java jar包的，而npm是用来管理js的。常用命令 #   npm init：初始化一个项目包，包含package.json文件 npm install：package.json的devDependencies字段里的插件全部安装到node_modules下  node #  node.js是javascript的一种运行环境，是对Google V8引擎进行的封装。是一个服务器端的javascript的解释器。包含关系，nodejs中含有npm，比如说你安装好nodejs，你打开cmd输入npm -v会发现出啊线npm的版本号，说明npm已经安装好。webpack #  Webpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将这些模块按照指定的规则生成对应的静态资源。我们为什么使用webpack? #  开发是时候需要一个开发环境，要是我们修改一下代码保存之后浏览器就自动展现最新的代码就好了（热更新服务）本地代码的时候，要是调后端的接口不跨域就好了（代理服务）为了跟上时代，要是能用上ES678N就好了（翻译服务）项目要上线了，要是能一键压缩代码，图片什么的就好了（压缩打包服务）我们平时的静态资源都是放到CDN上的，要是能自动帮我把这些搞好的静态资源怼到CDN上就好了（自动上传服务）这么多服务，我们需要webpack帮我们去整合那么多的服务，而node的出现，赋予了我们操作系统的能力，要根据自己的需求来使用webpack，知道自己需要什么样的服务，webpack能不能提供这样的服务，如果可以，那么这个服务应该在构建中的呢个环节被处理。1.</description>
    </item>
    
    <item>
      <title> groovy使用场景 </title>
      <link>https://huachengzhou.github.io/life/docs/javadir/groovy/groovy%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/groovy/groovy%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</guid>
      <description>groovy 使用场景 #  Groovy可以用于多种情况。比如 #    1、作为shell脚本语言完成数据处理和文件操作任务。
  2、在Java或者Java EE应用程序中嵌入Groovy，实现Java和Groovy的集成。（这样有助于编写和集中处理经常变化的业务逻辑，或者给应用程序架构提供可编程的配置管理能力。）
  Groovy是增强Java平台的唯一的脚本语言。 #   它提供了类似于Java的语法，内置映射（Map）、列表（List）、方法、类、闭包（closure）以及生成器。  脚本语言与系统编程语言： #   脚本语言不会替代系统编程语言，两者是相互补充的。
 系统编程语言的目的： #    开发复杂的算法或者数据结构
  实现计算密集型应用
  操作大型数据集
  实现定义良好的、变更缓慢的需求
  脚本语言应用的目的： #    连接已有的组件
  处理经常变化的多种类型的实体
  具有图形化用户界面
  拥有快速变化的功能
  Java编译器会产生可以在Java虚拟机上运行的字节码。 #  Groovy类和Java是二进制兼容的。 #  Groovy编译器产生的字节码与Java编译器产生的字节码是完全一样的。 #  ——对于JVM而言，Groovy和Java是完全一样的。 #  因此，Groovy能够完全使用各种Java API。 #  Groovy是一门面向对象的语言。也就是说，Groovy中每一个事物最终都会被当做某些类 的一个实例对象。 #  </description>
    </item>
    
    <item>
      <title> 操作系统的体系结构 </title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/one_chapter/1_7_/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/one_chapter/1_7_/</guid>
      <description>一:知识总览 #  操作系统的内核 #  二:知识回顾与重要考点 #  </description>
    </item>
    
    <item>
      <title>windows下 Mysql安装的一些问题解决方法</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_install_problem/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_install_problem/</guid>
      <description>windows下 Mysql安装的一些问题解决方法 #  1: The service already exists #    在mysql安装的时候要执行 mysqld &amp;ndash;install 这个命令,假如你已经安装完之后觉得不对，但是mysql服务已经生成(windows注册服务已经有mysql了),你不删除此服务为报一个错误
  The service already exists
  决绝方法就是 删除mysql相关的服务
  首先查询下是否存在mysql服务
  sc query mysqlSERVICE_NAME: mysqlTYPE : 10 WIN32_OWN_PROCESSSTATE : 4 RUNNING(STOPPABLE, PAUSABLE, ACCEPTS_SHUTDOWN)WIN32_EXIT_CODE : 0 (0x0)SERVICE_EXIT_CODE : 0 (0x0)CHECKPOINT : 0x0WAIT_HINT : 0x0# 这种情况就是mysql 没有删除干净 删除该mysql  sc delete mysql Please consider using UTF8MB4 in order to be unambiguous.</description>
    </item>
    
    <item>
      <title>常用 Console 调试命令</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/tooldoc/js_console%E7%94%A8%E6%B3%95/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/tooldoc/js_console%E7%94%A8%E6%B3%95/</guid>
      <description>Console 对象方法 #    常用 Console 调试命令
  console.log(&#39;hello&#39;);console.info(&#39;信息&#39;);console.error(&#39;错误&#39;);console.warn(&#39;警告&#39;);assert() #   ssert方法接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。  // 实例console.assert(true === false, &amp;quot;判断条件不成立&amp;quot;)// Assertion failed: 判断条件不成立clear() #   清除当前控制台的所有输出，将光标回置到第一行。  console.clear()count() #   用于计数，输出它被调用了多少次。  (function() {for (var i = 0; i &amp;lt; 5; i++) { console.count(&#39;count&#39;); }})()error() #   输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈。  console.error(&amp;quot;Error: %s (%i)&amp;quot;, &amp;quot;Server is not responding&amp;quot;,500)group() #   用于将显示的信息分组，可以把信息进行折叠和展开。  console.</description>
    </item>
    
    <item>
      <title>进程调度的时机、切换与过程、方式</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_2_2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_2_2/</guid>
      <description></description>
    </item>
    
    <item>
      <title>我自己理解的口才练习技巧</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/we4ycwfxb7/</link>
      <pubDate>Wed, 05 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/we4ycwfxb7/</guid>
      <description>1、朗读朗诵。  自己读书,大声地读出来。每天坚持朗读一些文章既可以口齿清晰伶俐,又积累了知识信息量,更重要的是对身体大有益处 每天坚持朗读半小时以上
  2、(气息和声)尝试躺下来朗读 腹式呼吸，这是练声练气的最好方法每天睡觉之前，躺着大声朗读十分钟，每天起床之前，先唱首歌。坚持一两个月，觉会感觉自己的呼吸流畅了，声音洪亮，音质也好听了
  3、对着镜子练习并且录音摄像 便于观察自己哪里有问题
  4、速读训练 是在于锻炼人口齿伶俐，语音准确，吐字清晰
  5、即兴朗读 平时空闲时，你可以随便拿一张报纸，任意翻到一段，然后尽量一气呵成的读下去。而且，在朗读过程中，能够注意一下，上半句看稿子，下半句离开稿子看前面（假设前面有听众）。长期以往，你发现自己记忆力加强许多，快速理解力和即兴构思能力也在加强。
  6、复述法 复述法简单地说，就是把别人的话重复地叙述一遍。可以找一位伙伴一起训练。首先，请对方随便讲一个话题，或是一个故事。自己先注意倾听。然后再向对方复述一遍。这种练习在于锻炼语言的连贯性及现场即兴构思能力，和语言组织能力。如果能面对众人复述就更好了，它还可以锻炼你的胆量，克服紧张心理。
  7、练唇和舌 大概就是在嘴巴里绕舌头
  8、微笑练习 日本微笑瑜伽
  （1）面对镜子，将上排牙齿咬住下唇
（2）将上唇用力往上拉起，直到露出牙龈为止
（3）再将嘴角用力提起，直到脸颊两边肌肉颤抖
（4）接着用力睁大双眼，保持 2 分钟</description>
    </item>
    
    <item>
      <title>park</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/park/</link>
      <pubDate>Mon, 12 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/park/</guid>
      <description>LockSupport 原理和使用 #  一: 基本介绍 #    LockSupport是一个线程阻塞工具类，所有的方法都是静态方法，可以让线程在任意位置阻塞，阻塞之后也有对应的唤醒方法。归根揭底，LockSupport调用的是Unsafe中的native代码
  LockSupport类使用了一种名为Permit（许可）的概念来做到阻塞和唤醒线程的功能，每个线程都有一个许可（permit）。
  permit只有两个值1和0，默认是0。
  可以把许可看成是一种（0，1）信号量（Semaphore），但与Semaphore不同的是，许可的累加上限是1。
  permit默认是0，所以一开始调用park()方法，当前线程就会阻塞，直到别的线程将当前线程的permit设置为1时，park()方法会被唤醒，然后会将permit再次设置为0并返回。
  面试题套路 #  为什么可以先唤醒线程后阻塞线程-----因为unpark获取了一个凭证，之后再调用park方法，就可以名正言顺的凭证消费，故不会阻塞。为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程？-----因为凭证的数量最多为1，连续调用两次unpark和调用一次unpark效果一样，只会增加一个凭证；而调用两次park却需要消费两个凭证，证不够，不能放行。可以把permit理解为boolean只有两个状态位置 大多数基本都使用int来描述booleanlet permit = 0;当 permit = 1是阻塞//第一次 unparkpermit--parkpermit++检测permit=0不会阻塞unparkunpark 第二次 permit由于只能是0和1 所以第二次没有效果park permit 回到初始值park permit达到了阻塞情况 阻塞  3种让线程等待和唤醒的方法
  1:使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程
  2:使用JUC包中Condition的await()方法让线程等待，使用signal()方法唤醒线程
  3:LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程</description>
    </item>
    
    <item>
      <title>ExecutorService</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/executorservice/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/executorservice/</guid>
      <description>ExecutorService #  </description>
    </item>
    
    <item>
      <title>webpack loader</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/webpack_loader/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/webpack_loader/</guid>
      <description>first css-loader #   文件目录  ▸\t1 ▸ \t1\dist ▸ \t1\dist\index.js ▸ \t1\node_modules ▸ \t1\node_modules\.bin //省略 ▸ \t1\node_modules\yocto-queue\readme.md ▸ \t1\package-lock.json ▸ \t1\package.json ▸ \t1\src ▸ \t1\src\index.css ▸ \t1\src\index.js ▸ \t1\webpack.config.js  webpack.config.js content  module.exports = { entry: { index :&amp;#34;./src/index.js&amp;#34; }, mode :&amp;#39;development&amp;#39; , module :{ rules:[ {test :/.css$/ ,use : &amp;#34;css-loader&amp;#34;} ] } }  package.json content  { &amp;#34;name&amp;#34;: &amp;#34;t1&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;1.0.0&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;main&amp;#34;: &amp;#34;webpack.config.js&amp;#34;, &amp;#34;scripts&amp;#34;: { &amp;#34;test&amp;#34;: &amp;#34;echo \&amp;#34;Error: no test specified\&amp;#34; &amp;amp;&amp;amp; exit 1&amp;#34;, &amp;#34;build&amp;#34;: &amp;#34;webpack&amp;#34; }, &amp;#34;keywords&amp;#34;: [], &amp;#34;author&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;license&amp;#34;: &amp;#34;ISC&amp;#34;, &amp;#34;devDependencies&amp;#34;: { &amp;#34;css-loader&amp;#34;: &amp;#34;^5.</description>
    </item>
    
    <item>
      <title>python string</title>
      <link>https://huachengzhou.github.io/life/docs/python/base/string/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/python/base/string/</guid>
      <description>字符串用法 #     方法 描述     capitalize() 把首字符转换为大写。   casefold() 把字符串转换为小写。   center() 返回居中的字符串。   count() 返回指定值在字符串中出现的次数。   encode() 返回字符串的编码版本。   endswith() 如果字符串以指定值结尾，则返回 true。   expandtabs() 设置字符串的 tab 尺寸。   find() 在字符串中搜索指定的值并返回它被找到的位置。   format() 格式化字符串中的指定值。   format_map() 格式化字符串中的指定值。   index() 在字符串中搜索指定的值并返回它被找到的位置。   isalnum() 如果字符串中的所有字符都是字母数字，则返回 True。   isalpha() 如果字符串中的所有字符都在字母表中，则返回 True。   isdecimal() 如果字符串中的所有字符都是小数，则返回 True。   isdigit() 如果字符串中的所有字符都是数字，则返回 True。   isidentifier() 如果字符串是标识符，则返回 True。   islower() 如果字符串中的所有字符都是小写，则返回 True。   isnumeric() 如果字符串中的所有字符都是数，则返回 True。   isprintable() 如果字符串中的所有字符都是可打印的，则返回 True。   isspace() 如果字符串中的所有字符都是空白字符，则返回 True。   istitle() 如果字符串遵循标题规则，则返回 True。   isupper() 如果字符串中的所有字符都是大写，则返回 True。   join() 把可迭代对象的元素连接到字符串的末尾。   ljust() 返回字符串的左对齐版本。   lower() 把字符串转换为小写。   lstrip() 返回字符串的左修剪版本。   maketrans() 返回在转换中使用的转换表。   partition() 返回元组，其中的字符串被分为三部分。   replace() 返回字符串，其中指定的值被替换为指定的值。   rfind() 在字符串中搜索指定的值，并返回它被找到的最后位置。   rindex() 在字符串中搜索指定的值，并返回它被找到的最后位置。   rjust() 返回字符串的右对齐版本。   rpartition() 返回元组，其中字符串分为三部分。   rsplit() 在指定的分隔符处拆分字符串，并返回列表。   rstrip() 返回字符串的右边修剪版本。   split() 在指定的分隔符处拆分字符串，并返回列表。   splitlines() 在换行符处拆分字符串并返回列表。   startswith() 如果以指定值开头的字符串，则返回 true。   strip() 返回字符串的剪裁版本。   swapcase() 切换大小写，小写成为大写，反之亦然。   title() 把每个单词的首字符转换为大写。   translate() 返回被转换的字符串。   upper() 把字符串转换为大写。   zfill() 在字符串的开头填充指定数量的 0 值。    str1 = &amp;#34;a,b&amp;#34; print(str1.</description>
    </item>
    
    <item>
      <title>jsoup学习文档</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/tooldoc/jsoup/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/tooldoc/jsoup/</guid>
      <description>jsoup学习文档 #  简介 #   Jsoup是用于解析HTML，就类似XML解析器用于解析XML。 Jsoup它解析HTML成为真实世界的HTML。 它与jquery选择器的语法非常相似，并且非常灵活容易使用以获得所需的结果
 +jsoup api 6个包提供用于开发jsoup应用程序的类和接口。
org.jsouporg.jsoup.examplesorg.jsoup.helperorg.jsoup.nodesorg.jsoup.parserorg.jsoup.safetyorg.jsoup.salect引入 #  //大多数情况使用jsouporg.jsoup.nodes.Document document = Jsoup.parse(html);Document doc = Jsoup.parse(new URL(&amp;quot;http://www.funi.com/&amp;quot;),7000);//少数情况使用httpUnitWebClient webClient = new WebClient() ;HtmlPage htmlPage = webClient.getPage(&amp;quot;http://www.89ip.cn/&amp;quot;);htmlPage.asXml()//html使用(maven) #  &amp;lt;dependency&amp;gt;&amp;lt;!-- jsoup HTML parser library @ http://jsoup.org/ --&amp;gt;&amp;lt;groupId&amp;gt;org.jsoup&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;jsoup&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;1.10.2&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;!-- httpclient --&amp;gt;&amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;org.apache.httpcomponents&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;httpclient&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;4.5.6&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;net.</description>
    </item>
    
    <item>
      <title>调度算法的评价指标</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_2_3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_2_3/</guid>
      <description></description>
    </item>
    
    <item>
      <title>python pipenv 包管理</title>
      <link>https://huachengzhou.github.io/life/docs/python/base/pipenv/</link>
      <pubDate>Tue, 07 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/python/base/pipenv/</guid>
      <description>pipenv 是Kenneth Reitz大神的作品，提供Python的各个版本间的管理，各种包管理。个人觉得是virtualenv pip等工具的合体
 安装pipenv #   本操作系统为windows10  pip install --user pipenv　# 安装失败 =&amp;gt; 升级一下默认安装的pip版本，因为默认会安装最新版的pipenv，pip的版本过低会导致安装失败.pip更新命令python -m pip install --upgrade pip更新完pip后，再次执行pipenv的安装命令pip install --user pipenv 失败的话 多半是你没能连接上世界真正网络 (自己找个梯子吧)  pipenv的简单使用 #  创建虚拟环境 #   (1)打开cmd窗口，首先切换到目标项目目录，输入以下命令：  # python 2环境pipenv --twopython 3环境pipenv --three （2）查看相关信息 　1） 查看项目位置：pipenv &amp;ndash;where 　2）查看虚拟环境位置：pipenv &amp;ndash;venv 　3）查看解释器信息：pipenv &amp;ndash;py  激活虚拟环境 #  （1）语法 pipenv shell</description>
    </item>
    
    <item>
      <title>自信相关理论</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/wwnrfnfjmb/</link>
      <pubDate>Wed, 05 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/wwnrfnfjmb/</guid>
      <description> 小技巧   到春熙路这些地方送玩具然后请求接受礼物的人答应帮自己一个忙那就是在一些祝福语中抽一个出来 然后我把它念出来 可以对此分类 比如孩子,妇女,男人,学生,中年妇女
 </description>
    </item>
    
    <item>
      <title>Fork-Join</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/fork_join/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/fork_join/</guid>
      <description>Fork-Join #  简介 #  从JDK1.7开始，Java提供Fork/Join框架用于并行执行任务，它的思想就是讲一个大任务分割成若干小任务，最终汇总每个小任务的结果得到这个大任务的结果。
这种思想和MapReduce很像（input &amp;ndash;&amp;gt; split &amp;ndash;&amp;gt; map &amp;ndash;&amp;gt; reduce &amp;ndash;&amp;gt; output）
 主要有两步：   第一、任务切分； 第二、结果合并  它的模型大致是这样的：线程池中的每个线程都有自己的工作队列（PS：这一点和ThreadPoolExecutor不同，ThreadPoolExecutor是所有线程公用一个工作队列， 所有线程都从这个工作队列中取任务），当自己队列中的任务都完成以后，会从其它线程的工作队列中偷一个任务执行，这样可以充分利用资源。
工作窃取（work-stealing） #  工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。工作窃取的运行流程图如下：
那么为什么需要使用工作窃取算法呢？
假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。
工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。
API介绍 #  ForkJoinPool #  ForkJoinPool与其它的ExecutorService区别主要在于它使用“工作窃取”：线程池中的所有线程都企图找到并执行提交给线程池的任务。当大量的任务产生子任务的时候，或者同时当有许多小任务被提交到线程池中的时候，这种处理是非常高效的。特别的，当在构造方法中设置asyncMode为true的时候这种处理更加高效。
ForkJoinTask #  ForkJoinTask代表运行在ForkJoinPool中的任务。
主要方法：
 fork() 在当前线程运行的线程池中安排一个异步执行。简单的理解就是再创建一个子任务。 join() 当任务完成的时候返回计算结果。 invoke() 开始执行任务，如果必要，等待计算完成。  子类：
 RecursiveAction 一个递归无结果的ForkJoinTask（没有返回值） RecursiveTask 一个递归有结果的ForkJoinTask（有返回值）  ForkJoinWorkerThread #  ForkJoinWorkerThread代表ForkJoinPool线程池中的一个执行任务的线程。
 类图  代码分析 #  WorkQueue是一个ForkJoinPool中的内部类，它是线程池中线程的工作队列的一个封装，支持任务窃取。</description>
    </item>
    
    <item>
      <title>node js - npm 重要命令 </title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/npm%E9%87%8D%E8%A6%81%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/npm%E9%87%8D%E8%A6%81%E5%91%BD%E4%BB%A4/</guid>
      <description>npm 包管理器查询网址 #   https://www.npmjs.com/ (和java的maven仓库差不多一个意思)  全局安装 #    npm install less-loader@4.1.0
  npm install less-loader@4.1.0 &amp;ndash;save
  本地安装命令 #    npm install less-loader@3.0.0 &amp;ndash;save-dev
  npm add -D less-loader@3.0.0
   上面两条等价
 升级到最高版本 , 更新npm到最新版本 #   npm i npm@latest -d npm i npm@latest -g  安装所有依赖 (package.json) #   npm install request  删除包问题 #    npm uninstall webpack webpack-cli -g 全局</description>
    </item>
    
    <item>
      <title>centos7安装多个mysql</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_install_centos/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_install_centos/</guid>
      <description>centos7单机安装多个mysql8.0
 一:上传 #  下载地址：https://cdn.mysql.com/archives/mysql-8.0/mysql-8.0.21-linux-glibc2.12-x86_64.tar.xz上传mysql-8.0.21-linux-glibc2.12-x86_64.tar.xz到服务器指定文件夹，如：/home/mysql二:解压 #  cd /home/mysqltar -xvf mysql-8.0.21-linux-glibc2.12-x86_64.tar.xz三:重命名文件夹 #  mv mysql-8.0.21-linux-glibc2.12-x86_64 mysql3306四:新建mysql用户、mysql用户组 #  cd /home/mysql/mysql3306#新建mysql用户、mysql用户组，如果之前已经建立过，就不用建立了groupadd mysql#给mysql添加用户为 mysqluseradd mysql -g mysql五:在mysql3306下新增文件夹data，var，tmp，binlogs，logs备用 #  cd /home/mysql/mysql3306mkdir data var tmp binlogs logschmod 777 ./tmpchmod 777 ./logscd /home/mysql/mysql3306/logstouch error.log六:在/home/mysql/mysql3306/etc下创建数据库配置文件 #  cd /home/mysql/mysql3306mkdir etccd /home/mysql/mysql3306/etctouch my.cnfvim my.cnf# my.</description>
    </item>
    
    <item>
      <title>mysql_数据库设计三范式</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F/</guid>
      <description>设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。
  目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。
 数据库三范式 #  第一范式（1NF） #   所谓第一范式（1NF）是指在关系模型中，对域添加的一个规范要求，所有的域都应该是原子性的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。简而言之，第一范式就是无重复的域。 说明：在任何一个关系数据库中，第一范式（1NF）是对关系模式的设计基本要求，一般设计中都必须满足第一范式（1NF）。不过有些关系模型中突破了1NF的限制，这种称为非1NF的关系模型。换句话说，是否必须满足1NF的最低要求，主要依赖于所使用的关系模型。  第二范式（2NF） #   在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖） 第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或记录必须可以被唯一地区分。选取一个能区分每个实体的属性或属性组，作为实体的唯一标识。例如在员工表中的身份证号码即可实现每个一员工的区分，该身份证号码即为候选键，任何一个候选键都可以被选作主键。在找不到候选键时，可额外增加属性以实现区分，如果在员工关系中，没有对其身份证号进行存储，而姓名可能会在数据库运行的某个时间重复，无法区分出实体时，设计辟如ID等不重复的编号以实现区分，被添加的编号或ID选作主键。（该主键的添加是在ER设计时添加，不是建库时随意添加） 第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是在第一范式的基础上属性完全依赖于主键。  第三范式（3NF） #   在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） 第三范式（3NF）是第二范式（2NF）的一个子集，即满足第三范式（3NF）必须满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个关系中不包含已在其它关系已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性，也就是在满足2NF的基础上，任何非主属性不得传递依赖于主属性。  巴斯-科德范式（BCNF） #   Boyce-Codd Normal Form（巴斯-科德范式）
  在3NF基础上，任何非主属性不能对主键子集依赖（在3NF基础上消除对主码子集的依赖） 巴斯-科德范式（BCNF）是第三范式（3NF）的一个子集，即满足巴斯-科德范式（BCNF）必须满足第三范式（3NF）。通常情况下，巴斯-科德范式被认为没有新的设计规范加入，只是对第二范式与第三范式中设计规范要求更强，因而被认为是修正第三范式，也就是说，它事实上是对第三范式的修正，使数据库冗余度更小。这也是BCNF不被称为第四范式的原因。某些书上，根据范式要求的递增性将其称之为第四范式是不规范，也是更让人不容易理解的地方。而真正的第四范式，则是在设计规范中添加了对多值及依赖的要求。 定义：关系模式R&amp;lt;U,F&amp;gt;∈1FNF,若X→Y且Y不是X的子集时X必含有码，则R&amp;lt;U,F&amp;gt;∈BCNF。也就是说，关系模式R&amp;lt;U,F&amp;gt;中，若每一个决定因素都包含码，则R&amp;lt;U,F&amp;gt;∈BCNF。   由BCNF的定义可以得到结论，一个满足BCNF的关系模式有：
  -所有非主属性对每一个码都是完全函数依赖。 -所有主属性对每一个不包含它的码也是完全函数依赖。 -没有任何属性完全函数依赖于非码的任何一组属性。 若R∈BCNF，按定义排除了任何属性对码的传递依赖与部分依赖，所以R∈3NF。[1] 一般关系型数据库设计中，达到BCNF就可以了！  #【数据库五大约束】
 1.primary KEY:设置主键约束； 2.UNIQUE：设置唯一性约束，不能有重复值； 3.DEFAULT 默认值约束，height DOUBLE(3,2)DEFAULT 1.2 height不输入是默认为1,2 4.NOT NULL：设置非空约束，该字段不能为空； 5.FOREIGN key :设置外键约束。  【主键】 #   1.</description>
    </item>
    
    <item>
      <title>spring工具类</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/tooldoc/spring%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/tooldoc/spring%E5%B7%A5%E5%85%B7/</guid>
      <description>spring工具类 #   Spring-core中提供了大量的工具类，常用的有StringUtils、ObjectUtils、NumberUtils、Base64Utils等，Spring工具类在spring-core.jar中的org.springframework.util包下。
  1:StringUtils  方法名	返回值类型	作用	备注isEmpty(Object str)	boolean	判断字符串是否为Null或者空字符串	null和&#39;&#39;都为truehasLength(CharSequence str)	boolean	判断字符串长度是否大于1	null和&#39;&#39;都为falsehasText(CharSequence str)	boolean	判断字符串中是否有字符	null和空字白符都为falsecontainsWhitespace(CharSequence str)	boolean	字符串中是否含有空白字符	trimWhitespace(CharSequence str)	String	去掉字符串中首尾的空白字符	trimAllWhitespace(String str)	String	去 掉字符串中所有的空白字符	trimLeadingWhitespace(String str)	String	去掉字符串左边的空白字符	trimTrailingWhitespace(String str)	String	去掉字符串右边边的空白字符	startsWithIgnoreCase(String str, String prefix)	String	判断字符串是否以xx开头，并且忽略大小写	getFilename(String path)	String	获取文件名	“mypath/myfile.txt” -&amp;gt; “myfile.txt”getFilenameExtension(String path)	String	获取文件扩展名	“mypath/myfile.txt” -&amp;gt; “txt”stripFilenameExtension(String path)	String	去掉文件扩展名	“mypath/myfile.</description>
    </item>
    
    <item>
      <title>线程最佳实践</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/practice/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/practice/</guid>
      <description>线程最佳实践 #  </description>
    </item>
    
    <item>
      <title>我自己理解的聊天技巧</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/b3akcg3n8k/</link>
      <pubDate>Wed, 05 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/b3akcg3n8k/</guid>
      <description>  1:要让对方觉得你在用心和她/他聊天
  2:要尽可能的照顾到对方的情绪因为聊天实际意义并不大共情的意义才是最大的 特别是情侣
  3:聊天后 你如果在意这个人 应当复盘和做相应的记录比如 生日,爱好,兴趣
  4:假如你以前不怎么会聊天 你最好每天总结聊天技巧
  </description>
    </item>
    
    <item>
      <title>并发集合框架</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/collection/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/collection/</guid>
      <description>collection #  </description>
    </item>
    
    <item>
      <title>npm部分插件安装问题 </title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/npm%E9%83%A8%E5%88%86%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/npm%E9%83%A8%E5%88%86%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/</guid>
      <description>less版本过高的解决办法  解决方法：卸载安装的高版本的less-loader ， 【npm uninstall less-loader】，安装指定低版本的less-loader 【npm install less-loader@4.1.0 --save】 webpack Cannot read property &amp;lsquo;tap&amp;rsquo; of undefined ?  解决：这个报错是webpack依赖重复引入导致的，由于已经有依赖中引入的webpack，然后有自己引入的webpack。下面是生产的依赖，将“webpack”: “^4.0.0-beta.3”,“webpack-dev-server”: “2.7.1”,“webpack-manifest-plugin”: “1.2.1”,删掉，移除node_modules。重新npm install 。再启动项目，就搞定了 使用webpack打包报ERROR in TypeError: Cannot read property ‘tap‘ of undefined  降低版本 webpack假如降为4.44.2 则npm install webpack@4.44.2 -g 全局npm install webpack@4.44.2 -D 局部 less-loader模块 TypeError: this.getOptions is not a function  原因： less-loader安装的版本过高解决方案： 1.</description>
    </item>
    
    <item>
      <title>python 面向对象</title>
      <link>https://huachengzhou.github.io/life/docs/python/base/python-object/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/python/base/python-object/</guid>
      <description>面向对象 #   类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或者实例变量, 用于处理类及其实例对象的相关的数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 局部变量：定义在方法中的变量，只作用于当前实例的类。 实例变量：在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟&amp;quot;是一个（is-a）&amp;ldquo;关系（例图，Dog是一个Animal）。 实例化：创建一个类的实例，类的具体对象。 方法：类中定义的函数。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。  import random class Employee: # 所有员工的基类 empCount 变量是一个类变量，它的值将在这个类的所有实例之间共享 empCount = 0 # 类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法 def __init__(self, name, salary): self.name = name self.salary = salary Employee.empCount += 1 def displayCount(self): print(&amp;#34;Total Employee&amp;#34;, Employee.empCount, sep=&amp;#34; _&amp;#34;) def displayEmployee(self): print(&amp;#34;name:&amp;#34;, self.name, &amp;#34; ;&amp;#34;, &amp;#34;salary:&amp;#34;, self.salary) # 定义实例 1 t1 = Employee(&amp;#34;张三&amp;#34;, random.random() * random.random() * 10000) t1.</description>
    </item>
    
    <item>
      <title>mysql事务</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql%E4%BA%8B%E5%8A%A1/</guid>
      <description>什么是事务 #   一系列有序的数据库操作：  要么全部成功 要么全部回退到操作前的状态 中间状态对其他连接不可见   事务的基本操作：    基本操作 说明     start transaction 开始事务   commit 提交(全部完成)   rollback 回滚(回到初始状态)       创建一个临时表  CREATE TABLE `t_transaction` ( `id` int NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `num` bigint DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;  例子事务使用  -- 开启一个事务 start TRANSACTION ; -- 或者使用(非标准sql) begin ; insert into t_transaction( `name` ,`num`) values(&amp;#39;abc&amp;#39;,ROUND(RAND()*100)); -- 事务结束，插入成功 COMMIT ;  例子 事务 回滚  START TRANSACTION ; BEGIN ; insert into t_transaction( `name` ,`num`) values(&amp;#39;kk&amp;#39;,ROUND(RAND()*100)); ROLLBACK ; -- 不会插入一条数据   事务回滚点  START TRANSACTION ; BEGIN ; insert into t_transaction( `name` ,`num`) values(&amp;#39;s1x&amp;#39;,ROUND(RAND()*100)); -- 设置回滚点1 savepoint a_point_1; insert into t_transaction( `name` ,`num`) values(&amp;#39;s1&amp;#39;,ROUND(RAND()*100)); -- 回滚到指定点 ROLLBACK to a_point_1; commit ; 自动提交 #   autocommit可以在session级别设置 每个DML操作都自动提交 DDL永远都是自动提交，无法通过rollback回滚  事务的四个基本属性(ACID) #   原子性(Atomicity) 一致性(Consistency) 隔离性(Isolation) 持久性(Durability)  事务的原子性 #   包含在事务中的操作要么全部被执行，要么都不执行 中途数据库或应用发生异常，未提交的事务都应该被回滚  事务的一致性 #   数据的正确性，合理性，完整性 数据一致性应该符合应用需要规则：  余额不能是负数 交易对象必须先有账号 用户账号不能重复   事务的结果需要满足数据的一致性约束  事物的持久性 #   提交完成的事务对数据库的影响必须是永久性的  数据库异常不会丢失事务更新 通常认为成功写入磁盘的数据即为持久化成功    事务的持久化的实现 #   数据文件持久化  随机同步刷新(慢)   事务日志持久化与实例恢复  顺序同步刷新(快) -&amp;gt; 事务日志 随机异步刷新 -&amp;gt; 磁盘 事务日志 -&amp;gt; 磁盘(实例恢复)    事务的隔离性 #   数据库事务在提交完成前，中间的任何数据变化对其他的事务都是不可见的。  数据库隔离现象 #     隔离现象 描述     脏读(Dirty Read) 事务B读到事务A尚未提交的数据变更   不可重复读(NonRepeatable Read) 事务B读取前后两次读取一条记录之间该记录被事务A修改并提交，于是事务B读到了不一样的结果   幻读(Phantom Read) 事务B按条件匹配到了若干行记录并修改。但是由于修改过程中事务A新插入了符合条件记录，导致B更新完成后发现仍有符合条件却未被更新的记录。    数据库隔离等级 #     隔离等级 脏读 不可重复读 幻读     未提交读 可能 可能 可能   已提交读 不可能 可能 可能   可重复读 不可能 不可能 可能   可串行化读 不可能 不可能 不可能    MySQL的事务隔离级别 #   InnoDB默认标记为可重复读 InnoDB并不是标准定义上的课重复读 InnoDB默认在可重复读的基础上避免幻读  MySQL事务隔离级别设置 #   可在global/session/下个事务，级别分别进行设置 建议使用Read committed(同Oracle) 或者建议使用默认的Repeatable read  set tx_isolation = &amp;#39;&amp;#39; -- 设置隔离级别 事务与并发写 #   某个正在更新的记录再提交或回滚前不能被其他事务同时更新  事务回滚的实现 #   回滚段(rollback segment)与数据前像  </description>
    </item>
    
    <item>
      <title>spring常用的工具类</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/tooldoc/spring%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/tooldoc/spring%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/</guid>
      <description>spring常用的工具类 #  内置的resouce类型 #  UrlResourceClassPathResourceFileSystemResourceServletContextResourceInputStreamResourceByteArrayResourceEncodedResource 也就是Resource加上encoding, 可以认为是有编码的资源VfsResource(在jboss里经常用到, 相应还有 工具类 VfsUtils)org.springframework.util.xml.ResourceUtils 用于处理表达资源字符串前缀描述资源的工具. 如: &amp;amp;quot;classpath:&amp;amp;quot;. 有 getURL, getFile, isFileURL, isJarURL, extractJarFileURL 工具类 #  org.springframework.core.annotation.AnnotationUtils 处理注解org.springframework.core.io.support.PathMatchingResourcePatternResolver 用 于处理 ant 匹配风格(com/*.jsp, com/**/*.jsp),找出所有的资源, 结合上面的resource的概念一起使用,对于遍历文件很有用. 具体请详细查看javadocorg.springframework.core.io.support.PropertiesLoaderUtils 加载Properties资源工具类,和Resource结合org.springframework.core.BridgeMethodResolver 桥接方法分析器. 关于桥接方法请参考: http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.12.4.5org.springframework.core.GenericTypeResolver 范型分析器, 在用于对范型方法, 参数分析.org.springframework.core.NestedExceptionUtilsxml工具 #  org.springframework.util.xml.AbstractStaxContentHandlerorg.springframework.util.xml.AbstractStaxXMLReaderorg.springframework.util.xml.AbstractXMLReaderorg.springframework.util.xml.AbstractXMLStreamReaderorg.springframework.util.xml.DomUtilsorg.springframework.util.xml.SimpleNamespaceContextorg.springframework.util.xml.SimpleSaxErrorHandlerorg.springframework.util.xml.SimpleTransformErrorListenerorg.springframework.util.xml.StaxUtilsorg.springframework.util.xml.TransformerUtils其它工具集 #  org.springframework.util.xml.AntPathMatcherant风格的处理org.</description>
    </item>
    
    <item>
      <title>使自己成熟稳重</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/6ngdcha8bk/</link>
      <pubDate>Wed, 05 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/6ngdcha8bk/</guid>
      <description>如何改变性格 #  case1 #  1、自我反省 #  稻盛和夫说，要每天反省。 他非常强调反省，他每天都会不断地问自己：今天有没有让别人感到不愉快？待人是否亲切？是否傲慢？有没有自私的行为？
通过这样的一些问题，不断回望自己，回顾自己的一天。 对照做人最基本的准则，确认自己的言行举止是否得当。 自我反省是人生的最高境界，通过过不断检讨自己的行为，更好地适应他人，也让自己变得更好。 正是这种正面的自我反省，才会让我们始终不偏离正确的航向，成功的步伐就会越迈越大。
2、注重自己有深刻感受的地方 #  只有我们自己有深刻感受的地方，才能容易改。 如果我们没有那些经历和感受，别人说太多，自己用再多的方法，也起不到任何作用。 我们要注重自己的亲身体验。 只有经常吃亏、经常碰壁并且反思自己，才能够慢慢改变自己。 时间长了性格自然会变好。
3、改变自己的习惯 #  习惯是很容易影响一个人的，如果自己以前的生活、说话做事的习惯有不好的地方，我们都要学会改变。 想要改变自己，养成所希望的性格，我们要学会尝试去做一些跟以前截然不同的事，并且不断形成新的习惯。 这样子别人对你的看法就会发生改变，情感也会发生变化。 这样我们也会受到积极的鼓舞，就会更加有信心，性格也会变得更好。
4、打开自己的心门 #  我们要学会敞开自己的心门，只有敞开心扉，我们才能成为阳光乐观的人。 坚持下去你就会发现你会变得更加开朗。 我们不要总是沉浸在自己的世界之中。你 要知道生活中某些重要的事情对我们的影响非常巨大，能够改变我们的观点和做法，这样子就会慢慢影响着我们为人处世得方式，性格也会慢慢改变。
5、虚心接受意见 #  生活中很多人会很自我，觉得自己认为的就是对的。 这种人大多数是固执已见，很难听得进去别人的意见或建议，只认准自己的理论，觉得自己的就是对的，很多时候我们并不想跟这样的人深交。 所以如果你觉得自己属于这种人，就要学会去改变下自己。 学会接受他人的意见，学会倾听和尝试。 这样子我们才能够更好跟别人走在一起，并且有更多的共同话题
6、敢于尝试 #  有句话说得好：“不管舞台有多大，你不上台演讲，永远只是个观众；不管平台有多好，不参与就赚不到钱；不管胆子有多大，都不敢闯入，永远发挥不了作用。只有敢于尝试、敢想敢干、敢于突破的人才会成功！”
每一个优秀的人，都是敢于去尝试，去不断折腾。
因为只有敢于去尝试，你才能知道自己究竟有多么优秀，你才能配得上当初努力付出的自己。
反之，做任何事情都不敢去尝试，那么只会原地踏步，甚至往后退。
一件事情，如果你下定决心去做，有可能成功，也有可能不成功。
但是，只要你去做，就要百分之五十的成功率，你不去做，就一点可能都没有。 任何事如果仅仅是停留在想的阶段，那么都不会有进展，有结果的。 人要敢于尝试，才能遇见不一样的自己。
要想改变性格，必须要坚持。
只有坚持才有希望，只有坚持才能得到自己想要的。
case2 #  从小到大我就被长辈朋友说傻、呆、笨、二。一直以来也比较佛系，因为有一堆爱我的人，他们也认可我的才华。直到最近一次，被一个人再次提起。我才开始意识到，很多时候某些聪明人第一眼就能看出我的气质，不是偶然，也不是不够了解我（然而我之前一直以为他们并不懂我）。而是我的确有这样的性格特点，当然这不是缺陷，只要不影响工作和生活，完全可以继续我行我素地活下去。但是我开始不甘心了，我希望自己在处理专业以外事情上能够通畅无阻、游刃有余。如果每次都被打上这样的标签，我不会愿意。我也不愿一辈子都这样。以前安慰自己傻人有傻福，单纯坦率没有心机很难得。直到我发现有另外一种人，他们的确没有心机，但是他们有趣，懂得察言观色，又很真性情。这就是把聪明用在对的地方，而且学识丰富，活出自我的人。我想，这会是我的目标，以下是我的自我缺点分析和解决方法。自己想了一些办法，怕忘记才写下来的，共勉：
1.不爱思考（笨）
多思考，观察事情，寻找规律和共性，总结经验，用于下一次相似问题的处理。
2.说话不经过大脑（一根筋）
宁可晚回复，也要说对的话、精准的话。如此反复训练，逐渐训练话术与语速。
3.没有时间观念（拖延）
超强计划力，不断给自己定目标，绝对不浪费任何时间。
4.没有说服能力，容易妥协，不维护自我利益，总被人坑（傻）
多用逻辑清楚三点表达法，交流前自己先用辩证法辩一遍，没有逻辑漏洞了，再去说服别人。</description>
    </item>
    
    <item>
      <title>webpack 应用自己插件 </title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/my-plugins/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/my-plugins/</guid>
      <description>webpack.config.js  const ConsoleLogOnBuildWebpackPlugin = require(&amp;#34;./src/console_log_on_build_webpack_plugin.js&amp;#34;); module.exports = { entry: { index: &amp;#34;./src/index.js&amp;#34; }, mode: &amp;#39;development&amp;#39;, plugins: [ new ConsoleLogOnBuildWebpackPlugin() ] };  package.json  { &amp;#34;name&amp;#34;: &amp;#34;demo08&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;1.0.0&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;main&amp;#34;: &amp;#34;webpack.config.js&amp;#34;, &amp;#34;scripts&amp;#34;: { &amp;#34;test&amp;#34;: &amp;#34;echo \&amp;#34;Error: no test specified\&amp;#34; &amp;amp;&amp;amp; exit 1&amp;#34;, &amp;#34;build&amp;#34; : &amp;#34;webpack&amp;#34; }, &amp;#34;keywords&amp;#34;: [], &amp;#34;author&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;license&amp;#34;: &amp;#34;ISC&amp;#34;, &amp;#34;devDependencies&amp;#34;: { &amp;#34;webpack&amp;#34;: &amp;#34;^5.44.0&amp;#34;, &amp;#34;webpack-cli&amp;#34;: &amp;#34;^4.7.2&amp;#34; } }  src console_log_on_build_webpack_plugin.js index.js  // console_log_on_build_webpack_plugin.</description>
    </item>
    
    <item>
      <title>mysql函数</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql%E5%87%BD%E6%95%B0/</guid>
      <description>日期函数 #    返回当前日期，只包含年月日 select curdate()
  返回当前时间，只包含时分秒 select curtime()
  返回当前的日期和时间，年月日时分秒全都包含 select now()
  提取具体日期类型 #   year() yearweek() ,hour(),month()等等   select year(now()) as &amp;lsquo;年&amp;rsquo;,yearweek(now()) as &amp;lsquo;年,周&amp;rsquo;,hour(now()) as &amp;lsquo;周&amp;rsquo;,minute(now()) as &amp;lsquo;小时&amp;rsquo;,month(now()) &amp;lsquo;月&amp;rsquo;,monthname(now()) &amp;lsquo;月名字&amp;rsquo;,dayofmonth(now()) as &amp;lsquo;当月多少日&amp;rsquo;   EXTRACT() 函数用于返回日期/时间的单独部分，比如年、月、日、小时、分钟等等。   (select extract(year from now()),extract(month from now()),extract(day from now()),extract(hour from now()),extract(minute from now()))  日期格式 #   DATE_FORMAT(date,fmt)函数：按字符串 fmt 格式化日期 date 值 (select date_format(now(),&#39;%Y-%m-%d&#39;))  日期运算 #    date_add(date,interval number dateType) example (select date_add(now(),interval 2 year) as &amp;lsquo;add 2 year date&amp;rsquo;) (select date_add(now(),interval -2 hour) as &amp;lsquo;add 2&amp;rsquo;)也可以传入负数即回到过去某个时间</description>
    </item>
    
    <item>
      <title>复盘</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/swtj6fgd6s/</link>
      <pubDate>Wed, 05 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/swtj6fgd6s/</guid>
      <description>复盘 #  复盘，借鉴于围棋的一个术语。在围棋中的意思是：下完一盘棋之后，要重新在棋盘上走一遍， 看看那些棋子下得好，哪些棋子下得不好等等。重新走一遍并且思考的过程就称为复盘或者复局。 这种走一遍不是简单地重新将棋子按照原来顺序摆满棋盘，而是要对每一手重新进行思考， 一方面是还原当时的思考逻辑，另一方面因为是事后的重来，可以过滤对局时的情绪， 获得一种站在画面外看画的角度，给自己理解重新思考的机会。
把复盘用于企业经营管理是柳传志柳总最先提出来，指通过对已经发生的事情进行回顾， 总结得失总结经验教训，从而掌握规律和方法，以便更好地达成终极目标， 或者再次发生同类事情时更好地处理。
复盘，可以流于形式，也可以非常深刻，取决于两方面因素，一方面是心态——开放的心态可以让我们正视问题、坦诚表达， 从而带来深刻的复盘，抵触防御的心态只能带来流于形式的复盘；一个是方法，复盘是有方法的，有高手在实践中，总结出复盘四步法：
 Step1.回顾目标  回忆下你做这件事之前，你的目的或期望是什么？ 这个目标设定得靠谱、精确吗？应用“SMART法则”扫描目标 有没有发生“目标损耗”？事前定了个高目标，事后没达到，安慰自己说：“还是有成长的”。 团队是否还记得目标？是否对于目标有共同的认知？
 Step2. 评估结果  满分100分，你给自己打多少分？ 差了多少分？差在哪里? 如果能够再提高10分，你希望提高在哪里？
 Step3.分析原因  情景再现，一个个环节回顾事情的事前、事中、事后全流程，分析成功或失败的关键原因。 可控的：有没有更好的做法？是不是全力以赴？ 需要合作的 :自己的部分做好了吗？需要合作部分,是否为别人留出了足够的空间、时间和支持？ 不可控的：是否有充分沟通，即时跟进进度？ 有没有方式纳入控制？有没有控制风险？
 Step4. 总结经验  哪些事情应该坚持做，哪些应该马上停止做？ 哪些人、行为的价值值得重新评估？ 哪些事可以做得更好？具体该如何做？ 对整个事情背后的规律，你有什么新的认识？ 有没有哪些“经验”，其实是假设？
 参考  </description>
    </item>
    
    <item>
      <title>如何变得更加成熟</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/8m3fmhf6t3/</link>
      <pubDate>Wed, 05 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/8m3fmhf6t3/</guid>
      <description>顺境做事,逆境读书,绝境养生 不要因为自己受到不公就否定这个世界上的公平
 一:成熟的标志是什么 #   拿事儿  这个词，既包括一个人具有独立主持完成一项工作所需要的专业技术能力和沟通交流能力，也包括 了一个人在决策和执行中有权拒绝他人干扰的权威性以及主动承担其可能造成不良后果的诚信度。 一个人能拿住一件事儿，大到治理一家单位，小到能带老丈人去医院看病，就表明了他是一个可以 被视作拥有公民权的独立成年个体。
人平事，事评人。成熟不成熟，还得事上见。每个人的能力有大有小，但只要能拿住一件事，就是 一个成熟的人。 不管男人女人，成年了，就都得拿事儿。
 不再憧憬爱情  人和人是有巨大的不同的，人和人的差别比哈士奇和泰迪的差别更大。
有的人年纪轻轻，就混吃等死，有的人年过半百，仍旧坚守信念。
有的人少年老成，喜怒不形于色，有的人头发花白，仍旧叽叽喳喳。
有的人，勇于承担责任，在家里，在单位，都是顶呱呱，但有的人，一辈子的妈宝，能留就留，能滑就滑。
有的人，年少荒唐，但成年之后，顶天立地。但也有的人，年轻的时候人模狗样，年纪大了，为了利益，无所不用其极，毫无底线，一切皆可交易。
那你说什么叫做成熟？
难道那些没有承担，没有大脑，连人品都没有的人就永远不成熟了？？虽然是歪瓜裂枣，但也不能青春永驻不是。
但是，所有的人，不管男女，当你有了一定的社会经验，你都天然的会懂得，爱情这玩意，是属于少男少女的青春荷尔蒙。
有就有，没有就是没有，你没办法强求。
当你还在憧憬爱情，你就还没有经受过社会的毒打。当你放弃了这种想法，有一天爱情或许会来找你，但概率也并不高。
人生这场游戏，每个人都认为自己独一无二，但其实大家都是生产线上批量生产的，每个人大脑中都有一些出厂就有的先天设置。在社会上摸爬滚打之后，这些设置有的就必须改变，有的或许可以长久保留。每个人的境遇不同而不同。
但是，相同的是，在经过社会的洗礼之后，成熟的人会懂得，自己的依靠和寄托，可以是事业，可以是金钱，也可以是情怀。同样，可以是无耻，可以是没有底线，可以是一切皆可交易，也可以是匍匐脚下，
但，唯独不会是爱情。
如果你的寄托是爱情，那只是你选择了匍匐脚下，而又死要面子活受罪的不愿意承认罢了。
爱情只不过是性心理驱动的大脑逆向合理化之后的自我幻想。
世间真有这种东西，不用怀疑。
但就像海市蜃楼，你千万不要把这当成真实。
 自我维持  最核心的标志是自我维持。其他都是衍生品或具体个性化选择
自我维持必然意味着，对权利和义务、收益和成本、机会和代价，首先有默认，其次有全面和较为准确的评估。而不是，仅能看到权利、收益和机会，无视义务、成本和代价，或假想该由他人承担 — 这本质上是巨婴。
在此基础上，个性化选择的方向，是完全无所谓的。有些人选择入世，有些人选择出世；有些人选择积极地照耀他人，有些人选择守好自己的城堡；有些人天然esfj，有些人天然intp……都可以很成熟，也都可以不成熟，核心不是这些具体方向的选择或天性特征，而依然是是否能做到自我维持，认清权责，并全套接受。
另一个常见的衍生品，则是情绪相对较为稳定。想清楚权责，就会建立合理预期 — 对潜在收益的预期，对可能的不确定性即风险的预期。实现收益时，会明白这是承担了对应风险的溢价实现，于是不会喜出望外；无法实现收益乃至出现损失时，也会明白这是预期必然对应的随机性，于是也不会过于失落。
总之，成熟的根本特征是自我维持。其他特征，或者，仅是自我维持的自然衍生；或者，并非成熟的必然特征，仅是一种个性化的具体选择。
 放弃和取舍  懂得且愿意，为了最少数的原则（或欲望），而放弃最大多数的原则（或执念）。
人生的成熟过程，其实就是一个被现实不断打磨的过程。
而打磨本身其实就是一次次大大小小的挫折组成的。
生活像锉刀一样，锉去了你的理想，你的锐气，你的欲望。
在这样的历程中，学会了取舍，学会了坚强，学会了隐忍，学会了放弃。
而所有的一切，只是你想要集中所有的力量去保护好你心中最重要的东西。
所以，成熟其实至少包涵着两个层面的问题：
1.在认知上，经过历练、筛选和左右权衡，认识到什么东西才是对自己最重要的。
哪些东西是不能放弃的，而哪些东西是可以完全放弃的或暂时放弃的。
这就是关于取舍的认知。没有经历过打磨的人，其实是很难清楚地知道取舍的。
他们总觉得再努力一下，什么都有可能拥有，所以是舍不得舍弃某些欲望的。
就像一个人被无数次灌输健康很重要的观点，但是在他经历严重病痛折磨前，其实很难真正体会这一点的。
2.在实践上，能够真正做到放下，且豁达、坦然。
认知是一回事儿，实践是另一回事儿。
在成熟这个问题上，知难，行也难。
因为很多取舍，本身就是两难。
你必须在两个都非常重要的东西之间，选择保留一个而放弃一个。
而很多人往往在痛苦的纠结中，犹豫不决，错失良机。 即便做了选择，也一辈子或长期处于懊丧之中，自责之中。 只有真正成熟的人，才能活得通透，活得坦然，哪怕是在别人看来错误的选择，他也能坦然视之。 活得理性而坚定，淡定而从容，这个时候，一个男生自然而然会由内而外地散发出成熟的气质。 所以，成熟，不是能装出来的，也不是有钱有势就行，甚至不是办事能力，恰恰相反，成熟更像是一种在应对灾难时所表现出来的心理抗性或抵抗力。 譬如面对死亡，谁也没有能力解决，成熟与不成熟的一个表现就是你能否坦然面对死亡。 对于失败，也是如此。</description>
    </item>
    
    <item>
      <title>webpack 热更新 </title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/webpack%E7%83%AD%E6%9B%B4%E6%96%B0/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/webpack%E7%83%AD%E6%9B%B4%E6%96%B0/</guid>
      <description>package.json  { &amp;#34;name&amp;#34;: &amp;#34;demo09&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;1.0.0&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;main&amp;#34;: &amp;#34;index.js&amp;#34;, &amp;#34;scripts&amp;#34;: { &amp;#34;test&amp;#34;: &amp;#34;echo \&amp;#34;Error: no test specified\&amp;#34; &amp;amp;&amp;amp; exit 1&amp;#34;, &amp;#34;build&amp;#34;: &amp;#34;webpack&amp;#34;, &amp;#34;dev&amp;#34;: &amp;#34;webpack-dev-server&amp;#34; }, &amp;#34;keywords&amp;#34;: [], &amp;#34;author&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;license&amp;#34;: &amp;#34;ISC&amp;#34;, &amp;#34;devDependencies&amp;#34;: { &amp;#34;html-webpack-plugin&amp;#34;: &amp;#34;^5.3.2&amp;#34;, &amp;#34;webpack&amp;#34;: &amp;#34;^5.45.1&amp;#34;, &amp;#34;webpack-cli&amp;#34;: &amp;#34;^3.3.12&amp;#34;, &amp;#34;webpack-dev-server&amp;#34;: &amp;#34;^3.11.2&amp;#34; } }  webpack.config.js  const path = require(&amp;#34;path&amp;#34;); const webpack = require(&amp;#34;webpack&amp;#34;); const HtmlWebpackPlugin = require(&amp;#39;html-webpack-plugin&amp;#39;); module.exports = { entry: { &amp;#34;index&amp;#34;: &amp;#34;./src/index.js&amp;#34; }, mode: &amp;#34;development&amp;#34;, output: { path: path.</description>
    </item>
    
    <item>
      <title>python 文件</title>
      <link>https://huachengzhou.github.io/life/docs/python/base/file/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/python/base/file/</guid>
      <description>文件 #   open()  open() 函数用于创建或打开指定文件，该函数的常用语法格式如下：
file = open(file_name [, mode=&#39;r&#39; [ , buffering=-1 [ , encoding = None ]]])此格式中，用 [] 括起来的部分为可选参数，即可以使用也可以省略。其中，各个参数所代表的含义如下：
  file：表示要创建的文件对象。
  file_name：要创建或打开文件的文件名称，该名称要用引号（单引号或双引号都可以）括起来。需要注意的是，如果要打开的文件和当前执行的代码文件位于同一目录，则直接写文件名即可；否则，此参数需要指定打开文件所在的完整路径。
  mode：可选参数，用于指定文件的打开模式。可选的打开模式如表 1 所示。如果不写，则默认以只读（r）模式打开文件。
  buffering：可选参数，用于指定对文件做读写操作时，是否使用缓冲区（本节后续会详细介绍）。
  encoding：手动设定打开文件时所使用的编码格式，不同平台的 ecoding 参数值也不同，以 Windows 为例，其默认为 cp936（实际上就是 GBK 编码）。
  open 函数支持的文件打开模式
     模式 意义 注意事项     r 只读模式打开文件，读文件内容的指针会放在文件的开头。 操作的文件必须存在。   rb 以二进制格式、采用只读模式打开文件，读文件内容的指针位于文件的开头，一般用于非文本文件，如图片文件、音频文件等。    r+ 打开文件后，既可以从头读取文件内容，也可以从开头向文件中写入新的内容，写入的新内容会覆盖文件中等长度的原有内容。    rb+ 以二进制格式、采用读写模式打开文件，读写文件的指针会放在文件的开头，通常针对非文本文件（如音频文件）。    w 以只写模式打开文件，若该文件存在，打开时会清空文件中原有的内容。 若文件存在，会清空其原有内容（覆盖文件）；反之，则创建新文件。   wb 以二进制格式、只写模式打开文件，一般用于非文本文件（如音频文件）    w+ 打开文件后，会对原有内容进行清空，并对该文件有读写权限。    wb+ 以二进制格式、读写模式打开文件，一般用于非文本文件    a 以追加模式打开一个文件，对文件只有写入权限，如果文件已经存在，文件指针将放在文件的末尾（即新写入内容会位于已有内容之后）；反之，则会创建新文件。     ab 以二进制格式打开文件，并采用追加模式，对文件只有写权限。如果该文件已存在，文件指针位于文件末尾（新写入文件会位于已有内容之后）；反之，则创建新文件。     a+ 以读写模式打开文件；如果文件存在，文件指针放在文件的末尾（新写入文件会位于已有内容之后）；反之，则创建新文件。     ab+ 以二进制模式打开文件，并采用追加模式，对文件具有读写权限，如果文件存在，则文件指针位于文件的末尾（新写入文件会位于已有内容之后）；反之，则创建新文件。       File对象的属性     属性 描述     file.</description>
    </item>
    
    <item>
      <title>mysql存储引擎</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</guid>
      <description>MySQL 存储引擎概述 #   MySQL 5.0 支持的存储引擎包括 MyISAM、 InnoDB、 BDB、 MEMORY、 MERGE、 EXAMPLE、 NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED 等，其中 InnoDB 和 BDB 提供事务安 全表，其他存储引擎都是非事务安全表。
  查看当前引擎 show ENGINES  MyISAM存储引擎 #   不支持事务、也不支持外键，优势是访问速度快，对事务完整性没有 要求或者以select，insert为主的应用基本上可以用这个引擎来创建表
  支持3种不同的存储格式，分别是：静态表；动态表；压缩表   静态表：表中的字段都是非变长字段，这样每个记录都是固定长度的，优点存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多（因为存储时会按照列的宽度定义补足空格）ps：在取数据的时候，默认会把字段后面的空格去掉，如果不注意会把数据本身带的空格也会忽略。 动态表：记录不是固定长度的，这样存储的优点是占用的空间相对较少；缺点：频繁的更新、删除数据容易产生碎片，需要定期执行OPTIMIZE TABLE或者myisamchk-r命令来改善性能 压缩表：因为每个记录是被单独压缩的，所以只有非常小的访问开支
  动态表：记录不是固定长度的，这样存储的优点是占用的空间相对较少；缺点：频繁的更新、删除数据容易产生碎片，需要定期执行OPTIMIZE TABLE或者myisamchk-r命令来改善性能
  压缩表：因为每个记录是被单独压缩的，所以只有非常小的访问开支
 InnoDB存储引擎 #   nnoDB 存储表和索引有两种方式
  使用共享表空间存储，这种方式创建的表的表结构保存在.frm 文件中，数据和索引 保存在 innodb_data_home_dir 和 innodb_data_file_path 定义的表空间中，可以是 多个文件。 使用多表空间存储，这种方式创建的表的表结构仍然保存在.frm 文件中，但是每个 表的数据和索引单独保存在.ibd 中。如果是个分区表，则每个分区对应单独的.</description>
    </item>
    
    <item>
      <title>webpack 其他 loader </title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/webpack-other-loader/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/webpack-other-loader/</guid>
      <description>url-loader file-loader #   package.json  { &amp;#34;name&amp;#34;: &amp;#34;demo10&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;1.0.0&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;main&amp;#34;: &amp;#34;webpack.config.js&amp;#34;, &amp;#34;scripts&amp;#34;: { &amp;#34;test&amp;#34;: &amp;#34;echo \&amp;#34;Error: no test specified\&amp;#34; &amp;amp;&amp;amp; exit 1&amp;#34;, &amp;#34;build&amp;#34;: &amp;#34;webpack&amp;#34;, &amp;#34;dev&amp;#34;: &amp;#34;webpack-dev-server&amp;#34; }, &amp;#34;keywords&amp;#34;: [], &amp;#34;author&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;license&amp;#34;: &amp;#34;ISC&amp;#34;, &amp;#34;devDependencies&amp;#34;: { &amp;#34;css-loader&amp;#34;: &amp;#34;^3.0.0&amp;#34;, &amp;#34;file-loader&amp;#34;: &amp;#34;^6.2.0&amp;#34;, &amp;#34;html-webpack-plugin&amp;#34;: &amp;#34;^5.3.2&amp;#34;, &amp;#34;less&amp;#34;: &amp;#34;^4.1.1&amp;#34;, &amp;#34;less-loader&amp;#34;: &amp;#34;^10.0.1&amp;#34;, &amp;#34;style-loader&amp;#34;: &amp;#34;^3.1.0&amp;#34;, &amp;#34;url-loader&amp;#34;: &amp;#34;^2.2.0&amp;#34;, &amp;#34;webpack&amp;#34;: &amp;#34;^5.45.1&amp;#34;, &amp;#34;webpack-cli&amp;#34;: &amp;#34;^3.3.12&amp;#34;, &amp;#34;webpack-dev-server&amp;#34;: &amp;#34;^3.11.2&amp;#34; } }  webpack.config.js  const path = require(&amp;#34;path&amp;#34;); const webpack = require(&amp;#34;webpack&amp;#34;); const HtmlWebpackPlugin = require(&amp;#39;html-webpack-plugin&amp;#39;); module.</description>
    </item>
    
    <item>
      <title>python list</title>
      <link>https://huachengzhou.github.io/life/docs/python/base/list/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/python/base/list/</guid>
      <description>所谓序列，指的是一块可存放多个值的连续内存空间，这些值按一定顺序排列，可通过每个值所在位置的编号（称为索引）访问它们
 创建 #  # 定义一个列表 aList = [] 添加新的元素 append , insert ,extend #  # 定义一个列表 aList = [] aList.append(&amp;#34;a&amp;#34;) aList.insert(len(aList),&amp;#34;insert&amp;#34;) print(aList) list1 = [&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34; , &amp;#34;c&amp;#34;] list2 = [1, 2, 3] list1.extend(list2) print(list1) 遍历列表 #  aList = [2,4,5] for x in aList: print(x) 索引问题 #  # 第一项的索引为 0 # 末尾索引为 -1 # 倒数第二索引为 -2 针对 删除 del 和访问 ,以及insert都有效 检查元素是否存在 #  aList = [2,4,5] if 1 in aList: print(&amp;#39;1存在&amp;#39;) else: print(&amp;#39;1不存在&amp;#39;) 删除元素 #  aList = [] aList.</description>
    </item>
    
    <item>
      <title>mysql存储过程</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_procedure/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_procedure/</guid>
      <description>MySQL mysql存储过程概述 #   存储过程是存储在数据库的一组SQL语句集，用户可以通过存储过程名和传参多次调用的程序模块。
 特点： #   使用灵活，可以使用流控制语句，自定义变量等完成复杂的业务逻辑。 提高数据安全性，屏蔽应用程序直接对表的操作，易于进行审计。 减少网络传输。 提高代码维护的复杂度，实际使用中要评估场景是否适合。  存储过程-基本语法： (非常重要) #  CREATE[DEFINER = { user | CURRENT_USER }]PROCEDURE sp_name ([proc_parameter[,...]])[characteristic ...] routine_bodyproc_parameter:[ IN | OUT | INOUT ] param_name typetype:Any valid MySQL data typecharacteristic:COMMENT &#39;string&#39;| [NOT] DETERMINISTICroutine_body:Valid SQL routine statement-- $ 可以改为分号 假如你直接是在控制台那么建议用$delimiter $ --将sql语句结束符号修改为$,这样只有sql遇到$时才开始执行create procedure 存储过程名(参数列表)beginsql语句集合end$delimiter ; --将结束符修改为默认的分号 例子 #  -- 创建一个表 CREATE TABLE `t_user` ( `USER_ID` int NOT NULL AUTO_INCREMENT, `USER_NAME` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, `USER_PASSWORD` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, `USER_EMAIL` char(80) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, PRIMARY KEY (`USER_ID`), KEY `IDX_NAME` (`USER_NAME`) ) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8; -- 插入2000条数据  DROP PROCEDURE IF EXISTS proc_initData;--如果存在此存储过程则删掉 DELIMITER $ CREATE PROCEDURE proc_initData() BEGIN DECLARE i INT DEFAULT 1; WHILE i&amp;lt;=2000 DO INSERT INTO t_user(USER_NAME,USER_PASSWORD,USER_EMAIL) VALUES(MD5(UUID()),MD5(UUID()), CONCAT(substring(UUID(),1,7) , &amp;#39;@&amp;#39;, substring(UUID(),4,8) ,&amp;#39;.</description>
    </item>
    
    <item>
      <title>小程序技术总结参考 </title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF%E5%8F%82%E8%80%83/</link>
      <pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF%E5%8F%82%E8%80%83/</guid>
      <description>多端比较 #     框架名称 h5 小程序 weex Native 可否使用其它ui     taro Y Y N Y ui根据修改就可以适配taro如 vant,light-ui,WeUI,Antd Design Mobile,自带的,京东ui等   uniapp Y Y Y N 只能用它自己的   Chameleon Y Y Y N ui根据修改就可以适配Chameleon light-ui,自带的,滴滴ui   mpvue Y Y N N 只能使用自己的 例如美团外卖     weex和Native 可以以一定的方式转为app 比如android ios  Chameleon #   CML (Chameleon) 是一个跨多端开发的统一解决方案，它可以像变色龙一样适应不同的环境。一次开发，多端运行，一端所见即多端所见。
  点评  滴滴的开源小程序框架 使用的是类vue语法 安装它自己的规范开发 比如 c-model 和v-model功能差不多但是不能直接使用v-model,一定要使用得这样 //注意这个 lang=&amp;#39;vue&amp;#39; &amp;lt;template lang=&amp;#39;vue&amp;#39;&amp;gt; &amp;lt;page title=&amp;#34;chameleon&amp;#34;&amp;gt; &amp;lt;view&amp;gt;&amp;lt;text&amp;gt;message:{{message}}&amp;lt;/text&amp;gt;&amp;lt;/view&amp;gt; &amp;lt;input v-model=&amp;#34;message&amp;#34;&amp;gt;&amp;lt;/input&amp;gt; &amp;lt;/page&amp;gt; &amp;lt;/template&amp;gt; 实际上uniapp照样也是使用的类vue 只不过uniapp模拟了几乎绝大多数的vue api 其实这种类vue挺恐怖的 框架自己把vue拿来魔改或者自己研发了一种数据驱动的响应式js框架 uniapp #   uni-app 是一个使用 Vue.</description>
    </item>
    
    <item>
      <title>python datetime</title>
      <link>https://huachengzhou.github.io/life/docs/python/base/python_datetime/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/python/base/python_datetime/</guid>
      <description>datetime #  构造函数 #   创建日期对象  import datetime import time time1 = datetime.datetime(year=2008,month=4,day=12) time2 = datetime.datetime(2027,6,23) print(time1) print(time2) 日期对象格式化为可读字符串 #   格式化参考     指令 描述 实例 TIY     %a Weekday，短版本 Wed 试一试   %A Weekday，完整版本 Wednesday 试一试   %w Weekday，数字 0-6，0 为周日 3 试一试   %d 日，数字 01-31 31 试一试   %b 月名称，短版本 Dec 试一试   %B 月名称，完整版本 December 试一试   %m 月，数字01-12 12 试一试   %y 年，短版本，无世纪 18 试一试   %Y 年，完整版本 2018 试一试   %H 小时，00-23 17 试一试   %I 小时，00-12 05 试一试   %p AM/PM PM 试一试   %M 分，00-59 41 试一试   %S 秒，00-59 08 试一试   %f 微妙，000000-999999 548513 试一试   %z UTC 偏移 +0100 试一试   %Z 时区 CST 试一试   %j 天数，001-366 365 试一试   %U 周数，每周的第一天是周日，00-53 52 试一试   %W 周数，每周的第一天是周一，00-53 52 试一试   %c 日期和时间的本地版本 Mon Dec 31 17:41:00 2018 试一试   %x 日期的本地版本 12/31/18 试一试   %X 时间的本地版本 17:41:00 试一试   %% A % character % 试一试     例子  import datetime x = datetime.</description>
    </item>
    
    <item>
      <title>Python Try Except</title>
      <link>https://huachengzhou.github.io/life/docs/python/base/python_try_except/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/python/base/python_try_except/</guid>
      <description>try 块允许您测试代码块以查找错误。
except 块允许您处理错误。
finally 块允许您执行代码，无论 try 和 except 块的结果如何
异常处理 #  当我们调用 Python 并发生错误或异常时，通常会停止并生成错误消息。
可以使用 try 语句处理这些异常：
try: print(x) except: print(&amp;#34;x没有定义&amp;#34;) 多个异常 #  try: print(x) except NameError: print(&amp;#34;参数 x 没有定义&amp;#34;) except: print(&amp;#34;Something else went wrong&amp;#34;) Else #  如果没有引发错误，那么您可以使用 else 关键字来定义要执行的代码块：
try: print(&amp;#34;你好啊!&amp;#34;) except: print(&amp;#34;抛出错误了&amp;#34;) else: print(&amp;#34;继续执行&amp;#34;) Finally #  如果指定了 finally 块，则无论 try 块是否引发错误，都会执行 finally 块
try: x1 = 2 / 0 except: print(&amp;#34;异常 除数为0&amp;#34;) finally: print(&amp;#34;不管抛出异常与否都会执行&amp;#34;) 引发异常 #  抛出（引发）异常，请使用 raise 关键词</description>
    </item>
    
    <item>
      <title>mysql存储函数</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_procedure_function/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_procedure_function/</guid>
      <description>参考1(重点)
参考2</description>
    </item>
    
    <item>
      <title>mysql运维</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_operation_maintenance/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_operation_maintenance/</guid>
      <description>一: 备份 #  1: 备份内容 #    数据 (数据文件或文本格式数据)
  操作日志(binlog) (数据库变更日志)
  2:冷备份与热备份 #    冷备份 (关闭数据库服务，完整拷贝数据文件)
  热备份 (在不影响数据库读写服务的情况下备份数据库)
  3:本地备份与远程备份 #    本地备份 (在数据库服务器本地进行备份)
  远程备份 (远程连接数据库进行备份)
  4:全量备份与增量备份 #    全量备份 (备份完整的数据库)
  增量备份 (只备份上一次备份以来发生修改的数据)
  5:备份周期 #   考虑因素： 数据库大小(决定备份时间) 恢复速度要求(快速or慢速) 备份方式(全量or增量)  6:常用工具及用法 #   mysqldump - 逻辑备份，热备 xtrabackup - 物理备份， 热备 Lvm/zfs snapshot - 物理备份 mydumper - 逻辑备份，热备 cp - 物理备份，冷备  常用工具及用法 - mysqldump #   逻辑备份  -- 备份全部数据库的数据库结构 mysqldump -h localhost -p3307 -uroot -p123456 -A -d &amp;gt; D:\data\mysql_all.</description>
    </item>
    
    <item>
      <title>Python RegEx</title>
      <link>https://huachengzhou.github.io/life/docs/python/base/python_regex/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/python/base/python_regex/</guid>
      <description>RegEx 或正则表达式是形成搜索模式的字符序列。
RegEx 可用于检查字符串是否包含指定的搜索模式
RegEx 模块 #  导入 re 模块后，就可以开始使用正则表达式了
RegEx 函数 #  re 模块提供了一组函数，允许我们检索字符串以进行匹配：
   函数 描述     findall 返回包含所有匹配项的列表   search 如果字符串中的任意位置存在匹配，则返回 Match 对象   split 返回在每次匹配时拆分字符串的列表   sub 用字符串替换一个或多个匹配项    元字符 #  元字符是具有特殊含义的字符：
   字符 描述 示例 TIY     [] 一组字符 &amp;ldquo;[a-m]&amp;rdquo; 试一试   \ 示意特殊序列（也可用于转义特殊字符） &amp;ldquo;\d&amp;rdquo; 试一试   .</description>
    </item>
    
    <item>
      <title>Python JSON</title>
      <link>https://huachengzhou.github.io/life/docs/python/base/python_json/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/python/base/python_json/</guid>
      <description>JSON 是用于存储和交换数据的语法。
JSON 是用 JavaScript 对象表示法（JavaScript object notation）编写的文本
解析 JSON - 把 JSON 转换为 Python #  import json # 一些 JSON: x = &amp;#39;{ &amp;#34;name&amp;#34;:&amp;#34;Bill&amp;#34;, &amp;#34;age&amp;#34;:63, &amp;#34;city&amp;#34;:&amp;#34;Seatle&amp;#34;}&amp;#39; # 解析 x: y = json.loads(x) print(f&amp;#34;json 类型 {type(y)}&amp;#34;) print(y) 把 Python 转换为 JSON #  import json dict2 = {&amp;#39;name&amp;#39;:&amp;#39;李世民&amp;#39;,&amp;#39;age&amp;#39;:18} json1 = json.dumps(dict2) print(json1) </description>
    </item>
    
    <item>
      <title>Python 字符串格式化</title>
      <link>https://huachengzhou.github.io/life/docs/python/base/python_string_formatting/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/python/base/python_string_formatting/</guid>
      <description>字符串 format() #  format() 方法允许您格式化字符串的选定部分。
有时文本的一部分是你无法控制的，也许它们来自数据库或用户输入？
要控制此类值，请在文本中添加占位符（花括号 {}），然后通过 format() 方法运行值：
  {} 占位符好
  简单例子
  woollenSweater = &amp;#34;这件毛衣{}块钱!&amp;#34; print(woollenSweater.format(52)) # 这件毛衣52块钱! print(&amp;#34;这件毛衣{:.2f}块钱!&amp;#34;.format(52.34)) # 这件毛衣52.34块钱!  多个值  text1 = &amp;#34;{}创立了这个公司,一共花了{}年,是一个享誉世界的人&amp;#34; print(f&amp;#34;参数 李世民_4: {text1.format(&amp;#39;李世民&amp;#39;,4)}&amp;#34;) print(f&amp;#34;参数 朱元璋_22: {text1.format(&amp;#39;朱元璋&amp;#39;,22)}&amp;#34;) #参数 李世民_4: 李世民创立了这个公司,一共花了4年,是一个享誉世界的人 #参数 朱元璋_22: 朱元璋创立了这个公司,一共花了22年,是一个享誉世界的人 </description>
    </item>
    
    <item>
      <title>Python 命令行输入</title>
      <link>https://huachengzhou.github.io/life/docs/python/base/python_cmd_input/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/python/base/python_cmd_input/</guid>
      <description>命令行输入 Python 允许命令行输入。
这意味着我们能够要求用户输入。
Python 3.6 中的方法与 Python 2.7 略有不同。
Python 3.6 使用 input() 方法。
Python 2.7 使用 raw_input() 方法
 例子  # Python 3.6 print(&amp;#34;请输入您的姓名&amp;#34;) name = input() print(&amp;#34;请输入您的年龄&amp;#34;) age = input() print(f&amp;#34;您的姓名:{name} ; 您的年龄:{age}&amp;#34;) # 请输入您的姓名 # 张三 # 请输入您的年龄 # 25 # 您的姓名:张三 ; 您的年龄:25 </description>
    </item>
    
    <item>
      <title>vue脚手架创建方式 </title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/vue%E8%84%9A%E6%89%8B%E6%9E%B6%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/vue%E8%84%9A%E6%89%8B%E6%9E%B6%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/</guid>
      <description>第一种方式 #     npm i -g @vue/cli-init or npm install @vue/cli-init@5.0.8 -g    D:\IdeaProjects\cycle\study\vuecli\demoB&amp;gt;vue init webpack learnrouter ? Project name learnrouter ? Project description &amp;#39;这是一个vue路由器&amp;#39; ? Author zch ? Vue build runtime ? Install vue-router? Yes ? Use ESLint to lint your code? No ? Set up unit tests Yes ? Pick a test runner noTest ? Setup e2e tests with Nightwatch? Yes ? Should we run `npm install` for you after the project has been created?</description>
    </item>
    
    <item>
      <title>python math</title>
      <link>https://huachengzhou.github.io/life/docs/python/base/math/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/python/base/math/</guid>
      <description>math #  math 模块常量 #     常量 描述     math.e 返回欧拉数 (2.7182&amp;hellip;)   math.inf 返回正无穷大浮点数   math.nan 返回一个浮点值 NaN (not a number)   math.pi π 一般指圆周率。 圆周率 PI (3.1415&amp;hellip;)   math.tau 数学常数 τ = 6.283185&amp;hellip;，精确到可用精度。Tau 是一个圆周常数，等于 2π，圆的周长与半径之比。    math 模块方法 #     方法 描述     math.acos(x) 返回 x 的反余弦，结果范围在 0 到 pi 之间。   math.</description>
    </item>
    
    <item>
      <title>Python 容器问题</title>
      <link>https://huachengzhou.github.io/life/docs/python/base/container/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/python/base/container/</guid>
      <description>容器 #  各个容器相互转换 #  容器通用用法 #  </description>
    </item>
    
    <item>
      <title>每天保持心情的5句话</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/pqpys8speb/</link>
      <pubDate>Wed, 05 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/pqpys8speb/</guid>
      <description>每天保持好心情的5句话 #    1:如果自己不伤害自己,这世界没有人能伤害我。面对一切外在风雨,我就对自己说一句话,我爱自己
  2:身体和心灵是自己的,没有人能代替我照顾自己,往后余生,一定好好照顾自己,一心一意让自己快乐健康。
  3:把时间浪费在美好的事情,比如读书 运动旅游。不要浪费在无聊的事情和人上。
  4:允许自己做不到 做不好。完美不是苛责自己,而是接纳自己,然后,继续前行
  5:不必讨好任何人,不要依赖任何人,自己和别人是平等的,抬起头生活。
  假如你遇到难事 这个时候最应该做的就是什么都不做 这个时候要让自己内心平静下来 否则你会干出你事后后悔的事情来 #  </description>
    </item>
    
    <item>
      <title>MySQL数据库基础</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter1/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter1/</guid>
      <description>MySQL数据库基础 #  1.1-认识MySQL #  什么是数据库 #   计算机处理和存储的一切信息都是数据。 计算机系统中一种用于存取数据的程序。 一种：  计算机系统中有很多种能够存取数据的程序 它们各有特征和长处，有自己的适用范围。   存取：  能够保存数据避免丢失。 能够按照需求找到符合条件的数据。    为什么要使用数据库 #  数据库帮助我们解决一下数据存取难题：
 较大数据量 网络控制 并发访问 高性能要求 事务控制 持久化和数据安全 查询数据需求逻辑复杂  数据库分类 #    关系型数据库
 MySQL Oracle SQL Server PostgreSQL    非关系型数据库
 hadoop：存放大数据 mongoDB： 文档型数据库 redis：键值型数据库 Cassandra：分布式数据库    最显著的区别：是否使用结构化查询语句（SQL）
为什么学习MySQL #  MySQL：The world&amp;rsquo;s most popular open source database</description>
    </item>
    
    <item>
      <title>和女孩聊天话题</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/talk_theme/girl/seiffjx8c7/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/talk_theme/girl/seiffjx8c7/</guid>
      <description>认知聊天基础 #   高情商的聊天，并不一定要学会固定的话术，学会揣摩对方的情绪，避免话术的客套，让双方都能发自内心的感受到舒服，这才是真正的
  聊天前做好准备，要了解你的聊天对象喜欢什么，在意什么，忌讳什么；赞美，每个人都喜欢得到对方的认同，而赞美是最好的认同方式；找对方感兴趣的话题；倾听；表示交谈愉快。
  社交方式有各种各样，最重要的是底层逻辑。聊天技巧很多,但是主要的核心，技巧、话术、都是辅助，核心是——让和你聊天的人感觉到舒服。聊天技巧包括情商，完全是可以通过后天提升的，无他为手熟尔，多聊多反思，终会有所收获。
  1、聊天前做好准备  首先，你要了解你的聊天对象喜欢什么，在意什么，忌讳什么，这样才不会在聊天中出现尴尬。想要了解聊天对象的信息，可以问问他（她）周围要好的朋友，亲戚等。
 2、赞美  每个人都喜欢得到对方的认同，而赞美是最好的认同方式。比如，他穿了一件很帅气的T恤，你可以说“哇，不知道是你衬托了这件衣服，还是衣服衬托了你”。
 3、找对方感兴趣的话题  之前的准备，现在就有所大用了，你应该专找对方喜欢的话题来谈论，这样可以大大的提高对方对你的好感。
 4、倾听  当看到对方说的滔滔不绝的时候，千万不要打断他，他正处于兴奋中，倾听也是一种很好的得到他人好感的方式。
 5、表示交谈愉快  在聊天快结束时，不得不加一句“今天的谈话，我感到很愉快”
一级话题 #  适用阶段：初始期（相识0~2周）
  愉悦度：★★★☆☆
  门槛度：☆☆☆☆☆
  要点：先讲自己，再问对方
这一阶段，聊天的核心目的不是拉进亲密度
而在于建立基本好感➕消除女生对我们的防卫心态
多数人对初次交流的目的是极度模糊的——没有想清楚我要在第一次聊天时达到什么目的
因而容易进退失据
不是放不开手脚，就是过分热络——共同的结局是尴尬收场、难有下文
如果在第一阶段就冒冒失失地去聊有门槛度的话题
大部分女生都不愿接茬
该阶段，应当从如下话题入手
 1，你好，我是xxx的xxx  “我是xxx”不足以给对方留下印象
“我是xxx的xxx”属于异化表达，会引起对方的好奇心
当然了，两个xxx绝对不是人名哈
是方式／状态＋人名
举例
你好，我是那天被迫相亲但吃了不少还认识了你的xxx
你好，我是那天说要加你结果真加了你的xxx
你好，我是练习时长两年半的个人练习生蔡徐坤（狗头.jgp）
诸如此类，灵活运用～
 2，不要问对方“在干嘛”  要先主动分享当下状态，再去询问她的状态
例如“我刚吃完饭 / 刚结束手头的工作，你呢？”</description>
    </item>
    
    <item>
      <title>PDCA循环工作法</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/esxjjecmn5/</link>
      <pubDate>Wed, 05 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/esxjjecmn5/</guid>
      <description>一、PDCA循环理念 #  PDCA的4个阶段： ①P计划：设定目标、提出课题、制定KPI指标、找出解决方法； ②D实施：行动措施、制定KDI指标、落实为具体行动； ③C检查：检验KGI指标、检查KDI指标、检查KPI指标、找出成功和失败； ④A调整：找出调整方案、为下一个循环做准备。
二、计划的8个步骤 #  ①定量化目标管理； ②找出目标与现状差距； ③制定课题，提出解决方案； ④课题排序，锁定三个主要课题； ⑤课题的KPI指标化； ⑥制定解决方案，达成KPI指标； ⑦将解决方案按优先顺序排序； ⑧将计划可视化。
三、执行的5个步骤 #  ①将解决方案转换为行动措施； ②将行动措施排除优先顺序，确定重点； ③量化行动措施KDI； ④将行动措施落实为“TODO”，待办任务； ⑤逐步推进具体任务；
四、反思的5个步骤 #  ①确定KGI达成率； ②确定KPI达成率； ③确定KDI达成率； ④查明失败原因； ⑤分析成功经验；
五、调整的3个步骤 #  ①根据验证结果提出解决方案；
②将调整方案排除优先顺序；
③连接下一轮PDCA循环。</description>
    </item>
    
    <item>
      <title>MySQL数据库对象与应用</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter2/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter2/</guid>
      <description>MySQL数据库对象与应用 #  2.1-MySQL数据类型 #  Number不止一种 #   整形 浮点型  整形 #   INT SMALLINT MEDIUMINT BIGINT     type Storage Minumun Value Maximum Value      (Bytes) (Signed/Unsigned) (Signed/Unsigned)   TINYINT 1 -128 127     0 255   SMALLINT 2 -32768 32767     0 65535   MEDIUMINT 3 -8388608 8388607     0 16777215   INT 4 -2147483648 2147483647     0 4294967295   BIGINT 8 -9223372036854775808 9223372036854775807     0 18446744073709551615    老生常谈的问题 #  int(11) VS int(21) 存储空间，还是存储范围有区别？</description>
    </item>
    
    <item>
      <title>耍朋友</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/talk_theme/girl/dpa4wtnhf8/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/talk_theme/girl/dpa4wtnhf8/</guid>
      <description>  女生都特别在意细节 所以一定要认真 做一些事可以多向别人请教 多上网查看 多演练
  其实任何事情都是这样 一定要认真仔细
  一旦开始就要百分之百尽力
  和女生聊天不要一个人滔滔不绝的讲个不停 尽量要讲两个人共同的话题 尽量讲 女生感兴趣的话题 当然了 如果实在找不到话题 那么自己讲自己活跃气氛也不错 对了可以讲自己被父母逼相亲 亲戚朋友聚会的事情
  case1
  并不是看着清纯的一定没谈过恋爱，更不是看着可爱的一定没谈过恋爱， 如果非要说的话，最可靠的评判标准就是这个女人是否老实。 对于男人来说，老实的男人不会撩妹，反过来呢，那些老实的女生，傻傻的，十有八九没谈过恋爱。 为什么这么说？因为无论是平淡的一段感情，还是刻骨铭心的一段感情，或者是伤痕累累的一段感情， 甚至是过眼云烟的短暂经历，都会改变一个女生对爱情和男人的看法、想法以及行为和表现，所以只要感情经历足够多，傻子也可以蜕变成情圣。就拿渣女来说，学会了温柔撩人也就算了，如果连男生想什么都能猜出来十有八九必定已经阅人无数。相反，如果一个女生不骚不婊不可爱不机灵，差不多没谈过恋爱，所以原谅她的不懂事，这个女生并非不爱你！我不否认有的人天生双商高，没谈过恋爱也表现得成熟而有魅力，也不否认有高手扮猪吃老虎，假装老实人打你个措手不及。每次讲到这一点时，我总是忍不住想要长篇大论――那继续和大家分享，如果你遇到的人是装出来的老实你怎么办？或者是天生的完美人格你却怀疑对方？我们都知道，很多事情并不像看上去那样，但是，我们可以从现象探寻本质。但是我知道大多数人是做不到“从现象探寻本质这一点的”。最可怕的人就是装傻的人和真傻的人，如果你想看透对方的本质，那么请你继续往下看。当你遇到只问你的信息，但对自己的信息却小心翼翼的姑娘，小心一些。她是在以居高临下的姿态考察你，筛选你，这种女的会因为你外在条件好和你在一起，但是她永远不会爱你。这种女的，说白了，不真诚。你作为一个爷们儿，一定要摆好框架，不要被对方牵着鼻子走。老实人之所以廉价，就是因为没原则无底线，也不敢跟姑娘提要求，毕竟有个姑娘跟自己约会就足够自己满足自豪好几天了。所谓有自己的框架，应该时不时停下来问问自己的人生目标是什么，想成为什么人。当她离你而去的时候你还有一技傍身，而不是几张朋友圈的恩爱照和一无是处的青春回忆。小心对方的回头，因为你不知道对方回头的动机。女人善变，但大部分情况下她们回头找你的理由都是暂时找不到更好的了，就找你先凑合一下吧。我不否认有的女生怀念旧情，不舍得，但是你也要想想当初她离开你的原因是什么。别被她感人的台词骗得泪流满面。如果你想了解一个女生，先看她的圈子。她的闺蜜没什么水准的话，她也不会好到哪里去。物以类聚人以群分这句话不是没有道理的，想法不同的人不会不谋而合，想法不同的朋友时间久了也会把人带跑偏。找机会参加女生的朋友聚会，你会有意外收获的！女人属猫，一直招惹她会让女生烦你。等你身上有了她想要的东西自然会回来找你，别怕错过。错过了，说明还是不喜欢你，没什么可惋惜的。喜欢你的人一定会主动，性格慢热或者天性凉薄都是借口。说自己慢热的女生，大概率是对你没感觉却又想长期吊着你的绿茶。真慢热的女的一般不会直接说自己慢热，除非脑子不太灵光。经常去夜店的女生，要远离。她们口中的“偶尔去”就是经常去。我也去过夜店，灯红酒绿肆无忌惮确实令人着迷，但是我知道它的样子，那些姑娘很性感。虽然很可能有误伤，但是老实人玩不起概率游戏，就这么简单，还不如选择远离。以前爱玩儿现在收心了也就算了，人品差点的，让你头上长草，你怕不怕？约不出来微信不回就放弃吧。我知道存在技术差异和魅力差异，但是女生不认可咱们，真没必要上赶着。大家都是成年人，第一次邀约说明不了啥，再二再三拒绝那就算了吧，拒绝邀约的理由不管怎么美化，本质就是我看不上你。但是，这个姑娘你先留着，冷处理就行了，别再为她花心思，谁知道以后会怎么样呢。追逐过程中，感觉自己负面情绪过多的话，这姑娘八成不适合你。问题是，很多人早早就意识到了却还是无法控制自己继续付出。毕竟付出越多越难以放弃，舔狗也是越舔越难以自拔，我都理解。但是看了这篇文章就再次提醒提醒自己。身边有个懂女人的朋友出谋划策很重要。让你闷头死追无脑献殷勤的是狗头军师，别信。然而大部分女人给别人教的泡妞手段，无非就是买买买送送送，感动感动加感动。这不是误人子弟呢嘛，说实话，私信我买套课程，你会发觉自己会脱胎换骨。摸清对方的段位再做决策。如果自己段位远低于对方，比如姑娘长得特好看，天天有人惦记着，你却没谈过恋爱。趁早撒手，强行在一起基本上是被吃到死的份。游戏中的越级闯关都应该知道：级别差太多，结局只能是自己费力之后一无所得。我的建议就是提升自己，不然就算闯关成功，耗费的装备和药水值得你这么做？想体验相对纯粹些的爱情，越早越好。不论男女一过三十，基本都认清了生活和现实，出来工作越早的越现实。离异女的能别碰就别碰。女人是感性动物是这个社会上最大的谎言。离异之后但凡有点脑子的，都会在婚前把婚后的利益算的清清楚楚。这也不怪她们，毕竟之前感性一次吃了大亏。时不时评估一下自己和对方的付出，维持一段关系，保持相对的平衡。花小钱要果断，花大钱还是免了吧，这不是你的责任。你下注了，她跟了，你们就继续玩；你下注了，她还不下注，不管她怎么跟你花言巧语“我要下注了”，别信！说什么女人的青春值钱，那男人的青春不值钱？真正的爱情永远是平等的。不要闷头给追求对象送礼物。送礼物可以，要么她先送了，你回礼；要么，你俩确定关系以后你再送。喜欢你的姑娘，不会因为你忘记一次生日礼物就拒绝你你，而一个她看不上的挫男，年年送生日礼物她也不会高看对方一眼。别自己感动自己了，追是吸引而不是讨好。碰到人品好的，徒增对方的社交压力；碰到人品差的，等于给对方把你当提款机的机会。什么时候一个人急不可耐地给对方送礼？是求人办事的时候。问题是，感情这东西，它也不是求来的啊。相对应的，无缘无故送你礼物的姑娘八成对你有兴趣，一般也是新司机。真诚是对的，要么狠要么稳，别徘徊。如果你精通pua，我支持你通过这种方式吸引女生；如果你你不精通，班门弄斧的样子真的很搞笑。老实人其实挺受欢迎的，你单位的阿姨肯定不会殷勤地给一个流里流气的痞子介绍对象，不过你要有点儿眼力见儿。那些臭毛病你得离远点，想改变对方是痴心妄想。朋友圈爱炫富的，远离；网红脸的，远离；脾气不好一点就炸的，有时候你买错一瓶水她就炸了，其实也不是脾气不好，也可能是单纯不喜欢你然后顺便拿你出气而已，远离；虚荣心爆棚的，远离；很多姑娘会把虚荣心延伸到感情上，攀比过后要么你累死，要么你被绿；有纹身的，要么有故事要么就是社会姐，私密部位也有的，自求多福吧。永远不要当舔狗。有机会有能力翻翻对方的微博，再看看知乎上秀腿秀胸回答下边的评论，你就知道一个女人每天能被舔多少次了。舔她的人那么多，你又和他们有何不同？就让她们迷失在舔狗的舌头里好了，过了三十，一个人真实的斤两才会显现出来。其实大部分姑娘不会一开始就把对她有好感的男人当舔狗的，舔狗的帽子是那些低自尊、没脾气的男的自己戴上去的。说自己没有追求者的，别信。人家肯定不会对外说一个月薪不多长得巨丑的人在追她，因为太丢人了。最擅长从男人身上攫取利益的女人总是对外宣称单身，同时多线发展，以吸引傻子们对其不断投资。宣称自己追求者众多的姑娘，别怂，直接默认这些竞争者们不存在就可以了。说自己的追求者多，要么是在对外营造“洛阳纸贵”的氛围，实际上追她的没多少个。要么，就是追她的她一个都没看上，根本无法构成你的威胁，否则她早脱单了，还能等到你碰上她？不要开口问她们喜欢什么样的男人。寻找渠道了解一下对方的前任，总结一下他们的共同点。那个共同点就是她眼中一个男人的核心价值，不过挺麻烦的何必这么累呢。所以说，一个人的选择，往往比他的嘴巴更能反映出内心真实的想法。不要信她们的嘴巴或者自己在朋友圈发的所谓的择偶标准。你也不要附和她那些所谓的择偶标准，这么做也会暴露出你有迎合她口味的倾向，只有低价值的人才会想法迎合别人。门当户对太重要了，中华文化源远流长是有原因的。和一个姑娘聊的特别投缘，很大原因是你俩出身背景相似，有时候跟喜不喜欢没啥关系。分清自己是有钱还是有魅力。大部分姑娘在这个二十六七岁以前更多关注的是男方提供的情绪价值，这个年纪以后则更多关注的是男方提供的物质价值。爱情这东西，往往跟情绪价值联系在一起，所以以前不理你，现在回头来找你的姑娘八成并不爱你，而是年纪到了人家需求变了而已。就别沾沾自喜地认为自己这几年挣了钱魅力就大了，两码事儿。女人大部分喜欢找能令自己仰望的男人，小部分会找跟自己能够势均力敌的男人，但没有一个愿意找比自己弱的男人。这话背后的含义是，如果你看到一个女人找了个条件比自己差很多的男人，那么那个男人在某一你看不见的方面一定有强过她的地方。追到了也别得意，注意观察细节，看看对方是在玩儿还是真的爱你。很多情侣动辄朝另一半撒泼，就是不够喜欢，真的不是什么性格问题，彭于晏当她男朋友她会随便发脾气找茬子？有钱并不能帮你得到爱情。你可能只能得到姑娘的人，却永远得不到她的心。这件事将会极大增加自己被绿的概率。所以分辨出一个人是不是真的爱你，很重要。这句话的另一半是，别先画地为牢地认为自己在一无所有的时候没资格谈恋爱。其实当你一无所有的时候，碰到的姑娘才是最真的。一定不要上头，记得给自己划条时间线。这个不行就赶紧放弃。明明人家不鸟你或者明明你条件比她好你却还是执迷不悟死追不放；你这不是傻吗？从现实利益的考量角度来说，找个喜欢你的比找个你喜欢的舒服很多。而且很多时候喜欢你的各方面的条件是优于你喜欢的那个。好姑娘真的很多，别放弃。被渣女玩过一次的话，问题在她；如果次次遇人不淑的人是你，那有问题的人是你。保持忠诚和专一其实是非常难得的品质。可惜女孩子希望的是她们喜欢的人有这个品质然后反过来对她们忠诚专一。换句话说，人家不喜欢你，你再专一都没用。看清对方对你的态度，分清好坏。女人的高傲都是摆给自己不喜欢的人看的，碰到喜欢的瞬间化身小女人。不要死皮赖脸地追，勉强追到了你还得继续无底线付出，长期看也难以维系。人都是自作聪明的生物，那就不要自作聪明。想让对方知道你的价值和优点，不要过于明显地展示，而是要让她以为是她自己发现的。明显地展示自己价值的，比如朋友圈秀豪车钥匙，坐头等舱，出席所谓社会名流会议的，吸引来的也就是没什么层次的女人。好姑娘看到你这么炫，直接会排除你。追求阶段，在确定自己没有犯原则性错误的情况下，注意，绝对不要低头道歉。宁可冷酷到底也别装绅士，唯唯诺诺的男人一点儿魅力都没有。舔狗最擅长的事就是反复道歉，结果就是本来不是什么大事，他搞成了大事，然后继续舔。千万千万不要让对方知道你在揣测她的心思。你会被她朋友圈发的每一条状态玩到心态崩溃。女人早期天然比男人擅长情感博弈，特别擅长玩弄弱势地位者的感情。你需要做的是对她永远保留三分神秘你追不到的，大概率是综合评分远高于你的姑娘。如果有女孩追你，你一直都看不上，想通背后的道理，你就知道自己应不应该反过来追女生。水平强于你太多的，根本就入不了对方的眼，你怎么追都没用；水平低于你太多的，人家倒贴你；水平和你差不多的，根本不需要太追。这个评分包括很多方面，其中对于感情的把控和pua能力指数作为评分标准，真正的高手还是有的，比如我。喜欢不喜欢你，细节足以说明一切。注意力从头到尾压根就没在你身上的人，就别瞎费心思了。约出来了，但是长时间低头玩手机不说话，不主动开启话题，不问你的个人消息，这就是对你没兴趣。女人爱不爱你跟你优不优秀没有什么关系。她们的感情是毫无逻辑的。 我朋友婚前房车一概没有，俩人靠女朋友死工资过，然而他有车有房了之后，这姑娘居然先提出分手。迷信“有车有房有钱就会有姑娘喜欢”的理论的人，最终结果要么就是累死在挣钱的路上，要么就是吸引来看重金钱的绿茶。事业上的优秀和感情上的优秀完全是两码事。我常说你十座金钱换不来的姑娘我一颗糖能追回来，这句话不是骗人的。但是大部分人两者都不优秀；少数人有能力把握其中之一；两者能兼顾的人，我很敬佩。事业优秀、外表光鲜的成熟大叔，往往都有不为人知的黑暗面；情场上顺风顺水的浪子事业、学业基本看不成；人其实经不起细看。永远别贪恋远高于自己阶层的女人，更别相信“捡漏”这种事情会在自己身上发生。不要觉得找个低于自己阶层的女人就万事大吉了。对低于自己阶层的女人，同样不可松懈。对穷人家庭出身，还有点姿色的女人，尤其要警惕。忽冷忽热未必就是把你当备胎。对方一开始对你感兴趣的可能仅仅是你的附加价值，并不是对你感兴趣。女人在男女之事上的洞察力极高，一旦她们发现自己想要的东西你身上其实并没有，她们自然会脱身走人，并且没有丝毫犹豫。另一方面，确实有把男人当备胎的女人。当然她们也会用所谓的“考察期”来使自己的逻辑自洽——只是她们从来不告诉你，碰到自己喜欢的，确定关系能有多快，快到能立刻献身的地步。这个时候她们又会告诉你她找到了真爱，哦，我的老天，真是完美的理由啊！用考察期作理由的，就是不够喜欢你。追姑娘特简单，只要别对她太上心就好。开车的时候，新司机最容易犯的错误是注意力过于集中。追求女生也是一样，注意力太集中的弊端太多了，无论是吸引力还是感情维护都会让你很累。女人说“我有钱，我不在乎另一半有没有钱，无所谓”，别太相信这句话。事实上，说这句话的人，要的是物质需求加精神需求，只不过披了个“只要精神需求”的外衣而已。毕竟聪明点的美女勾搭富豪，第一步就是要先表现出对金钱的鄙夷，本来富豪最怕的就是人家冲着你的钱来。你真的以为一个用惯卡地亚香奈儿的女人，会喜欢上一个不懂摄影、没多少旅游见闻、没什么品味的男人？哪一项不需要钱？有些东西，你有钱甚至都未必接触的到。浅薄的小资产阶级有点小钱之后便阵阵作响，恨不得把自己能秀的东西秀个遍：男的秀车秀表，女的秀旅游秀包秀舔狗，用所谓的“品味”来包装自己，以求得一个高于自己原生阶层的人。不要觉得对方足够主动了你就能吃定她。散步时拉你的手、私底下对你撒娇、坐公交时睡着靠在你肩膀上——这些最容易让男人精虫上脑了。人家今天能对你这么做，明天就能对别人这么做。脑袋里那根弦请一直搭上，绿茶最喜欢用的就是这招。货悖而入者，亦悖而出。以不正当的手段得来的“爱情”，最后一定会以不正当的手段失去。别觉得自己能挖墙脚有多厉害，人家只不过从功利的角度考量了一下你而已，等有更好的了，照样蹬了你。在一起以后，想和你结婚过日子的，会把你当存钱罐。而不想结婚只想和你玩玩的，会把你当提款机。虽然价值观可能不同，但总的来说你感受到的都是真的。长得漂亮、家里有钱的姑娘啥都不缺，就缺一个能虐她的人。所以跟她们打交道，开舔必死。反倒是你越不把她们当回事，她们越对你感兴趣。但是想虐别人，得先有那个实力。所以归根到底，还是要提升自己的竞争力。这个世界上真正独立自主的女性极少。当然你问周围的姑娘，她们独立自主吗？她们一定会告诉你是的。但问题是，为什么这些姑娘的择偶标准里都有一条“男方收入不能低于我”。既然独立自主了，为什么还惦记别人的工资有多少呢？忙事业归忙事业，有时候还是要抬头看看前边的路和旁边的人。男人，还是要多交些异性朋友。跟异性打交道太少，最终的结果就是经验不足被吃到死。在微信朋友圈动辄抱怨自己没有男朋友、想要谈恋爱的女的，别去招惹。这种人，十个里面九个是绿茶。还有，朋友圈喜欢配一句心灵鸡汤加上一张自拍的，大概率是绿茶，微商除外。傻小子就知道盯着膜看。奉劝你们不要把找个处女或者不接受婚前性行为的姑娘当做终极目标。让你开心的非处和天天生气的处女你咋选？何况有的女生和自己不满意的男人谈恋爱时，向对方强调自己洁身自好，不接受婚前性行为。男的一听，“哇，碰到这么洁身自好的姑娘是自己的福气”，然后死心塌地。姑娘则趁此机会享受对方的好，同时寻找下家。所有不认可婚前性行为的理由，本质就一个，那就是你太丑，还没有进入我身体的资格。最恶心的就是技术性处女，边缘性行为玩了个遍，还对外宣称自己是处女的人，极其恶心人。真诚确实有用，尤其是在感情上受过重大创伤的女人。这种女人要么从此彻底不信男人，要么只信给自己花钱的男人。跟她们相处，你花言巧语越多，越会被对方拒绝。问题是在感情上受过重大创伤的，男人女人都会有执念，所以这种人你敢要么？对外声称自己希望找个灵魂有趣的人的人，不分男女，择偶方面天生具有优越感。这种优越感来自于对自身条件的过高估计，过高估计的后果你们明白的，说实话这一点影响的方面太大了。 </description>
    </item>
    
    <item>
      <title>表达能力提高</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/h847ijsjzr/</link>
      <pubDate>Wed, 05 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/h847ijsjzr/</guid>
      <description>“一个人的成功，15％靠技术支持，85％靠ロ才艺术” 无论在工作还是生活中 表达能力都是一项稀缺又非常重要的能力 如果你曾因为表达能力差吃过亏 那就要好好提升你的表达力了
  1朗读  睡前20分钟朗读一篇新闻或者你喜欢的文章,切记不要默读,一定要高于平常说话的音量读出来,可以慢读、快读的方式
 2录制视频  每天三分钟 尝试着用手机录制视频演讲 多次对着镜头表达自己观点 分享自己想法 在分析视频你自己讲话是否自然 语言是否磕巴 有停顿 及时发现问题去调整它 你会越来越优秀的
  3跟读 每天花10分钟跟着主持人一起去读 ,像康辉老师,董卿老师啊 因为他们吐字清晰 发音标准
  4镜子练习
  每天早上 你对着镜子说一些鼓励自己的话 比如&amp;quot;小周 早上好啊 你今天一定要努力哦 你是最棒的 你只要坚持你就可以获得自己想要的 加油 &amp;quot; 时间久了你就会变得从容越来越自信
 5速读训练  找一段喜欢的文字 慢慢的加快阅读速度 训练自己的口齿
 6背诵法  背诵跟自己有共鸣的文字 慢慢的增加自己的素材储备
 7即兴演讲  就是每天你任选3个词 你把那三个词组成一段话或者一个故事 你表达出来
 8公开表达  你可以把自己录制的视频 给自己身边的朋友看 所谓&amp;quot;当局者迷,旁边者清&amp;quot; 这一点是让他们帮你挑出存在的问题,并且公开你的视频 也可以锻炼你自己的胆量 不要不好意识 不好意思的人是没有办法提高自己的自信的</description>
    </item>
    
    <item>
      <title>任务分类法</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/ca7cqmh4j8/</link>
      <pubDate>Wed, 05 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/ca7cqmh4j8/</guid>
      <description>任务分类法 #  一:分类的目的是什么？ #   不知你会感到这样吗？有时候完成不了任务，可能是当下在犹豫做什么事之中放走了时间。分类可以避免这种情况，让你在需要时，二话不说就可以根据即刻的情况，迅速找到对应清单下的任务开干，减少因为找不到可做任务而拖延的现象。
 二:任务分类法 #   按照任务属性分类，可将事项分类为工作、学习、生活、娱乐…… 🉑这种分类方法最为常见、符合直觉、也适用于大多数人。  三:场景分类法 #   可以让你在某种特定的场景下，迅速找到自己当下要做的事情。比如工具场景和地点场景； 🉑任务不多或者在某种特定场景效率更高的人，可采取这种分类  四:四象限分类法 #   按照任务的重要紧急程度，将待办事项分类成四个象限：重要紧急、重要不紧急、不重要紧急、不重要不紧急。 🉑适合任务较多、事情繁琐的人使用  五:能量分类法 #    按照待办事项需要耗费多少能量，来进行分类。可将其分为：
  非常耗费能量、比较耗费能量
  不耗费能量、有助于恢复能量。
  🉑如果你常有这种差异很大的任务，那么可以试试能量分类法。✨
  六:时长分类法 #   按照任务需花费的时长，将其分类为： 10分钟以内、半个小时以内 30分钟到1个小时、一个小时以上。 🉑非常适合于碎片化时间较多的人。  总结 #    🌈分类方法没有好与不好，
  按照自己的实际情况和使用习惯去分类，才是最适合自己最好的分类方式呀
  也可以混搭来用💖💖
  参考1</description>
    </item>
    
    <item>
      <title>MySQL事务与存储引擎</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter3/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter3/</guid>
      <description>MySQL事务与存储引擎 #  3.1-数据库事务 #  什么是事务 #   一系列有序的数据库操作：  要么全部成功 要么全部回退到操作前的状态 中间状态对其他连接不可见   事务的基本操作：    基本操作 说明     start transaction 开始事务   commit 提交(全部完成)   rollback 回滚(回到初始状态)      -- 开启一个事务 start transaction; -- 或者使用(非标准sql) begin; insert into t values (1, 1, 1); -- 事务结束，插入成功 commit; begin; insert into t values (2, 1, 1); insert into t values (3, 1, 1); insert into t values (4, 1, 1); -- 事务结束，没有插入数据 rollback; begin; insert into t values (1, 1, 1); savepoint a1; insert into t values (2, 1, 1); -- 回滚到指定的保存点 rollback to a1; commit; 自动提交 #   autocommit可以在session级别设置 每个DML操作都自动提交 DDL永远都是自动提交，无法通过rollback回滚  事务的四个基本属性(ACID) #   原子性(Atomicity) 一致性(Consistency) 隔离性(Isolation) 持久性(Durability)  事务的原子性 #   包含在事务中的操作要么全部被执行，要么都不执行 中途数据库或应用发生异常，未提交的事务都应该被回滚  事务的一致性 #   数据的正确性，合理性，完整性 数据一致性应该符合应用需要规则：  余额不能是负数 交易对象必须先有账号 用户账号不能重复   事务的结果需要满足数据的一致性约束  事物的持久性 #   提交完成的事务对数据库的影响必须是永久性的  数据库异常不会丢失事务更新 通常认为成功写入磁盘的数据即为持久化成功    事务的持久化的实现 #   数据文件持久化  随机同步刷新(慢)   事务日志持久化与实例恢复  顺序同步刷新(快) -&amp;gt; 事务日志 随机异步刷新 -&amp;gt; 磁盘 事务日志 -&amp;gt; 磁盘(实例恢复)    事务的隔离性 #   数据库事务在提交完成前，中间的任何数据变化对其他的事务都是不可见的。  数据库隔离现象 #     隔离现象 描述     脏读(Dirty Read) 事务B读到事务A尚未提交的数据变更   不可重复读(NonRepeatable Read) 事务B读取前后两次读取一条记录之间该记录被事务A修改并提交，于是事务B读到了不一样的结果   幻读(Phantom Read) 事务B按条件匹配到了若干行记录并修改。但是由于修改过程中事务A新插入了符合条件记录，导致B更新完成后发现仍有符合条件却未被更新的记录。    数据库隔离等级 #     隔离等级 脏读 不可重复读 幻读     未提交读 可能 可能 可能   已提交读 不可能 可能 可能   可重复读 不可能 不可能 可能   可串行化读 不可能 不可能 不可能    MySQL的事务隔离级别 #   InnoDB默认标记为可重复读 InnoDB并不是标准定义上的课重复读 InnoDB默认在可重复读的基础上避免幻读  MySQL事务隔离级别设置 #   可在global/session/下个事务，级别分别进行设置 建议使用Read committed(同Oracle) 或者建议使用默认的Repeatable read  set tx_isolation = &amp;#39;&amp;#39; -- 设置隔离级别 事务与并发写 #   某个正在更新的记录再提交或回滚前不能被其他事务同时更新  事务回滚的实现 #   回滚段(rollback segment)与数据前像  3.</description>
    </item>
    
    <item>
      <title>如何保持积极乐观的心态</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/em24ppenbm/</link>
      <pubDate>Sun, 29 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/em24ppenbm/</guid>
      <description>如何保持积极乐观的心态 #  </description>
    </item>
    
    <item>
      <title>MySQL应用优化</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter4/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter4/</guid>
      <description>MySQL应用优化 #  4.1-MySQL索引优化与设计 #  什么是索引 #   索引的意义 —— 快速定位要查找的数据  数据库索引查找 #   全表扫描 VS 索引查找  如何根据首字母找到所在行 #   二分查找 B+tree  InnoDB表聚簇索引 #  索引中只放着排序字段和ID
创建索引 #   单列索引  create index idx_test1 on tb_student (name);  联合索引  create index idx_test2 on tb_student (name, age);  索引中先根据name排序，name相同的情况下，根据age排序  索引维护 #   索引维护由数据库自动完成 插入/修改/删除每一个索引行都会变成一个内部封装的事务 索引越多，事务越长，代价越高 索引越多对表的插入和索引字段修改就越慢 控制表上索引的数量，切忌胡乱添加无用索引  如何使用索引 #   依据WHERE查询条件建立索引  select a, b from tab_a where c=?</description>
    </item>
    
    <item>
      <title>社恐、性格闷、胆子小</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/mm8cnxmzyz/</link>
      <pubDate>Sun, 29 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/mm8cnxmzyz/</guid>
      <description>解决办法 #  </description>
    </item>
    
    <item>
      <title>MySQL运维实践</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter5/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter5/</guid>
      <description>MySQL运维实践 #  5.1-MySQL日志系统 #  什么是日志 #   日志(log)是一种顺序记录事件流水的文件 记录计算机程序运行过程中发生了什么 多种多样的用途  帮助分析程序问题 分析服务请求的特征、流量等 判断工作是否成功执行 等等……    MySQL日志的分类 #   服务器日志  记录进程启动运行过程中的特殊事件，帮助分析MySQL服务遇到的问题 根据需求抓取特定的SQL语句，追踪性能可能存在的问题的业务SQL   事务日志  记录应用程序对数据的所有更改 可用于数据恢复 可用于实例间数据同步       分类 日志名称     服务器日志 服务错误日志   服务器日志 慢查询日志   服务器日志 综合查询日志   事务日志 存储引擎事务日志   事务日志 二进制日志    服务错误日志 #   记录实例启动运行过程中重要消息 配置参数  log_error = /data/mysql_data/node-1/mysql.</description>
    </item>
    
    <item>
      <title>逻辑推导</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/nnefbyyxgr/</link>
      <pubDate>Sun, 29 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/nnefbyyxgr/</guid>
      <description>逻辑推导 #  逻辑自洽 #   按照自身的逻辑推演的话，自己可以证明自己本身至少不是矛盾或者错误的
  没有发现任何矛盾达到自我完备
 自圆其说 #   意思是指使自己的说法前后一致，没有自相矛盾的地方
 逻辑 #  通常所说的逻辑，是指我们从某些已知条件出发推出合理的结论的规律
因此我们可以说，逻辑的可靠性受两个因素的影响：
第一是：已知条件
第二是：推导方式、过程
“推导方式、过程” 决定着结论的可靠性
在限定条件下，我们所熟知的各种公理、定理必然可导出正确的答案
但必须注意这些公理、定理所适用的范围以及使用的限制条件。
错误归因 #  客观的事情经过错误的归因,就极容易出现错误的推断 很多人分析问题时,喜欢结诸于间接论证, 由A推出B由B得出C,最后证明A可以推出C 这固然是一种正确的逻辑形式,但放到具体个例时常常由于错误归因 ,得出错误的结论 再以错误的结论进一步递推 当然最终的结论就是错误的
错用诛心论的本质是诉诸动机,它其实也是错误归因的一种表现
资料来源</description>
    </item>
    
    <item>
      <title>数据库设计的规范</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</guid>
      <description>数据库设计的规范 #   数据库表和字段都大写 表都要加业务后缀，例如_C客户表 _B基础表 _P权限表 必须有主键，主键是表名去掉业务后缀，加_ID，大多表的主键使用UUID 字段多个单词时，全大写，用下划线隔开 类型INT/LONG/DOUBLE/TIMESTAMP/CHAR/VARCHAR2 尽量化在这几个类型中，这样数据库设计相当简单 排序号定死名称ORDER_NO 权限两个字段CREATE_BY创建人，CREATE_DEPT创建部门 记录创建时间CREATE_TIME  </description>
    </item>
    
    <item>
      <title>mysql查询</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql%E6%9F%A5%E8%AF%A2/</guid>
      <description>mysql学习(下面所有都是针对mysql而言) #  sql排序语句 #   升序   (select f.* from fruits f WHERE s_id IN (101,102) order by f_name)==(select f.* from fruits f WHERE s_id IN (101,102) order by f_name asc)   对于sql的升序而言,当使用了order by之后如果不添加desc那么默认是升序 order by f_name 和 order by f_name ASC 效果一致 降序   (select f.* from fruits f WHERE s_id not IN (101,102) order by f_name DESC )   order by之后加上DESC结果集就是降序   上面结合了 关键字in可以看到 in (101,102)和not in (101,102)</description>
    </item>
    
    <item>
      <title>mysql正则表达式</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_regexp/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_regexp/</guid>
      <description>一:数据准备 #  CREATE TABLE `t_user` ( `USER_ID` int NOT NULL AUTO_INCREMENT, `USER_NAME` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, `USER_PASSWORD` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, `USER_EMAIL` char(80) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, PRIMARY KEY (`USER_ID`), KEY `IDX_NAME` (`USER_NAME`) ) ENGINE=InnoDB AUTO_INCREMENT=209 DEFAULT CHARSET=utf8mb3; -- 如果存在此存储过程则删掉 DROP PROCEDURE IF EXISTS proc_initData; DELIMITER ; CREATE PROCEDURE proc_initData() BEGIN DECLARE i INT DEFAULT 1; WHILE i&amp;lt;=6000 DO INSERT INTO t_user(USER_NAME,USER_PASSWORD,USER_EMAIL) VALUES(MD5(UUID()),MD5(UUID()), CONCAT(substring(UUID(),1,7) , &amp;#39;@&amp;#39;, substring(UUID(),4,8) ,&amp;#39;.</description>
    </item>
    
    <item>
      <title>mysql用户与权限</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90/</guid>
      <description>mysql.version=5.7 (必须注意版本)
 创建用户 #   ( CREATE USER &amp;lsquo;bob&amp;rsquo;@&#39;%&#39; IDENTIFIED BY &amp;lsquo;07fa533360d9&amp;rsquo;; ) 创建bob用户 密码:07fa533360d9 ( CREATE USER &amp;ldquo;test&amp;rdquo;@&amp;ldquo;localhost&amp;rdquo; IDENTIFIED BY &amp;lsquo;123456&amp;rsquo; )创建test用户　密码123456 ( CREATE USER &amp;ldquo;test&amp;rdquo;@&amp;ldquo;192.168.87.26&amp;rdquo; IDENTIFIED BY &amp;lsquo;123456&amp;rsquo; )创建test用户　密码123456   参数说明:&#39;%&amp;lsquo;表示所有情况都能访问;&amp;lsquo;localhost&amp;rsquo;表示本机才能访问;&amp;lsquo;192.168.87.26&amp;rsquo; 某个具体 ip 才能访问
 授权命令 (GRANT privileges ON databasename.tablename TO &amp;lsquo;username&amp;rsquo;@&amp;lsquo;host&amp;rsquo; ) #  GRANT SELECT,INSERT privileges on spring.* to &amp;lsquo;alice&amp;rsquo;@&amp;lsquo;localhost&amp;rsquo; identified by &amp;lsquo;123456&amp;rsquo;
 参数说明:databasename表示数据库名字;tablename数据库表的名字;username用户名;host表示链接地址如本机localhost,远程任意%,具体ip192.168.87.26
 授权test用户拥有testDB数据库的所有权限 #  create database testDB;grant all privileges on testDB.</description>
    </item>
    
    <item>
      <title>mysql索引</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql%E7%B4%A2%E5%BC%95/</guid>
      <description>索引 #   MySQL使用索引快速查找具有特定列值的行。如果没有索引，MySQL必须扫描整个表以找到相关的行。较大的表，搜索速度越慢。
  索引由类型和方法组成(有的时候你没有指定就是使用的默认方法Btree这是一种B+树)有的人也把方法称为方式  讨论索引之前讨论树这种结构 #    B树
  B树有如下特点:
  所有键值分布在整颗树中（索引值和具体data都在每个节点里）；
  任何一个关键字出现且只出现在一个结点中；
  搜索有可能在非叶子结点结束（最好情况O(1)就能找到数据）；
  在关键字全集内做一次查找,性能逼近二分查找；
  与AVL 树，红黑树相比性能没那么好但是可以处理较大数据量后者虽然查得快但是处理大量数据有一定的问题比如(耗内存,数据库可能会有海量的数据)
  B+树
  B+树是B-树的变体，也是一种多路搜索树, 它与 B- 树的不同之处在于
  所有关键字存储在叶子节点出现,内部节点(非叶子节点并不存储真正的 data) 为所有叶子结点增加了一个链指针
  (自己理解)B+树每个节点都包含了指向其子节点的指针虽然没有直接包含子节点但是相当于间接包含了子节点
  因此B+树是大多数 MySQL 存储引擎的默认索引类型
  讨论hash结构 #   哈希索引能以 O(1) 时间进行查找，但是失去了有序性，它具有以下限制 无法用于排序与分组 只支持精确查找，无法用于部分查找和范围查找。 InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。   MySQL中，只有Memory存储引擎显示支持hash索引，是Memory表的默认索引类型，尽管Memory表也可以使用B-Tree索引 也就是我们从某种程度日常开发基本就接触BTREE数据结构了</description>
    </item>
    
    <item>
      <title>所有命运的馈赠，早已暗中标好了价格</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/x5xdewmh5e/</link>
      <pubDate>Sun, 29 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/my_self/x5xdewmh5e/</guid>
      <description>所有命运的馈赠，早已暗中标好了价格 #  好什么 最终要亡在什么上 #  以什么上台或者以什么为基本盘 盘么最终你的弱点就是你的基本盘 特别是高管或者大人物 #  </description>
    </item>
    
    <item>
      <title>mysql整理</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql%E6%95%B4%E7%90%86/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql%E6%95%B4%E7%90%86/</guid>
      <description>mysql整理 #  跨库更新数据 #  UPDATE pmcc_assess.tb_project_info aTable INNER JOIN ( SELECT id as data_id, uuid as data_uuid FROM pmcc_contract.tb_cms_contract bTable ) bTable ON aTable.contract_id = bTable.data_uuid SET aTable.contract_uuid = bTable.data_uuid , aTable.contract_id = null where 1=1 and aTable.contract_uuid is null and aTable.contract_id is not null and aTable.id = 596; UPDATE pmcc_assess.tb_project_info aTable INNER JOIN ( SELECT id as data_id, uuid as data_uuid FROM pmcc_contract.tb_cms_contract bTable ) bTable ON aTable.</description>
    </item>
    
    <item>
      <title>mysql优化</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysq_advanced_optimization/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysq_advanced_optimization/</guid>
      <description>mysql like 优化 #  思路 #   要提高Mysql 的查询效率最有效的办法是让所有的查询走索引字段，但是在Mysql中 Like 关键字只有对前缀查询(&amp;ldquo;keyword%&amp;quot;)走索引 例如: select title,content from demo_like_table where 1=1 and title like &amp;lsquo;73%&#39;; 我们常常需要模糊查询（&amp;quot;%keyword%&amp;quot;）或后缀查询(&amp;quot;%keyword&amp;rdquo;) 解决办法的思路是想办法让模糊查询和后缀查询都能走索引就可以达到目的 后缀查询解决方案：使用新建字段反转索引然后关键字段反转变成前缀查询 select REVERSE(rtitle) as title,content from demo_like_table where 1=1 and rtitle like &amp;lsquo;73%&#39;; 上面虽然用的前缀查询但是实际起到了后缀查询的效果  -- 创建一个表 CREATE TABLE `demo_like_table` ( `id` int NOT NULL AUTO_INCREMENT, `rtitle` varchar(255) DEFAULT NULL, `title` varchar(255) DEFAULT NULL, `content` longtext, `create_date` datetime DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `rtitle` (`rtitle`) USING BTREE, UNIQUE KEY `title` (`title`) USING BTREE ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci; -- 创建一个存储过程插入10w条数据  DROP PROCEDURE IF EXISTS pro_demo_like_table;--如果存在此存储过程则删掉 DELIMITER ; CREATE PROCEDURE pro_demo_like_table(IN len_value int) BEGIN DECLARE i INT DEFAULT 1; DECLARE `temp_value` VARCHAR(255) DEFAULT &amp;#39;&amp;#39;; WHILE i&amp;lt;= len_value DO set temp_value = substring(UUID(),1,7) ; INSERT INTO demo_like_table(title,rtitle,content,create_date) VALUES(`temp_value`, concat(REVERSE(`temp_value`),&amp;#39;&amp;#39;) ,MD5(UUID()), NOW()); SET i = i+1; END WHILE; END ; -- 借用了一个反转函数 REVERSE  CALL pro_demo_like_table(100000); -- 看一下数据(取少部分数据) id rtitle title content create_date 1	7b24016	61042b7	f1c4052d07190711480433bb5868d45f	2022-06-13 22:01:53 2	810e216	612e018	7da9f8cfc164709eaa538d00764b46fe	2022-06-13 22:01:53 3	df29316	61392fd	62c7635129b115d4b856ad55b2204f4e	2022-06-13 22:01:53 4	84a0416	6140a48	d8afb2f28952e446eb324fc92b211909	2022-06-13 22:01:53 5	6e28416	61482e6	86b76454892329da4b5f20f9a4900cb0	2022-06-13 22:01:54 6	60bf416	614fb06	5970f2b5e0635c73028823e425eebda4	2022-06-13 22:01:54 7	2037516	6157302	53b3c4a700d63267ea2f9efbd9aea224	2022-06-13 22:01:54 8	88be516	615eb88	fa8fd07bfe053316ffd0b0e99a53d702	2022-06-13 22:01:54 9	5e36616	61663e5	8deb3030510e1245c8d90ffa5be26e2f	2022-06-13 22:01:54 10	f4cd616	616dc4f	e76a2db7b00aaa32ecaca17d759f31ca	2022-06-13 22:01:54 11	4245716	6175424	4a243f6dde1d498dd4035c5b55f17908	2022-06-13 22:01:54 12	e880816	618088e	f2e7b09be96035cd9b0159c9dfb1818f	2022-06-13 22:01:54 13	cacb816	618bcac	4fac609c5d69f4f32925b4ab1142e883	2022-06-13 22:01:54 select REVERSE(rtitle) as title,content from demo_like_table where 1=1 and rtitle like &amp;#39;73%&amp;#39;; select title,content from demo_like_table where 1=1 and title like &amp;#39;73%&amp;#39;; 索引优化 #  索引 #   排好序的快速查找数据结构,影响查找和排序</description>
    </item>
    
    <item>
      <title>mysql新查询</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_select/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_select/</guid>
      <description>一:创建计算字段 #  -- 将 fruits.f_name 和 suppliers.s_city创建为了一个新字段连在一起来计算查询 select fruits.f_name as name ,suppliers.s_city as city from suppliers left join fruits on fruits.s_id = suppliers.s_id where 1=1 and CONCAT(fruits.f_name,&amp;#39;-&amp;#39;,suppliers.s_city) = &amp;#39;apple-Tianjin&amp;#39; ; -- 员工的部门和名称组合为新字段 select CONCAT_WS(&amp;#39;-&amp;#39;,dept.d_name,employee.e_name) as name from employee left join dept on dept.d_no = employee.dept_no 二:函数 #   聚集函数 预定义函数-字符串函数 预定义函数-时间处理函数 预定义函数-数字处理函数 算数、逻辑运算 流程函数  1:聚集函数 (聚合函数可以理解成多对一) #   什么是聚合函数   聚合函数作用于一组数据，并对一组数据返回一个值
  常用聚合函数：     函数 描述     AVG() 返回列的平均值   COUNT(DISTINCT) 返回列去重后的行数   COUNT() 返回列的行数   MAX() 返回列的最大值   MIN() 返回列的最小值   SUM() 返回列的总和   GROUP_CONCAT() 返回一组值的连接字符串(MySQL独有)     例子一  -- 计算表中数量,最小值,最大值,平均值,平均值,累加值 select count(*) as count_value ,MIN(f_price) as min_value,MAX(f_price) as max_value,AVG(f_price) as avg_value ,SUM(f_price) as sum_value from fruits  例子二  SELECT c_name,GROUP_CONCAT(grade), sum(grade) as total_grade ,avg(grade) as avg_grade FROM score GROUP BY c_name 2:预定义函数-字符串函数 #     函数 描述     LENGTH() 返回列的字节数   CHAR_LENGTH() 返回列的字符数   TRIM()/RTRIM()/LTRIM() 去除两边空格/去除右边空格/去除左边空格   SUBSTRING(str, pos, [len]) 从pos位置截取字符串str，截取len长度   LOCATE(substr, str, [pos]) 返回substr在str字符串中的位置   REPLACE(str, from_str, to_str) 将str字符串中的from_str替换成to_str   LOWER(), UPPER() 字符串转换为小写/大写     例子  SELECT `USER_NAME`, LENGTH( `USER_NAME` ) AS name_length, CHAR_LENGTH( USER_NAME ) AS string_length, LOWER( USER_NAME ) AS LOWER_NAME, UPPER( USER_NAME ) AS UPPER_NAME, REPLACE ( USER_NAME, &amp;#39;0&amp;#39;, &amp;#39;O&amp;#39; ) AS REPLACE_NAME, SUBSTRING( USER_NAME, &amp;#39;0&amp;#39;, 5 ) AS SUBSTRING_NAME, TRIM( `USER_NAME` ) AS TRIM_NAME FROM `t_user` LIMIT 2,40 3:预定义函数-数字处理函数 #     函数 描述     ABS() 返回数值的绝对值   CEIL() 对小数向上取整 CEIL(1.</description>
    </item>
    
    <item>
      <title>mysql视图</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_view/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_view/</guid>
      <description>数据库视图简介 #   数据库视图是一个虚拟表或逻辑表，它被定义为带有INNER的SQL SELECT查询。因为数据库视图类似于由行和列组成的数据库表，所以您可以针对它查询数据。大多数数据库管理系统（包括MySQL）允许您通过数据库视图更新基础表中的数据，并具有一些先决条件
 数据库视图的优点 #    数据库视图允许您简化复杂查询：数据库视图由与许多基础表关联的SQL语句定义。您可以使用数据库视图向最终用户和外部应用程序隐藏基础表的复杂性。通过数据库视图，您只需使用简单的SQL语句而不是具有许多连接的复杂语句。
  数据库视图有助于限制对特定用户的数据访问。您可能不希望所有用户都可以查询敏感数据的子集。您可以使用数据库视图仅将非敏感数据公开给特定用户组。
  数据库视图提供额外的安全层。安全性是任何关系数据库管理系统的重要组成部分。数据库视图为数据库管理系统提供了额外的保护。数据库视图允许您创建只读视图以向特定用户公开只读数据。用户只能以只读视图检索数据，但无法更新数据。
  数据库视图启用计算列。数据库表不应有计算列，但数据库视图应。假设orderDetails您在表中有quantityOrder（订购产品的数量）和priceEach（每个产品的价格）列。但是，orderDetails 表没有用于存储订单的每个行项目的总销售额的计算列。如果有，数据库模式将不是一个好的设计。在这种情况下，您可以创建一个名为的计算列total ，它是quantityOrder和priceEach计算结果的乘积。从数据库视图查询数据时，将动态计算计算列的数据。
  数据库视图可实现向后兼容性。假设您有一个中央数据库，许多应用程序正在使用它。有一天，您决定重新设计数据库以适应新的业务需求。您删除了一些表并创建新表，并且您不希望更改影响其他应用程序。在此方案中，您可以使用与要删除的旧表相同的模式创建数据库视图
  数据库视图的缺点 #   性能：从数据库视图查询数据可能会很慢，尤其是在基于其他视图创建视图时。 表依赖项：您基于数据库的基础表创建视图。每当您更改与其关联的视图的这些表的结构时，您也必须更改视图。  创建视图 #  CREATE [ALGORITHM = {MERGE | TEMPTABLE | UNDEFINED}] VIEW view_name [(column_list)] AS select-statement; 视图的处理算法 #   MERGE   使用MERGE算法，MySQL首先将输入查询与SELECT定义视图的语句组合成单个查询。然后MySQL执行组合查询以返回结果集。 如果SELECT语句包含聚合函数，例如 MIN，MAX，SUM，COUNT，AVG 或DISTINCT，GROUP BY，HAVING，LIMIT，UNION，UNION ALL，子查询，则不允许使用MERGE算法。如果SELECT语句引用无表，则也不允许MERGE算法。如果不允许MERGE算法，MySQL将算法更改为UNDEFINED。请注意，将视图定义中的输入查询和查询组合到一个查询中称为视图分辨率
  TEMPTABLE   使用TEMPTABLE算法，MySQL首先根据定义视图的SELECT语句创建临时表，然后对临时表执行输入查询。因为MySQL必须创建一个临时表来存储结果集并将数据从基表移动到临时表，所以TEMPTABLE 算法的效率低于MERGE算法。此外，使用TEMPTABLE 算法的视图不可更新。</description>
    </item>
    
    <item>
      <title>mysql触发器</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/triggers/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/triggers/</guid>
      <description>SQL触发器简介 #   SQL触发器是存储在数据库目录中的一组SQL语句。只要与表关联的事件发生，例如插入，更新或删除，就会执行或触发SQL触发器
 SQL触发器的优点 #   SQL触发器提供了另一种检查数据完整性的方法。 SQL触发器可以捕获数据库层中业务逻辑中的错误。 SQL触发器提供了另一种运行计划任务的方法。通过使用SQL触发器，您不必等待运行计划任务，因为在对表中的数据进行更改之前或之后会自动调用触发器。 SQL触发器对于审计表中数据的更改非常有用。  SQL触发器的缺点 #   SQL触发器只能提供扩展验证，并且不能替换所有验证。必须在应用程序层中完成一些简单的验证。例如，您可以使用JavaScript在客户端验证用户的输入，或者使用服务器端脚本语言（如JSP，PHP，ASP.NET，Perl）在服务器端验证用户的输入。 从客户端应用程序调用和执行SQL触发器是不可见的，因此很难弄清楚数据库层中发生了什么。 SQL触发器可能会增加数据库服务器的开销  MySQL 触发器的创建 #  MySQL触发语法 #  CREATE TRIGGER trigger_name trigger_time trigger_event ON table_name FOR EACH ROW BEGIN ... END;   触发器名称约定 [trigger time][table name][trigger event]，例如before_employees_update
  触发激活时间可以是BEFORE或AFTER
  触发事件可以是INSERT，UPDATE或者DELETE事件导致触发器被调用
  触发器必须与特定表关联。如果没有表触发器将不存在，因此您必须在ON关键字后指定表名
  将SQL语句放在BEGIN和END阻止之间
  例子1
  -- create table CREATE TABLE employees_audit ( id INT AUTO_INCREMENT PRIMARY KEY, employeeNumber INT NOT NULL, lastname VARCHAR(50) NOT NULL, changedat DATETIME DEFAULT NULL, action VARCHAR(50) DEFAULT NULL ); </description>
    </item>
    
    <item>
      <title>国内咨询平台</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/r2xcf5nxjq/</link>
      <pubDate>Sun, 09 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/r2xcf5nxjq/</guid>
      <description>国内靠谱咨询平台 #  广义平台 #    知乎平台
  创客匠人 慎重
  得到 慎重
  心理 #    壹点灵
  简单心理
  糖心理
  看见心理
  思睿明 慎重
  法律 #   华律网 慎重   华律网创建于2004年，国内知名的一站式法律服务平台，提供法律咨询、找律师、法律知识等服务。截至2021年1月，华律网注册普通会员人数已达1亿多，日独立访客680万，日产生咨询10万多，注册律师人数近30万，华律网全线产品每年为超过30亿人次普及法律知识
  找法网 慎重   找法网创立于2003年，国内知名的法律信息咨询网站，致力于为法律需求者提供免费多样的法律咨询服务。截至目前，找法网的业务已覆盖全国34个省，近370个大中小城市，吸引20多万执业律师、1亿余公众注册，创造了每天超10万次的法律咨询服务
  中顾法律网 慎重   中顾法律网创办于2005年，是专业的法律服务平台，在法律资讯、咨询及法律爱好者交互等方面保持国内业界领先地位。目前，中顾法律网已有全国95%以上的执业律师加盟，涉及有50多个专长领域，城市分站遍布全国34省、近四百个大中城市
  法律快车 慎重   法律快车创立于2004年，致力于打造放心的互联网法律服务平台，提供问律师、找律师、看知识等法律服务。法律快车融合了线上和线下法律服务的交易模式，提供全程的法律服务。目前，法律快车已覆盖180多个法律专业领域细分，为分散在全国360多个大中小城市的超23万律师和数千万法律需求者创造近在身边的法律服务机会</description>
    </item>
    
    <item>
      <title>记忆方法</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%AE%B0%E5%BF%86/</link>
      <pubDate>Sun, 17 Jan 2021 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%AE%B0%E5%BF%86/</guid>
      <description>记忆方法 #   提高记忆的关键，在于想象和创意 编故事有助于提高记忆力  通过编故事，再加上逻辑或地点（后者更多一些）; 编故事是加强了记忆桩之间的联系 记忆和创造力 #   记忆本身与创造力密不可分 ， 训练记忆力在很大程度上取决于你的创造力  要想记住毫不相关的信息和扑克牌， 首先就要把它们变成图像。 通过这种方式， 那些零散的信息才可能会建立某种联系 联想 #  利用事物间的联系通过联想进行记忆的方法。 联想是由当前感知或思考的事物想起有关的另一事物， 或者由头脑中想起的一件事物，又引起想到另一件事物。 由于客观事物是相互联系的，各种知识也是相互联系的，因而在思维中， 联想是一种基本的思维形式，是记忆的一种方法。 联想，就是当人脑接受某一剌激时，浮现出与该刺激有关的事物形象的心理过程。 一般来说，互相接近的事物、相反的事物、相似的事物之间容易产生联想。 用联想来增强记忆是一种很常用的方法。 记忆的一种主要机能就是在有关经验中建立联系，思维中的联想越活跃，经验的联系就越牢固。 如能经常形成联想和运用联想，就可增强记忆的效果。 联想是有规律可循的，联想的规律有接近律、类似律、对比律、因果律等，有接近联想、类似联想、对比联想、因果联想。   联想不仅快速，而且它还不是一个简单、一维的东西。首先，你在联想中会加入一些情感因素，甚至还没回想起一段经历，就已经产生了某种情绪。
  一旦学会动用感情和感官，还有逻辑和创造力，来与不同事物间建立联系，你的记忆能力就会大大提高。除此之外，你还会慢慢习惯放松大脑，以最快的速度在不同事物之间建立联系。瞬间联想之所以对提高记忆力如此重要，是因为一个人在瞬间建立的联系往往是最牢靠的
  如何在两个并无联系的单词之间建立联系&amp;ndash;记忆的关键，就在于将二者结合到一起。
  如果没有过去的某些参照物作为参考，你就不能在两个概念( 包括单词、物体、活动等)之间建立联系。你的过去为你提供了某种经验，而正是这种经验可以帮助你由一个概念想到另一件概念。你的生活中发生的一切都像是积木中的模块，正是这一个个模块帮助你搭建了自己的人生大厦。要想在两个模块之间尽快建立联系，你需要用尽可能少的连接物来实现过渡。也就是说，要想从一件事情想到另外一件事情，最快的方式就是直接找到二者之间的联系
   比如说我想记住两个单词：墙壁和小鸡。 每个单词都能激发我丰富的联想，我必须找到某种连接物将两个单词连接起来。 比如说： 墙壁会让我想到一个相册，想找到我小时候放学后经常爬的墙等。 随着联想越来越细致、快速，我突然想到了一个最明显的连接：一首叫&amp;lt;&amp;lt;小胖鸡&amp;gt;&amp;gt;的儿歌。 好极了！小胖鸡坐着墙壁上，它是一个鸡蛋----而鸡蛋又是小鸡下的。 这时我就会展开联想，想象一只小鸡坐在墙下下蛋。 为了让这个联想更加生动，我想起了小时候我在唱歌时的样子， 然后自然而然地想到了自己看着小鸡下蛋时吃吃发笑的情形。 虽然我并不记得发生过这件事，但它却足以激发我的联想。 这个过程听起来可能有些复杂、繁琐，但事实上，这在大脑中只是一瞬间发生的事情。 链条法 #   如何使用链条法记住5个单词 小提琴、武士、箱子、项链、雪球  首先想想你突然听到小提琴发出的悠扬乐声。 然后看到一个武士在演奏小提琴， 你甚至可以清楚地看到他把小提琴放到下巴下面--这武士满副盔甲，很是搞笑。 然后你看到他脚边放了一个箱子，可能颜色很鲜艳，也可能已经很破旧了。 你打开箱子，发现里面有一挂价值连城的钻石项链，钻石反射阳光，分外耀眼。 最后你转过头去，突然一个雪球砸中你的脸颊，你甚至感觉到右脸有些发疼。 记住，你越练习动用五官来加强想象，你的大脑就会越熟悉这种练习，你也就越容易记住自己想象的场景。   要要记住五个单词以及单词之间的顺序，需要在单词之间建立联系</description>
    </item>
    
    <item>
      <title>学习方法</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 17 Jan 2021 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</guid>
      <description></description>
    </item>
    
    <item>
      <title>冥想</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E5%86%A5%E6%83%B3/</link>
      <pubDate>Sun, 17 Jan 2021 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E5%86%A5%E6%83%B3/</guid>
      <description>冥想 #  呼吸冥想法 #    1:坐好，后背挺直，然后闭上眼睛
  2:关注你自己呼吸时的感觉,吸气，吸气，选择一个感受突出的地方，通常是你的鼻子或者耳朵、腹部然后集中注意力，关注你自己呼吸时的感觉。吸气，吸气，用嘴呼吸（最好关注腹部，因为我们大部分人都是腹部呼吸法）
  3:一旦你开始这样做了脑子会乱想,你需要关注你到什么时候走神的，那么走神后重新调整后重新开始集中注意力开始冥想。
  </description>
    </item>
    
    <item>
      <title>适合分享的段子和笑话</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/paragraph/</link>
      <pubDate>Sun, 17 Jan 2021 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/paragraph/</guid>
      <description>段子 #   王朔自嘲段子  王朔在酒馆喝的大醉，大吼一声:谁小说写的比我好？旁边王小波轻描淡写来一句:我写的比你好。
王朔走过来揽住王小波的肩，继续张扬:谁能写小说比我们俩好？</description>
    </item>
    
    <item>
      <title>第n天记录</title>
      <link>https://huachengzhou.github.io/life/posts/change/2022-10-18/</link>
      <pubDate>Wed, 12 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/posts/change/2022-10-18/</guid>
      <description>记录 #  当你和她不对等的时候 这个时候即便苦苦等待得来了相处也是痛苦的 好的感情一定是相互成就的 所以一定要大量的去追求女孩子 那个真心回应你的女孩子才是你值得用心去爱的
相亲来的女孩子大都不是真心的还是放弃吧只是来了咱也用心对待 如果不用心就随她去吧
双向奔赴的爱情最值得肯定.</description>
    </item>
    
    <item>
      <title>第一天记录</title>
      <link>https://huachengzhou.github.io/life/posts/change/2022-10-12/</link>
      <pubDate>Wed, 12 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/posts/change/2022-10-12/</guid>
      <description>记录下目前想法 #  人生没有谁是完美的,每个人都是独特的,当然你站在特殊的角度去强行评价一个人那多半是可以分出高低贵贱的,只是这就有点肤浅了主观在个人你是怎样去看待这个问题的
你经历越多从表面上看你可能确实比较痛苦但是从反面看你经历这些之后你也就越坚强如果你以后要找灵感那么你的经历就天然成了你的优势之一
最近我在想我不是正在改变嘛 我可以把这些录下来 然后既可以帮助自己观察自己状态 也可以用来帮助其他人</description>
    </item>
    
    <item>
      <title>uniapp打包</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/packing/</link>
      <pubDate>Sat, 04 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/packing/</guid>
      <description>android本地打包 #  参考1 参考2 参考3
uniapp创建keystore jks 参考
 这里是因为创建密匙文件有多种方式  第一步 下载 Android Studio 配置必要的数据 #     配置 android sdk 选用google 可以官网下载也可以使用工具下载    配置 jdk ( java jdk建议)    假如你没有手机或者手机不在打包环境那么你需要配置模拟android平台    第二部(重要) #   我也是在网上找了下，发现网上的有残缺吧
  1:HBuilderX版本 必须和 sdk一致  uniapp本地打包下载地址
  2: Android Studio导入HBuilder-Integrate-AS
  3:删除 HBuilder-Integrate-AS_c\simpleDemo\src\main\assets\apps 下的 生成的包
  4: 生成签名
  C:\Windows\system32&amp;gt;c: C:\Windows\system32&amp;gt;cd C:\Program Files\Java\jdk1.</description>
    </item>
    
    <item>
      <title>2021-06-15</title>
      <link>https://huachengzhou.github.io/life/posts/2021/oneday/</link>
      <pubDate>Tue, 15 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/posts/2021/oneday/</guid>
      <description>  努力
  英语越来越重要了
  </description>
    </item>
    
    <item>
      <title>DNS 污染</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/dns%E6%B1%A1%E6%9F%93/</link>
      <pubDate>Sun, 17 Jan 2021 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/dns%E6%B1%A1%E6%9F%93/</guid>
      <description>中国国内访问 GitHub 为什么很慢很卡甚至访问不了？如何加速访问 GitHub 网站？ #  个人总结：强扭的瓜不甜，修改 hosts 也就片刻好光景，要不了多久就变得比没改 hosts 之前更慢。所以还是顺其自然就好，不要白费力气去修改 hosts。 #    摘要
  网站分发加速网络的域名遭到 DNS 污染，DNS 不能直接找到那个最快的 IP！ 通过修改系统 hosts 文件的办法，绕过国内 DNS 解析，直接访问 GitHub 的 CDN 节点，从而达到加速的目的！
  如何检验效果
  操作之前先 ping 一下 github.com，两个请求超时，两个 93ms。
  操作之后再 ping 一下 github.com，没有丢失，四个 287ms。
  一、国内访问 GitHub 为什么很慢？ #   GitHub 的 CDN 域名遭到 DNS 污染，导致无法连接使用 GitHub 的加速分发服务器，才使得国内访问速度很慢。  二、如何解决 DNS 污染？ #   通过修改 Hosts 文件，将域名解析直接指向 IP 地址来绕过 DNS 的解析，以此解决污染问题。  三、具体操作步骤 #    1、打开 https://www.</description>
    </item>
    
    <item>
      <title>GitHubPages绑定来自阿里云的域名</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/githubpages%E7%BB%91%E5%AE%9A%E6%9D%A5%E8%87%AA%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E5%9F%9F%E5%90%8D/</link>
      <pubDate>Sun, 17 Jan 2021 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/githubpages%E7%BB%91%E5%AE%9A%E6%9D%A5%E8%87%AA%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E5%9F%9F%E5%90%8D/</guid>
      <description>原教程但是由于他使用的github的用户名做的域名映射器,这样不好的地方是有可能你使用自定义的方式建立github仓库名比如 English study,还有一个是他使用的阿里云的域名映射解析这些是老版本的
  GitHub Pages 绑定来自阿里云的域名==原博客教程
  我的使用 #  github url ==&amp;gt; https://github.com/noatnu/studyDoc , 买的域名 http://www.zhouchenghua.com/ #   解析第一个设置   创建A记录，请将您的顶点域指向GitHub Pages的IP地址 https 解析ip,上面的192.30.252.153是http解析方式现在官方已经宣布过时了,选择下面任意一个都可以  185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153  解析第二个设置    github 要做的事
  创建 CNAME文件,写入www.zhouchenghua.com
   这个是我设置github project 设置截图   ping 地址  C:\Users\noatn&amp;gt;ping www.github.com 正在 Ping github.com [13.250.177.223] 具有 32 字节的数据: 请求超时。 请求超时。 请求超时。 请求超时。 13.</description>
    </item>
    
    <item>
      <title>git处理网络和权限问题</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/git_andsower/git%E5%A4%84%E7%90%86/</link>
      <pubDate>Sun, 17 Jan 2021 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/git_andsower/git%E5%A4%84%E7%90%86/</guid>
      <description>Push master to origin/master was rejected by remote  有三种原因 1:push的这个工程是其他人新建的，找她开通master权限后，再次push 2:git 工程错误 git pull git pull origin master git pull origin master --allow-unrelated-histories 3:github 设置原因 勾选了Keep my email addresses private 解决办法2种 第一种 通知账户人员取消勾选 第二种 重新设置你的全局用户E-mail git config --list 查看这个时候一定不对 因此重新设置全局email 重置上次提交的作者信息 git commit --amend --reset-author git config --global user.name &amp;quot;zch&amp;quot; git config --global user.email &amp;quot;sdhshd@163.com&amp;quot; ok 对了你如果使用的不是idea而是git 那么抛出的错误非常明显 如果抛出 git报错--&amp;gt;! [remote rejected] master -&amp;gt; master (push declined due to email privacy restrictions) 那么一定是这个原因  git clone时报RPC failed; curl 18 transfer closed with outstanding read data remaining 错误  原因1：缓存区溢出 git config http.</description>
    </item>
    
    <item>
      <title>idea 解决working directory 设置到 target</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/idea/idea/</link>
      <pubDate>Sun, 17 Jan 2021 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/idea/idea/</guid>
      <description> idea 解决working directory 设置到 target  test ng D:\IdeaProjects\java-se-study run config $MODULE_DIR$ </description>
    </item>
    
    <item>
      <title>idea 问题解决</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/maven/idea%E8%A7%A3%E5%86%B3/</link>
      <pubDate>Sun, 17 Jan 2021 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/maven/idea%E8%A7%A3%E5%86%B3/</guid>
      <description>idea导入项目出现Unable to import maven project: See logs for details提示
 第一种解决办法 #    删除项目根目录下.idea文件夹
  关闭idea工具，重新打开选择File-&amp;gt;New-&amp;gt;Project from the existing source ,选择刚才的项目根目，下一步：
  一直点next，最后点击主工程的pom.xml 完成！
  第二种 #    打开idea 的日志文件如果发现【Error】com.google.inject.CreationException: Unable to create injector
  那么自定义配置Maven3.6.2报错 或者更高版本maven
  原因：Maven3.6.2的版本兼容问题。
  解决方法：重新下载较低版本Maven3.6.1及以下版本可以顺利解决。
  用maven无论是新建项目还是导入没有下载到本地仓库的jar。出现了Unable to import maven project
  打开cmd，ping localhost，显示一般故障
  在左边控制栏，关闭防火墙，再开启防火墙 再次ping localhost，成功
  对了 假如出现文件权限问题 那么更改maven的本地仓库地址</description>
    </item>
    
    <item>
      <title>Visual Studio Code 问题解决方案</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/visual_studio_code/visualstudiocode%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 17 Jan 2021 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/visual_studio_code/visualstudiocode%E9%97%AE%E9%A2%98/</guid>
      <description>Visual Studio Code 过滤文件 不显示某些文件 #  效果 #   过滤工程中显示的文件 不显示某些类型的文件或文件夹  菜单 #   File/Preferences/ 搜索file exclude 选中workspack页签 添加一个过滤规则 如图:   </description>
    </item>
    
    <item>
      <title>如何在油管YouTube开通收益赚钱</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%8E%B7%E5%8F%96%E9%87%91%E9%92%B1/%E5%A6%82%E4%BD%95%E5%9C%A8%E6%B2%B9%E7%AE%A1youtube%E5%BC%80%E9%80%9A%E6%94%B6%E7%9B%8A%E8%B5%9A%E9%92%B1/</link>
      <pubDate>Sun, 17 Jan 2021 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%8E%B7%E5%8F%96%E9%87%91%E9%92%B1/%E5%A6%82%E4%BD%95%E5%9C%A8%E6%B2%B9%E7%AE%A1youtube%E5%BC%80%E9%80%9A%E6%94%B6%E7%9B%8A%E8%B5%9A%E9%92%B1/</guid>
      <description>如何在油管YouTube开通收益赚钱？ #  如果想在YouTube创业赚取美金，建议关注【YouTube运营笔记】，少走弯路，不被忽悠
本篇主要由3个常见问题详细展开： #   如何在油管上开通获利？ 油管广告收益情况如何？ 油管除了广告还能怎么赚钱？  一、如何在YouTube开通获利？ #  第1步：你得有一个Gmail账号 #   YouTube账号是跟谷歌邮箱账号是关联的。想创建频道然后上传视频的基础条件就是，注册并登陆谷歌账号，目前一些国内手机注册会失败。   注：Gmail能登录就行，手机号码归属和注册地对后期收益不存在影响。
 第2步：你得有一个YouTube频道 #   一般而言只要你有了谷歌账号，就默认有一个YouTube频道了，但那个频道名称头像是跟谷歌邮箱是挂钩的，建议单独创建频道。此外，一个谷歌账号是创建多个频道的。   注：创建频道前，要想清楚频道的内容定位；频道创建后，还要对频道进行装修。
 第3步：你得有策略地上传视频 #   这一步非常重要，YouTube运营是一个技术活，不是随随便便发几个视频就有人看，也不是坚持发布就能做起来。有志要做的建议查看本专栏的其它文章，这里不细讲。   注：做YouTube成功的条件是「优质的内容+正确的方法」，缺一不可
 第4步（重点）：你须达到获利门槛/申请开通 #   想开通获利，必须满足以下条件：   1:选择支持YouTube合作伙伴计划的国家或地区。 2:12 个月内的有效观看时长累计超过4000小时。 3:频道拥有至少1000订阅。 4:拥有可关联的 AdSense 帐号。   其中，最为关键的同时最难的条件是4000小时和1000名订阅；「国家/地区」后台设置支持的国家/地区即可；「AdSense」是在频道达到获利门槛后显示注册入口，看似简单却最容易出错，资料要仔细填写，一旦填错后续非常麻烦。《YouTube运营新手最常踩5大坑，最后1个最坑人！》 除了订阅者数量和观看次数要求外，还有内容要求。获利申请的审核是官方人工审核，如果审核者认为频道或视频不符合条件，也是容易无法通过的，审核时间快则一两天，慢的一个多月也有。《YouTube获利政策：这11类内容没有收益》  二、油管广告收益情况如何？ #   YouTube将部分广告收入（55%）分给相应的Youtuber，就能构成一个良性循环的三赢局面：广告商得到宣传，Youtuber赚钱，油管平台赚钱同时有源源不断的优质内容创作出来。平台把55%的广告收益分给视频创作者，这对自媒体从业者而言，真不算低。    YouTube的千次播放（CPM）的收益差距略大，一般在1-10美元不等。影响视频收益主要因素包括：</description>
    </item>
    
    <item>
      <title>hugo教程 hugo server Failed to get JSON</title>
      <link>https://huachengzhou.github.io/life/docs/hugo%E5%AD%A6%E4%B9%A0/hugo_server_faile_-to_get_json/</link>
      <pubDate>Tue, 17 Oct 2017 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/hugo%E5%AD%A6%E4%B9%A0/hugo_server_faile_-to_get_json/</guid>
      <description>今天尝试了一下静态博客 hugo , hugo的官网本身也是使用 hugo 制作的网站。安装和运行非常简单。只有两个步骤安装和运行。运行的时候出现了一个小问题，就是由于网络的原因不能启动成功。
 粗暴的禁用网络连接相关的操作 #   就是两个 短代码 给删除了 instagram, tweet。  find . -name &amp;amp;quot;*.md&amp;amp;quot; | xargs sed -i &amp;amp;#x27;/{{&amp;amp;lt; instagram/cinstagram content&amp;amp;#x27; find . -name &amp;amp;quot;*.md&amp;amp;quot; | xargs sed -i &amp;amp;#x27;/{{&amp;amp;lt; tweet/ctwitter content&amp;amp;#x27; hugo server --bind &amp;amp;#x27;0.0.0.0&amp;amp;#x27;  print code  ERROR 2021/03/06 09:55:20 Failed to get JSON resource &amp;quot;https://api.twitter.com/1/statuses/oembed.json?id=877500564405444608&amp;amp;dnt=false&amp;quot;: Get &amp;quot;https://api.twitter.com/1/statuses/oembed.json?id=877500564405444608&amp;amp;dnt=false&amp;quot;: dial tcp 31.13.91.33:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.</description>
    </item>
    
    <item>
      <title>hugo教程1</title>
      <link>https://huachengzhou.github.io/life/docs/hugo%E5%AD%A6%E4%B9%A0/hugo_tutorials1/</link>
      <pubDate>Tue, 17 Oct 2017 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/hugo%E5%AD%A6%E4%B9%A0/hugo_tutorials1/</guid>
      <description>教程1 #  快速开始 #   步骤1：安装Hugo  brew install hugo # or port install hugo  要验证新安装  hugo version  步骤2：建立新网站  hugo new site quickstart # 上面的代码将在名为的文件夹中创建一个新的Hugo网站quickstart。  步骤3：添加主题  # 首先，从GitHub下载主题并将其添加到您站点的themes目录中： cd quickstart git init git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke  然后，将主题添加到站点配置中：  echo &#39;theme = &amp;quot;ananke&amp;quot;&#39; &amp;gt;&amp;gt; config.toml  步骤4：添加一些内容  hugo new posts/my-first-post.md  如果需要，请编辑新创建的内容文件，该文件将从以下内容开始：   --- title: &amp;quot;My First Post&amp;quot; date: 2019-03-26T08:47:11+01:00 draft: true ---  步骤5：启动Hugo服务器  ▶ hugo server -D | EN +------------------+----+ Pages | 10 Paginator pages | 0 Non-page files | 0 Static files | 3 Processed images | 0 Aliases | 1 Sitemaps | 1 Cleaned | 0 Total in 11 ms Watching for changes in /Users/bep/quickstart/{content,data,layouts,static,themes} Watching for config changes in /Users/bep/quickstart/config.</description>
    </item>
    
    <item>
      <title>hugo教程2</title>
      <link>https://huachengzhou.github.io/life/docs/hugo%E5%AD%A6%E4%B9%A0/hugo_tutorials2/</link>
      <pubDate>Tue, 17 Oct 2017 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/hugo%E5%AD%A6%E4%B9%A0/hugo_tutorials2/</guid>
      <description>教程2 #   1、	创建blog  hugo new site myblog_pub cd myblog_pub/ git submodule add https://github.com/chinanf-boy/gohugo-theme-yinwang.git themes/yinwang   2、	修改配置
  vi config.toml
  root@instance-x8rtph4n:/home/go/code/hugo_dir/myblog_pub/public# more ../config.toml baseURL = &amp;quot;http://ypbsyy.github.io/&amp;quot; languageCode = &amp;quot;en-us&amp;quot; title = &amp;quot;我是yaopeng&amp;quot; theme = &amp;quot;yinwang&amp;quot; #pygmentsCodeFences = true #pygmentsCodefencesGuessSyntax = false #pygmentsStyle = &amp;quot;dracula&amp;quot; #pygmentsOptions = [&#39;linenos&#39;] # 代码高亮/chroma，hugo默认自带 [params] author = &amp;quot;yaopeng&amp;quot; github = &amp;quot;yaopeng&amp;quot; # gitlab = &amp;quot;yobrave&amp;quot; #googleAnalytics = &amp;quot;****&amp;quot; # 谷歌统计gtag highlight = &amp;quot;dracula&amp;quot; # 默认样式 `github` langs = [&amp;quot;go&amp;quot;] # 默认加载 highlight.</description>
    </item>
    
    <item>
      <title>统一建模语言</title>
      <link>https://huachengzhou.github.io/life/posts/uml/</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/posts/uml/</guid>
      <description> 统一建模语言(Unified Modeling Language，UML)是一种为面向对象系统的产品进行说明、可视化和编制文档的一种标准语言，是非专利的第三代建模和规约语言。UML是面向对象设计的建模工具，独立于任何具体程序设计语言。
 UML作为一种统一的软件建模语言具有广泛的建模能力。UML是在消化、吸收、提炼至今存在的所有软件建模语言的基础上提出的，集百家之所长，它是软件建模语言的集大成者。UML还突破了软件的限制，广泛吸收了其他领域的建模方法，并根据建模的一般原理，结合了软件的特点，因此具有坚实的理论基础和广泛性。UML不仅可以用于软件建模，还可以用于其他领域的建模工作。 [1] #  UML立足于对事物的实体、性质、关系、结构、状态和动态变化过程的全程描述和反映。UML可以从不同角度描述人们所观察到的软件视图，也可以描述在不同开发阶段中的软件的形态。UML可以建立需求模型、逻辑模型、设计模型和实现模型等，但UML在建立领域模型方面存在不足，需要进行补充。 [1] #  作为一种建模语言，UML有严格的语法和语义规范。UML建立在元模型理论基础上，包括4层元模型结构，分别是基元模型、元模型、模型和用户对象。4层结构层层抽象，下一层是上一层的实例。UML中的所有概念和要素均有严格的语义规范。 [1] #  UML采用一组图形符号来描述软件模型，这些图形符号具有简单、直观和规范的特点，开发人员学习和掌握起来比较简单。所描述的软件模型，可以直观地理解和阅读，由于具有规范性，所以能够保证模型的准确、一致。 #  </description>
    </item>
    
    <item>
      <title>项目管理</title>
      <link>https://huachengzhou.github.io/life/posts/project-management/</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/posts/project-management/</guid>
      <description>项目管理（Project Management,PM/Management by Projects,MBP） #  项目管理概述 #  项目管理是项目的管理者，在有限的资源约束下，运用系统的观点、方法和理论，对项目涉及的全部工作进行有效地管理。即从项目的投资决策开始到项目结束的全过程进行计划、组织、指挥、协调、控制和评价，以实现项目的目标。 #  按照传统的做法，当企业设定了一个项目后，参与这个项目的至少会有好几个部门，包括财务部门、市场部门、行政部门等等，而不同部门在运作项目过程中不可避免地会产生摩擦，须进行协调，而这些无疑会增加项目的成本，影响项目实施的效率。 #  而项目管理的做法则不同。不同职能部门的成员因为某一个项目而组成团队，项目经理则是项目团队的领导者，他们所肩负的责任就是领导他的团队准时、优质地完成全部工作，在不超出预算的情况下实现项目目标。项目的管理者不仅仅是项目执行者，他参与项目的需求确定、项目选择、计划直至收尾的全过程，并在时间、成本、质量、风险、合同、采购、人力资源等各个方面对项目进行全方位的管理，因此项目管理可以帮助企业处理需要跨领域解决的复杂问题，并实现更高的运营效率。 #  项目管理的应用从80年代仅限于建筑、国防、航天等行业迅速发展到今天的计算机、电子通讯、金融业甚至政府机关等众多领域。 #  人们通常认为，项目管理是第二次世界大战的产物（如：曼哈顿计划）。在1950年至1980年期间，应用项目管理的主要是国防建设部门和建筑公司。传统的观点认为，项目管理者的工作就是单纯地完成既定的任务。 #  从本世纪八十年代开始，项目管理的应用扩展到其他工业领域（行业），如制药行业、电信部门、软件开发业等。项目管理者也不再被认为仅仅是项目的执行者，要求他们能胜任其它各个领域的更为广泛的工作，同时具有一定的经营技巧。美国项目管理学会（PMI）已提出了关于一个有效的专业项目管理者必须具备的几个方面的基本能力： #   项目范围管理 项目时间管理 项目费用管理 项目质量管理 项目人力资源管理 项目沟通管理 项目风险管理 项目采购管理 项目综合管理  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://huachengzhou.github.io/life/docs/javadir/groovy/groovy%E5%8F%98%E9%87%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/groovy/groovy%E5%8F%98%E9%87%8F/</guid>
      <description>Groovy 变量 #   Groovy中的变量可以通过两种方式定义 - 使用数据类型的本地语法，或者使用def关键字。对于变量定义，必须明确提供类型名称或在替换中使用“def”。这是Groovy解析器需要的。
   byte - 这用于表示字节值。例如2。
  short - 用于表示一个短数。例如10。
  int - 这用于表示整数。 例如1234。
  long - 这用于表示一个长数。例如10000090。
  float - 用于表示32位浮点数。例如12.34。
  double - 这用于表示64位浮点数。例如12.3456565。
  char - 这定义了单个字符文字。例如&amp;rsquo;a&#39;。
  Boolean - 这表示一个布尔值，可以是true或false。
  String - 这是以字符串形式表示的文本。 例如“Hello World”。
  Groovy还允许其他类型的变量，如数组，结构和类
  变量声明 #   title: &amp;quot; groovy变量 &amp;quot; date: 2021-04-15 draft: false weight: 3 #    变量声明告诉编译器为变量创建存储的位置和大小。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://huachengzhou.github.io/life/docs/physics/light/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/physics/light/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://huachengzhou.github.io/life/posts/change/secret/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/posts/change/secret/</guid>
      <description>还是继续学习英语吧 就使用新概念英语 继续加强每天的朗读和沟通技巧 有时间就尝试记忆宫殿 另外抽空把python和算法学习了
回家路上把 几个重点 看了 回家花半小时把博客写了 然后 以后还是提神自己的厨艺吧 哈哈 自己给自己弄好吃的
记住和自己和解吧 你和昨天相比有进步就是好样的
「少吃多餐」单词学习法。所谓「少吃多餐」单词学习法，就是单位时间内少量学习新词，但是却高频重复新词的方法，关键词是：一次少量，循环多次。如今，很多单词学习app都遵循了这种学习规律，同学们可以结合背单词app去积累单词。
在学习单词时，警惕一个误区——「豆腐渣工程」：贪多求全的背诵大词、难词，但是却因为不常使用和复习逐渐忘记，造成「胸中自诩词汇万千，实则溃于蚁穴」的词汇量假象</description>
    </item>
    
  </channel>
</rss>
