<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Introduction on 所悟所想</title>
    <link>https://huachengzhou.github.io/life/</link>
    <description>Recent content in Introduction on 所悟所想</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 04 Dec 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://huachengzhou.github.io/life/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ECMAScript 6</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/javascript/es6/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/javascript/es6/</guid>
      <description>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。  Module 的语法#概述#历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。
在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。
ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。
// CommonJS模块let { stat, exists, readFile } = require(&#39;fs&#39;);// 等同于let _fs = require(&#39;fs&#39;);let stat = _fs.stat;let exists = _fs.exists;let readfile = _fs.</description>
    </item>
    
    <item>
      <title>node js </title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/nodejs/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/nodejs/</guid>
      <description>node js# Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时
 Linux 上安装 Node.js# 直接使用已编译好的包 Node 官网已经把 linux 下载版本更改为已编译好的版本了，我们可以直接下载解压后使用：  # wget https://nodejs.org/dist/v10.9.0/node-v10.9.0-linux-x64.tar.xz // 下载 # tar xf node-v10.9.0-linux-x64.tar.xz // 解压 # cd node-v10.9.0-linux-x64/ // 进入解压目录 # ./bin/node -v // 执行node命令 查看版本 v10.9.0  解压文件的 bin 目录底下包含了 node、npm 等命令，我们可以使用 ln 命令来设置软连接：  ln -s /usr/software/nodejs/bin/npm /usr/local/bin/ ln -s /usr/software/nodejs/bin/node /usr/local/bin/  Ubuntu 源码安装 Node.js   以下部分我们将介绍在 Ubuntu Linux 下使用源码安装 Node.</description>
    </item>
    
    <item>
      <title> Groovy 概述 </title>
      <link>https://huachengzhou.github.io/life/docs/javadir/groovy/groovy%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/groovy/groovy%E5%AD%A6%E4%B9%A0/</guid>
      <description>Groovy 概述# Groovy是一种基于Java平台的面向对象语言。 Groovy 1.0于2007年1月2日发布，其中Groovy 2.4是当前的主要版本。 Groovy通过Apache License v 2.0发布。  Groovy的特点# 同时支持静态和动态类型。 支持运算符重载。 本地语法列表和关联数组。 对正则表达式的本地支持。 各种标记语言，如XML和HTML原生支持。 Groovy对于Java开发人员来说很简单，因为Java和Groovy的语法非常相似。 您可以使用现有的Java库。 Groovy扩展了java.lang.Object。  groovy-脚本和类#  在groovy中定义类和java中是一样的。类的方法可以是static，也可以是非static的
  groovy中的方法可以是public, protected, private，同时也支持java中的修饰符，比如synchronized
  groovy自动导入的包有以下这些
   groovy.lang.* groovy.util.* java.lang.* java.util.* java.net.* java.io.* import java.math.BigInteger import java.math.BigDecimal    在groovy和java中不同的一点就是，groovy默认是public的
  每一个groovy类，在JVM层级，都是字节码形式的java code，所以在java代码中可以调用groovy中申明的方法，反之亦然
  你可以指定方法的参数和返回值，以便他们能够更好的和java代码相互调用。当然你也可以实现接口或者重载方法。但是需要你没有指定方法后者属性的类型的话，那么在JVM层级的字节码中，他们将会是 java.lang.Object 类型
  例如 Callee.</description>
    </item>
    
    <item>
      <title>groovy 基本概念 </title>
      <link>https://huachengzhou.github.io/life/docs/javadir/groovy/groovy%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/groovy/groovy%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid>
      <description>groovy 基本概念#1、基本概念# Groovy是一种面向对象的动态类型语言，跟Java一样运行在JVM上。
（注：给Java静态世界带来动态能力的语言）
   与Java不同的语言特性：
  a) 函数字面值
  b) 对集合的一等支持
  c) 对正则表达式的一等支持
  d) 对XML处理的一等支持
  （注：所谓“一等”指的是内置到语言的语法中，不需要调用类库。）
  2:Groovy能解决包括：#  快速Web开发
  原型设计
  脚本处理
  等问题，这些使用Java不是解决动态层问题的理想语言。
  例如:
System.out.println(&amp;quot;It&#39;s a Groovy baby, yeah!&amp;quot;);def writer = new StringWriter();def xml = new groovy.xml.MarkupBuilder(writer);xml.person(id:2){name &#39;kobicc&#39;age 1}println writer.</description>
    </item>
    
    <item>
      <title>java_监听事件原理 </title>
      <link>https://huachengzhou.github.io/life/docs/javadir/basedir/jsp_dir/java_%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6%E5%8E%9F%E7%90%86/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/basedir/jsp_dir/java_%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6%E5%8E%9F%E7%90%86/</guid>
      <description>接口回调法#模拟输出监听事件#第一步先定义事件接口#public interface PrintListener {public void print();}第二步自定义输出类#public class Out {PrintListener listener=null;public Out() {}public Out(PrintListener listener) {this.listener=listener;}public void printlen(String s) {System.out.println(s);if(listener!=null) {listener.print();}}}第三步实现监听事件接口#public class PrintListenerDemo implements PrintListener {@Overridepublic void print() {System.out.println(&amp;quot;监听到输出事件&amp;quot;);}}测试#public class Test {public static void main(String[] args) {//新建一个默认输出类Out b=new Out();b.</description>
    </item>
    
    <item>
      <title>Apache Commons 工具类介绍及简单使用</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/tooldoc/apache-common%E5%B7%A5%E5%85%B7%E5%8C%85/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/tooldoc/apache-common%E5%B7%A5%E5%85%B7%E5%8C%85/</guid>
      <description>Apache Commons 工具类介绍及简单使用#   组件 功能介绍     BeanUtils Commons-BeanUtils 提供对 Java 反射和自省API的包装, 提供了对于JavaBean进行各种操作，克隆对象,属性等等.   Betwixt XML与Java对象之间相互转换.   Codec 处理常用的编码方法的工具类包 例如DES、SHA1、MD5、Base64等.   Collections java集合框架操作.   Compress java提供文件打包 压缩类库.   Configuration Commons-Configuration 工具对各种各式的配置和参考文件提供读取帮助,java应用程序的配置管理类库.   DBCP 提供数据库连接池服务.   DbUtils DbUtils 是一个 JDBC helper 类库，完成数据库任务的简单的资源清除代码,提供对jdbc 的操作封装来简化数据查询和记录读取操作   Email java发送邮件 对javamail的封装.   FileUpload 提供文件上传功能.   HttpClient 提供HTTP客户端与服务器的各种通讯操作. 现在已改成HttpComponents   Lang Java基本对象方法的工具类包 如：StringUtils,ArrayUtils等等.</description>
    </item>
    
    <item>
      <title>apache FilenameUtils 文件名称操作</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/tooldoc/commons_io/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/tooldoc/commons_io/</guid>
      <description>org.apache.commons.io.FilenameUtils 文件名称操作#  FilenameUtils.getExtension(fileName) 获取文件后缀 //text
  FilenameUtils.getName(fileName) 获取文件完整名称 //c.text
  FilenameUtils.getBaseName(fileName) 获取文件名称 //c
  FilenameUtils.getFullPath(fileName) 获取文件的完整路径 //D:\data\
  String path = &amp;quot;D:\\data\\假设开发法土地模板.docx&amp;quot; ;String fullPath = FilenameUtils.getFullPath(path);System.out.println(&amp;quot;fullPath:&amp;quot;+fullPath);//D:\data\String name = FilenameUtils.getName(path);System.out.println(&amp;quot;name:&amp;quot;+name); //假设开发法土地模板.docxString prefix = FilenameUtils.getPrefix(path);System.out.println(&amp;quot;prefix:&amp;quot;+prefix); //D:\int prefixLength = FilenameUtils.getPrefixLength(path);System.out.println(&amp;quot;prefixLength:&amp;quot;+prefixLength); //3String path1 = FilenameUtils.getPath(path);System.out.println(&amp;quot;path:&amp;quot;+path1); //data\String baseName = FilenameUtils.getBaseName(path);System.out.println(&amp;quot;baseName:&amp;quot;+baseName); //假设开发法土地模板String extension = FilenameUtils.getExtension(path);System.</description>
    </item>
    
    <item>
      <title>dom4j</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/tooldoc/dom4j/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/tooldoc/dom4j/</guid>
      <description>dom4j# 选取节点
   nodename 选取当前节点的所有子节点
  / 从根节点选取
  // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置
  . 选取当前节点
  .. 选取当前节点的父节点
  @ 选取属性
   实例
   路径表达式 结果
  bookstore 选取 bookstore 元素的所有子节点
  /bookstore 选取根元素 bookstore
  bookstore/book 选取bookstore 下名字为 book的所有子元素。
  //book 选取所有 book 子元素，而不管它们在文档中的位置。
  bookstore//book 选取bookstore 下名字为 book的所有后代元素，而不管它们位于 bookstore 之下的什么位置。</description>
    </item>
    
    <item>
      <title>git学习</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/linux/git_introduction/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/linux/git_introduction/</guid>
      <description>git学习#git 区域概念# git分为工作区(我们自己的file)和版本库这其中版本库又包含暂存区(Stage)和分支区(master)    git add ********** 把文件添加到仓库
  git reset README.md 取消提交到暂存区域
  git commmit -m &amp;lsquo;xxxx&amp;rsquo; 提交到仓库
  git diff 查看提交到仓库文件之后文件又被修改的变化
  git status 查看状态
  git rm -f gitS.md 强制删除
  git log 显示从最近到最远的提交日志
  git log &amp;ndash;pretty=oneline 只显示版本号
  关于版本回退问题#  git reset &amp;ndash;hard HEAD^ 版本重置为上一个版本
  git 关于版本处理进行了设置</description>
    </item>
    
    <item>
      <title>git配置</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/linux/gitub_config/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/linux/gitub_config/</guid>
      <description>zhou@zhou-Lenovo-Z480:~$ git versiongit version 2.7.4zhou@zhou-Lenovo-Z480:~$ ssh -T git@github.comWarning: Permanently added the RSA host key for IP address &#39;192.30.255.112&#39; to the list of known hosts.Permission denied (publickey).zhou@zhou-Lenovo-Z480:~$ git config --global user.name &amp;quot;zhouchenhua&amp;quot;zhou@zhou-Lenovo-Z480:~$ git config --global user.email &amp;quot;noatnu@163.com&amp;quot;zhou@zhou-Lenovo-Z480:~$ git config --listuser.name=zhouchenhuauser.email=noatnu@163.comzhou@zhou-Lenovo-Z480:~$ ssh-keygen -C ‘noatnu@163.com’ -t rsaGenerating public/private rsa key pair.Enter file in which to save the key (/home/zhou/.ssh/id_rsa): america347191Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in america347191.</description>
    </item>
    
    <item>
      <title>Guava 基于java1.6的类库集合的扩展项目</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/tooldoc/guava-common/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/tooldoc/guava-common/</guid>
      <description>Guava 基于java1.6的类库集合的扩展项目# com.google.common.annotations：普通注解类型。 com.google.common.base：基本工具类库和接口。 com.google.common.cache：缓存工具包，非常简单易用且功能强大的JVM内缓存。 com.google.common.collect：带泛型的集合接口扩展和实现，以及工具类，这里你会发现很多好玩的集合。 com.google.common.eventbus：发布订阅风格的事件总线。 com.google.common.hash： 哈希工具包。 com.google.common.io：I/O工具包。 com.google.common.math：原始算术类型和超大数的运算工具包。 com.google.common.net：网络工具包。 com.google.common.primitives：八种原始类型和无符号类型的静态工具包。 com.google.common.reflect：反射工具包。 com.google.common.util.concurrent：多线程工具包。 常见Object方法   hashCode compare/compareTo 实现一个比较器[Comparator]，或者直接实现Comparable接口有时也伤不起
 public class ProjectInfo implements Serializable,Comparable&amp;lt;ProjectInfo&amp;gt; {private int id;private String name;public int getId() {return id;}public String getName() {return name;}public void setId(int id) {this.id = id;}public void setName(String name) {this.name = name;}@Overridepublic int compareTo(ProjectInfo o) {return ComparisonChain.</description>
    </item>
    
    <item>
      <title>host映射</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/linux/host%E6%98%A0%E5%B0%84/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/linux/host%E6%98%A0%E5%B0%84/</guid>
      <description>sudo vi hosts
127.0.0.1	localhost 127.0.1.1	zhou-Lenovo-Z480
The following lines are desirable for IPv6 capable hosts#::1 ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters
#pmcc dev 127.0.0.1 dev.pmcc.com</description>
    </item>
    
    <item>
      <title>jsoup学习文档</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/tooldoc/jsoup/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/tooldoc/jsoup/</guid>
      <description>jsoup学习文档#简介# Jsoup是用于解析HTML，就类似XML解析器用于解析XML。 Jsoup它解析HTML成为真实世界的HTML。 它与jquery选择器的语法非常相似，并且非常灵活容易使用以获得所需的结果
 +jsoup api 6个包提供用于开发jsoup应用程序的类和接口。
org.jsouporg.jsoup.examplesorg.jsoup.helperorg.jsoup.nodesorg.jsoup.parserorg.jsoup.safetyorg.jsoup.salect引入#//大多数情况使用jsouporg.jsoup.nodes.Document document = Jsoup.parse(html);Document doc = Jsoup.parse(new URL(&amp;quot;http://www.funi.com/&amp;quot;),7000);//少数情况使用httpUnitWebClient webClient = new WebClient() ;HtmlPage htmlPage = webClient.getPage(&amp;quot;http://www.89ip.cn/&amp;quot;);htmlPage.asXml()//html使用(maven)#&amp;lt;dependency&amp;gt;&amp;lt;!-- jsoup HTML parser library @ http://jsoup.org/ --&amp;gt;&amp;lt;groupId&amp;gt;org.jsoup&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;jsoup&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;1.10.2&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;!-- httpclient --&amp;gt;&amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;org.apache.httpcomponents&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;httpclient&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;4.5.6&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;net.</description>
    </item>
    
    <item>
      <title>Linux下设置和查看环境变量</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/linux/linux%E4%B8%8B%E8%AE%BE%E7%BD%AE%E5%92%8C%E6%9F%A5%E7%9C%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/linux/linux%E4%B8%8B%E8%AE%BE%E7%BD%AE%E5%92%8C%E6%9F%A5%E7%9C%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</guid>
      <description>Linux的变量种类 按变量的生存周期来划分，Linux变量可分为两类： 1 永久的：需要修改配置文件，变量永久生效。 2 临时的：使用export命令声明即可，变量在关闭shell时失效。
设置变量的三种方法 1 在/etc/profile文件中添加变量【对所有用户生效(永久的)】 用VI在文件/etc/profile文件中增加变量，该变量将会对Linux下所有用户有效，并且是“永久的”。 例如：编辑/etc/profile文件，添加CLASSPATH变量
vi /etc/profile#export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib
注：修改文件后要想马上生效还要运行# source /etc/profile不然只能在下次重进此用户时生效。
2 在用户目录下的.bash_profile文件中增加变量【对单一用户生效(永久的)】 用VI在用户目录下的.bash_profile文件中增加变量，改变量仅会对当前用户有效，并且是“永久的”。 例如：编辑guok用户目录(/home/guok)下的.bash_profile $ vi /home/guok/.bash.profile 添加如下内容： export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib 注：修改文件后要想马上生效还要运行$ source /home/guok/.bash_profile不然只能在下次重进此用户时生效。
3 直接运行export命令定义变量【只对当前shell(BASH)有效(临时的)】 在shell的命令行下直接使用[export 变量名=变量值] 定义变量，
该变量只在当前的shell(BASH)或其子shell(BASH)下是有效的，
shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的话还需要重新定义。
环境变量的查看 1 使用echo命令查看单个环境变量。例如： echo $PATH 2 使用env查看所有环境变量。例如： env 3 使用set查看所有本地定义的环境变量。
使用unset删除指定的环境变量 set可以设置某个环境变量的值。清除环境变量的值用unset命令。如果未指定值，则该变量值将被设为NULL。示例如下： $ export TEST=&amp;ldquo;Test&amp;hellip;&amp;rdquo; #增加一个环境变量TEST $ env|grep TEST #此命令有输入，证明环境变量TEST已经存在了 TEST=Test&amp;hellip; unset TEST #删除环境变量TEST $ env|grep TEST #此命令没有输出，证明环境变量TEST已经删除
常用的环境变量 PATH 决定了shell将到哪些目录中寻找命令或程序 HOME 当前用户主目录 HISTSIZE　历史记录数 LOGNAME 当前用户的登录名 HOSTNAME　指主机的名称 SHELL 当前用户Shell类型 LANGUGE 语言相关的环境变量，多语言可以修改此环境变量 MAIL　当前用户的邮件存放目录 PS1　基本提示符，对于root用户是#，对于普通用户是$</description>
    </item>
    
    <item>
      <title>linux命令</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/linux/linux%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/linux/linux%E5%91%BD%E4%BB%A4/</guid>
      <description>linux命令#文件管理#文件基本操作#  less命令 (Q退出less命令)([pagedown]： 向下翻动一页)([pageup]： 向上翻动一页) less ss.md
  cat命令 (cat -n ss.md &amp;gt; sdfsd.txt)把 ss.md 的文档内容加上行号后输入 sdfsd.txt 这个文档里, 这要注意假如sdfsd.txt先有文档会被清空,另外(cat ss.md)可以把消息打印到输出流中,cat 软盘功能暂时不予以考虑
  ls命令 (ls -a)显示所有文件及目录包括隐藏文件,相当于la命令,ll显示具体信息
  touch命令 主要用作创建文件如touch ss.md,(touch -m miss,touch -a miss)可以改变文件的读取时间,另外touch miss也可以改变文件的读取时间, 当且仅当miss不存在的时候会创建miss空文件
  mkdir命令 主要用作创建文件目录;(mkdir dd)创建一个dd目录,(mkdir -p dd/ffg)在当前目录下建立一个dd目录并且在dd下创建一个ffg目录,假如dd不存在会自动创建的
  mv命令 (mv missA miss.txt)把missA修改为miss.txt (mv sskg /home/zhou/fontconfig/dgsd/sdfg)把sskg移到sdfg目录 (mv ss.md ~)
  file命令 (file -c ss.</description>
    </item>
    
    <item>
      <title>nginx学习</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/linux/nginx/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/linux/nginx/</guid>
      <description>nginx学习#基础操作# start ./sbin/nginx stop ./sbin/nginx -s stop quite ./sbin/nginx -s quit   启动成功标志
 Welcome to nginx! 默认监听的端口是80 也就是说访问此端口就可以得到启动成功的标识符号
  简单的负载均衡配置    http 模块中配置  #配置开始 author zhouupstream myproject{server 127.0.0.1:8000 weight=3;server 127.0.0.1:8080 weight=10;server 127.0.0.1:8090;}#配置结束 author zhou location模块配置  proxy_pass http://myproject;注意:这的myproject要和上面的name一致测试结果 (这的测试用到了session的唯一性)
 http://localhost/nginx_test/ sessionId=8D9C4ACEE65EB24301B1C0D9E4CF3A6Ehttp://localhost:8080/nginx_test/ sessionId=8D9C4ACEE65EB24301B1C0D9E4CF3A6Ehttp://localhost:8090/nginx_test/ sessionId=7539B2C4AFD433ECEFAC8F2B2EBCC411 由于配置了权重 因此大部分是8080端口</description>
    </item>
    
    <item>
      <title>Notepad&#43;&#43; 学习与使用</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/linux/notepad&#43;&#43;%E5%AE%89%E8%A3%85/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/linux/notepad&#43;&#43;%E5%AE%89%E8%A3%85/</guid>
      <description>Notepad++是一套非常有特色的自由软件的纯文字编辑器(许可证:GPL)。有完整的中文化接口及支持多国语言编写的功能(UTF8 技术)。 它的功能比 Windows 中的 Notepad(记事本)强大，除了可以用来制作一般的纯文字说明文件，也十分适合当作编写电脑程序的编辑器。 Notepad++ 不仅有语法高亮度显示，也有语法折叠功能，并且支持宏以及扩充基本功能的外挂模组。但是可惜的是Notepad++只能在Windows平台下使用。 工作中必须使用Windows时，Notepad++是众多程序员最喜爱的文本编辑器，在Ubuntu下是否能够使用到相同的软件呢？Notepadqq就是这样一款与Notepad++非常接近的编辑器，拥有几乎相同的功能。 如果您是一个Notepad++粉丝，我们推荐您尝试下Notepadqq。
对于Ubuntu发行版本可以通过PPA安装，命令如下： sudo add-apt-repository ppa:notepadqq-team/notepadqq sudo apt-get update sudo apt-get install notepadqq 类似的，卸载命令如下：
sudo apt-get remove notepadqq sudo add-apt-repository &amp;ndash;remove ppa:notepadqq-team/notepadqq</description>
    </item>
    
    <item>
      <title>Redis 学习与使用</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/middleware/redis/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/middleware/redis/</guid>
      <description>一.Redis介绍#1.1引言# 1:由于用户量大，请求了随之增大，数据压力过大。 2:多台服务器之间数据不同步 3:多台服务器之间的锁已经不存在互斥性了
 #1.2 NOSQL# redis就是nosql
  非关系数据库 &amp;gt; not only sql
 1:key-value redis 2:文档型 solr,Mongodb,ElasticSearch 3:面向列 Hbase(一般大数据) 4:图形化 Neo4j
  1.3 redis介绍# Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 Redis是一款基于Key-Value的NOSQL，而且Redis是基于内存存储数据的,Redis还提供了多种持久化机制，Redis还提供了主从、哨兵以及集群的搭建方式，可以更方便的横向扩展以及垂直扩展
  操作都是原子的
 所有 Redis 的操作都是原子的，从而确保当两个客户同时访问 Redis 服务器时，得到的是更新后的值（最新值）。在需要高并发的场合可以考虑使用 Redis 的事务，处理一些需要锁的业务。
  二.Redis安装#三.Redis命令# keys * 获取所有的keyclear 清除屏幕quit ,exit 退出set name blake 设置值setex ip 5 192.</description>
    </item>
    
    <item>
      <title>spring工具类</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/tooldoc/spring%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/tooldoc/spring%E5%B7%A5%E5%85%B7/</guid>
      <description>spring工具类# Spring-core中提供了大量的工具类，常用的有StringUtils、ObjectUtils、NumberUtils、Base64Utils等，Spring工具类在spring-core.jar中的org.springframework.util包下。
  1:StringUtils  方法名	返回值类型	作用	备注isEmpty(Object str)	boolean	判断字符串是否为Null或者空字符串	null和&#39;&#39;都为truehasLength(CharSequence str)	boolean	判断字符串长度是否大于1	null和&#39;&#39;都为falsehasText(CharSequence str)	boolean	判断字符串中是否有字符	null和空字白符都为falsecontainsWhitespace(CharSequence str)	boolean	字符串中是否含有空白字符	trimWhitespace(CharSequence str)	String	去掉字符串中首尾的空白字符	trimAllWhitespace(String str)	String	去 掉字符串中所有的空白字符	trimLeadingWhitespace(String str)	String	去掉字符串左边的空白字符	trimTrailingWhitespace(String str)	String	去掉字符串右边边的空白字符	startsWithIgnoreCase(String str, String prefix)	String	判断字符串是否以xx开头，并且忽略大小写	getFilename(String path)	String	获取文件名	“mypath/myfile.txt” -&amp;gt; “myfile.txt”getFilenameExtension(String path)	String	获取文件扩展名	“mypath/myfile.txt” -&amp;gt; “txt”stripFilenameExtension(String path)	String	去掉文件扩展名	“mypath/myfile.</description>
    </item>
    
    <item>
      <title>spring常用的工具类</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/tooldoc/spring%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/tooldoc/spring%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/</guid>
      <description>spring常用的工具类#内置的resouce类型#UrlResourceClassPathResourceFileSystemResourceServletContextResourceInputStreamResourceByteArrayResourceEncodedResource 也就是Resource加上encoding, 可以认为是有编码的资源VfsResource(在jboss里经常用到, 相应还有 工具类 VfsUtils)org.springframework.util.xml.ResourceUtils 用于处理表达资源字符串前缀描述资源的工具. 如: &amp;amp;quot;classpath:&amp;amp;quot;. 有 getURL, getFile, isFileURL, isJarURL, extractJarFileURL 工具类#org.springframework.core.annotation.AnnotationUtils 处理注解org.springframework.core.io.support.PathMatchingResourcePatternResolver 用 于处理 ant 匹配风格(com/*.jsp, com/**/*.jsp),找出所有的资源, 结合上面的resource的概念一起使用,对于遍历文件很有用. 具体请详细查看javadocorg.springframework.core.io.support.PropertiesLoaderUtils 加载Properties资源工具类,和Resource结合org.springframework.core.BridgeMethodResolver 桥接方法分析器. 关于桥接方法请参考: http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.12.4.5org.springframework.core.GenericTypeResolver 范型分析器, 在用于对范型方法, 参数分析.org.springframework.core.NestedExceptionUtilsxml工具#org.springframework.util.xml.AbstractStaxContentHandlerorg.springframework.util.xml.AbstractStaxXMLReaderorg.springframework.util.xml.AbstractXMLReaderorg.springframework.util.xml.AbstractXMLStreamReaderorg.springframework.util.xml.DomUtilsorg.springframework.util.xml.SimpleNamespaceContextorg.springframework.util.xml.SimpleSaxErrorHandlerorg.springframework.util.xml.SimpleTransformErrorListenerorg.springframework.util.xml.StaxUtilsorg.springframework.util.xml.TransformerUtils其它工具集#org.springframework.util.xml.AntPathMatcherant风格的处理org.</description>
    </item>
    
    <item>
      <title>Ubuntu 16.04修改hosts</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/linux/ubuntu16.04%E4%BF%AE%E6%94%B9hosts/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/linux/ubuntu16.04%E4%BF%AE%E6%94%B9hosts/</guid>
      <description>IntelliJ IDE运行Tomcat报错解决办法的相关资料,出现“Unable to ping server at localhost:1099”错误解决方法，需要的朋友可以参考下
sudo gedit /etc/hosts</description>
    </item>
    
    <item>
      <title>ubuntu安装chmsee</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/linux/ubuntu%E5%AE%89%E8%A3%85chmsee/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/linux/ubuntu%E5%AE%89%E8%A3%85chmsee/</guid>
      <description>垃圾的ubuntu 14.04 又一次去掉一些特别好用的软件, 官方给的解释是怕破坏他们系统. 只想说一句 我去年买了个本.
14.04 之前的版本,如13.10, 12.04 继续能够使用 sudo apt-get install chmsee 来安装.
14.04 需要下载安装包来安装:
sudo apt-get install libc6 libchm1 libgcrypt11 libgdk-pixbuf2.0-0 libglib2.0-0 libgtk2.0-0 libpango1.0-0 libwebkitgtk-1.0-0 libxml2 安装依赖包
(64位) sudo dpkg -i chmsee_1.3.0-2ubuntu2_amd64.deb 安装软件包,下载地址: http://kr.archive.ubuntu.com/ubuntu/pool/universe/c/chmsee/chmsee_1.3.0-2ubuntu2_amd64.deb Ubuntu的官方软件库放心下载.
(32位) sudo dpkg -i chmsee_1.3.0-2ubuntu2_i386.deb 安装软件包,下载地址: http://kr.archive.ubuntu.com/ubuntu/pool/universe/c/chmsee/chmsee_1.3.0-2ubuntu2_i386.deb Ubuntu的官方软件库放心下载.</description>
    </item>
    
    <item>
      <title>Ubuntu清理系统垃圾</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/linux/ubuntu%E6%B8%85%E7%90%86%E7%B3%BB%E7%BB%9F%E5%9E%83%E5%9C%BE/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/linux/ubuntu%E6%B8%85%E7%90%86%E7%B3%BB%E7%BB%9F%E5%9E%83%E5%9C%BE/</guid>
      <description>1，非常有用的清理命令： sudo apt-get autoclean &amp;ndash;清理旧版本的软件缓存 www.2cto.com
sudo apt-get clean&amp;ndash;清理所有软件缓存
sudo apt-get autoremove&amp;ndash;删除系统不再使用的孤立软件
这三个命令主要清理升级缓存以及无用包的。
2，清理opera firefox的缓存文件： ls ~/.opera/cache4 ls ~/.mozilla/firefox/*.default/Cache
3，清理Linux下孤立的包： 图形界面下我们可以用：gtkorphan sudo apt-get install gtkorphan -y 终端命令下我们可以用：deborphan sudo apt-get install deborphan -y
4，卸载：tracker 这个东西一般我只要安装Ubuntu就会第一删掉tracker 他不仅会产生大量的cache文件而且还会影响开机速度。所以在新得利里面删掉就行。 www.2cto.com
5，删除多余的内核：一定不要删错哦，切记！！ 打开终端敲命令：dpkg &amp;ndash;get-selections|grep linux 有image的就是内核文件 删除老的内核文件： sudo apt-get remove 内核文件名（例如：linux-image-2.6.27-2-generic） 内核删除，释放空间了，应该能释放130－140M空间。
最后不要忘了看看当前内核：uname -a 附录： 包管理的临时文件目录: 包在 /var/cache/apt/archives 没有下载完的在 /var/cache/apt/archives/partial</description>
    </item>
    
    <item>
      <title>ubuntu软件卸载</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/linux/ubuntu%E8%BD%AF%E4%BB%B6%E5%8D%B8%E8%BD%BD/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/linux/ubuntu%E8%BD%AF%E4%BB%B6%E5%8D%B8%E8%BD%BD/</guid>
      <description>ubuntu软件卸载
安装Synaptic
sudo apt-get install synaptic</description>
    </item>
    
    <item>
      <title>常用 Console 调试命令</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/tooldoc/js_console%E7%94%A8%E6%B3%95/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/tooldoc/js_console%E7%94%A8%E6%B3%95/</guid>
      <description>Console 对象方法#  常用 Console 调试命令
  console.log(&#39;hello&#39;);console.info(&#39;信息&#39;);console.error(&#39;错误&#39;);console.warn(&#39;警告&#39;);assert()# ssert方法接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。  // 实例console.assert(true === false, &amp;quot;判断条件不成立&amp;quot;)// Assertion failed: 判断条件不成立clear()# 清除当前控制台的所有输出，将光标回置到第一行。  console.clear()count()# 用于计数，输出它被调用了多少次。  (function() {for (var i = 0; i &amp;lt; 5; i++) { console.count(&#39;count&#39;); }})()error()# 输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈。  console.error(&amp;quot;Error: %s (%i)&amp;quot;, &amp;quot;Server is not responding&amp;quot;,500)group()# 用于将显示的信息分组，可以把信息进行折叠和展开。  console.</description>
    </item>
    
    <item>
      <title>权限</title>
      <link>https://huachengzhou.github.io/life/docs/databases/postgresql/postgresql_create%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/postgresql/postgresql_create%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90/</guid>
      <description>权限# 系统权限 role和user都是用户,只不过role属性不能登录当然也可以指定 超级权限 不做权限检查(实际中是很危险的)
 Pg权限分为两部分，一部分是“系统权限”或者数据库用户的属性，可以授予role或user（两者区别在于login权限）；一部分为数据库对象上的操作权限。对超级用户不做权限检查，其它走acl。对于数据库对象，开始只有所有者和超级用户可以做任何操作，其它走acl。在pg里，对acl模型做了简化，组和角色都是role，用户和角色的区别是角色没有login权限。超级权限# 创建超级用户(create user alice with superuser password &amp;lsquo;123456&amp;rsquo;;)系统不会做权限操作校验,仅仅是不能够创建用户与删除用户  系统权限#  (create role blake password &amp;lsquo;123456&amp;rsquo;;)(create user bob password &amp;lsquo;123456&amp;rsquo;;)(create database testdb;)
  (grant all on database testdb to bob;grant all on database testdb to blake;)
  测试如下 用户bob可以登录而blake不能登录直接抛出了FATL:role blake is not &amp;lsquo;permitted to log in&amp;rsquo;
  ( drop database testdb;drop role blake;drop user bob;)</description>
    </item>
    
    <item>
      <title>操作系统的概念、功能</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/one_chapter/1_1_/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/one_chapter/1_1_/</guid>
      <description>一:大家熟悉的操作系统#二:知识总览# 1:操作系统的概念（定义）   操作系统（Operating System， OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调 度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本 的系统软件。
   直观的例子：打开 Windows 操作系统的“任务管理器”（快捷键：Ctrl+Alt+Del）
  ①操作系统是系统资源的管理者
  ②向上层提供方便易用的服务
  ③是最接近硬件的一层软件
  一台电脑的诞生~Step 1：厂家组装一台裸机Step 2：出售前安装操作系统Step 3：用户安装应用程序（eg：QQ）Step 4：使用 QQ 聊天 2:操作系统的功能和目标——作为系统资源的管理者   操作系统的功能和目标——向上层提供方便易用的服务  </description>
    </item>
    
    <item>
      <title>数据通信基础知识 </title>
      <link>https://huachengzhou.github.io/life/docs/computer_network/physical_layer/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/computer_network/physical_layer/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>典型的数据通信模型#数据通信相关术语# 通信的目的是传送消息(消息:语音、文字、图像、视频等)。
   信号:数据的电气/电磁的表现，是数据在传输过程中的存在形式。
  数字信号/离散信号:代表消息的参数的取值是离散的
   模拟信号/连续信号:代表消息的参数的取值是连续的   信源:产生和发送数据的源头。 信宿:接收数据的终点。 信道:信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。   信道  按传输信号分 模拟信道(传送模拟信号) 数字信道(传送数字信号) 按传输介质分 无线信道 有线信道    设计数据通信系统要考虑的三个问题#采用单工通信(只有一个方向)/半双工通信(回合制)/全双工通信(可以同时如擂台上拳击手打击) *#采用串行通信/并行通信#采用同步通信/异步通信#串行传输&amp;amp;并行传输#同步传输&amp;amp;异步传输#</description>
    </item>
    
    <item>
      <title>物理层基本概念 </title>
      <link>https://huachengzhou.github.io/life/docs/computer_network/physical_layer/%E7%89%A9%E7%90%86%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/computer_network/physical_layer/%E7%89%A9%E7%90%86%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid>
      <description>物理层接口特性# 物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。 物理层主要任务：确定与传输媒体接口有关的一些特性 ==&amp;gt; 定义标准
  1.机械特性 定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量、排列情况  2.电器特性 规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制。 某网络在物理层规定，信号的电平用+10V~+15V表示二进制0，用-10V~-15V表示二进制1，电线长度限于15m以内 3.功能特性 指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途。 描述一个物理层接口引脚处于高电平时的含义 4.过程特性 定义各条物理线路的工作规程和时序关系。  </description>
    </item>
    
    <item>
      <title>计算机概念 组成 功能 分类 * </title>
      <link>https://huachengzhou.github.io/life/docs/computer_network/network_architecture/1.1.1%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E5%BF%B5-%E7%BB%84%E6%88%90-%E5%8A%9F%E8%83%BD-%E5%88%86%E7%B1%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/computer_network/network_architecture/1.1.1%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E5%BF%B5-%E7%BB%84%E6%88%90-%E5%8A%9F%E8%83%BD-%E5%88%86%E7%B1%BB/</guid>
      <description>计算机网络#概念# 计算机网络是互连的、自治的计算机集合。  组成# 组成部分:硬件、软件、协议 1 工作方式:边缘部分、核心部分 2 功能组成:通信子网、资源子网  分类# 1 分布范围:广域网、城域网、局域网、个人区域网 2 使用者: 公用网、专用网 3 交换技术:电路交换、报文交换、分组交换 4 拓扑结构:总线型、星型、环型、网状型 5 传输技术:广播式、点对点  功能# 1:数据通信 2:资源共享 3:分布式处理、提高可靠性、负载均衡  </description>
    </item>
    
    <item>
      <title>进程的概念、组成、特征</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_1_1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_1_1/</guid>
      <description></description>
    </item>
    
    <item>
      <title>node js - npm </title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/npm%E6%A8%A1%E5%9D%97%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/npm%E6%A8%A1%E5%9D%97%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6%E7%AE%80%E4%BB%8B/</guid>
      <description>npm 是 Node 的模块管理器，功能极其强大。它是 Node 获得成功的重要原因之一
  假如是nodejs 高版本 那么不需要再安装npm了因为node js已经包含了npm  一、从 npm install 说起# npm install 命令用来安装模块到node_modules目录。  $ npm install &amp;lt;packageName&amp;gt;   安装之前，npm install会先检查，node_modules目录之中是否已经存在指定模块。如果存在，就不再重新安装了，即使远程仓库已经有了一个新版本，也是如此。
  如果你希望，一个模块不管是否安装过，npm 都要强制重新安装，可以使用-f 或 &amp;ndash;force 参数。
  $ npm install &amp;lt;packageName&amp;gt; --force 二、npm update# 如果想更新已安装模块，就要用到npm update命令。  $ npm update &amp;lt;packageName&amp;gt;  它会先到远程仓库查询最新版本，然后查询本地版本。如果本地版本不存在，或者远程版本较新，就会安装。  三、registry#  npm update命令怎么知道每个模块的最新版本呢？
  答案是 npm 模块仓库提供了一个查询服务，叫做 registry 。以 npmjs.</description>
    </item>
    
    <item>
      <title>DOS基本命令 </title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/windows/dos_basic/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/windows/dos_basic/</guid>
      <description>DOS基本命令# wing+r ==&amp;gt; cmd 进入dos控制台   打开屏幕键盘  C:\Users\noatn&amp;gt;osk; dos各种操作查看参数用法 command params ==? command /?  C:\Users\noatn&amp;gt;cd /?显示当前目录名或改变当前目录。CHDIR [/D] [drive:][path]CHDIR [..]CD [/D] [drive:][path]CD [..].. 指定要改成父目录。键入 CD drive: 显示指定驱动器中的当前目录。不带参数只键入 CD，则显示当前驱动器和目录。使用 /D 开关，除了改变驱动器的当前目录之外，还可改变当前驱动器。如果命令扩展被启用，CHDIR 会如下改变:当前的目录字符串会被转换成使用磁盘名上的大小写。所以，如果磁盘上的大小写如此，CD C:\TEMP 会将当前目录设为C:\Temp。CHDIR 命令不把空格当作分隔符，因此有可能将目录名改为一个带有空格但不带有引号的子目录名。例如:cd \winnt\profiles\username\programs\start menu与下列相同:cd &amp;quot;\winnt\profiles\username\programs\start menu&amp;quot;在扩展停用的情况下，你必须键入以上命令。  显示文件夹列表 dir
  改变目录 cd</description>
    </item>
    
    <item>
      <title>EL基础教程 </title>
      <link>https://huachengzhou.github.io/life/docs/javadir/basedir/jsp_dir/jsp_el%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/basedir/jsp_dir/jsp_el%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</guid>
      <description>EL基础教程#El标签语法# ${参数名}
 EL标签的功能#  可以访问JSP中不同的域的对象    可以访问JavaBean中的属性    可以访问集合元素    支持简单的运算操作   访问JSP中不同的域的对象#&amp;lt;%pageContext.setAttribute(&amp;quot;name1&amp;quot;, &amp;quot;zhangsan&amp;quot;);request.setAttribute(&amp;quot;name2&amp;quot;, &amp;quot;lisi&amp;quot;);session.setAttribute(&amp;quot;name3&amp;quot;, &amp;quot;wangwu&amp;quot;);application.setAttribute(&amp;quot;name4&amp;quot;, &amp;quot;liuliu&amp;quot;);%&amp;gt;&amp;lt;!--范围.参数名 --&amp;gt;${pageScope.name1 } ${requestScope.name2 } ${sessionScope.name3 }${applicationScope.name4 }&amp;lt;br&amp;gt;&amp;lt;!-- 直接写参数名称 --&amp;gt;${name1 } ${name2 } ${name3 } ${name4 } 访问JavaBean中的属性#&amp;lt;%User user=new User(&amp;quot;zhangsan&amp;quot;,20,&amp;quot;北京&amp;quot;);request.</description>
    </item>
    
    <item>
      <title>groovy 数据类型 </title>
      <link>https://huachengzhou.github.io/life/docs/javadir/groovy/groovy%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/groovy/groovy%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>Groovy 数据类型# 在任何编程语言中，需要使用各种变量来存储各种类型的信息。变量只是保留值的存储位置,这意味着，当你创建一个变量，你保留在内存中的一些空间来存储与变量相关的值。
  您可能喜欢存储各种数据类型的信息，如字符串，字符，宽字符，整数，浮点数，布尔值等。基于变量的数据类型，操作系统分配内存并决定什么可以存储在保留的存储器中。
 内置数据类型# byte -这是用来表示字节值。例如2。 short -这是用来表示一个短整型。例如10。 int -这是用来表示整数。例如1234。 long -这是用来表示一个长整型。例如10000090。 float -这是用来表示32位浮点数。例如12.34。 double -这是用来表示64位浮点数，这些数字是有时可能需要的更长的十进制数表示。例如12.3456565。 char -这定义了单个字符文字。例如“A”。 Boolean -这表示一个布尔值，可以是true或false。 String -这些是以字符串的形式表示的文本。例如，“Hello World”的  绑定值#   类型 值     byte -128到127   short -32,768到32,767   int 2,147,483,648 到,147,483,647   long -9,223,372,036,854,775,808到+9,223,372,036,854,775,807   float 1.40129846432481707e-45到3.40282346638528860e + 38   double 4.</description>
    </item>
    
    <item>
      <title>学习计划</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/2021-04%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</link>
      <pubDate>Sun, 17 Jan 2021 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/2021-04%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</guid>
      <description>  Java 消息中间件 RabbitMq 和 kafka (建议学习RabbitMq)
  web socket or spring socket
  springboot (spring cloud考虑)
  redis (深入使用)
  mysql 这次复习以往 突破 存储和锁 如行锁
  java 并发(深入)
  nio netty
  </description>
    </item>
    
    <item>
      <title>操作系统的特征</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/one_chapter/1_2_/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/one_chapter/1_2_/</guid>
      <description>一:知识总览#二:分类描述# 1:操作系统的特征——并发   2:操作系统的特征——共享   3:操作系统的特征——并发和共享的关系   4:操作系统的特征——虚拟   5:操作系统的特征——异步   总结  </description>
    </item>
    
    <item>
      <title>标准的分类</title>
      <link>https://huachengzhou.github.io/life/docs/computer_network/network_architecture/1.1.2%E6%A0%87%E5%87%86%E5%8C%96%E5%B7%A5%E4%BD%9C%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%BB%84%E7%BB%87/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/computer_network/network_architecture/1.1.2%E6%A0%87%E5%87%86%E5%8C%96%E5%B7%A5%E4%BD%9C%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%BB%84%E7%BB%87/</guid>
      <description>标准的分类#法定标准# 由权威机构制定的正式的、合法的标准 OSI  事实标准# 某些公司的产品在竞争中占据了主流 ， TCP/IP 时间长了，这些产品中的协议和技术就成了标准  RFC#  因特网标准的形式 (4个阶段)
  1:因特网草案
  2:建议标准
  3:草案标准
  4:因特网标准
  国际标准化组织 ISO (最重要)#国际电信联盟 ITU#国际电气电子工程协会 IEEE#</description>
    </item>
    
    <item>
      <title>进程的状态与转换</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_1_2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_1_2/</guid>
      <description></description>
    </item>
    
    <item>
      <title>DOS基本文件操作命令 </title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/windows/dos_file/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/windows/dos_file/</guid>
      <description>DOS基本文件操作命令#  wing+r ==&amp;gt; cmd 进入dos控制台
  D:
  进入D盘 cd命令  CD命令是更改目录命令 如果要进入D盘不用这个命令直接输入 D: 回车 即可例如:C:\Users\HP&amp;gt;D:D:\&amp;gt;D:\&amp;gt;dir驱动器 D 中的卷是 新加卷卷的序列号是 DAB4-11FED:\ 的目录2019-10-10 14:15 &amp;lt;DIR&amp;gt; 360极速浏览器下载2020-01-13 13:47 &amp;lt;DIR&amp;gt; BaiduNetdiskDownload2020-01-20 13:59 &amp;lt;DIR&amp;gt; CS2019-12-13 16:53 &amp;lt;DIR&amp;gt; data2020-02-10 15:55 &amp;lt;DIR&amp;gt; IdeaProjects2019-12-06 15:01 &amp;lt;DIR&amp;gt; log2019-10-23 10:40 &amp;lt;DIR&amp;gt; MailMasterData2019-09-29 10:43 &amp;lt;DIR&amp;gt; output2020-01-13 13:40 &amp;lt;DIR&amp;gt; soft2020-02-04 17:43 &amp;lt;DIR&amp;gt; temp2020-01-15 18:05 &amp;lt;DIR&amp;gt; ultraeditWork2019-12-10 09:47 &amp;lt;DIR&amp;gt; workspace0 个文件 0 字节12 个目录 463,738,040,320 可用字节D:\&amp;gt;cd CSD:\CS&amp;gt; /*进入了CS目录**/ cd .</description>
    </item>
    
    <item>
      <title>jsp jstl core 标签库 </title>
      <link>https://huachengzhou.github.io/life/docs/javadir/basedir/jsp_dir/jsp_jstl_core%E6%A0%87%E7%AD%BE%E5%BA%93/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/basedir/jsp_dir/jsp_jstl_core%E6%A0%87%E7%AD%BE%E5%BA%93/</guid>
      <description>JSTL标签库#JSTL主要有五大类标签库
 core标签库(核心标签库),包括通用标签(输出标签),流程控制和循环控制标签 fmt标签库,包括格式化,国际格式化标签等 fn标签库,函数标签库 XML标签库,关于XML操作的标签库 SQL标签库,操作数据库标签  core标签库用法#使用core标签前必须添加taglie指令
 %@ taglib prefix=&amp;ldquo;c&amp;rdquo; uri=&amp;ldquo;http://java.sun.com/jsp/jstl/core&amp;quot; %&amp;gt;
  &amp;lt;c:set&amp;gt;在某个范围设定某个值   &amp;lt;c:set value=&amp;ldquo;表达式&amp;rdquo; var=&amp;ldquo;varname&amp;rdquo; [scope=&amp;ldquo;request|page|session|application&amp;rdquo;]&amp;gt;&amp;lt;/c:set&amp;gt;
 &amp;lt;c:set value=&amp;quot;${1+2 }&amp;quot; var=&amp;quot;variable&amp;quot;&amp;gt;&amp;lt;/c:set&amp;gt;${variable } &amp;lt;c:out&amp;gt;把表达式的结构输出到页面中   &amp;lt;c:out value=&amp;ldquo;表达式&amp;rdquo; [escapeXml=&amp;ldquo;true|false&amp;rdquo;]&amp;gt;&amp;lt;/c:out&amp;gt;
 &amp;lt;c:set value=&amp;quot;${1+2 }&amp;quot; var=&amp;quot;variable&amp;quot;&amp;gt;&amp;lt;/c:set&amp;gt;&amp;lt;c:out value=&amp;quot;${variable }&amp;quot;&amp;gt;&amp;lt;/c:out&amp;gt; &amp;lt;c:if&amp;gt;条件判断   &amp;lt;c:if test=&amp;ldquo;判断条件&amp;rdquo; [var=&amp;ldquo;varname&amp;rdquo;] [scope=&amp;ldquo;request|page|session|application&amp;rdquo;]&amp;gt; 条件为真执行的语句 &amp;lt;/c:if&amp;gt;
 &amp;lt;c:if test=&amp;quot;${1&amp;lt;2 }&amp;quot; var=&amp;quot;result&amp;quot;&amp;gt;&amp;lt;c:out value=&amp;quot;${result }&amp;quot;&amp;gt;&amp;lt;/c:out&amp;gt;&amp;lt;/c:if&amp;gt; &amp;lt;c:choose&amp;gt;,&amp;lt;c:when&amp;gt;,&amp;lt;c:otherwise&amp;gt;流程控制标签   &amp;lt;c:choose&amp;gt; &amp;lt;c:when test=&amp;ldquo;表达式&amp;rdquo;&amp;gt; 表达式为真执行的语句 &amp;lt;/c:when&amp;gt; [&amp;lt;c:otherwise&amp;gt; 表达式为假执行的语句 &amp;lt;/c:otherwise&amp;gt;] &amp;lt;/c:choose&amp;gt;</description>
    </item>
    
    <item>
      <title>基本命令</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_basis/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_basis/</guid>
      <description>停止命令：net stop mysql
  启动命令：net start mysql
  登陆 mysql -u 用户名 -p
  查看数据库版本: mysql &amp;ndash;version：用于在未登录情况下，查看本机mysql版本,select version();：登录情况下，查看链接的库版本
  显示所有数据库：show databases;
  进入指定的库：use 库名;
  显示当前库中所有的表：show tables;
  查看其他库中所有的表：show tables from 库名;
  查看表的创建语句：show create table 表名;
  查看表结构：desc 表名;
  SQL的语言分类#DQL（Data Query Language）：数据查询语言select 相关语句DML（Data Manipulate Language）：数据操作语言insert 、update、delete 语句DDL（Data Define Languge）：数据定义语言create、drop、alter 语句TCL（Transaction Control Language）：事务控制语言set autocommit=0、start transaction、savepoint、commit、rollbackmysql语法规范#不区分大小写，但建议关键字大写，表名、列名小写每条命令最好用英文分号结尾每条命令根据需要，可以进行缩进或换行注释单行注释：#注释文字单行注释：-- 注释文字 ，注意， 这里需要加空格多行注释：/* 注释文字 */MySQL删除数据库中的所有表#SELECT CONCAT(&#39;drop table &#39;,table_name,&#39;;&#39;) FROM information_schema.</description>
    </item>
    
    <item>
      <title> 操作系统的发展与分类 </title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/one_chapter/1_3_/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/one_chapter/1_3_/</guid>
      <description>一:知识总览#二:分类描述# 1:手工操作阶段   2:批处理阶段——单道批处理系统   引入脱机输入/输出技术（用外围机+磁带完成），并由监督程序负责控制作业的输入、输出
  和上面不同的是不必等结果输出在执行而是计算机执行完毕马上将结果输入磁带中并在同事已经开始执行其它数据程序
  3:批处理阶段——多道批处理系统   4:分时操作系统   5:实时操作系统   主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性  三:其他几种操作系统# 网络操作系统：是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信。（如：Windows NT 就是一种典型的网络操作系统，网站服务器就可以使用） 分布式操作系统：主要特点是分布性和并行性。系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务。 个人计算机操作系统：如 Windows XP、MacOS，方便个人使用。  四:知识回顾与重要考点#</description>
    </item>
    
    <item>
      <title>进程控制</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_1_3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_1_3/</guid>
      <description></description>
    </item>
    
    <item>
      <title>速率</title>
      <link>https://huachengzhou.github.io/life/docs/computer_network/network_architecture/1.1.3%E9%80%9F%E7%8E%87%E7%9B%B8%E5%85%B3%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/computer_network/network_architecture/1.1.3%E9%80%9F%E7%8E%87%E7%9B%B8%E5%85%B3%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</guid>
      <description>速率# 速率即数据率或称数据传输率或比特率
  速率即数据率或称数据传输率或比特率 比特 1/0 位 连接在计算机网络上的主机在数字信道上传输数据位数的速率 单位是b/s , kb/s,Gb/s,Gb/s ,Tb/s 发送端 ==&amp;gt; 接收端 速率是10b/s 0101010101  宽带# &amp;ldquo;带宽&amp;quot;原本指某个信号具有的频道宽度，即最高频率与最低频率之差，单位是赫兹(Hz) 计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一点到另一点所能通过的&amp;quot;最高数据率&amp;rdquo;。单位是&amp;quot;比特/秒&amp;quot;  吞吐量# 表示在单位时间内通过某个网络(或信道、接口)的数据量。单位b/s,kb/s,Mb/s 吞吐量受网络的带宽或网络的额定速率的限制   时延#  时延 = 发送时延 + 传播时延 + 排队时延 + 处理时延
  发送时延 : 从发送分组的第一个比特算起，到分组的最后一个比特发送完毕所需的时间(分组交换/路由器将数据推到信道上的时间)
  传播时延 : 这里看什么介质来传播数据 计算机网络中是 数字信号 -&amp;gt; 模拟信号 因此假如是光纤那么传播速度非常快2x⑩9 当然也有用无线电波我个人不知道无限电波是怎样模拟的无法知道速度究竟怎样,公示 传播时间 = 数据长度 / 传播速率(发送速率,带宽)</description>
    </item>
    
    <item>
      <title> DOS网络操作命令 </title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/windows/dos_network/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/windows/dos_network/</guid>
      <description>DOS网络操作命令# netstat -ano (列出所有端口的情况)  PS C:\Users\noatn&amp;gt; netstat -ano活动连接协议 本地地址 外部地址 状态 PIDTCP 0.0.0.0:135 0.0.0.0:0 LISTENING 1028TCP 0.0.0.0:445 0.0.0.0:0 LISTENING 4TCP 0.0.0.0:1024 0.0.0.0:0 LISTENING 852TCP 0.0.0.0:1025 0.0.0.0:0 LISTENING 2232TCP 0.0.0.0:3306 0.0.0.0:0 LISTENING 3672TCP 0.0.0.0:5040 0.0.0.0:0 LISTENING 5660TCP 0.0.0.0:7680 0.0.0.0:0 LISTENING 6628TCP 0.0.0.0:49664 0.0.0.0:0 LISTENING 868TCP 0.0.0.0:49665 0.0.0.0:0 LISTENING 784TCP 0.0.0.0:49666 0.0.0.0:0 LISTENING 1580TCP 0.0.0.0:49667 0.</description>
    </item>
    
    <item>
      <title> groovy变量和数据类型 </title>
      <link>https://huachengzhou.github.io/life/docs/javadir/groovy/groovy%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8A%A0%E5%BC%BA/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/groovy/groovy%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8A%A0%E5%BC%BA/</guid>
      <description>groovy 变量和数据类型#groovy类型自动推断# 先看有一段代码  def a = 12;def int a1 = 12;def a_type = a instanceof Integer ;def a1_type = a1 instanceof Integer ;println(a_type) ;println(a1_type) ;//打印结果如下truetrue 从上面我们可以看出a和a1实际推导出的类型是一样的,但是有哪些不同呢 接着我把上面的例子改了  def a = 12;def int a1 = 12;def a_type = a instanceof Integer ;def a1_type = a1 instanceof Integer ;println(a_type) ;println(a1_type) ;a = 52253.</description>
    </item>
    
    <item>
      <title> 操作系统的运行机制与体系结构 </title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/one_chapter/1_4_/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/one_chapter/1_4_/</guid>
      <description>运行机制#一: 知识总览#二: 预备知识：程序是如何运行的？#三:内核程序 v.s. 应用程序#四:特权指令 v.s. 非特权指令#五:内核态 v.s. 用户态#六:内核态、用户态 的切换#知识回顾与重要考点#体系结构#两种指令、两种处理器状态、两种程序#操作系统的内核# Yo~生活经验：我们安装完 Windows 操作系统后，会发现操作系统提供了多种多样的功能，比如“记事本”、 “任务管理器”。然而，这些功能并不是必不可少的。即使没有“任务管理器”，我们仍然可以使用计算机。
  内核是计算机上配置的底层软件，是操作系统最基本、最核心的部分。实现操作系统内核功能的那些程序就是内核程序。   计算机系统的层次结构  知识回顾与重要考点#</description>
    </item>
    
    <item>
      <title>jsp jstl session </title>
      <link>https://huachengzhou.github.io/life/docs/javadir/basedir/jsp_dir/jsp_jstl_session/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/basedir/jsp_dir/jsp_jstl_session/</guid>
      <description>Session# HTTP是无状态协议，这意味着每次客户端检索网页时，都要单独打开一个服务器连接，因此服务器不会记录下先前客户端请求的任何信息#  会话,当用户打开一个浏览器连接到web应用或者打开某个页面,直到关闭浏览器这个过程叫做会话#  Session是保存在服务器上的数据结构，用于跟踪用户的状态。此数据可以保存在群集、数据库、文件中# Session常用方法#  public boolean isNew()
返回是否为一个新的客户端，或者客户端是否拒绝加入session     public Enumeration getAttributeNames()
返回session对象中所有的对象名称     public int getMaxInactiveInterval()
返回最大时间间隔，以秒为单位，servlet 容器将会在这段时间内保持会话打开     public long getCreationTime()
返回session对象被创建的时间， 以毫秒为单位，从1970年1月1号凌晨开始算起     public long getLastAccessedTime()
返回客户端最后访问的时间，以毫秒为单位，从1970年1月1号凌晨开始算起     public Object getAttribute(String name)
返回session对象中与指定名称绑定的对象，如果不存在则返回null     public Object getAttribute(String name)</description>
    </item>
    
    <item>
      <title>数据准备</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_data/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_data/</guid>
      <description>数据准备  数据准备
drop datbase ch10;create database ch10;use ch10;CREATE TABLE fruits(f_id char(10) NOT NULL,s_id INT NOT NULL,f_name char(255) NOT NULL,f_price decimal(8,2) NOT NULL,PRIMARY KEY(f_id) );INSERT INTO fruits (f_id, s_id, f_name, f_price)VALUES(&#39;a1&#39;, 101,&#39;apple&#39;,5.2),(&#39;b1&#39;,101,&#39;blackberry&#39;, 10.2),(&#39;bs1&#39;,102,&#39;orange&#39;, 11.2),(&#39;bs2&#39;,105,&#39;melon&#39;,8.2),(&#39;t1&#39;,102,&#39;banana&#39;, 10.3),(&#39;t2&#39;,102,&#39;grape&#39;, 5.3),(&#39;o2&#39;,103,&#39;coconut&#39;, 9.2),(&#39;c0&#39;,101,&#39;cherry&#39;, 3.2),(&#39;a2&#39;,103, &#39;apricot&#39;,2.2),(&#39;l2&#39;,104,&#39;lemon&#39;, 6.4),(&#39;b2&#39;,104,&#39;berry&#39;, 7.6),(&#39;m1&#39;,106,&#39;mango&#39;, 15.6),(&#39;m2&#39;,105,&#39;xbabay&#39;, 2.6),(&#39;t4&#39;,107,&#39;xbababa&#39;, 3.6),(&#39;m3&#39;,105,&#39;xxtt&#39;, 11.</description>
    </item>
    
    <item>
      <title>分层结构</title>
      <link>https://huachengzhou.github.io/life/docs/computer_network/network_architecture/%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/computer_network/network_architecture/%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84/</guid>
      <description>为什么要分层，分层要做什么# （1）发起通信的计算机必须将数据通信的通路进行激活。 （2）要告诉网络如何识别目的主机。 （3）发起通信的计算机要查明目的主机是否开机，并且与网络连接正常。 （4）发起通信的计算机要弄清楚，对方计算机中文件管理程序是否已经做好准备工作。 （5）确保差错和意外可以解决。  正式认识分层结构# 使用 协议 ，服务， 接口 来完成分层
 总结# 网络体系结构是从功能上描述计算机网络结构 计算机网络体系结构简称网络体系结构是分层结构 每层遵循某个/多个网络协议以完成本层功能 计算机网络体系结构是计算机网络的各层及其协议的集合 上层要求服务 下层提供服务 实际是上层制定接口标准，下层实现接口标准  </description>
    </item>
    
    <item>
      <title>进程通信</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_1_4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_1_4/</guid>
      <description></description>
    </item>
    
    <item>
      <title>uniapp基础知识 </title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/uniapp%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/uniapp%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>uni-app的基本使用#课程介绍：
基础部分：
 环境搭建 页面外观配置 数据绑定 uni-app的生命周期 组件的使用 uni-app中样式学习 在uni-app中使用字体图标和开启scss 条件注释跨端兼容 uni中的事件 导航跳转 组件创建和通讯，及组件的生命周期 uni-app中使用uni-ui库  项目：黑马商城项目
uni-app介绍 官方网页#uni-app view uni-app view#uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台。
即使不跨端，uni-app同时也是更好的小程序开发框架。
具有vue和微信小程序的开发经验，可快速上手uni-app
为什么要去学习uni-app？
相对开发者来说，减少了学习成本，因为只学会uni-app之后，即可开发出iOS、Android、H5、以及各种小程序的应用，不需要再去学习开发其他应用的框架，相对公司而言，也大大减少了开发成本。
环境搭建#安装编辑器HbuilderX 下载地址
HBuilderX是通用的前端开发工具，但为uni-app做了特别强化。
下载App开发版，可开箱即用
安装微信开发者工具 下载地址
利用HbuilderX初始化项目#  点击HbuilderX菜单栏文件&amp;gt;项目&amp;gt;新建
  选择uni-app,填写项目名称，项目创建的目录
  运行项目#在菜单栏中点击运行，运行到浏览器，选择浏览器即可运行
在微信开发者工具里运行：进入hello-uniapp项目，点击工具栏的运行 -&amp;gt; 运行到小程序模拟器 -&amp;gt; 微信开发者工具，即可在微信开发者工具里面体验uni-app
在微信开发者工具里运行：进入hello-uniapp项目，点击工具栏的运行 -&amp;gt; 运行到手机或模拟器 -&amp;gt; 选择调式的手机</description>
    </item>
    
    <item>
      <title> FTP </title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/windows/ftp/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/windows/ftp/</guid>
      <description>本地设置FTP服务器#步骤1：在计算机上打开“控制面板”，然后单击“程序和功能”。#步骤2：在“程序和功能”窗口中，单击“控制面板”窗口左侧的“打开或关闭Windows功能”。#第3步：现在等待一段时间并向下滚动以找出“Internet信息服务”。 只需展开它，打开“FTP服务器”，“Web管理工具”和“万维网服务”下的所有内容，与下面的屏幕截图相同。 完成所有服务后，单击“确定”#第4步：应用更改需要一些时间，完成后，单击“立即重新启动”以重新启动计算机并应用所做的更改#步骤5：重新启动计算机后，再次打开“控制面板”，然后单击“管理工具”将其打开#步骤7：在IIS管理器窗口的左侧，展开窗口左侧的计算机名称，除非您找到“站点”。 只需右键单击“站点”，然后单击“添加FTP站点&amp;hellip;”#第8步：这里给FTP站点命名。 我将&amp;rsquo;sampleftp&amp;rsquo;赋予FTP站点名称。 现在单击“&amp;hellip;”按钮以找到要通过FTP服务器访问的文件夹或驱动程序。 我为本教程选择了“C：FTP_Path”。 完成所有操作后，单击“下一步”#步骤9：在下一个窗口中，单击与“IP Address：”对应的下拉菜单，然后在本地网络上选择计算机的IP地址。# 将端口号保留为“21”，默认情况下是这样。  步骤10：选择“No SSL”并启用“自动启动FTP站点”，然后单击“下一步”。# *由于这是一个教程，我不允许使用SSL。 但是，如果您想通过FTP服务器访问敏感数据，我建议您使用SSL  步骤11：现在选择“基本”的身份验证方法，并向“所有用户”提供“授权”。 用户必须输入您的Windows用户名和密码才能使用此身份验证方法访问FTP服务器上的文件# 现在，根据您要如何设置FTP服务器，将权限设置为“读取”和“写入”或仅设置为“读取”。 之后，单击“完成”以完成站点设置并在Windows计算机上启动FTP服务器  配置防火墙# 您的FTP服务器已准备就绪并且正在运行 但是，您需要配置Windows防火墙以允许与您的计算机进行FTP通信的事务处理。  步骤12：打开“控制面板”并在Windows 10上单击“Windows Defender Firewall”或在Windows 7上单击“Windows防火墙”#步骤13：单击窗口左侧的“允许通过Windows Defender防火墙的应用程序或功能”#步骤14：在新窗口中，单击“更改设置”并标记“FTP服务器”的“公共”和“私人”对应的复选框，然后单击“确定”。#  现在，您可以使用适当的应用程序轻松地从本地网络中的任何其他计算机或移动设备访问FTP服务器，或者只需从浏览器访问即可。</description>
    </item>
    
    <item>
      <title> groovy变量值获取 </title>
      <link>https://huachengzhou.github.io/life/docs/javadir/groovy/%E5%A6%82%E4%BD%95%E5%9C%A8groovy%E4%B8%AD%E8%8E%B7%E5%8F%96%E4%BB%A5%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E7%9A%84%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/groovy/%E5%A6%82%E4%BD%95%E5%9C%A8groovy%E4%B8%AD%E8%8E%B7%E5%8F%96%E4%BB%A5%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E7%9A%84%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC/</guid>
      <description>groovy变量值获取#`
https://www.codenong.com/34288451/
`
回到上一级#</description>
    </item>
    
    <item>
      <title> 中断和异常 </title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/one_chapter/1_5_/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/one_chapter/1_5_/</guid>
      <description>一:知识总览#中断的作用# “中断”会使CPU由用户态变为内核态，使操作系统重新夺回对CPU的控制权
   CPU 上会运行两种程序，一种是操作系统内核程序，一种是应用程序
  在合适的情况下，操作系统内核会把CPU的使用权主动让给应用程序(进程管理相关内容)
  如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序
    内核态à用户态：执行一条特权指令——修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权
  用户态à内核态：由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权
  中断的类型#中断机制的基本原理#二:知识回顾与重要考点#</description>
    </item>
    
    <item>
      <title>字符串el表达式 </title>
      <link>https://huachengzhou.github.io/life/docs/javadir/basedir/jsp_dir/jsp_%E5%AD%97%E7%AC%A6%E4%B8%B2el%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/basedir/jsp_dir/jsp_%E5%AD%97%E7%AC%A6%E4%B8%B2el%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>字符串el表达式#fn:contains 判断字符串是否包含另外一个字符串 &amp;lt;c:if test=&amp;quot;${fn:contains(name, searchString)}&amp;quot;&amp;gt;fn:containsIgnoreCase 判断字符串是否包含另外一个字符串(大小写无关) &amp;lt;c:if test=&amp;quot;${fn:containsIgnoreCase(name, searchString)}&amp;quot;&amp;gt;fn:endsWith 判断字符串是否以另外字符串结束 &amp;lt;c:if test=&amp;quot;${fn:endsWith(filename, &amp;quot;.txt&amp;quot;)}&amp;quot;&amp;gt;fn:escapeXml 把一些字符转成XML表示，例如 &amp;lt;字符应该转为&amp;lt; ${fn:escapeXml(param:info)}fn:indexOf 子字符串在母字符串中出现的位置 ${fn:indexOf(name, &amp;quot;-&amp;quot;)}fn:join 将数组中的数据联合成一个新字符串，并使用指定字符格开 ${fn:join(array, &amp;quot;;&amp;quot;)}fn:length 获取字符串的长度，或者数组的大小 ${fn:length(shoppingCart.products)}fn:replace 替换字符串中指定的字符 ${fn:replace(text, &amp;quot;-&amp;quot;, &amp;quot;?&amp;quot;)}fn:split 把字符串按照指定字符切分 ${fn:split(customerNames, &amp;quot;;&amp;quot;)}fn:startsWith 判断字符串是否以某个子串开始 &amp;lt;c:if test=&amp;quot;${fn:startsWith(product.id, &amp;quot;100-&amp;quot;)}&amp;quot;&amp;gt;fn:substring 获取子串 ${fn:substring(zip, 6, -1)}fn:substringAfter 获取从某个字符所在位置开始的子串 ${fn:substringAfter(zip, &amp;quot;-&amp;quot;)}fn:substringBefore 获取从开始到某个字符所在位置的子串 ${fn:substringBefore(zip, &amp;quot;-&amp;quot;)}fn:toLowerCase 转为小写 ${fn.toLowerCase(product.name)}fn:toUpperCase 转为大写字符 ${fn.UpperCase(product.name)}fn:trim 去除字符串前后的空格 ${fn.trim(name)}函数 描述fn:contains(string, substring)如果参数string中包含参数substring，返回truefn:containsIgnoreCase(string, substring)如果参数string中包含参数substring（忽略大小写），返回truefn:endsWith(string, suffix)如果参数 string 以参数suffix结尾，返回truefn:escapeXml(string)将有特殊意义的XML (和HTML)转换为对应的XML character entity code，并返回fn:indexOf(string, substring)返回参数substring在参数string中第一次出现的位置fn:join(array, separator)将一个给定的数组array用给定的间隔符separator串在一起，组成一个新的字符串并返回。fn:length(item)返回参数item中包含元素的数量。参数Item类型是数组、collection或者String。如果是String类型,返回值是String中的字符数。fn:replace(string, before, after)返回一个String对象。用参数after字符串替换参数string中所有出现参数before字符串的地方，并返回替换后的结果 fn:split(string, separator)返回一个数组，以参数separator 为分割符分割参数string，分割后的每一部分就是数组的一个元素fn:startsWith(string, prefix)如果参数string以参数prefix开头，返回truefn:substring(string, begin, end)返回参数string部分字符串, 从参数begin开始到参数end位置，包括end位置的字符fn:substringAfter(string, substring)返回参数substring在参数string中后面的那一部分字符串?</description>
    </item>
    
    <item>
      <title>MySQL分库分表原理</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_distinguish/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_distinguish/</guid>
      <description>前言#在互联网还未崛起的时代,我们的传统应用都有这样一个特点：访问量、数据量都比较小，单库单表都完全可以支撑整个业务。随着互联网的发展和用户规模的迅速扩大,对系统的要求也越来越高。因此传统的MySQL单库单表架构的性能问题就暴露出来了。而有下面几个因素会影响数据库性能: 数据量  MySQL单库数据量在5000万以内性能比较好,超过阈值后性能会随着数据量的增大而变弱。MySQL单表的数据量是500w-1000w之间性能比较好,超过1000w性能也会下降。 磁盘  因为单个服务的磁盘空间是有限制的,如果并发压力下,所有的请求都访问同一个节点,肯定会对磁盘IO造成非常大的影响。 数据库连接  数据库连接是非常稀少的资源,如果一个库里既有用户、商品、订单相关的数据,当海量用户同时操作时,数据库连接就很可能成为瓶颈。为了提升性能,所以我们必须要解决上述几个问题,那就有必要引进分库分表。垂直拆分 or 水平拆分？#当我们单个库太大时,我们先要看一下是因为表太多还是数据量太大，如果是表太多,则应该将部分表进行迁移(可以按业务区分),这就是所谓的垂直切分。如果是数据量太大,则需要将表拆成更多的小表,来减少单表的数据量,这就是所谓的水平拆分。垂直拆分# 垂直分库  垂直分库针对的是一个系统中的不同业务进行拆分,比如用户一个库,商品一个库,订单一个库。 一个购物网站对外提供服务时,会同时对用户、商品、订单表进行操作。没拆分之前, 全部都是落到单一的库上的,这会让数据库的单库处理能力成为瓶颈。如果垂直分库后还是将用户、商品、订单放到同一个服务器上,只是分到了不同的库,这样虽然会减少单库的压力,但是随着用户量增大,这会让整个数据库的处理能力成为瓶颈,还有单个服务器的磁盘空间、内存也会受非常大的影响。 所以我们要将其拆分到多个服务器上，这样上面的问题都解决了，以后也不会面对单机资源问题。 垂直分表  也就是“大表拆小表”，基于列字段进行的。一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的拆分到“扩展表“。一般是针对那种几百列的大表，也避免查询时，数据量太大造成的“跨页”问题。水平拆分# 水平分表  和垂直分表有一点类似,不过垂直分表是基于列的,而水平分表是基于全表的。水平拆分可以大大减少单表数据量,提升查询效率。 水平分库分表  将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。几种常用的分库分表的策略# HASH取模  假设有用户表user,将其分成3个表user0,user1,user2.路由规则是对3取模,当uid=1时,对应到的是user1,uid=2时,对应的是user2。 范围分片  从1-10000一个表,10001-20000一个表。 地理位置分片  华南区一个表,华北一个表。 时间分片  按月分片，按季度分片等等,可以做到冷热数据。分库分表后引入的问题# 分布式事务问题  如果我们做了垂直分库或者水平分库以后,就必然会涉及到跨库执行SQL的问题,这样就引发了互联网界的老大难问题-&amp;quot;分布式事务&amp;quot;。那要如何解决这个问题呢？1.</description>
    </item>
    
    <item>
      <title>分层参考模型</title>
      <link>https://huachengzhou.github.io/life/docs/computer_network/network_architecture/%E5%88%86%E5%B1%82%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/computer_network/network_architecture/%E5%88%86%E5%B1%82%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/</guid>
      <description>   名称 英文 作用     应用层 Application Layer 直接为用户的应用进程（例如电子邮件、文件传输和终端仿真）提供服务。如HTTP、SMTP、FTP、DNS等   表示层 Presentation Layer 把数据转换为能与接收者的系统格式兼容并适合传输的格式，即让两个系统可以交换信息   会话层 Session Layer 负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接   传输层 Transport Layer 负责端到端通讯，可靠传输，不可靠传输 ，流量控制，复用分用   网络层 Network Layer 负责选择路由最佳路径，规划IP地址(ipv4和ipv6变化只会影响网络层)，拥塞控制   数据链路层 Data Link Layer 帧的开始和结束，还有透明传输，差错校验(纠错由传输层解决)   物理层 Physical Layer 定义网络设备接口标准，电气标准(电压)，如何在物理链路上传输的更快    </description>
    </item>
    
    <item>
      <title>线程概念与多线程模型</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_1_5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_1_5/</guid>
      <description></description>
    </item>
    
    <item>
      <title>webpack </title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/webpack/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/webpack/</guid>
      <description>（十五）webpack#15.1	webpack起步#15.1.1	什么是webpack#webpack是一个JavaScript应用的静态模块打包工具。
从这句话中有两个要点，模块和打包需要关注。grunt/gulp都可以打包，那有什么区别。
 模块化
 webpack可以支持前端模块化的一些方案，例如AMD、CMD、CommonJS、ES6。可以处理模块之间的依赖关系。不仅仅是js文件可以模块化，图片、css、json文件等等都可以模块化。
 打包
 webpack可以将模块资源打包成一个或者多个包，并且在打包过程中可以处理资源，例如压缩图片，将scss转成css，ES6语法转成ES5语法，将TypeScript转成JavaScript等等操作。grunt/gulp也可以打包。
和grunt/glup的对比
 grunt/glup的核心是Task  我们可以配置一系列的task，并且定义task要处理的事务（例如ES6/TS转化，图片压缩，scss转css） 之后可以让grunt/glup来执行依次这些任务，让整个流程自动化 所以grunt/glup也被称为前端自动化任务管理工具   看一个gulp例子  task将src下的js文件转化为ES5语法 并输入到dist文件夹中     什么时候使用grunt/gulp呢？  如果工程依赖简单，甚至没有模块化 只需要进行简单的合并/压缩 如果模块复杂，相互依赖性强，我们需要使用webpack   grunt/glup和webpack区别  grunt/glup更加强调的是前端自动化流程，模块化不是其核心 webpack加强模块化开发管理，而文件压缩/合并/预处理等功能，是附带功能    webpack就是前端模块化打包工具
15.1.2	webpack的安装# webpack依赖node环境。 node环境依赖众多包，所以需要npm，npm（node packages manager）node包管理工具 nvm是node管理工具可以自由切换node环境版本  全局安装webpack
npm install webpack -g //指定版本安装 npm install webpack@3.</description>
    </item>
    
    <item>
      <title>webpack simple</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/simple-webpack/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/simple-webpack/</guid>
      <description>webpack#一:卸载# 全局卸载  D:\IdeaProjects\cycle\docs\webc\web\webpack-study\one&amp;gt;npm uninstall webpack webpack-cli -g removed 73 packages in 0.726s  本地卸载  D:\IdeaProjects\cycle\docs\webc\web\webpack-study\one&amp;gt;npm uninstall webpack webpack-cli -D npm WARN saveError ENOENT: no such file or directory, open &amp;#39;D:\IdeaProjects\package.json&amp;#39; npm WARN enoent ENOENT: no such file or directory, open &amp;#39;D:\IdeaProjects\package.json&amp;#39; npm WARN IdeaProjects No description npm WARN IdeaProjects No repository field. npm WARN IdeaProjects No README data npm WARN IdeaProjects No license field.</description>
    </item>
    
    <item>
      <title> groovy对象比较以及空判断 </title>
      <link>https://huachengzhou.github.io/life/docs/javadir/groovy/groovy%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83%E4%BB%A5%E5%8F%8A%E9%9D%9E%E7%A9%BA%E5%88%A4%E6%96%AD/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/groovy/groovy%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83%E4%BB%A5%E5%8F%8A%E9%9D%9E%E7%A9%BA%E5%88%A4%E6%96%AD/</guid>
      <description>groovy 对象比较以及空判断# 目前测试得知 groovy的比较貌似很多直接可以使用==来比较
 groovy对象的比较#1.字符串比较#def str1 = &amp;quot;Hello World1&amp;quot;if (&amp;quot;Hello World&amp;quot; == str1) {println &amp;quot;Hello World&amp;quot;} else {println &amp;quot;不匹配&amp;quot;}2.map集合的比较（list集合也可以这样比较）#	def m1=[&amp;quot;name&amp;quot;:&amp;quot;李明&amp;quot;,&amp;quot;age&amp;quot;:20]def m2=[&amp;quot;name&amp;quot;:&amp;quot;李明&amp;quot;,&amp;quot;age&amp;quot;:21]def m3=[&amp;quot;name&amp;quot;:&amp;quot;李明&amp;quot;,&amp;quot;age&amp;quot;:21]if(m1==m2){println &amp;quot;m1和m2匹配&amp;quot;}else{println &amp;quot;m1和m2不匹配&amp;quot;}  特别是字符串的比较，是不是比java要简洁的多呢
  如果要比较两个对象的引用是否相同在groovy中可以使用is
  def list1 = []def list2 = [1,2,3,4]boolean check = list1.</description>
    </item>
    
    <item>
      <title> windows 问题 </title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/windows/windows_question/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/windows/windows_question/</guid>
      <description> 磁盘变为了动态磁盘解决办法 最好是找软件解决 如DiskGenius 或者 傲梅分区助手 暴力解决办法  1、diskpart2、list disk3、select disk n4、convert basicSTEP 1：打开命令提示符窗口，在其中键入：“diskpart”命令并按下回车键。 STEP 2：在DISKPART命令提示符下，键入“list disk”命令并按下回车键后，能够查看到电脑中的磁盘情况。 STEP 3：在DISKPART命令提示符下，继续键入“select disk n”命令并按下回车键，其中n代表磁盘的序号。 STEP 4：在DISKPART命令提示符下，键入“convert dynamic”命令并按下回车键后，开始转换的工作。</description>
    </item>
    
    <item>
      <title> 系统调用 </title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/one_chapter/1_6_/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/one_chapter/1_6_/</guid>
      <description>一:知识总览#什么是系统调用，有何作用？# 知识点回顾：操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组系统调用组成。
  “系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务
 系统调用与库函数的区别#小例子：为什么系统调用是必须的？#什么功能要用到系统调用？# 应用程序通过系统调用请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此凡是与共享资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。
 系统调用的过程#二:知识回顾与重要考点#</description>
    </item>
    
    <item>
      <title>mysql安装</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_install/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_install/</guid>
      <description>mysql安装# 这里我们不再采用exe的安装的方式,我们使用压缩包的方式安装
   地址 https://downloads.mysql.com/archives/community/
  将页面拉到最下面选择选择操作系统后，选择要下载的版本点击 Downloads
  我选择安装的版本为8.0.13。如果不想要最新的版本也可以进Archives页面选择其他版本
  选择压缩包的版本哦
  一:配置环境变量#  因为下载的mysql数据库包的格式是zip的，下载完成后直接解压就可以用，但解压后需要进行配置。
  首先进行环境变量的配置：右击计算机-&amp;gt;属性-&amp;gt;高级系统设置-&amp;gt;环境变量，选择双击Path，在最后面添加你的mysql bin文件夹的路径
  我的目录是：D:\databases\mysql-8.0.13-winx64
   必须设置这个才行,因为后面我们要在控制台运行命令,假如你不设置这个环境变量那么在控制台根本识别不了,exe安装会自动在环境中设置,而压缩包没有设置  二:在 D:\databases\mysql-8.0.13-winx64 目录下新建一个my.ini的文件#[mysqld]# skip-grant-tables 暂时注释了 容易引起 mysql服务启动后立马关闭 这个错误# 设置3306端口port=3306# 自定义设置mysql的安装目录，即解压mysql压缩包的目录# 切记此处一定要用双斜杠\\，单斜杠这里会出错。basedir=D:\\databases\\mysql-8.0.13-winx64# 自定义设置mysql数据库的数据存放目录datadir=D:\\databases\\mysql-8.0.13-winx64\\data# 允许最大连接数max_connections=200# 允许连接失败的次数，这是为了防止有人从该主机试图攻击数据库系统max_connect_errors=10# 服务端使用的字符集默认为UTF8character-set-server=utf8mb4# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证default_authentication_plugin=mysql_native_password[mysql]# 设置mysql客户端默认字符集default-character-set=utf8mb4[client]# 设置mysql客户端连接服务端时默认使用的端口和默认字符集port=3306default-character-set=utf8mb4三:windows下运行控制台程序# 进入 C:\Windows\System32 中搜索   右键用管理员权限执行  四:初始化mysql# mysqld &amp;ndash;initialize &amp;ndash;console，等待一会出现几行代码，root@localhost：后面的是随机生成的数据库初始密码，将初始密码记下来后面会用到。 没记住初始密码的话，删掉初始化的 data目录，再执行一遍初始化命令又会重新生成  D:\databases\mysql-8.</description>
    </item>
    
    <item>
      <title>处理机调度的概念、层次</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_2_1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_2_1/</guid>
      <description></description>
    </item>
    
    <item>
      <title>模型层次详解</title>
      <link>https://huachengzhou.github.io/life/docs/computer_network/network_architecture/%E6%A8%A1%E5%9E%8B%E5%B1%82%E6%AC%A1%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/computer_network/network_architecture/%E6%A8%A1%E5%9E%8B%E5%B1%82%E6%AC%A1%E8%AF%A6%E8%A7%A3/</guid>
      <description>计算机网络分成结构#7层OSI参考模型#4层TCP/IP参考模型#5层体系结构#ISO/OSI模型怎么来的#ISO/OSI参考模型#ISO/OSI参考模型解释通信过程#应用层#表示层#会话层#传输层#网络层#数据链路层#物理层#OSI参考模型 与 TCP/IP参考模型#OSI参考模型与TCP/IP参考模型#相同点# 1:都分层 2:基于独立的协议栈的概念 3:可以实现异构网络互联  不同点#面向连接分为三个阶段，第一是建立连接，在此阶段，发出一个建立连接的请求。只有在连接成功建立之后，才能开始数据传输，这是第二阶段。接着，当数据传输完毕，必须释放连接。而面向无连接没有这么多阶段，它直接进行数据传输。    ISO/OSI参考模型 TCP/IP模型     网络层 无连接 + 面向连接 无连接   传输层 面向连接 无连接 + 面向连接    五层参考模型# 综合了OSI和TCP/IP的优点</description>
    </item>
    
    <item>
      <title>webpack和nodejs关系 </title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/webpack%E5%92%8Cnodejs%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/webpack%E5%92%8Cnodejs%E5%85%B3%E7%B3%BB/</guid>
      <description>webpack和nodejs关系# webpack可以将 .vue 文件转换为 .js 文件，而这个转换需要借助打包器vue-loader，这个打包器的下载是在node环境使用 npm 下载的（npm类似与一个应用商店，里面有很多包）；这样webpack在打包的时候是在node环境中运行的。
  nodejs是js后端运行平台，可以把它看成java体系中对应的jdk，是三个里面最基础的。 npm是nodejs的包管理工具，可以把它看成maven中包依赖管理那部分。 webpack是前端工程化打包工具，可以把它看成maven中工程自动化那部分  npm#npm是什么#是Node.js的包管理工具，是全球最大的开发库生态系统（注册表）为何产生？#当网站的依赖的js越来越多，程序员发现这是一件麻烦事：去JQuery官网下载JQuery，去 BootStrap 官网下载 BootStrap ，去 Underscore 官网下载 Underscore .......没完没了于是npm就出来了（全称 Node Package Manager 包管理工具），大家把自己写好的源码上传到npm官网上，如果要用某个或某些个，直接通过npm安装就可以了，并且模块A依赖B，B依赖C、D，此时只需安装A即可，因为此时npm会根据依赖关系，把所有依赖的包都下载下来并且管理起来；这一点和maven、gradle十分相似，只不过maven、gradle是用来管理java jar包的，而npm是用来管理js的。常用命令# npm init：初始化一个项目包，包含package.json文件 npm install：package.json的devDependencies字段里的插件全部安装到node_modules下  node#node.js是javascript的一种运行环境，是对Google V8引擎进行的封装。是一个服务器端的javascript的解释器。包含关系，nodejs中含有npm，比如说你安装好nodejs，你打开cmd输入npm -v会发现出啊线npm的版本号，说明npm已经安装好。webpack#Webpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将这些模块按照指定的规则生成对应的静态资源。我们为什么使用webpack?#开发是时候需要一个开发环境，要是我们修改一下代码保存之后浏览器就自动展现最新的代码就好了（热更新服务）本地代码的时候，要是调后端的接口不跨域就好了（代理服务）为了跟上时代，要是能用上ES678N就好了（翻译服务）项目要上线了，要是能一键压缩代码，图片什么的就好了（压缩打包服务）我们平时的静态资源都是放到CDN上的，要是能自动帮我把这些搞好的静态资源怼到CDN上就好了（自动上传服务）这么多服务，我们需要webpack帮我们去整合那么多的服务，而node的出现，赋予了我们操作系统的能力，要根据自己的需求来使用webpack，知道自己需要什么样的服务，webpack能不能提供这样的服务，如果可以，那么这个服务应该在构建中的呢个环节被处理。1.</description>
    </item>
    
    <item>
      <title> groovy使用场景 </title>
      <link>https://huachengzhou.github.io/life/docs/javadir/groovy/groovy%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/groovy/groovy%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</guid>
      <description>groovy 使用场景#Groovy可以用于多种情况。比如#  1、作为shell脚本语言完成数据处理和文件操作任务。
  2、在Java或者Java EE应用程序中嵌入Groovy，实现Java和Groovy的集成。（这样有助于编写和集中处理经常变化的业务逻辑，或者给应用程序架构提供可编程的配置管理能力。）
  Groovy是增强Java平台的唯一的脚本语言。# 它提供了类似于Java的语法，内置映射（Map）、列表（List）、方法、类、闭包（closure）以及生成器。  脚本语言与系统编程语言：# 脚本语言不会替代系统编程语言，两者是相互补充的。
 系统编程语言的目的：#  开发复杂的算法或者数据结构
  实现计算密集型应用
  操作大型数据集
  实现定义良好的、变更缓慢的需求
  脚本语言应用的目的：#  连接已有的组件
  处理经常变化的多种类型的实体
  具有图形化用户界面
  拥有快速变化的功能
  Java编译器会产生可以在Java虚拟机上运行的字节码。#Groovy类和Java是二进制兼容的。#Groovy编译器产生的字节码与Java编译器产生的字节码是完全一样的。#——对于JVM而言，Groovy和Java是完全一样的。#因此，Groovy能够完全使用各种Java API。#Groovy是一门面向对象的语言。也就是说，Groovy中每一个事物最终都会被当做某些类 的一个实例对象。#回到上一级#</description>
    </item>
    
    <item>
      <title> 操作系统的体系结构 </title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/one_chapter/1_7_/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/one_chapter/1_7_/</guid>
      <description>一:知识总览#操作系统的内核#二:知识回顾与重要考点#</description>
    </item>
    
    <item>
      <title>windows下 Mysql安装的一些问题解决方法</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_install_problem/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_install_problem/</guid>
      <description>windows下 Mysql安装的一些问题解决方法#1: The service already exists#  在mysql安装的时候要执行 mysqld &amp;ndash;install 这个命令,假如你已经安装完之后觉得不对，但是mysql服务已经生成(windows注册服务已经有mysql了),你不删除此服务为报一个错误
  The service already exists
  决绝方法就是 删除mysql相关的服务
  首先查询下是否存在mysql服务
  sc query mysqlSERVICE_NAME: mysqlTYPE : 10 WIN32_OWN_PROCESSSTATE : 4 RUNNING(STOPPABLE, PAUSABLE, ACCEPTS_SHUTDOWN)WIN32_EXIT_CODE : 0 (0x0)SERVICE_EXIT_CODE : 0 (0x0)CHECKPOINT : 0x0WAIT_HINT : 0x0# 这种情况就是mysql 没有删除干净 删除该mysql  sc delete mysql Please consider using UTF8MB4 in order to be unambiguous.</description>
    </item>
    
    <item>
      <title>进程调度的时机、切换与过程、方式</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_2_2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_2_2/</guid>
      <description></description>
    </item>
    
    <item>
      <title>webpack loader</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/webpack_loader/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/webpack_loader/</guid>
      <description>first css-loader# 文件目录  ▸\t1 ▸ \t1\dist ▸ \t1\dist\index.js ▸ \t1\node_modules ▸ \t1\node_modules\.bin //省略 ▸ \t1\node_modules\yocto-queue\readme.md ▸ \t1\package-lock.json ▸ \t1\package.json ▸ \t1\src ▸ \t1\src\index.css ▸ \t1\src\index.js ▸ \t1\webpack.config.js  webpack.config.js content  module.exports = { entry: { index :&amp;#34;./src/index.js&amp;#34; }, mode :&amp;#39;development&amp;#39; , module :{ rules:[ {test :/.css$/ ,use : &amp;#34;css-loader&amp;#34;} ] } }  package.json content  { &amp;#34;name&amp;#34;: &amp;#34;t1&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;1.0.0&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;main&amp;#34;: &amp;#34;webpack.config.js&amp;#34;, &amp;#34;scripts&amp;#34;: { &amp;#34;test&amp;#34;: &amp;#34;echo \&amp;#34;Error: no test specified\&amp;#34; &amp;amp;&amp;amp; exit 1&amp;#34;, &amp;#34;build&amp;#34;: &amp;#34;webpack&amp;#34; }, &amp;#34;keywords&amp;#34;: [], &amp;#34;author&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;license&amp;#34;: &amp;#34;ISC&amp;#34;, &amp;#34;devDependencies&amp;#34;: { &amp;#34;css-loader&amp;#34;: &amp;#34;^5.</description>
    </item>
    
    <item>
      <title>数据库设计的规范</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</guid>
      <description>数据库设计的规范# 数据库表和字段都大写 表都要加业务后缀，例如_C客户表 _B基础表 _P权限表 必须有主键，主键是表名去掉业务后缀，加_ID，大多表的主键使用UUID 字段多个单词时，全大写，用下划线隔开 类型INT/LONG/DOUBLE/TIMESTAMP/CHAR/VARCHAR2 尽量化在这几个类型中，这样数据库设计相当简单 排序号定死名称ORDER_NO 权限两个字段CREATE_BY创建人，CREATE_DEPT创建部门 记录创建时间CREATE_TIME  </description>
    </item>
    
    <item>
      <title>调度算法的评价指标</title>
      <link>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_2_3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/operating_system/two_chapter/2_2_3/</guid>
      <description></description>
    </item>
    
    <item>
      <title>node js - npm 重要命令 </title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/npm%E9%87%8D%E8%A6%81%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/npm%E9%87%8D%E8%A6%81%E5%91%BD%E4%BB%A4/</guid>
      <description>npm 包管理器查询网址# https://www.npmjs.com/ (和java的maven仓库差不多一个意思)  全局安装#  npm install less-loader@4.1.0
  npm install less-loader@4.1.0 &amp;ndash;save
  本地安装命令#  npm install less-loader@3.0.0 &amp;ndash;save-dev
  npm add -D less-loader@3.0.0
   上面两条等价
 升级到最高版本 , 更新npm到最新版本# npm i npm@latest -d npm i npm@latest -g  安装所有依赖 (package.json)# npm install request  删除包问题#  npm uninstall webpack webpack-cli -g 全局</description>
    </item>
    
    <item>
      <title>mysql_数据库设计三范式</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F/</guid>
      <description>设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。
  目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。
 数据库三范式#第一范式（1NF）# 所谓第一范式（1NF）是指在关系模型中，对域添加的一个规范要求，所有的域都应该是原子性的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。简而言之，第一范式就是无重复的域。 说明：在任何一个关系数据库中，第一范式（1NF）是对关系模式的设计基本要求，一般设计中都必须满足第一范式（1NF）。不过有些关系模型中突破了1NF的限制，这种称为非1NF的关系模型。换句话说，是否必须满足1NF的最低要求，主要依赖于所使用的关系模型。  第二范式（2NF）# 在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖） 第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或记录必须可以被唯一地区分。选取一个能区分每个实体的属性或属性组，作为实体的唯一标识。例如在员工表中的身份证号码即可实现每个一员工的区分，该身份证号码即为候选键，任何一个候选键都可以被选作主键。在找不到候选键时，可额外增加属性以实现区分，如果在员工关系中，没有对其身份证号进行存储，而姓名可能会在数据库运行的某个时间重复，无法区分出实体时，设计辟如ID等不重复的编号以实现区分，被添加的编号或ID选作主键。（该主键的添加是在ER设计时添加，不是建库时随意添加） 第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是在第一范式的基础上属性完全依赖于主键。  第三范式（3NF）# 在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） 第三范式（3NF）是第二范式（2NF）的一个子集，即满足第三范式（3NF）必须满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个关系中不包含已在其它关系已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性，也就是在满足2NF的基础上，任何非主属性不得传递依赖于主属性。  巴斯-科德范式（BCNF）# Boyce-Codd Normal Form（巴斯-科德范式）
  在3NF基础上，任何非主属性不能对主键子集依赖（在3NF基础上消除对主码子集的依赖） 巴斯-科德范式（BCNF）是第三范式（3NF）的一个子集，即满足巴斯-科德范式（BCNF）必须满足第三范式（3NF）。通常情况下，巴斯-科德范式被认为没有新的设计规范加入，只是对第二范式与第三范式中设计规范要求更强，因而被认为是修正第三范式，也就是说，它事实上是对第三范式的修正，使数据库冗余度更小。这也是BCNF不被称为第四范式的原因。某些书上，根据范式要求的递增性将其称之为第四范式是不规范，也是更让人不容易理解的地方。而真正的第四范式，则是在设计规范中添加了对多值及依赖的要求。 定义：关系模式R&amp;lt;U,F&amp;gt;∈1FNF,若X→Y且Y不是X的子集时X必含有码，则R&amp;lt;U,F&amp;gt;∈BCNF。也就是说，关系模式R&amp;lt;U,F&amp;gt;中，若每一个决定因素都包含码，则R&amp;lt;U,F&amp;gt;∈BCNF。   由BCNF的定义可以得到结论，一个满足BCNF的关系模式有：
  -所有非主属性对每一个码都是完全函数依赖。 -所有主属性对每一个不包含它的码也是完全函数依赖。 -没有任何属性完全函数依赖于非码的任何一组属性。 若R∈BCNF，按定义排除了任何属性对码的传递依赖与部分依赖，所以R∈3NF。[1] 一般关系型数据库设计中，达到BCNF就可以了！  #【数据库五大约束】
 1.primary KEY:设置主键约束； 2.UNIQUE：设置唯一性约束，不能有重复值； 3.DEFAULT 默认值约束，height DOUBLE(3,2)DEFAULT 1.2 height不输入是默认为1,2 4.NOT NULL：设置非空约束，该字段不能为空； 5.FOREIGN key :设置外键约束。  【主键】# 1.</description>
    </item>
    
    <item>
      <title>npm部分插件安装问题 </title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/npm%E9%83%A8%E5%88%86%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/npm%E9%83%A8%E5%88%86%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/</guid>
      <description>less版本过高的解决办法  解决方法：卸载安装的高版本的less-loader ， 【npm uninstall less-loader】，安装指定低版本的less-loader 【npm install less-loader@4.1.0 --save】 webpack Cannot read property &amp;lsquo;tap&amp;rsquo; of undefined ?  解决：这个报错是webpack依赖重复引入导致的，由于已经有依赖中引入的webpack，然后有自己引入的webpack。下面是生产的依赖，将“webpack”: “^4.0.0-beta.3”,“webpack-dev-server”: “2.7.1”,“webpack-manifest-plugin”: “1.2.1”,删掉，移除node_modules。重新npm install 。再启动项目，就搞定了 使用webpack打包报ERROR in TypeError: Cannot read property ‘tap‘ of undefined  降低版本 webpack假如降为4.44.2 则npm install webpack@4.44.2 -g 全局npm install webpack@4.44.2 -D 局部 less-loader模块 TypeError: this.getOptions is not a function  原因： less-loader安装的版本过高解决方案： 1.</description>
    </item>
    
    <item>
      <title>mysql事务</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql%E4%BA%8B%E5%8A%A1/</guid>
      <description></description>
    </item>
    
    <item>
      <title>webpack 应用自己插件 </title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/my-plugins/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/my-plugins/</guid>
      <description>webpack.config.js  const ConsoleLogOnBuildWebpackPlugin = require(&amp;#34;./src/console_log_on_build_webpack_plugin.js&amp;#34;); module.exports = { entry: { index: &amp;#34;./src/index.js&amp;#34; }, mode: &amp;#39;development&amp;#39;, plugins: [ new ConsoleLogOnBuildWebpackPlugin() ] };  package.json  { &amp;#34;name&amp;#34;: &amp;#34;demo08&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;1.0.0&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;main&amp;#34;: &amp;#34;webpack.config.js&amp;#34;, &amp;#34;scripts&amp;#34;: { &amp;#34;test&amp;#34;: &amp;#34;echo \&amp;#34;Error: no test specified\&amp;#34; &amp;amp;&amp;amp; exit 1&amp;#34;, &amp;#34;build&amp;#34; : &amp;#34;webpack&amp;#34; }, &amp;#34;keywords&amp;#34;: [], &amp;#34;author&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;license&amp;#34;: &amp;#34;ISC&amp;#34;, &amp;#34;devDependencies&amp;#34;: { &amp;#34;webpack&amp;#34;: &amp;#34;^5.44.0&amp;#34;, &amp;#34;webpack-cli&amp;#34;: &amp;#34;^4.7.2&amp;#34; } }  src console_log_on_build_webpack_plugin.js index.js  // console_log_on_build_webpack_plugin.</description>
    </item>
    
    <item>
      <title>mysql函数</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql%E5%87%BD%E6%95%B0/</guid>
      <description>日期函数#  返回当前日期，只包含年月日 select curdate()
  返回当前时间，只包含时分秒 select curtime()
  返回当前的日期和时间，年月日时分秒全都包含 select now()
  提取具体日期类型# year() yearweek() ,hour(),month()等等   select year(now()) as &amp;lsquo;年&amp;rsquo;,yearweek(now()) as &amp;lsquo;年,周&amp;rsquo;,hour(now()) as &amp;lsquo;周&amp;rsquo;,minute(now()) as &amp;lsquo;小时&amp;rsquo;,month(now()) &amp;lsquo;月&amp;rsquo;,monthname(now()) &amp;lsquo;月名字&amp;rsquo;,dayofmonth(now()) as &amp;lsquo;当月多少日&amp;rsquo;   EXTRACT() 函数用于返回日期/时间的单独部分，比如年、月、日、小时、分钟等等。   (select extract(year from now()),extract(month from now()),extract(day from now()),extract(hour from now()),extract(minute from now()))  日期格式# DATE_FORMAT(date,fmt)函数：按字符串 fmt 格式化日期 date 值 (select date_format(now(),&#39;%Y-%m-%d&#39;))  日期运算#  date_add(date,interval number dateType) example (select date_add(now(),interval 2 year) as &amp;lsquo;add 2 year date&amp;rsquo;) (select date_add(now(),interval -2 hour) as &amp;lsquo;add 2&amp;rsquo;)也可以传入负数即回到过去某个时间</description>
    </item>
    
    <item>
      <title>webpack 热更新 </title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/webpack%E7%83%AD%E6%9B%B4%E6%96%B0/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/webpack%E7%83%AD%E6%9B%B4%E6%96%B0/</guid>
      <description>package.json  { &amp;#34;name&amp;#34;: &amp;#34;demo09&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;1.0.0&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;main&amp;#34;: &amp;#34;index.js&amp;#34;, &amp;#34;scripts&amp;#34;: { &amp;#34;test&amp;#34;: &amp;#34;echo \&amp;#34;Error: no test specified\&amp;#34; &amp;amp;&amp;amp; exit 1&amp;#34;, &amp;#34;build&amp;#34;: &amp;#34;webpack&amp;#34;, &amp;#34;dev&amp;#34;: &amp;#34;webpack-dev-server&amp;#34; }, &amp;#34;keywords&amp;#34;: [], &amp;#34;author&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;license&amp;#34;: &amp;#34;ISC&amp;#34;, &amp;#34;devDependencies&amp;#34;: { &amp;#34;html-webpack-plugin&amp;#34;: &amp;#34;^5.3.2&amp;#34;, &amp;#34;webpack&amp;#34;: &amp;#34;^5.45.1&amp;#34;, &amp;#34;webpack-cli&amp;#34;: &amp;#34;^3.3.12&amp;#34;, &amp;#34;webpack-dev-server&amp;#34;: &amp;#34;^3.11.2&amp;#34; } }  webpack.config.js  const path = require(&amp;#34;path&amp;#34;); const webpack = require(&amp;#34;webpack&amp;#34;); const HtmlWebpackPlugin = require(&amp;#39;html-webpack-plugin&amp;#39;); module.exports = { entry: { &amp;#34;index&amp;#34;: &amp;#34;./src/index.js&amp;#34; }, mode: &amp;#34;development&amp;#34;, output: { path: path.</description>
    </item>
    
    <item>
      <title>mysql存储引擎</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</guid>
      <description>MySQL 存储引擎概述# MySQL 5.0 支持的存储引擎包括 MyISAM、 InnoDB、 BDB、 MEMORY、 MERGE、 EXAMPLE、 NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED 等，其中 InnoDB 和 BDB 提供事务安 全表，其他存储引擎都是非事务安全表。
  查看当前引擎 show ENGINES  MyISAM存储引擎# 不支持事务、也不支持外键，优势是访问速度快，对事务完整性没有 要求或者以select，insert为主的应用基本上可以用这个引擎来创建表
  支持3种不同的存储格式，分别是：静态表；动态表；压缩表   静态表：表中的字段都是非变长字段，这样每个记录都是固定长度的，优点存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多（因为存储时会按照列的宽度定义补足空格）ps：在取数据的时候，默认会把字段后面的空格去掉，如果不注意会把数据本身带的空格也会忽略。 动态表：记录不是固定长度的，这样存储的优点是占用的空间相对较少；缺点：频繁的更新、删除数据容易产生碎片，需要定期执行OPTIMIZE TABLE或者myisamchk-r命令来改善性能 压缩表：因为每个记录是被单独压缩的，所以只有非常小的访问开支
  动态表：记录不是固定长度的，这样存储的优点是占用的空间相对较少；缺点：频繁的更新、删除数据容易产生碎片，需要定期执行OPTIMIZE TABLE或者myisamchk-r命令来改善性能
  压缩表：因为每个记录是被单独压缩的，所以只有非常小的访问开支
 InnoDB存储引擎# nnoDB 存储表和索引有两种方式
  使用共享表空间存储，这种方式创建的表的表结构保存在.frm 文件中，数据和索引 保存在 innodb_data_home_dir 和 innodb_data_file_path 定义的表空间中，可以是 多个文件。 使用多表空间存储，这种方式创建的表的表结构仍然保存在.frm 文件中，但是每个 表的数据和索引单独保存在.ibd 中。如果是个分区表，则每个分区对应单独的.</description>
    </item>
    
    <item>
      <title>webpack 其他 loader </title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/webpack-other-loader/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/webpack-other-loader/</guid>
      <description>url-loader file-loader# package.json  { &amp;#34;name&amp;#34;: &amp;#34;demo10&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;1.0.0&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;main&amp;#34;: &amp;#34;webpack.config.js&amp;#34;, &amp;#34;scripts&amp;#34;: { &amp;#34;test&amp;#34;: &amp;#34;echo \&amp;#34;Error: no test specified\&amp;#34; &amp;amp;&amp;amp; exit 1&amp;#34;, &amp;#34;build&amp;#34;: &amp;#34;webpack&amp;#34;, &amp;#34;dev&amp;#34;: &amp;#34;webpack-dev-server&amp;#34; }, &amp;#34;keywords&amp;#34;: [], &amp;#34;author&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;license&amp;#34;: &amp;#34;ISC&amp;#34;, &amp;#34;devDependencies&amp;#34;: { &amp;#34;css-loader&amp;#34;: &amp;#34;^3.0.0&amp;#34;, &amp;#34;file-loader&amp;#34;: &amp;#34;^6.2.0&amp;#34;, &amp;#34;html-webpack-plugin&amp;#34;: &amp;#34;^5.3.2&amp;#34;, &amp;#34;less&amp;#34;: &amp;#34;^4.1.1&amp;#34;, &amp;#34;less-loader&amp;#34;: &amp;#34;^10.0.1&amp;#34;, &amp;#34;style-loader&amp;#34;: &amp;#34;^3.1.0&amp;#34;, &amp;#34;url-loader&amp;#34;: &amp;#34;^2.2.0&amp;#34;, &amp;#34;webpack&amp;#34;: &amp;#34;^5.45.1&amp;#34;, &amp;#34;webpack-cli&amp;#34;: &amp;#34;^3.3.12&amp;#34;, &amp;#34;webpack-dev-server&amp;#34;: &amp;#34;^3.11.2&amp;#34; } }  webpack.config.js  const path = require(&amp;#34;path&amp;#34;); const webpack = require(&amp;#34;webpack&amp;#34;); const HtmlWebpackPlugin = require(&amp;#39;html-webpack-plugin&amp;#39;); module.</description>
    </item>
    
    <item>
      <title>mysql查询</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql%E6%9F%A5%E8%AF%A2/</guid>
      <description>mysql学习(下面所有都是针对mysql而言)#sql排序语句# 升序   (select f.* from fruits f WHERE s_id IN (101,102) order by f_name)==(select f.* from fruits f WHERE s_id IN (101,102) order by f_name asc)   对于sql的升序而言,当使用了order by之后如果不添加desc那么默认是升序 order by f_name 和 order by f_name ASC 效果一致 降序   (select f.* from fruits f WHERE s_id not IN (101,102) order by f_name DESC )   order by之后加上DESC结果集就是降序   上面结合了 关键字in可以看到 in (101,102)和not in (101,102)</description>
    </item>
    
    <item>
      <title>mysql用户与权限</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90/</guid>
      <description>mysql.version=5.7 (必须注意版本)
 创建用户# ( CREATE USER &amp;lsquo;bob&amp;rsquo;@&#39;%&#39; IDENTIFIED BY &amp;lsquo;07fa533360d9&amp;rsquo;; ) 创建bob用户 密码:07fa533360d9 ( CREATE USER &amp;ldquo;test&amp;rdquo;@&amp;ldquo;localhost&amp;rdquo; IDENTIFIED BY &amp;lsquo;123456&amp;rsquo; )创建test用户　密码123456 ( CREATE USER &amp;ldquo;test&amp;rdquo;@&amp;ldquo;192.168.87.26&amp;rdquo; IDENTIFIED BY &amp;lsquo;123456&amp;rsquo; )创建test用户　密码123456   参数说明:&#39;%&amp;lsquo;表示所有情况都能访问;&amp;lsquo;localhost&amp;rsquo;表示本机才能访问;&amp;lsquo;192.168.87.26&amp;rsquo; 某个具体 ip 才能访问
 授权命令 (GRANT privileges ON databasename.tablename TO &amp;lsquo;username&amp;rsquo;@&amp;lsquo;host&amp;rsquo; )#GRANT SELECT,INSERT privileges on spring.* to &amp;lsquo;alice&amp;rsquo;@&amp;lsquo;localhost&amp;rsquo; identified by &amp;lsquo;123456&amp;rsquo;
 参数说明:databasename表示数据库名字;tablename数据库表的名字;username用户名;host表示链接地址如本机localhost,远程任意%,具体ip192.168.87.26
 授权test用户拥有testDB数据库的所有权限#create database testDB;grant all privileges on testDB.</description>
    </item>
    
    <item>
      <title>mysql索引</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql/mysql%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql/mysql%E7%B4%A2%E5%BC%95/</guid>
      <description>索引# 所有 MySQL 列类型都可以被索引，对相关列使用索引是提高 SELECT 操作性能的最佳途 径.根据存储引擎可以定义每个表的最大索引数和最大索引长度， 每种存储引擎 （如 MyISAM、 InnoDB、BDB、MEMORY 等）对每个表至少支持 16 个索引，总索引长度至少为 256 字节。 大多数存储引擎有更高的限制。
  MyISAM 和 InnoDB 存储引擎的表默认创建的都是 BTREE 索引。MySQL 目前还不支持函 数索引，但是支持前缀索引，即对索引字段的前 N 个字符创建索引。前缀索引的长度跟存 储引擎相关，对于 MyISAM 存储引擎的表，索引的前缀长度可以达到 1000 字节长，而对于 InnoDB 存储引擎的表，索引的前缀长度最长是 767 字节。请注意前缀的限制应以字节为单 位进行测量，而 CREATE TABLE 语句中的前缀长度解释为字符数。
  MySQL 中还支持全文本（FULLTEXT）索引，该索引可以用于全文搜索。但是当前最新版 本中（5.0）只有 MyISAM 存储引擎支持 FULLTEXT 索引，并且只限于 CHAR、 VARCHAR 和 TEXT 列。索引总是对整个列进行的，不支持局部（前缀）索引
  默认情况下，MEMORY 存储引擎使用 HASH 索引，但也支持 BTREE 索引
 </description>
    </item>
    
    <item>
      <title>MySQL数据库基础</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter1/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter1/</guid>
      <description>MySQL数据库基础#1.1-认识MySQL#什么是数据库# 计算机处理和存储的一切信息都是数据。 计算机系统中一种用于存取数据的程序。 一种：  计算机系统中有很多种能够存取数据的程序 它们各有特征和长处，有自己的适用范围。   存取：  能够保存数据避免丢失。 能够按照需求找到符合条件的数据。    为什么要使用数据库#数据库帮助我们解决一下数据存取难题：
 较大数据量 网络控制 并发访问 高性能要求 事务控制 持久化和数据安全 查询数据需求逻辑复杂  数据库分类#  关系型数据库
 MySQL Oracle SQL Server PostgreSQL    非关系型数据库
 hadoop：存放大数据 mongoDB： 文档型数据库 redis：键值型数据库 Cassandra：分布式数据库    最显著的区别：是否使用结构化查询语句（SQL）
为什么学习MySQL#MySQL：The world&amp;rsquo;s most popular open source database</description>
    </item>
    
    <item>
      <title>MySQL数据库对象与应用</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter2/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter2/</guid>
      <description>MySQL数据库对象与应用#2.1-MySQL数据类型#Number不止一种# 整形 浮点型  整形# INT SMALLINT MEDIUMINT BIGINT     type Storage Minumun Value Maximum Value      (Bytes) (Signed/Unsigned) (Signed/Unsigned)   TINYINT 1 -128 127     0 255   SMALLINT 2 -32768 32767     0 65535   MEDIUMINT 3 -8388608 8388607     0 16777215   INT 4 -2147483648 2147483647     0 4294967295   BIGINT 8 -9223372036854775808 9223372036854775807     0 18446744073709551615    老生常谈的问题#int(11) VS int(21) 存储空间，还是存储范围有区别？</description>
    </item>
    
    <item>
      <title>MySQL事务与存储引擎</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter3/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter3/</guid>
      <description>MySQL事务与存储引擎#3.1-数据库事务#什么是事务# 一系列有序的数据库操作：  要么全部成功 要么全部回退到操作前的状态 中间状态对其他连接不可见   事务的基本操作：    基本操作 说明     start transaction 开始事务   commit 提交(全部完成)   rollback 回滚(回到初始状态)      -- 开启一个事务 start transaction; -- 或者使用(非标准sql) begin; insert into t values (1, 1, 1); -- 事务结束，插入成功 commit; begin; insert into t values (2, 1, 1); insert into t values (3, 1, 1); insert into t values (4, 1, 1); -- 事务结束，没有插入数据 rollback; begin; insert into t values (1, 1, 1); savepoint a1; insert into t values (2, 1, 1); -- 回滚到指定的保存点 rollback to a1; commit; 自动提交# autocommit可以在session级别设置 每个DML操作都自动提交 DDL永远都是自动提交，无法通过rollback回滚  事务的四个基本属性(ACID)# 原子性(Atomicity) 一致性(Consistency) 隔离性(Isolation) 持久性(Durability)  事务的原子性# 包含在事务中的操作要么全部被执行，要么都不执行 中途数据库或应用发生异常，未提交的事务都应该被回滚  事务的一致性# 数据的正确性，合理性，完整性 数据一致性应该符合应用需要规则：  余额不能是负数 交易对象必须先有账号 用户账号不能重复   事务的结果需要满足数据的一致性约束  事物的持久性# 提交完成的事务对数据库的影响必须是永久性的  数据库异常不会丢失事务更新 通常认为成功写入磁盘的数据即为持久化成功    事务的持久化的实现# 数据文件持久化  随机同步刷新(慢)   事务日志持久化与实例恢复  顺序同步刷新(快) -&amp;gt; 事务日志 随机异步刷新 -&amp;gt; 磁盘 事务日志 -&amp;gt; 磁盘(实例恢复)    事务的隔离性# 数据库事务在提交完成前，中间的任何数据变化对其他的事务都是不可见的。  数据库隔离现象#   隔离现象 描述     脏读(Dirty Read) 事务B读到事务A尚未提交的数据变更   不可重复读(NonRepeatable Read) 事务B读取前后两次读取一条记录之间该记录被事务A修改并提交，于是事务B读到了不一样的结果   幻读(Phantom Read) 事务B按条件匹配到了若干行记录并修改。但是由于修改过程中事务A新插入了符合条件记录，导致B更新完成后发现仍有符合条件却未被更新的记录。    数据库隔离等级#   隔离等级 脏读 不可重复读 幻读     未提交读 可能 可能 可能   已提交读 不可能 可能 可能   可重复读 不可能 不可能 可能   可串行化读 不可能 不可能 不可能    MySQL的事务隔离级别# InnoDB默认标记为可重复读 InnoDB并不是标准定义上的课重复读 InnoDB默认在可重复读的基础上避免幻读  MySQL事务隔离级别设置# 可在global/session/下个事务，级别分别进行设置 建议使用Read committed(同Oracle) 或者建议使用默认的Repeatable read  set tx_isolation = &amp;#39;&amp;#39; -- 设置隔离级别 事务与并发写# 某个正在更新的记录再提交或回滚前不能被其他事务同时更新  事务回滚的实现# 回滚段(rollback segment)与数据前像  3.</description>
    </item>
    
    <item>
      <title>MySQL应用优化</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter4/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter4/</guid>
      <description>MySQL应用优化#4.1-MySQL索引优化与设计#什么是索引# 索引的意义 —— 快速定位要查找的数据  数据库索引查找# 全表扫描 VS 索引查找  如何根据首字母找到所在行# 二分查找 B+tree  InnoDB表聚簇索引#索引中只放着排序字段和ID
创建索引# 单列索引  create index idx_test1 on tb_student (name);  联合索引  create index idx_test2 on tb_student (name, age);  索引中先根据name排序，name相同的情况下，根据age排序  索引维护# 索引维护由数据库自动完成 插入/修改/删除每一个索引行都会变成一个内部封装的事务 索引越多，事务越长，代价越高 索引越多对表的插入和索引字段修改就越慢 控制表上索引的数量，切忌胡乱添加无用索引  如何使用索引# 依据WHERE查询条件建立索引  select a, b from tab_a where c=?</description>
    </item>
    
    <item>
      <title>MySQL运维实践</title>
      <link>https://huachengzhou.github.io/life/docs/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter5/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter5/</guid>
      <description>MySQL运维实践#5.1-MySQL日志系统#什么是日志# 日志(log)是一种顺序记录事件流水的文件 记录计算机程序运行过程中发生了什么 多种多样的用途  帮助分析程序问题 分析服务请求的特征、流量等 判断工作是否成功执行 等等……    MySQL日志的分类# 服务器日志  记录进程启动运行过程中的特殊事件，帮助分析MySQL服务遇到的问题 根据需求抓取特定的SQL语句，追踪性能可能存在的问题的业务SQL   事务日志  记录应用程序对数据的所有更改 可用于数据恢复 可用于实例间数据同步       分类 日志名称     服务器日志 服务错误日志   服务器日志 慢查询日志   服务器日志 综合查询日志   事务日志 存储引擎事务日志   事务日志 二进制日志    服务错误日志# 记录实例启动运行过程中重要消息 配置参数  log_error = /data/mysql_data/node-1/mysql.</description>
    </item>
    
    <item>
      <title>记忆方法</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%AE%B0%E5%BF%86/</link>
      <pubDate>Sun, 17 Jan 2021 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%AE%B0%E5%BF%86/</guid>
      <description>记忆方法# 提高记忆的关键，在于想象和创意 编故事有助于提高记忆力  通过编故事，再加上逻辑或地点（后者更多一些）;编故事是加强了记忆桩之间的联系记忆和创造力# 记忆本身与创造力密不可分 ， 训练记忆力在很大程度上取决于你的创造力  要想记住毫不相关的信息和扑克牌，首先就要把它们变成图像。通过这种方式，那些零散的信息才可能会建立某种联系联想#利用事物间的联系通过联想进行记忆的方法。联想是由当前感知或思考的事物想起有关的另一事物，或者由头脑中想起的一件事物，又引起想到另一件事物。由于客观事物是相互联系的，各种知识也是相互联系的，因而在思维中，联想是一种基本的思维形式，是记忆的一种方法。联想，就是当人脑接受某一剌激时，浮现出与该刺激有关的事物形象的心理过程。一般来说，互相接近的事物、相反的事物、相似的事物之间容易产生联想。用联想来增强记忆是一种很常用的方法。记忆的一种主要机能就是在有关经验中建立联系，思维中的联想越活跃，经验的联系就越牢固。如能经常形成联想和运用联想，就可增强记忆的效果。联想是有规律可循的，联想的规律有接近律、类似律、对比律、因果律等，有接近联想、类似联想、对比联想、因果联想。  联想不仅快速，而且它还不是一个简单、一维的东西。首先，你在联想中会加入一些情感因素，甚至还没回想起一段经历，就已经产生了某种情绪。
  一旦学会动用感情和感官，还有逻辑和创造力，来与不同事物间建立联系，你的记忆能力就会大大提高。除此之外，你还会慢慢习惯放松大脑，以最快的速度在不同事物之间建立联系。瞬间联想之所以对提高记忆力如此重要，是因为一个人在瞬间建立的联系往往是最牢靠的
  如何在两个并无联系的单词之间建立联系&amp;ndash;记忆的关键，就在于将二者结合到一起。
  如果没有过去的某些参照物作为参考，你就不能在两个概念( 包括单词、物体、活动等)之间建立联系。你的过去为你提供了某种经验，而正是这种经验可以帮助你由一个概念想到另一件概念。你的生活中发生的一切都像是积木中的模块，正是这一个个模块帮助你搭建了自己的人生大厦。要想在两个模块之间尽快建立联系，你需要用尽可能少的连接物来实现过渡。也就是说，要想从一件事情想到另外一件事情，最快的方式就是直接找到二者之间的联系
   比如说我想记住两个单词：墙壁和小鸡。每个单词都能激发我丰富的联想，我必须找到某种连接物将两个单词连接起来。比如说：墙壁会让我想到一个相册，想找到我小时候放学后经常爬的墙等。随着联想越来越细致、快速，我突然想到了一个最明显的连接：一首叫&amp;lt;&amp;lt;小胖鸡&amp;gt;&amp;gt;的儿歌。好极了！小胖鸡坐着墙壁上，它是一个鸡蛋----而鸡蛋又是小鸡下的。这时我就会展开联想，想象一只小鸡坐在墙下下蛋。为了让这个联想更加生动，我想起了小时候我在唱歌时的样子，然后自然而然地想到了自己看着小鸡下蛋时吃吃发笑的情形。虽然我并不记得发生过这件事，但它却足以激发我的联想。这个过程听起来可能有些复杂、繁琐，但事实上，这在大脑中只是一瞬间发生的事情。链条法# 如何使用链条法记住5个单词 小提琴、武士、箱子、项链、雪球  首先想想你突然听到小提琴发出的悠扬乐声。然后看到一个武士在演奏小提琴，你甚至可以清楚地看到他把小提琴放到下巴下面--这武士满副盔甲，很是搞笑。然后你看到他脚边放了一个箱子，可能颜色很鲜艳，也可能已经很破旧了。你打开箱子，发现里面有一挂价值连城的钻石项链，钻石反射阳光，分外耀眼。最后你转过头去，突然一个雪球砸中你的脸颊，你甚至感觉到右脸有些发疼。记住，你越练习动用五官来加强想象，你的大脑就会越熟悉这种练习，你也就越容易记住自己想象的场景。  要要记住五个单词以及单词之间的顺序，需要在单词之间建立联系</description>
    </item>
    
    <item>
      <title>学习方法</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 17 Jan 2021 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</guid>
      <description></description>
    </item>
    
    <item>
      <title>冥想</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E5%86%A5%E6%83%B3/</link>
      <pubDate>Sun, 17 Jan 2021 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E5%86%A5%E6%83%B3/</guid>
      <description>冥想#呼吸冥想法#  1:坐好，后背挺直，然后闭上眼睛
  2:关注你自己呼吸时的感觉,吸气，吸气，选择一个感受突出的地方，通常是你的鼻子或者耳朵、腹部然后集中注意力，关注你自己呼吸时的感觉。吸气，吸气，用嘴呼吸（最好关注腹部，因为我们大部分人都是腹部呼吸法）
  3:一旦你开始这样做了脑子会乱想,你需要关注你到什么时候走神的，那么走神后重新调整后重新开始集中注意力开始冥想。
  </description>
    </item>
    
    <item>
      <title>uniapp打包</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/packing/</link>
      <pubDate>Sat, 04 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%84%9A%E6%9C%AC/packing/</guid>
      <description>android本地打包#参考1 参考2 参考3
uniapp创建keystore jks 参考
 这里是因为创建密匙文件有多种方式  第一步 下载 Android Studio 配置必要的数据#   配置 android sdk 选用google 可以官网下载也可以使用工具下载    配置 jdk ( java jdk建议)    假如你没有手机或者手机不在打包环境那么你需要配置模拟android平台    第二部(重要)# 我也是在网上找了下，发现网上的有残缺吧
  1:HBuilderX版本 必须和 sdk一致  uniapp本地打包下载地址
  2: Android Studio导入HBuilder-Integrate-AS
  3:删除 HBuilder-Integrate-AS_c\simpleDemo\src\main\assets\apps 下的 生成的包
  4: 生成签名
  C:\Windows\system32&amp;gt;c:C:\Windows\system32&amp;gt;cd C:\Program Files\Java\jdk1.</description>
    </item>
    
    <item>
      <title>2021-06-15</title>
      <link>https://huachengzhou.github.io/life/posts/2021/oneday/</link>
      <pubDate>Tue, 15 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/posts/2021/oneday/</guid>
      <description>  努力
  英语越来越重要了
  </description>
    </item>
    
    <item>
      <title>DNS 污染</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/dns%E6%B1%A1%E6%9F%93/</link>
      <pubDate>Sun, 17 Jan 2021 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/dns%E6%B1%A1%E6%9F%93/</guid>
      <description>中国国内访问 GitHub 为什么很慢很卡甚至访问不了？如何加速访问 GitHub 网站？#个人总结：强扭的瓜不甜，修改 hosts 也就片刻好光景，要不了多久就变得比没改 hosts 之前更慢。所以还是顺其自然就好，不要白费力气去修改 hosts。#  摘要
  网站分发加速网络的域名遭到 DNS 污染，DNS 不能直接找到那个最快的 IP！ 通过修改系统 hosts 文件的办法，绕过国内 DNS 解析，直接访问 GitHub 的 CDN 节点，从而达到加速的目的！
  如何检验效果
  操作之前先 ping 一下 github.com，两个请求超时，两个 93ms。
  操作之后再 ping 一下 github.com，没有丢失，四个 287ms。
  一、国内访问 GitHub 为什么很慢？# GitHub 的 CDN 域名遭到 DNS 污染，导致无法连接使用 GitHub 的加速分发服务器，才使得国内访问速度很慢。  二、如何解决 DNS 污染？# 通过修改 Hosts 文件，将域名解析直接指向 IP 地址来绕过 DNS 的解析，以此解决污染问题。  三、具体操作步骤#  1、打开 https://www.</description>
    </item>
    
    <item>
      <title>GitHubPages绑定来自阿里云的域名</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/githubpages%E7%BB%91%E5%AE%9A%E6%9D%A5%E8%87%AA%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E5%9F%9F%E5%90%8D/</link>
      <pubDate>Sun, 17 Jan 2021 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/githubpages%E7%BB%91%E5%AE%9A%E6%9D%A5%E8%87%AA%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E5%9F%9F%E5%90%8D/</guid>
      <description>原教程但是由于他使用的github的用户名做的域名映射器,这样不好的地方是有可能你使用自定义的方式建立github仓库名比如 English study,还有一个是他使用的阿里云的域名映射解析这些是老版本的
  GitHub Pages 绑定来自阿里云的域名==原博客教程
  我的使用#github url ==&amp;gt; https://github.com/noatnu/studyDoc , 买的域名 http://www.zhouchenghua.com/# 解析第一个设置   创建A记录，请将您的顶点域指向GitHub Pages的IP地址 https 解析ip,上面的192.30.252.153是http解析方式现在官方已经宣布过时了,选择下面任意一个都可以  185.199.108.153185.199.109.153185.199.110.153185.199.111.153 解析第二个设置    github 要做的事
  创建 CNAME文件,写入www.zhouchenghua.com
   这个是我设置github project 设置截图   ping 地址  C:\Users\noatn&amp;gt;ping www.github.com正在 Ping github.com [13.250.177.223] 具有 32 字节的数据:请求超时。请求超时。请求超时。请求超时。13.</description>
    </item>
    
    <item>
      <title>git处理网络和权限问题</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/git_andsower/git%E5%A4%84%E7%90%86/</link>
      <pubDate>Sun, 17 Jan 2021 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/git_andsower/git%E5%A4%84%E7%90%86/</guid>
      <description>Push master to origin/master was rejected by remote  有三种原因1:push的这个工程是其他人新建的，找她开通master权限后，再次push2:git 工程错误git pullgit pull origin mastergit pull origin master --allow-unrelated-histories3:github 设置原因勾选了Keep my email addresses private解决办法2种第一种 通知账户人员取消勾选第二种重新设置你的全局用户E-mailgit config --list 查看这个时候一定不对因此重新设置全局email重置上次提交的作者信息 git commit --amend --reset-authorgit config --global user.name &amp;quot;zch&amp;quot;git config --global user.email &amp;quot;sdhshd@163.com&amp;quot;ok对了你如果使用的不是idea而是git那么抛出的错误非常明显如果抛出git报错--&amp;gt;! [remote rejected] master -&amp;gt; master (push declined due to email privacy restrictions)那么一定是这个原因 git clone时报RPC failed; curl 18 transfer closed with outstanding read data remaining 错误  原因1：缓存区溢出git config http.</description>
    </item>
    
    <item>
      <title>idea 解决working directory 设置到 target</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/idea/idea/</link>
      <pubDate>Sun, 17 Jan 2021 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/idea/idea/</guid>
      <description> idea 解决working directory 设置到 target  test ng D:\IdeaProjects\java-se-studyrun config $MODULE_DIR$</description>
    </item>
    
    <item>
      <title>idea 问题解决</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/maven/idea%E8%A7%A3%E5%86%B3/</link>
      <pubDate>Sun, 17 Jan 2021 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/maven/idea%E8%A7%A3%E5%86%B3/</guid>
      <description>idea导入项目出现Unable to import maven project: See logs for details提示
 第一种解决办法#  删除项目根目录下.idea文件夹
  关闭idea工具，重新打开选择File-&amp;gt;New-&amp;gt;Project from the existing source ,选择刚才的项目根目，下一步：
  一直点next，最后点击主工程的pom.xml 完成！
  第二种#  打开idea 的日志文件如果发现【Error】com.google.inject.CreationException: Unable to create injector
  那么自定义配置Maven3.6.2报错 或者更高版本maven
  原因：Maven3.6.2的版本兼容问题。
  解决方法：重新下载较低版本Maven3.6.1及以下版本可以顺利解决。
  用maven无论是新建项目还是导入没有下载到本地仓库的jar。出现了Unable to import maven project
  打开cmd，ping localhost，显示一般故障
  在左边控制栏，关闭防火墙，再开启防火墙 再次ping localhost，成功
  对了 假如出现文件权限问题 那么更改maven的本地仓库地址</description>
    </item>
    
    <item>
      <title>Visual Studio Code 问题解决方案</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/visual_studio_code/visualstudiocode%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 17 Jan 2021 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/visual_studio_code/visualstudiocode%E9%97%AE%E9%A2%98/</guid>
      <description>Visual Studio Code 过滤文件 不显示某些文件#效果# 过滤工程中显示的文件 不显示某些类型的文件或文件夹  菜单# File/Preferences/ 搜索file exclude 选中workspack页签 添加一个过滤规则 如图:   </description>
    </item>
    
    <item>
      <title>如何在油管YouTube开通收益赚钱</title>
      <link>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%8E%B7%E5%8F%96%E9%87%91%E9%92%B1/%E5%A6%82%E4%BD%95%E5%9C%A8%E6%B2%B9%E7%AE%A1youtube%E5%BC%80%E9%80%9A%E6%94%B6%E7%9B%8A%E8%B5%9A%E9%92%B1/</link>
      <pubDate>Sun, 17 Jan 2021 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%8E%B7%E5%8F%96%E9%87%91%E9%92%B1/%E5%A6%82%E4%BD%95%E5%9C%A8%E6%B2%B9%E7%AE%A1youtube%E5%BC%80%E9%80%9A%E6%94%B6%E7%9B%8A%E8%B5%9A%E9%92%B1/</guid>
      <description>如何在油管YouTube开通收益赚钱？#如果想在YouTube创业赚取美金，建议关注【YouTube运营笔记】，少走弯路，不被忽悠
本篇主要由3个常见问题详细展开：# 如何在油管上开通获利？ 油管广告收益情况如何？ 油管除了广告还能怎么赚钱？  一、如何在YouTube开通获利？#第1步：你得有一个Gmail账号# YouTube账号是跟谷歌邮箱账号是关联的。想创建频道然后上传视频的基础条件就是，注册并登陆谷歌账号，目前一些国内手机注册会失败。   注：Gmail能登录就行，手机号码归属和注册地对后期收益不存在影响。
 第2步：你得有一个YouTube频道# 一般而言只要你有了谷歌账号，就默认有一个YouTube频道了，但那个频道名称头像是跟谷歌邮箱是挂钩的，建议单独创建频道。此外，一个谷歌账号是创建多个频道的。   注：创建频道前，要想清楚频道的内容定位；频道创建后，还要对频道进行装修。
 第3步：你得有策略地上传视频# 这一步非常重要，YouTube运营是一个技术活，不是随随便便发几个视频就有人看，也不是坚持发布就能做起来。有志要做的建议查看本专栏的其它文章，这里不细讲。   注：做YouTube成功的条件是「优质的内容+正确的方法」，缺一不可
 第4步（重点）：你须达到获利门槛/申请开通# 想开通获利，必须满足以下条件：   1:选择支持YouTube合作伙伴计划的国家或地区。 2:12 个月内的有效观看时长累计超过4000小时。 3:频道拥有至少1000订阅。 4:拥有可关联的 AdSense 帐号。   其中，最为关键的同时最难的条件是4000小时和1000名订阅；「国家/地区」后台设置支持的国家/地区即可；「AdSense」是在频道达到获利门槛后显示注册入口，看似简单却最容易出错，资料要仔细填写，一旦填错后续非常麻烦。《YouTube运营新手最常踩5大坑，最后1个最坑人！》 除了订阅者数量和观看次数要求外，还有内容要求。获利申请的审核是官方人工审核，如果审核者认为频道或视频不符合条件，也是容易无法通过的，审核时间快则一两天，慢的一个多月也有。《YouTube获利政策：这11类内容没有收益》  二、油管广告收益情况如何？# YouTube将部分广告收入（55%）分给相应的Youtuber，就能构成一个良性循环的三赢局面：广告商得到宣传，Youtuber赚钱，油管平台赚钱同时有源源不断的优质内容创作出来。平台把55%的广告收益分给视频创作者，这对自媒体从业者而言，真不算低。    YouTube的千次播放（CPM）的收益差距略大，一般在1-10美元不等。影响视频收益主要因素包括：</description>
    </item>
    
    <item>
      <title>hugo教程 hugo server Failed to get JSON</title>
      <link>https://huachengzhou.github.io/life/docs/hugo%E5%AD%A6%E4%B9%A0/hugo_server_faile_-to_get_json/</link>
      <pubDate>Tue, 17 Oct 2017 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/hugo%E5%AD%A6%E4%B9%A0/hugo_server_faile_-to_get_json/</guid>
      <description>今天尝试了一下静态博客 hugo , hugo的官网本身也是使用 hugo 制作的网站。安装和运行非常简单。只有两个步骤安装和运行。运行的时候出现了一个小问题，就是由于网络的原因不能启动成功。
 粗暴的禁用网络连接相关的操作# 就是两个 短代码 给删除了 instagram, tweet。  find . -name &amp;amp;quot;*.md&amp;amp;quot; | xargs sed -i &amp;amp;#x27;/{{&amp;amp;lt; instagram/cinstagram content&amp;amp;#x27;find . -name &amp;amp;quot;*.md&amp;amp;quot; | xargs sed -i &amp;amp;#x27;/{{&amp;amp;lt; tweet/ctwitter content&amp;amp;#x27;hugo server --bind &amp;amp;#x27;0.0.0.0&amp;amp;#x27; print code  ERROR 2021/03/06 09:55:20 Failed to get JSON resource &amp;quot;https://api.twitter.com/1/statuses/oembed.json?id=877500564405444608&amp;amp;dnt=false&amp;quot;: Get &amp;quot;https://api.twitter.com/1/statuses/oembed.json?id=877500564405444608&amp;amp;dnt=false&amp;quot;: dial tcp 31.13.91.33:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.</description>
    </item>
    
    <item>
      <title>hugo教程1</title>
      <link>https://huachengzhou.github.io/life/docs/hugo%E5%AD%A6%E4%B9%A0/hugo_tutorials1/</link>
      <pubDate>Tue, 17 Oct 2017 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/hugo%E5%AD%A6%E4%B9%A0/hugo_tutorials1/</guid>
      <description>教程1#快速开始# 步骤1：安装Hugo  brew install hugo# orport install hugo 要验证新安装  hugo version 步骤2：建立新网站  hugo new site quickstart# 上面的代码将在名为的文件夹中创建一个新的Hugo网站quickstart。 步骤3：添加主题  # 首先，从GitHub下载主题并将其添加到您站点的themes目录中：cd quickstartgit initgit submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke 然后，将主题添加到站点配置中：  echo &#39;theme = &amp;quot;ananke&amp;quot;&#39; &amp;gt;&amp;gt; config.toml 步骤4：添加一些内容  hugo new posts/my-first-post.md 如果需要，请编辑新创建的内容文件，该文件将从以下内容开始：   ---title: &amp;quot;My First Post&amp;quot;date: 2019-03-26T08:47:11+01:00draft: true--- 步骤5：启动Hugo服务器  ▶ hugo server -D| EN+------------------+----+Pages | 10Paginator pages | 0Non-page files | 0Static files | 3Processed images | 0Aliases | 1Sitemaps | 1Cleaned | 0Total in 11 msWatching for changes in /Users/bep/quickstart/{content,data,layouts,static,themes}Watching for config changes in /Users/bep/quickstart/config.</description>
    </item>
    
    <item>
      <title>hugo教程2</title>
      <link>https://huachengzhou.github.io/life/docs/hugo%E5%AD%A6%E4%B9%A0/hugo_tutorials2/</link>
      <pubDate>Tue, 17 Oct 2017 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/hugo%E5%AD%A6%E4%B9%A0/hugo_tutorials2/</guid>
      <description>教程2# 1、	创建blog  hugo new site myblog_pubcd myblog_pub/git submodule add https://github.com/chinanf-boy/gohugo-theme-yinwang.git themes/yinwang  2、	修改配置
  vi config.toml
  root@instance-x8rtph4n:/home/go/code/hugo_dir/myblog_pub/public# more ../config.toml baseURL = &amp;quot;http://ypbsyy.github.io/&amp;quot;languageCode = &amp;quot;en-us&amp;quot;title = &amp;quot;我是yaopeng&amp;quot;theme = &amp;quot;yinwang&amp;quot;#pygmentsCodeFences = true#pygmentsCodefencesGuessSyntax = false#pygmentsStyle = &amp;quot;dracula&amp;quot;#pygmentsOptions = [&#39;linenos&#39;]# 代码高亮/chroma，hugo默认自带[params]author = &amp;quot;yaopeng&amp;quot;github = &amp;quot;yaopeng&amp;quot;# gitlab = &amp;quot;yobrave&amp;quot;#googleAnalytics = &amp;quot;****&amp;quot;# 谷歌统计gtaghighlight = &amp;quot;dracula&amp;quot; # 默认样式 `github`langs = [&amp;quot;go&amp;quot;]# 默认加载 highlight.</description>
    </item>
    
    <item>
      <title>统一建模语言</title>
      <link>https://huachengzhou.github.io/life/posts/uml/</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/posts/uml/</guid>
      <description> 统一建模语言(Unified Modeling Language，UML)是一种为面向对象系统的产品进行说明、可视化和编制文档的一种标准语言，是非专利的第三代建模和规约语言。UML是面向对象设计的建模工具，独立于任何具体程序设计语言。
 UML作为一种统一的软件建模语言具有广泛的建模能力。UML是在消化、吸收、提炼至今存在的所有软件建模语言的基础上提出的，集百家之所长，它是软件建模语言的集大成者。UML还突破了软件的限制，广泛吸收了其他领域的建模方法，并根据建模的一般原理，结合了软件的特点，因此具有坚实的理论基础和广泛性。UML不仅可以用于软件建模，还可以用于其他领域的建模工作。 [1]#UML立足于对事物的实体、性质、关系、结构、状态和动态变化过程的全程描述和反映。UML可以从不同角度描述人们所观察到的软件视图，也可以描述在不同开发阶段中的软件的形态。UML可以建立需求模型、逻辑模型、设计模型和实现模型等，但UML在建立领域模型方面存在不足，需要进行补充。 [1]#作为一种建模语言，UML有严格的语法和语义规范。UML建立在元模型理论基础上，包括4层元模型结构，分别是基元模型、元模型、模型和用户对象。4层结构层层抽象，下一层是上一层的实例。UML中的所有概念和要素均有严格的语义规范。 [1]#UML采用一组图形符号来描述软件模型，这些图形符号具有简单、直观和规范的特点，开发人员学习和掌握起来比较简单。所描述的软件模型，可以直观地理解和阅读，由于具有规范性，所以能够保证模型的准确、一致。#</description>
    </item>
    
    <item>
      <title>项目管理</title>
      <link>https://huachengzhou.github.io/life/posts/project-management/</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/posts/project-management/</guid>
      <description>项目管理（Project Management,PM/Management by Projects,MBP）#项目管理概述#项目管理是项目的管理者，在有限的资源约束下，运用系统的观点、方法和理论，对项目涉及的全部工作进行有效地管理。即从项目的投资决策开始到项目结束的全过程进行计划、组织、指挥、协调、控制和评价，以实现项目的目标。#按照传统的做法，当企业设定了一个项目后，参与这个项目的至少会有好几个部门，包括财务部门、市场部门、行政部门等等，而不同部门在运作项目过程中不可避免地会产生摩擦，须进行协调，而这些无疑会增加项目的成本，影响项目实施的效率。#而项目管理的做法则不同。不同职能部门的成员因为某一个项目而组成团队，项目经理则是项目团队的领导者，他们所肩负的责任就是领导他的团队准时、优质地完成全部工作，在不超出预算的情况下实现项目目标。项目的管理者不仅仅是项目执行者，他参与项目的需求确定、项目选择、计划直至收尾的全过程，并在时间、成本、质量、风险、合同、采购、人力资源等各个方面对项目进行全方位的管理，因此项目管理可以帮助企业处理需要跨领域解决的复杂问题，并实现更高的运营效率。#项目管理的应用从80年代仅限于建筑、国防、航天等行业迅速发展到今天的计算机、电子通讯、金融业甚至政府机关等众多领域。#人们通常认为，项目管理是第二次世界大战的产物（如：曼哈顿计划）。在1950年至1980年期间，应用项目管理的主要是国防建设部门和建筑公司。传统的观点认为，项目管理者的工作就是单纯地完成既定的任务。#从本世纪八十年代开始，项目管理的应用扩展到其他工业领域（行业），如制药行业、电信部门、软件开发业等。项目管理者也不再被认为仅仅是项目的执行者，要求他们能胜任其它各个领域的更为广泛的工作，同时具有一定的经营技巧。美国项目管理学会（PMI）已提出了关于一个有效的专业项目管理者必须具备的几个方面的基本能力：# 项目范围管理 项目时间管理 项目费用管理 项目质量管理 项目人力资源管理 项目沟通管理 项目风险管理 项目采购管理 项目综合管理  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://huachengzhou.github.io/life/docs/javadir/groovy/groovy%E5%8F%98%E9%87%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/groovy/groovy%E5%8F%98%E9%87%8F/</guid>
      <description>Groovy 变量# Groovy中的变量可以通过两种方式定义 - 使用数据类型的本地语法，或者使用def关键字。对于变量定义，必须明确提供类型名称或在替换中使用“def”。这是Groovy解析器需要的。
   byte - 这用于表示字节值。例如2。
  short - 用于表示一个短数。例如10。
  int - 这用于表示整数。 例如1234。
  long - 这用于表示一个长数。例如10000090。
  float - 用于表示32位浮点数。例如12.34。
  double - 这用于表示64位浮点数。例如12.3456565。
  char - 这定义了单个字符文字。例如&amp;rsquo;a&#39;。
  Boolean - 这表示一个布尔值，可以是true或false。
  String - 这是以字符串形式表示的文本。 例如“Hello World”。
  Groovy还允许其他类型的变量，如数组，结构和类
  变量声明# title: &amp;quot; groovy变量 &amp;quot; date: 2021-04-15 draft: false weight: 3#  变量声明告诉编译器为变量创建存储的位置和大小。</description>
    </item>
    
  </channel>
</rss>
