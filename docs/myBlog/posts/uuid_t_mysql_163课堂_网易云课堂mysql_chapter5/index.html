<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>blog | 网易云课堂MySQL &gt; chapter5</title>
    <meta name="description" content="测试博客 ">
    <link rel="canonical" href="https://huachengzhou.github.io/life/posts/uuid_t_mysql_163%E8%AF%BE%E5%A0%82_%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter5/" />
    <link rel="icon" type="image/x-icon" href='./../../images/favicon.ico' />
    <link rel="stylesheet" href='./../../css/style.css' />


    <meta property="og:title" content="网易云课堂MySQL &gt; chapter5" />
<meta property="og:description" content="测试博客" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://huachengzhou.github.io/life/posts/uuid_t_mysql_163%E8%AF%BE%E5%A0%82_%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-15T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2021-02-15T00:00:00&#43;00:00" />


    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="网易云课堂MySQL &gt; chapter5"/>
<meta name="twitter:description" content="测试博客"/>

    
        
    
    <link rel="stylesheet" href='./../../css/style.css' />
    <link rel="stylesheet" href='./../../css/search.css' />
    <link rel="stylesheet" href='./../../css/list.css' />
    <link rel="stylesheet" href='./../../css/terms.css' />
    <link rel="stylesheet" href='./../../css/taxonomy.css' />
    <link rel="stylesheet" href='./../../css/home.css' />
    <link rel="stylesheet" href='./../../css/syntax.css' />
    
    <link rel="stylesheet" href='./../../css/shortcode.css' />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    
    <link rel="stylesheet" href='./../../css/_custom.css' />
    <style>
        
    </style>
    
    
    <script>
    MathJax = {
      tex: {
        inlineMath: [["$", "$"]],
      },
      displayMath: [
        ["$$", "$$"],
        ["\[\[", "\]\]"],
      ],
      svg: {
        fontCache: "global",
      },
    };
  </script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script
    id="MathJax-script"
    async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
  ></script>


    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script async=""  src='./../../js/lazysizes.min.js' ></script>
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    <script  src='./../../js/search.js' ></script>
    <script  src='./../../js/yes.js' ></script>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
</head>
<body style="font-family: ,'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'Heiti SC', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;">
        <div class="loading">
            <div class="loading-bg"></div>
            <div class="loading-long">
                <div class="loading-short"></div>
            </div>
        </div>

        <header>
    <nav class="navbar">
        <div class="navbar-brand">
            <a href="/">
                <span class="logo">blog</span>
            </a>
        </div>
        <div class="navbar-menu">
            
                <a href="./../..//">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-home'></i> 主页</div>
                        </div>
                    </div>
                </a>
            
                <a href="./../../posts">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-book'></i> 文章</div>
                        </div>
                    </div>
                </a>
            
                <a href="./../..//categories">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-folder-open'></i> 分类</div>
                        </div>
                    </div>
                </a>
            
                <a href="./../..//tags">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-tags'></i> 系列</div>
                        </div>
                    </div>
                </a>
            
                <a href="./../..//about">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-info-circle'></i> 关于</div>
                        </div>
                    </div>
                </a>
            
                <a href="">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"> docs</div>
                        </div>
                    </div>
                </a>
            
            <div class="navbar-burger">
                <div class="burger-btn"><span><i class="fa fa-navicon"></i></span></div>
            </div>
            
            
            <div class="search-in"><span><i class="fa fa-search"></i></span></div>
            
                <div class="mode">
                    <span class="sun"><i class="fa fa-sun-o"></i></span>
                    <span class="moon"><i class="fa fa-moon-o"></i></span>
                </div>
            
        </div>
    </nav>
    <div class="burger-items">
        
        <a href="./../..//">
            <div class="burger-item">
                <i class='fa fa-home'></i> 主页
            </div>
        </a>
        
        <a href="./../../posts">
            <div class="burger-item">
                <i class='fa fa-book'></i> 文章
            </div>
        </a>
        
        <a href="./../..//categories">
            <div class="burger-item">
                <i class='fa fa-folder-open'></i> 分类
            </div>
        </a>
        
        <a href="./../..//tags">
            <div class="burger-item">
                <i class='fa fa-tags'></i> 系列
            </div>
        </a>
        
        <a href="./../..//about">
            <div class="burger-item">
                <i class='fa fa-info-circle'></i> 关于
            </div>
        </a>
        
        <a href="">
            <div class="burger-item">
                 docs
            </div>
        </a>
        
    </div>
    <div class="header-rest"></div>
</header>


        <div id="content">








    <div class="hero">
        
            <div class="hero-img">
                <img class="lazyload"  src='./../../images/thumbnail.gif' data-src="./../../images/default.jpg" alt="">
            </div>
        
        <div class="hero-content">
            <div class="hero-title">网易云课堂MySQL &gt; chapter5</div>
            <div class="hero-subtitle"></div>
            <div class="hero-date">
                    <span class="no-wrap"><i class="fa fa-calendar"></i> postedOn: 2021-2-15 &nbsp;</span>
                    <span class="no-wrap"><i class="fa fa-calendar-check-o"></i> updatedOn: 2021-2-15 &nbsp;</span>
                    <span class="no-wrap"><i class="fa fa-folder"></i>
                        includedIn:
                        
                            <a href='
                                /life/categories/mysql
                            '>
                                mysql
                            </a>, 
                            <a href='
                                /life/categories/index
                            '>
                                index
                            </a>
                    </span>
            </div>
            <div class="timelong">
                <span class="no-wrap"><i class="fa fa-pencil"></i> wordsCount: 6855 &nbsp;</span>
                <span class="no-wrap"><i class="fa fa-clock-o"></i> readingTime: 14 mins &nbsp;</span>
                <span class="no-wrap"><i class="fa fa-eye"></i> viewers: <span id="busuanzi_value_page_pv"></span></span>
            </div>
        </div>
    </div>




<div class="zhuti-0">
    <div class="container">
        <div class="zhuti">
            <div class="zhuti-l">
                




    


<div class="content-root">
    <div class="long">
        <button class="tosides-1 text-wbd">
            <i class="fa fa-arrow-right"></i>
        </button>
        <button class="tosides-2 text-wbd">
            <i class="fa fa-arrow-left"></i>
        </button>
        <button class="toup text-wbd">
            <i class="fa fa-arrow-up"></i>
        </button>
    </div>
    
        <div class="content">
            <div class="content-self">
                <h1 id="mysql运维实践">MySQL运维实践</h1>
<h2 id="51-mysql日志系统">5.1-MySQL日志系统</h2>
<h3 id="什么是日志">什么是日志</h3>
<ul>
<li>日志(log)是一种顺序记录事件流水的文件</li>
<li>记录计算机程序运行过程中发生了什么</li>
<li>多种多样的用途
<ul>
<li>帮助分析程序问题</li>
<li>分析服务请求的特征、流量等</li>
<li>判断工作是否成功执行</li>
<li>等等……</li>
</ul>
</li>
</ul>
<h3 id="mysql日志的分类">MySQL日志的分类</h3>
<ul>
<li>服务器日志
<ul>
<li>记录进程启动运行过程中的特殊事件，帮助分析MySQL服务遇到的问题</li>
<li>根据需求抓取特定的SQL语句，追踪性能可能存在的问题的业务SQL</li>
</ul>
</li>
<li>事务日志
<ul>
<li>记录应用程序对数据的所有更改</li>
<li>可用于数据恢复</li>
<li>可用于实例间数据同步</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">日志名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">服务器日志</td>
<td style="text-align:left">服务错误日志</td>
</tr>
<tr>
<td style="text-align:left">服务器日志</td>
<td style="text-align:left">慢查询日志</td>
</tr>
<tr>
<td style="text-align:left">服务器日志</td>
<td style="text-align:left">综合查询日志</td>
</tr>
<tr>
<td style="text-align:left">事务日志</td>
<td style="text-align:left">存储引擎事务日志</td>
</tr>
<tr>
<td style="text-align:left">事务日志</td>
<td style="text-align:left">二进制日志</td>
</tr>
</tbody>
</table>
<h3 id="服务错误日志">服务错误日志</h3>
<ul>
<li>记录实例启动运行过程中重要消息</li>
<li>配置参数
<ul>
<li><code>log_error = /data/mysql_data/node-1/mysql.log</code></li>
</ul>
</li>
<li>内容并非全是错误消息</li>
<li>如果mysqld进程无法正常启动首先查看错误日志</li>
</ul>
<h3 id="慢查询日志">慢查询日志</h3>
<ul>
<li>记录执行时间超过一定阈值的SQL语句</li>
<li>配置参数</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">slow_query_log</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="w"></span><span class="n">slow_query_log_file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">/</span><span class="k">data</span><span class="o">/</span><span class="n">mysql_data</span><span class="o">/</span><span class="n">node</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">mysql</span><span class="o">-</span><span class="n">slow</span><span class="p">.</span><span class="n">log</span><span class="w">
</span><span class="w"></span><span class="n">long_query_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>用于分析系统中可能存在性能问题的SQL</li>
</ul>
<h3 id="综合查询日志">综合查询日志</h3>
<ul>
<li>如果开启将会记录系统中所有SQL语句</li>
<li>配置参数</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">general_log</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="w"></span><span class="n">general_log_file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">/</span><span class="k">data</span><span class="o">/</span><span class="n">mysql_data</span><span class="o">/</span><span class="n">node</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">mysql</span><span class="o">-</span><span class="n">slow</span><span class="p">.</span><span class="n">log</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>偶尔用于帮助分析系统问题，对性能有影响</li>
</ul>
<h3 id="查询日志的输出与文件切换">查询日志的输出与文件切换</h3>
<ul>
<li>日志输出参数</li>
</ul>
<p><code>log_output={file|table|none}</code></p>
<ul>
<li>如果日志文件过大，可以定期截断并切换新文件</li>
</ul>
<p><code>flush log;</code></p>
<h3 id="存储引擎事务日志">存储引擎事务日志</h3>
<ul>
<li>部分存储引擎拥有重做日志(redo log)</li>
<li>如InnoDB, TokuDB等WAL(Write Ahead Log)机制存储引擎</li>
<li>日志随着事务commit优先持久化，确保异常恢复不丢数据</li>
<li>日志顺序写性能较好</li>
</ul>
<h3 id="innodb事务日志重用机制">InnoDB事务日志重用机制</h3>
<ul>
<li>InnoDB事务日志采用两组文件交替重用</li>
</ul>
<h3 id="二进制日志binlog">二进制日志binlog</h3>
<ul>
<li>binlog (binary log)</li>
<li>记录数据引起数据变化的SQL语句或数据逻辑变化的内容</li>
<li>MySQL服务层记录，无关存储引擎</li>
<li>binlog的主要作用：
<ul>
<li>基于备份恢复数据</li>
<li>数据库主从同步</li>
<li>挖掘分析SQL语句</li>
</ul>
</li>
</ul>
<h3 id="开启binlog">开启binlog</h3>
<ul>
<li>主要参数</li>
</ul>
<pre><code>log_bin = c:/tmp/mylog/mysql-bin
sql_log_bin = 1
sync_binlog = 1
</code></pre><ul>
<li>查看binlog</li>
</ul>
<p><code>show binary logs;</code></p>
<h3 id="binlog管理">binlog管理</h3>
<ul>
<li>主要参数</li>
</ul>
<pre><code>max_binlog_size = 100MB
expire_logs_days = 7
</code></pre><ul>
<li>
<p>binlog始终生成新文件，不会重用</p>
</li>
<li>
<p>手工清理binlog</p>
</li>
</ul>
<pre><code>purge binary logs to 'mysql-bin.000009';
purge binary logs before '2016-4-2 21:00:40'
</code></pre><h3 id="查看binlog内容">查看binlog内容</h3>
<ul>
<li>日志</li>
</ul>
<pre><code>show binlog events in 'mysql-bin.000011';
show binlog events in 'mysql-bin.000011' from 60 limit 3;
</code></pre><ul>
<li>mysqlbinlog工具</li>
</ul>
<pre><code>mysqlbinlog c:/tmp/mylog/mysql-bin.000001
--start-datetime | --stop-datetime
--start-position | --stop-position
</code></pre><h3 id="binlog格式">binlog格式</h3>
<ul>
<li>主要参数</li>
</ul>
<p><code>binlog_format = {ROW|STATEMENT|MIXED}</code></p>
<ul>
<li>查看row模式的binlog内容</li>
</ul>
<p><code>mysqlbinlog --base64-output=decode-rows -v c:/tmp/mylpg/mysql-bin.000001</code></p>
<h2 id="52-mysql数据备份">5.2-MySQL数据备份</h2>
<h3 id="基本指数---备份用途">基本指数 - 备份用途</h3>
<ul>
<li>数据备灾
<ul>
<li>应对硬件故障数据丢失</li>
<li>应对人为或程序bug导致数据删除</li>
</ul>
</li>
<li>制作镜像库以供服务
<ul>
<li>需要将数据迁移、统计分析等用处</li>
<li>需要为线上数据建立一个镜像</li>
</ul>
</li>
</ul>
<h3 id="基本知识---备份内容">基本知识 - 备份内容</h3>
<ul>
<li>数据
<ul>
<li>数据文件或文本格式数据</li>
</ul>
</li>
<li>操作日志(binlog)
<ul>
<li>数据库变更日志</li>
</ul>
</li>
</ul>
<h3 id="基本知识---冷备份与热备份">基本知识 - 冷备份与热备份</h3>
<ul>
<li>冷备份
<ul>
<li>关闭数据库服务，完整拷贝数据文件</li>
</ul>
</li>
<li>热备份
<ul>
<li>在不影响数据库读写服务的情况下备份数据库</li>
</ul>
</li>
</ul>
<h3 id="基本知识---物理备份与逻辑备份">基本知识 - 物理备份与逻辑备份</h3>
<ul>
<li>物理备份
<ul>
<li>以数据页的形式拷贝数据</li>
</ul>
</li>
<li>逻辑备份
<ul>
<li>导出为裸数据或者SQL(insert)语句</li>
</ul>
</li>
</ul>
<h3 id="基本知识---本地备份与远程备份">基本知识 - 本地备份与远程备份</h3>
<ul>
<li>本地备份
<ul>
<li>在数据库服务器本地进行备份</li>
</ul>
</li>
<li>远程备份
<ul>
<li>远程连接数据库进行备份</li>
</ul>
</li>
</ul>
<h3 id="基本知识---全量备份与增量备份">基本知识 - 全量备份与增量备份</h3>
<ul>
<li>全量备份
<ul>
<li>备份完整的数据库</li>
</ul>
</li>
<li>增量备份
<ul>
<li>只备份上一次备份以来发生修改的数据</li>
</ul>
</li>
</ul>
<h3 id="基本知识---备份周期">基本知识 - 备份周期</h3>
<p>考虑因素：</p>
<ul>
<li>数据库大小(决定备份时间)</li>
<li>恢复速度要求(快速or慢速)</li>
<li>备份方式(全量or增量)</li>
</ul>
<h3 id="常用工具及用法">常用工具及用法</h3>
<ul>
<li>mysqldump - 逻辑备份，热备</li>
<li>xtrabackup - 物理备份， 热备</li>
<li>Lvm/zfs snapshot - 物理备份</li>
<li>mydumper - 逻辑备份，热备</li>
<li>cp - 物理备份，冷备</li>
</ul>
<h3 id="常用工具及用法---mysqldump">常用工具及用法 - mysqldump</h3>
<p>MySQL官方自带的命令行工具</p>
<p>主要示例：</p>
<ul>
<li>演示使用mysqldump备份表、库、实例</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 备份所有数据库</span>
mysqldump -uroot -p123456 --socket<span class="o">=</span>/var/run/mysqld/mysqld.sock --all-databases &gt; /dbbackup/all_db.sql
<span class="c1"># 备份指定的数据库</span>
mysqldump -uroot -p123456 --socket<span class="o">=</span>/var/run/mysqld/mysqld.sock --databases db2 &gt; /dbbackup/db2.sql
<span class="c1"># 备份单个表</span>
mysqldump -uroot -p123456 --socket<span class="o">=</span>/var/run/mysqld/mysqld.sock db2 t1 &gt;/dbbackup/db2_t1.sql
<span class="c1"># 还原表</span>
mysql &gt; <span class="nb">source</span> /dbbackup/db2_t1.sql
</code></pre></td></tr></table>
</div>
</div><ul>
<li>演示使用mysqldump制作一致性备份</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">mysqldump --single-transaction -uroot -p123456 --all-databases &gt; /dbbackup/add_db_2.sql
</code></pre></td></tr></table>
</div>
</div><ul>
<li>演示使用mysqldump远程备份一个数据库</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">mysqldump -utest -ptest -h192.168.0.68 -P3306 --all-databases &gt; /dbbackup/remote_bakall.sql
</code></pre></td></tr></table>
</div>
</div><ul>
<li>演示使用mysqldump导出数据为csv格式</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">mysqldump -uroot -p123456 --single-transaction --fields-terminated-by<span class="o">=</span>, db1 -T /tmp
</code></pre></td></tr></table>
</div>
</div><h3 id="常用工具及用法---xtrabackup">常用工具及用法 - xtrabackup</h3>
<p>特点：</p>
<ul>
<li>开源，在线备份InnoDB表</li>
<li>支持限速备份，避免对业务造成影响</li>
<li>支持流备</li>
<li>支持增量备份</li>
<li>支持备份文件压缩与加密</li>
<li>支持并行备份与恢复，速度快</li>
</ul>
<h3 id="xtrabackup备份原理">xtrabackup备份原理</h3>
<ul>
<li>基于InnoDB的crash-recovery功能</li>
<li>备份期间允许用户读写，写请求产生redo日志</li>
<li>从磁盘上拷贝数据文件</li>
<li>从InnoDB redo log file实时拷贝走备份期间产生的所有redo日志</li>
<li>恢复的时候 数据文件 + redo日志 = 一致性数据</li>
</ul>
<h3 id="实用脚本innobackupex">实用脚本innobackupex</h3>
<ul>
<li>开源Perl脚本，封装调用xtrabackup及一系列相关工具与OS操作，最终完成备份过程</li>
<li>支持备份InnoDB和其他引擎的表</li>
<li>备份一致性保证</li>
</ul>
<h3 id="innobackupex备份基本流程">innobackupex备份基本流程</h3>
<p>start xtrabackup_log -&gt; copy .ibd; ibdata1 -&gt; FLUSH TABLE WITH READ LOCK -&gt; copy .FRM; MYD; MYI; misc files -&gt; Get binary log position -&gt; UNLOCK TABLES -&gt; stop and copy xtrabackup_log</p>
<h3 id="innobackupex使用">innobackupex使用</h3>
<p>主要示例：</p>
<ul>
<li>全量备份</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">innobackupex --user<span class="o">=</span>root --password<span class="o">=</span><span class="m">123456</span> --defaults-file<span class="o">=</span>/etc/mysql/my.cnf /dbbackup
</code></pre></td></tr></table>
</div>
</div><ul>
<li>增量备份</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">innobackupex --user<span class="o">=</span>root --password<span class="o">=</span><span class="m">123456</span> --defaults-file<span class="o">=</span>/etc/mysql/my.cnf --incremental --incremental-dir /dbbackup/2016-4-3_13:24:32 /dbbackup
</code></pre></td></tr></table>
</div>
</div><ul>
<li>流方式备份</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">innobackupex --user<span class="o">=</span>root --password<span class="o">=</span><span class="m">123456</span> --defaults-file<span class="o">=</span>/etc/mysql/my.cnf --stream<span class="o">=</span>xbstream /dbbackup/ &gt; /dbbackup/stream.bak
</code></pre></td></tr></table>
</div>
</div><ul>
<li>并行备份</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">innobackupex --user<span class="o">=</span>root --password<span class="o">=</span><span class="m">123456</span> --defaults-file<span class="o">=</span>/etc/mysql/my.cnf --parallel<span class="o">=</span><span class="m">4</span> /dbbackup/
</code></pre></td></tr></table>
</div>
</div><ul>
<li>限流备份</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">innobackupex --user<span class="o">=</span>root --password<span class="o">=</span><span class="m">123456</span> --defaults-file<span class="o">=</span>/etc/mysql/my.cnf --throttle<span class="o">=</span><span class="m">10</span> /dbbackup/
</code></pre></td></tr></table>
</div>
</div><ul>
<li>压缩备份</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">innobackupex --user<span class="o">=</span>root --password<span class="o">=</span><span class="m">123456</span> --defaults-file<span class="o">=</span>/etc/mysql/my.cnf --compress --compress-thread <span class="m">4</span> /dbbackup/
</code></pre></td></tr></table>
</div>
</div><h3 id="如何制定备份策略">如何制定备份策略</h3>
<p>需要考虑的因素</p>
<ul>
<li>数据库是不是都是innodb引擎表 -&gt; 备份方式，热备or冷备</li>
<li>数据量大小 -&gt; 逻辑备份or物理备份，全量or增量</li>
<li>数据库本地磁盘空间十分充足 -&gt; 备份到本地or远程</li>
<li>需要多块恢复 -&gt; 备份频率 小时or天</li>
</ul>
<h2 id="53-mysql数据恢复">5.3-MySQL数据恢复</h2>
<h3 id="什么时候需要恢复数据">什么时候需要恢复数据</h3>
<ul>
<li>硬件故障(如磁盘损坏)</li>
<li>人为删除(如误删除数据、被黑)</li>
<li>业务回滚(如游戏bug需要回档)</li>
<li>正常需求(如部署镜像库、查看历史某时刻数据)</li>
</ul>
<h3 id="数据恢复的必要条件">数据恢复的必要条件</h3>
<ul>
<li>有效备份</li>
<li>完整的数据库操作日志(binlog)</li>
</ul>
<h3 id="数据恢复思路">数据恢复思路</h3>
<ul>
<li>最新一次备份 + binlog恢复到故障时间点(适用于各种数据丢失场景)</li>
<li>挖掘最后一次备份到故障点之间的binlog获取相关SQL语句，构造反转SQL语句并应用到数据库(只是用于记录丢失，且binlog必须是row格式)</li>
</ul>
<h3 id="反转sql语句">反转SQL语句</h3>
<p>例：</p>
<p><code>t1(id primary key, a int)</code></p>
<p>反转SQL语句：</p>
<p><code>insert into t(id, a) values(1, 1)</code> -&gt; <code>delete t1 where id=1 and a=1</code>
<code>update t1 set a=5 where id=1</code> -&gt; <code>update t1 set a=1 where id=1</code>
<code>delete from t1 where id=1</code> -&gt; <code>insert into t(id, a) values(1, 1)</code></p>
<h3 id="数据库恢复工具与命令">数据库恢复工具与命令</h3>
<ul>
<li>mysqldump备份 -&gt; source恢复</li>
<li>xtrabackup备份 -&gt; xtrabackup恢复</li>
<li>binlog备份 -&gt; mysqlbinlog恢复</li>
</ul>
<h3 id="详细示例讲解">详细示例讲解</h3>
<ul>
<li>恢复某几条误删数据</li>
<li>恢复误删表、库</li>
<li>将数据库恢复到指定时间点</li>
</ul>
<h3 id="恢复误删除数据">恢复误删除数据</h3>
<p>case：误操作，删除数据忘记带完整条件，执行<code>delete from user where age &gt; 30 [and sex=male]</code></p>
<p>需求：将被删除的数据还原</p>
<p>恢复前提：完整的数据库操作日志(binlog)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">delete</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="k">user</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">sex</span><span class="o">=</span><span class="s1">&#39;female&#39;</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 首先需要找到binlog里的信息</span>
mysqlbinlog -vv mysql-bin.000001
<span class="c1"># 找出sql语句，然后写出反转sql语句</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="恢复误删表库">恢复误删表、库</h3>
<p>case：业务被黑，表被删除了(drop teble user)</p>
<p>需求：将表恢复</p>
<p>前提：备份 + 备份以来完整binlog</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">innobackupex --apply-log /dbbackup/filename
<span class="c1"># 查看binlog的位置点</span>
cat xtrabackup_binlog_info
<span class="c1"># 查看结束点</span>
mysqlbinlog -vv filename

mysqlbinlog -vv --start-position<span class="o">=</span><span class="m">2556990</span> -- stop-position<span class="o">=</span><span class="m">2776338</span>
mysqlbinlog -vv --start-position<span class="o">=</span><span class="m">2556990</span> -- stop-position<span class="o">=</span><span class="m">2776338</span> <span class="p">|</span> mysql -uroot -p123456 --sock<span class="o">=</span>/dbbackup/mysql_3309/mysqld.sock
</code></pre></td></tr></table>
</div>
</div><h3 id="课程小结">课程小结</h3>
<ul>
<li>恢复是已经非常苦逼的差事，尽量避免做。我们要做数据卫士而不是救火队员。(线上应该严格把控权限，数据变更操作应事先测试，操作时做好备份)</li>
<li>有效备份(+binlog)是重中之重，对数据库定期备份是必须的</li>
<li>备份是一切数据恢复的基础</li>
</ul>
<h2 id="54-mysql线上部署">5.4-MySQL线上部署</h2>
<h3 id="mysql线上部署">MySQL线上部署</h3>
<p>考虑因素：</p>
<ul>
<li>版本选择， 5.1、5.5还是5.6？</li>
<li>分支选择，官方社区版？ percona server？ Mariadb？</li>
<li>安装方式，包安装？二进制包安装？源码安装？</li>
<li>路径配置，参数配置(尽量模板化、标准化)</li>
<li>一个实例多个库 or 多个实例单个库？</li>
</ul>
<h3 id="二进制安装mysql">二进制安装MySQL</h3>
<ul>
<li>下载软件包</li>
<li>解压放到指定目录(比如/usr/local)</li>
<li>将MySQL目录放到PATH中</li>
<li>初始化实例，编辑配置文件并启动</li>
<li>账户安全设置</li>
</ul>
<h3 id="编译安装mysql">编译安装MySQL</h3>
<ul>
<li>下载MySQL源码安装包</li>
<li>安装必要包(make cmake bison-devel ncurses-devel build-essential)</li>
<li>Cmake配置MySQL编译选项，可以定制需要安装的功能</li>
<li>make &amp;&amp; make install</li>
<li>初始化实例，编辑配置文件并启动</li>
<li>账户安全设置</li>
</ul>
<h3 id="mysql升级">MySQL升级</h3>
<ul>
<li>下载MySQL5.6安装包并配置MySQL5.6安装包安装路径</li>
<li>关闭MySQL5.5实例，修改部分参数，使用MySQL5.6软件启动</li>
<li>执行MySQL5.6路径下mysql_upgrade脚本</li>
<li>验证是否成功升级</li>
</ul>
<h3 id="mysql多实例安装">MySQL多实例安装</h3>
<ul>
<li>部署好mysql软件</li>
<li>编辑多个配置文件，初始化多个实例</li>
<li>启动MySQL实例</li>
</ul>
<h3 id="mysql多实例部署">MySQL多实例部署</h3>
<p>为啥多实例部署？</p>
<ul>
<li>充分利用系统资源</li>
<li>资源隔离</li>
<li>业务、模块隔离</li>
</ul>
<h3 id="mysql线上安装小结">MySQL线上安装小结</h3>
<ul>
<li>根据需求选择合适的版本以及分支，建议使用或升级到较高版本5.5或5.6</li>
<li>如果需要定制MySQL功能的话，可以考虑编译安装，否则的话建议使用二进制包安装，比较省事</li>
<li>根据机器配置选择部署多个MySQL实例还是单个实例，机器配置非常好的话，建议部署多实例</li>
</ul>
<h2 id="55-mysql主从复制">5.5-MySQL主从复制</h2>
<h3 id="mysql主从复制">MySQL主从复制</h3>
<ul>
<li>一主一从</li>
<li>主主复制</li>
<li>一主多从</li>
<li>多主一从</li>
<li>联级复制</li>
</ul>
<h3 id="mysql主从复制用途">MySQL主从复制用途</h3>
<ul>
<li>实时灾备，用于故障切换</li>
<li>读写分离，提供查询服务</li>
<li>备份，避免影响业务</li>
</ul>
<h3 id="mysql主从复制部署">MySQL主从复制部署</h3>
<p>主从部署必要条件</p>
<ul>
<li>主库开启binlog日志(设置log-bin参数)</li>
<li>主从server-id不同</li>
<li>从库服务器能连通主库</li>
</ul>
<p>主从部署步骤：</p>
<ul>
<li>备份还原(mysqldump或xtrabackup)</li>
<li>授权(grant replication slave on <em>.</em>)</li>
<li>配置复制，并启动(change master to)</li>
<li>查看主从复制信息(show slave status\G)</li>
</ul>
<h3 id="mysql复制存在的问题">MySQL复制存在的问题</h3>
<p>存在的问题</p>
<ul>
<li>主机宕机后，数据可能丢失</li>
<li>从库只有一个sql thread，主库写压力大，复制很可能延时</li>
</ul>
<p>解决方法：</p>
<ul>
<li>半同步复制</li>
<li>并行复制</li>
</ul>
<h3 id="mysql-semi-sync半同步复制">MySQL semi-sync(半同步复制)</h3>
<p>半同步复制</p>
<ul>
<li>5.5集成到MySQL，以插件形式存在，需要单独安装</li>
<li>确保事务提交后binlog至少传输到一个从库</li>
<li>不保证从库应用完这个事务的binlog</li>
<li>性能有一定的降低，响应时间更长</li>
<li>网络异常或从库宕机，卡住主库，直到超时或从库恢复</li>
</ul>
<h3 id="mysql异步复制">MySQL异步复制</h3>
<p><img src="./sorence/images/04.png" alt="异步复制"></p>
<h3 id="mysql-semi-sync半同步复制-1">MySQL semi-sync(半同步复制)</h3>
<p><img src="./sorence/images/05.png" alt="半同步复制"></p>
<h3 id="配置mysql半同步复制">配置MySQL半同步复制</h3>
<p>只需一次：</p>
<p>主库：</p>
<p><code>INSTALL PLUGIN rpl_semi_sync_master SONAME 'semisync_master.so';</code></p>
<p>从库：</p>
<p><code>INSTALL PLUGIN rpl_semi_sync_slave SONAME 'semisync_slave.so';</code></p>
<p>动态设置：</p>
<p>主库：</p>
<p><code>SET GLOBAL rpl_semi_sync_master_enabled=1;</code>
<code>SET GLOBAL rpl_semi_sync_master_timeout=N;</code> master 延迟切异步</p>
<p>从库：</p>
<p><code>SET GLOBAL rpl_semi_sync_slave_enabled=1;</code></p>
<h3 id="配置mysql并行复制">配置MySQL并行复制</h3>
<p>并行复制</p>
<ul>
<li>社区版5.6中新增</li>
<li>并行是指从库多线程apply binlog</li>
<li>库级别并行应用binlog，同一个数据库更改还是串行的(5.7版并行复制基于事务组)</li>
</ul>
<p>设置</p>
<p><code>set global slave_parallel_workers=10;</code> 设置sql线程数为10</p>
<h3 id="联级复制">联级复制</h3>
<p>A -&gt; B -&gt; C</p>
<p>B中添加参数：
log_slave_updates
B将把A的binlog记录到自己的binlog日志中</p>
<h3 id="复制监控">复制监控</h3>
<p>查询从库状态：</p>
<p><code>show slave status\G</code></p>
<h3 id="复制出错处理">复制出错处理</h3>
<p>常见：1062(主键冲突) 1032(记录不存在)
解决：手动处理
或：
跳过复制出错
<code>set global sql_slave_skip_counter=1</code></p>
<h3 id="总结">总结</h3>
<ul>
<li>MySQL主从复制是MySQL高可用性、高性能(负载均衡)的基础</li>
<li>简单、灵活，部署方式多样，可以根据不同业务场景部署不同复制结构</li>
<li>MySQL主从复制目前也存在一些问题，可以根据需要部署复制增强功能来解决问题</li>
<li>复制过程中应该时刻监控复制状态，复制出错或延时可能给系统造成影响</li>
<li>MySQL复制是MySQL数据库工程师必知必会的一项基本技能</li>
</ul>
<h2 id="56-mysql日常运维">5.6-MySQL日常运维</h2>
<h3 id="dba运维工作">DBA运维工作</h3>
<p>日常</p>
<ul>
<li>导数据、数据修改、表结构变更</li>
<li>加权限、问题处理
其他</li>
<li>数据库选型部署、设计、监控、备份、优化等</li>
</ul>
<h3 id="导数据及注意事项">导数据及注意事项</h3>
<ul>
<li>数据最终形式(csv、sql文本 还是直接导入某库中)</li>
<li>导数据方法(mysqldump、select into outfile)</li>
<li>导数据注意事项
<ul>
<li>导出为csv格式需要file权限，而且只能数据库本地导</li>
<li>避免锁库锁表(mysqldump使用——single-transaction选项不锁表)</li>
<li>避免对业务造成影响，尽量在镜像库做</li>
</ul>
</li>
</ul>
<h3 id="数据修改及注意事项">数据修改及注意事项</h3>
<ul>
<li>修改前切记做好备份</li>
<li>开事务做，修改完检查好了再提交</li>
<li>避免一次 修改大量数据，可以分批修改</li>
<li>避免业务高峰期做</li>
</ul>
<h3 id="表结构变更注意事项">表结构变更注意事项</h3>
<ul>
<li>在低峰期做</li>
<li>表结构变更是否会有锁？(5.6包含online ddl功能)</li>
<li>使用pt-online-schema-change完成表结构变更
<ul>
<li>可以避免主从延时</li>
<li>可以避免负载过高，可以限速</li>
</ul>
</li>
</ul>
<h3 id="加权限及注意事项">加权限及注意事项</h3>
<ul>
<li>只给符合需求的最低权限</li>
<li>避免授权时修改密码</li>
<li>避免给应用账号super权限</li>
</ul>
<h3 id="问题处理数据库慢">问题处理(数据库慢？)</h3>
<ul>
<li>数据库慢在哪？</li>
<li>show processlist查看mysql连接信息</li>
<li>查看系统状态(iostat, top, vmstat)</li>
</ul>
<h3 id="小结">小结</h3>
<ul>
<li>日常工作比较简单，但是任何一个操作都可能影响线上服务</li>
<li>结合不同环境，不同要求选择最合适的方法处理</li>
<li>日常工作应该求稳不求快，保障线上稳定是DBA的最大责任</li>
</ul>
<h2 id="57-mysql参数调优">5.7-MySQL参数调优</h2>
<h3 id="为什么要调整参数">为什么要调整参数</h3>
<ul>
<li>不同服务器之间的配置、性能不一样</li>
<li>不同业务场景对数据的需求不一样</li>
<li>MySQL的默认参数只是个参考值，并不适合所有的应用场合</li>
</ul>
<h3 id="优化之前我们需要知道什么">优化之前我们需要知道什么</h3>
<ul>
<li>服务器相关的配置</li>
<li>业务相关的情况</li>
<li>MySQL相关的配置</li>
</ul>
<h3 id="服务器上需要关注哪些">服务器上需要关注哪些</h3>
<ul>
<li>硬件情况</li>
<li>操作系统版本</li>
<li>CPU、网卡节电模式</li>
<li>服务器numa设置</li>
<li>RAID卡缓存</li>
</ul>
<h3 id="磁盘调度策略-write-back">磁盘调度策略-write back</h3>
<ul>
<li>数据写入cache既返回，数据异步的从cache刷入存储介质</li>
</ul>
<h3 id="磁盘调度策略-write-through">磁盘调度策略-write through</h3>
<ul>
<li>数据同时写入cache和存储介质才返回写入成功</li>
</ul>
<h3 id="write-back-vs-write-through">Write Back VS Write Through</h3>
<ul>
<li>write Back 性能优于 Write Through</li>
<li>Write Through 比 Write Back安全性高</li>
</ul>
<h3 id="raid">RAID</h3>
<ul>
<li>RAID Redundant Array of Independent Disks
<ul>
<li>生产环境里一般不太会用裸设备，通常会使用RAID卡对一块盘或多块盘做RAID</li>
<li>RAID卡会预留一块内存，来保证数据高效存储与读取</li>
<li>常见的RAID类型有:RAID1、RAID0、RAID10和RAID5</li>
</ul>
</li>
</ul>
<h3 id="raid0-vs-raid1">RAID0 VS RAID1</h3>
<ul>
<li>RAID 0 - Block Striped. No Mirror. No Parity.</li>
<li>RAID 1 - Block Mirrored. No Stripe. No Parity.</li>
</ul>
<h3 id="raid5-vs-raid10">RAID5 VS RAID10</h3>
<ul>
<li>RAID 5 - Block Striped. Distributed Parity.(至少三块盘，每块里有两个数据块和一个校验块)</li>
<li>RAID 10 - Block Mirrored.(每两块盘做RAID1，然后再按组做RAID0，至少四块盘)</li>
</ul>
<h3 id="raid如何保证数据安全">RAID如何保证数据安全</h3>
<ul>
<li>BBU(Backup Battery Unit)
<ul>
<li>BBU保证在WB策略下，即使服务器发生掉电或者宕机，也能够将缓存数据写入到磁盘，从而保证数据的安全</li>
</ul>
</li>
</ul>
<h3 id="mysql有哪些注意事项">MySQL有哪些注意事项</h3>
<ul>
<li>MySQL的部署安装</li>
<li>MySQL的监控</li>
<li>MySQL参数调优</li>
</ul>
<h3 id="部署mysql的要求">部署MySQL的要求</h3>
<ul>
<li>推荐的MySQL版本: &gt;= MySQL5.5</li>
<li>推荐的MySQL存储引擎: InnoDB</li>
</ul>
<h3 id="系统调优的依据监控">系统调优的依据：监控</h3>
<ul>
<li>实时监控MySQL的slow log</li>
<li>实时监控数据库服务器的负载情况</li>
<li>实时监控MySQL内部状态值</li>
</ul>
<h3 id="通常关注哪些mysql-status">通常关注哪些MySQL Status</h3>
<ul>
<li>Com_Select/Update/Delete/Insert</li>
<li>Bytes_received/Bytes_sent</li>
<li>Buffer Pool Hit Rate</li>
<li>Threads_connected/Threads_created/Threads_running</li>
</ul>
<h3 id="mysql参数调优">MySQL参数调优</h3>
<ul>
<li>为什么要调整MySQL的参数
<ul>
<li>MySQL是通用数据库，但业务是多变的，默认参数无法满足所有业务需求</li>
<li>MySQL内部一些参数是在MySQL一些很老的版本时候做的，可能之前是做限流和保护用的，但随着机器性能的提高，这些保护类的参数可能会成为性能瓶颈</li>
</ul>
</li>
</ul>
<h3 id="读优化">读优化</h3>
<ul>
<li>合理利用索引对MySQL查询性能至关重要</li>
<li>适当的调整参数也能提升查询性能</li>
</ul>
<h3 id="innodb_buffer_pool_size">innodb_buffer_pool_size</h3>
<ul>
<li>InnoDB存储引擎自己维护一块内存区域完成新老数据的替换</li>
<li>内存越大越能缓存更多的数据</li>
</ul>
<h3 id="innodb_thread_concurrency">innodb_thread_concurrency</h3>
<ul>
<li>innoDB内部并发控制参数，设置为0代表不做控制</li>
<li>如果并发请求较多，参数设置较小，后进来的请求将会排队</li>
</ul>
<h3 id="写优化">写优化</h3>
<ul>
<li>表结构设计上使用自增字段作为表的主键</li>
<li>只对合适的字段加索引，索引太多影响写入性能</li>
<li>监控服务器磁盘IO情况，如果写延迟较大则需要扩容</li>
<li>选择正确的MySQL版本，合理设置参数</li>
</ul>
<h3 id="哪些参数有助于提高写入性能">哪些参数有助于提高写入性能</h3>
<ul>
<li>innoDB_flush_log_at_trx_commit &amp;&amp; sync_binlog</li>
<li>innodb log file size</li>
<li>innodb_io_capacity</li>
<li>innodb insert buffer</li>
</ul>
<h3 id="主要影响mysql写性能的两个参数">主要影响MySQL写性能的两个参数</h3>
<ul>
<li>innoDB_flush_log_at_trx_commit</li>
<li>sync_binlog</li>
</ul>
<h3 id="innodb_flush_log_at_trx_commit">innoDB_flush_log_at_trx_commit</h3>
<ul>
<li>控制InnoDB事务的刷新方式，一共有三个值：0,1,2
<ul>
<li>N=0 - 每隔一秒，把事务日志缓存区的数据写到日志文件中，以及把日志文件的数据刷新到磁盘上(高效，但不安全)</li>
<li>N=1 - 每个事务提交时候，把事务日志从缓存区写到日志文件中，并且刷新日志文件的数据到磁盘上，优先使用此模式保障数据安全性(低效，非常安全)</li>
<li>N=2 - 每事务提交的时候，把事务日志数据从缓存区写到日志文件中；每隔一秒，但不一定刷新到磁盘上，而是取决于操作系统的调度(高效，但不安全)</li>
</ul>
</li>
</ul>
<h3 id="sync_binlog">sync_binlog</h3>
<ul>
<li>控制每次写入Binlog，是否都需要进行一次持久化</li>
</ul>
<h3 id="如何保证事务的安全">如何保证事务的安全</h3>
<ul>
<li>innoDB_flush_log_at_trx_commit 和 sync_binlog都设为1</li>
<li>事务要和Binlog保证一致性</li>
</ul>
<p>(加锁)-&gt; xa_prepare, Fsync -&gt; Write And Fsync Binlog -&gt; InnoDB Commit, Fsync -&gt;(释放锁)</p>
<h3 id="串行有哪些问题">串行有哪些问题</h3>
<ul>
<li>SAS盘一般每秒只能有150~200个Fsync。</li>
<li>换算到数据库每秒只能执行50~60个事务</li>
</ul>
<h3 id="社区和官方的改进">社区和官方的改进</h3>
<ul>
<li>MariaDB提出改进，即使这两个参数都是1也能做到合并效果，性能得到了大幅提高。</li>
<li>官方吸收了MariaDB的思想，并在此基础上进行了改进，性能再次得到了提高</li>
</ul>
<p>Tips:</p>
<ul>
<li>官方在MySQL5.6版本之后才做了这个优化</li>
<li>Percona和MariaDB版本在MySQL5.5已经包含了这个优化</li>
</ul>
<h3 id="innodb-redo-log">InnoDB Redo log</h3>
<ul>
<li>Write ahead Log</li>
</ul>
<h3 id="redo-log的作用">Redo log的作用</h3>
<ul>
<li>Redo log用在数据库崩溃会的故障恢复</li>
</ul>
<h3 id="redo-log有哪些问题">Redo log有哪些问题</h3>
<ul>
<li>如果写入频繁导致Redo log里对应的最老的数据脏页还没有刷新到磁盘，此时数据库将卡住，强制刷新脏页到磁盘</li>
<li>MySQL默认配置两个文件才10M，非常容易写满，生产环境中应适当调整大小。</li>
</ul>
<h3 id="innodb_io_capacity">innodb_io_capacity</h3>
<ul>
<li>InnoDB每次刷多少个脏页，决定InnoDB存储引擎的吞吐能力。</li>
<li>在SSD等高性能存储介质下，应该提高该参数以提高数据库的性能。</li>
</ul>
<h3 id="insert-buffer">Insert Buffer</h3>
<ul>
<li>顺序读写 VS 随机读写</li>
<li>随机请求性能远小于顺序请求</li>
</ul>
<p>尽可能多的随机请求合并为顺序请求才是提高数据库性能的关键</p>
<ul>
<li>MySQL从5.1版本开始支持Insert Buffer</li>
<li>MySQL5.5版本之后同时支持update和delete的merge</li>
<li>Insert Buffer只对二级索引且非唯一索引有效</li>
</ul>
<h3 id="总结-1">总结</h3>
<ul>
<li>服务器配置要合理(内核版本、磁盘调度策略、RAID卡缓存)</li>
<li>完善的监控系统，提前发现问题</li>
<li>数据库版本要跟上，不要太新，也不要太老</li>
<li>数据库性能优化：
<ul>
<li>查询优化：索引优化为主，参数优化为辅</li>
<li>写入优化：业务优化为主，参数优化为辅</li>
</ul>
</li>
</ul>

            </div>
            
                <div class="tags">
                    
                    <span class="down-type-item">
                        <div class="type-text">
                            <a href='
                                        /life/tags/mysql
                                    '>
                                <i class="fa fa-tag"></i> MySQL
                            </a>
                        </div>
                    </span>
                    
                    <span class="down-type-item">
                        <div class="type-text">
                            <a href='
                                        /life/tags/163%E8%AF%BE%E5%A0%82
                                    '>
                                <i class="fa fa-tag"></i> 163课堂
                            </a>
                        </div>
                    </span>
                    
                </div>
            
        </div>
        
            
                <div class="pre-next">
                    
    
        
        <a href="./../../posts/uuid_t_mysql_163%E8%AF%BE%E5%A0%82_%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql%E5%BE%AE%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="pre">
            <span class="pre-icon"><i class="fa fa-hand-o-left"></i></span>
            <div class="pre-title-root">
                <span>网易云课堂MySQL微专业学习笔记</span>
            </div>
        </a>
        

        
        <a href="./../../posts/uuid_t_mysql_163%E8%AF%BE%E5%A0%82_%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter4/" class="next">
            <div class="next-title-root">
                <span>网易云课堂MySQL &gt; chapter4</span>
            </div>
            <span class="next-icon"><i class="fa fa-hand-o-right"></i></span>
        </a>
        

    
    

                </div>
            
        
    
</div>

    
        <div class="content-last">
            
                <button class="aixin content-last-item efct-button">
                    <i class="fa fa-heart"></i>
                </button>
            
            
        </div>
    


            </div>
            <div class="zhuti-r">
                
<div class="zhuti-r-0">
    <div class="zhuti-r-1">
        
        <div id="r1">
            

<div class="about-zuozhe">
    <div class="zuozhe">
        
            <div class="datou">
                <img class="lazyload" src='./../../images/thumbnail.gif'  data-src="./../../images/author.jpeg" alt="">
            </div>
        
        <div class="name-jianjie">
            <div class="name">xioyito</div>
            <div class="jianjie">
                Be Water, My Friend.
            </div>
        </div>
    </div>

    <div class="type">
        <a href='
                    /life/posts/
                '>
            <p>posts</p>
            <p>134</p>
        </a>
        <a href='
                    /life/categories/
                '>
            <p>categories</p>
            <p>23</p>
        </a>
        <a href='
                    /life/tags/
                '>
            <p>tags</p>
            <p>58</p>
        </a>
    </div>

    <a href="https://github.com/xioyito">
        <div class="follow">Follow Me</div>
    </a>
    <div class="link">
        
        <a href="https://github.com/xioyito" class="link-item is-hidden-desktop" title="GitHub">
            <span class="icon"><i class='fa fa-github'></i></span>
        </a>
        
        <a href="https://www.youtube.com" class="link-item is-hidden-desktop" title="YouTube">
            <span class="icon"><i class='fa fa-youtube'></i></span>
        </a>
        
    </div>
</div>

            <div class="mulu">
    <div class="dong"></div>
    <div class="zhi">
        <div class="wenzi">
            <div class="zhi-mulu text-wbd">Table of Contents</div>
            <div class="mulu-items">
            </div>
        </div>
    </div>
</div>
            



    
    


<div class="other">
    <div class="other-up">
        <div class="other-qita text-wbd">Related Posts</div>
        <div class="xian"></div>
    </div>
    <div class="list">
        
            <a href="./../../posts/uuid_t_mysql_163%E8%AF%BE%E5%A0%82_%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter1/">
                
<a href="./../../posts/uuid_t_mysql_163%E8%AF%BE%E5%A0%82_%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter1/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /life/images/default.jpg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                网易云课堂MySQL &gt; chapter1
            </div>
            <div class="other-summary">MySQL数据库基础 1.1-认识MySQL 什么是数据库 计算机处理和存储的一切信息都是数据。 计算机系统</div>
            <div class="other-date">2021-2-15</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="./../../posts/uuid_t_mysql_163%E8%AF%BE%E5%A0%82_%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter2/">
                
<a href="./../../posts/uuid_t_mysql_163%E8%AF%BE%E5%A0%82_%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter2/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /life/images/default.jpg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                网易云课堂MySQL &gt; chapter2
            </div>
            <div class="other-summary">MySQL数据库对象与应用 2.1-MySQL数据类型 Number不止一种 整形 浮点型 整形 INT SMALLINT MEDIUMINT BIGINT type Storage Minumun</div>
            <div class="other-date">2021-2-15</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="./../../posts/uuid_t_mysql_163%E8%AF%BE%E5%A0%82_%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter3/">
                
<a href="./../../posts/uuid_t_mysql_163%E8%AF%BE%E5%A0%82_%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter3/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /life/images/default.jpg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                网易云课堂MySQL &gt; chapter3
            </div>
            <div class="other-summary">MySQL事务与存储引擎 3.1-数据库事务 什么是事务 一系列有序的数据库操作： 要么全部成功 要么全部回退</div>
            <div class="other-date">2021-2-15</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="./../../posts/uuid_t_mysql_163%E8%AF%BE%E5%A0%82_%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter4/">
                
<a href="./../../posts/uuid_t_mysql_163%E8%AF%BE%E5%A0%82_%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter4/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /life/images/default.jpg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                网易云课堂MySQL &gt; chapter4
            </div>
            <div class="other-summary">MySQL应用优化 4.1-MySQL索引优化与设计 什么是索引 索引的意义 —— 快速定位要查找的数据 数据库</div>
            <div class="other-date">2021-2-15</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="./../../posts/uuid_t_mysql_163%E8%AF%BE%E5%A0%82_%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql%E5%BE%AE%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
                
<a href="./../../posts/uuid_t_mysql_163%E8%AF%BE%E5%A0%82_%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql%E5%BE%AE%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /life/images/default.jpg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                网易云课堂MySQL微专业学习笔记
            </div>
            <div class="other-summary">NTES_MySQL_notes 网易云课堂MySQL微专业学习笔记 但愿可以不弃坑。 目录 数据库基础 1.1-认识MySQL 1.2-轻松</div>
            <div class="other-date">2021-2-15</div>
        </div>
    </div>
</a>
            </a>
        
    </div>
</div>
        </div>
        <div id="r2">
            
        </div> 
    </div>
</div>

            </div>
        </div>
    </div>
</div>

    

<div class="sponsor">
    <div class="sponsor-self">
        <div class="sponsor-title">Sponsor</div>
        <div class="sponsor-btn">
            
                
                    
                        <div class="sponsor-btn-1 border-r">Wechat</div>
                    
                
                
            
                
                    
                        <div class="sponsor-btn-2 border-l">Alipay</div>
                    
                
                
            
        </div>
        
        <div class="sponsor-img">
            
                
                    <img class="sponsor-img-1" src="./../../images/sponsor/wechat.jpeg" alt="">
                
                
            
                
                    <img class="sponsor-img-2" src="./../../images/sponsor/alipay.jpeg" alt="" style="display: none;">
                
                
            
        </div>
        <div class="cancel efct-button">cancel</div>
    </div>
</div>


        </div>

        <footer class="footer">
    
        <div class="container">
            <div class="footer-items">
                
                    <div class="footer-item">
                        <i class="fa fa-user"></i> <span id="busuanzi_value_site_pv"></span> |
                        <i class="fa fa-eye"></i> <span id="busuanzi_value_site_uv"></span>
                    </div>
                
                
                    <div class="footer-item">
                        © 2022-2023 <a href="https://github.com/xioyito">xioyito</a>
                    </div>
                
                
                    <div class="footer-item">
                        Theme by <a href="https://github.com/xioyito/NewBee">NewBee</a> | Powered by <a href="https://gohugo.io/">Hugo</a>
                    </div>
                
            </div>
        </div>
    

    
</footer>


        
        <div class="search-root">
    <div class="search-zz"></div>
    <div class="search">
        <div class="sheader anniu">
            <div class="sh-l">
                <input type="text" placeholder='Enter a KeyWord' id="search-key">
                <span class="sclear"><i class="fa fa-close"></i></span>
            </div>
            <div class="sh-r">
                <button>search</button>
            </div>
        </div>
        <div class="sbody">
            <div class="sbody-1">
                <div class="stip"></div>
            </div>
        </div>
    </div>
</div>
        








    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    


<script type="text/javascript">
    var mode_custom = "auto";
    var postsCount =  134 ;
    var arrPosts = [{"link":"https://huachengzhou.github.io/life/posts/jane%E4%B8%BB%E9%A2%98%E9%A2%84%E8%A7%88/","plain":"Jane 是一个专注于阅读体验的 Hugo 主题。最早的版本基于hugo-theme-even，在它的基础上进行了重新改造。简约、可定制性强。主要特色：响应式设计多国语言支持支持多个 Shortcode单独设计的 标签页 和 分类页社交网站链接更好的分页、目录、注脚样式使用更快的 Chroma 代码高亮自定义 css，自定义 js，自定义 head子目录支持搜索优化\n作者：贤民\n gitee https://gitee.com/shaoxia1991/hugo-theme-jane.git github https://github.com/xianmin/hugo-theme-jane.git  ","pubDate":"2018-03-06","title":"Jane 主题预览"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_10%E4%B8%AAjava%E7%BB%8F%E5%85%B8%E7%9A%84list%E9%9D%A2%E8%AF%95%E9%A2%98/","plain":"1、你知道的 List 都有哪些？ ArrayList、LinkedList、Vector 等。 2、List 和 Vector 有什么区别？ Vector 是 List 接口下线程安全的集合。 3、List 是有序的吗？ List 是有序的。 4、ArrayList 和 LinkedList 的区别？分别用在什么场景？ ArrayList 和 LinkedList 数据结构不一样，前者用在查询较多的场合，后者适用于插入较多的 场合。 5、ArrayList 和 LinkedList 的底层数据结构是什么？ ArrayList 使用的是数组结构，LinkedList 使用的是链表结构。 6、ArrayList 默认大小是多少，是如何扩容的？ Jdk1.7 之前 ArrayList 默认大小是 10，JDK1.7 之后是 0，JDK 差异，每次约按 1.5 倍扩容。 7、List 是线程安全的吗？如果要线程安全要怎么做？ List 中 的 Vector 才 是 线 程 安 全 的 ， 其 他 要 实 现 线 程 安 全 使 用 工 具 类 Collections.synchronizedList(new ArrayList())方法。 8、怎么给 List 排序？ 使用 List 自身的 sort 方法，或者使用 Collections.sort(list)方法; 9、Arrays.asList 方法后的 List 可以扩容吗？ Arrays.asList 使用的是 final 数组，并且不支持 add 方法，不支持扩容。 10、List 和 Array 之间如何互相转换？ List\u0026gt;Array 使用 toArray 方法，Array\u0026gt;List 使用 Arrays.asList(array)方法，由于它是固定的，不固 定的可以使用 new ArrayList(Arrays.asList(array))。\n","pubDate":"2021-02-15","title":"10个Java经典的List面试题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_10%E4%B8%AAjava%E7%BB%8F%E5%85%B8%E7%9A%84main%E6%96%B9%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/","plain":"1.main方法是做什么用的？\nmain方法是Java程序的入口方法，JVM在运行的时候会首先查找main方法。\n2.不用main方法如何运行一个类？\n不行，没有main方法我们不能运行Java类。 在Java 7之前，你可以通过使用静态初始化运行Java类。但是，从Java 7开始就行不通了。\n3.main方法如何传递参数？传递参数的类型是什么？能不能改变该参数类型？\nString数组，不能改变。\n4.main方法为什么是静态的？能不能改为非静态？\nmain()方法一定是静态的，如果main()是非静态的那么在调用main方法时JVM就得实例化 它的类。\n不能改为非静态，main()方法必须声明为静态的，这样JVM才可以调用main()方法而无需实 例化它的类。 如果从main()方法去掉“static”这个声明，虽然编译依然可以成功，但在运行时会导致程序 失败。 在实例化时，还得调用类的构造函数。如果这个类的构造函数有参数，那么届时就会出现歧 义。\n5.main方法能被重载吗？\n可以，我们可以重载main()方法。一个Java类可以有任意数量的main()方法。\n6.main方法能被覆盖吗？\n在Java中静态方法在编译时会编译在一起，main方法是静态方法，所以你在Java中不能覆 盖静态方法。\n7.main方法的返回类型是什么？能不能改变？\nvoid，不能改变。\n8.main方法的作用域用什么修饰？能不能改变？\npublic，不能改变。\n9.main方法可以同步吗？\nmain方法可以在Java中同步，synchronized修饰符允许用于main方法的声明中，这样就可 以在Java中同步main方法了。\n10.main方法可以终结吗？\n可以在Java中终结main方法。\n更多关注Java大后端公众号\r","pubDate":"2021-02-15","title":"10个Java经典的Main方法面试题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_10%E4%B8%AAjava%E7%BB%8F%E5%85%B8%E7%9A%84string%E9%9D%A2%E8%AF%95%E9%A2%98/","plain":"1 、String是基本数据类型吗？\nString不是基本数据类型。\n2 、String是可变的话？\nString是final类型的，不可变。\n3 、怎么比较两个字符串的值一样，怎么比较两个字符串是否同一对象？\n比较字符串的值是否相同用equals,比较字符串对象是否同一个用==。\n4 、switch中可以使用String吗？\njdk7+中的switch可以使用String类型。\n5 、String str = new String(\u0026ldquo;abc\u0026rdquo;);创建了几个对象，为什么？\n创建了两个，\u0026ldquo;abc\u0026quot;本身创建在常量池，通过new又创建在堆中。\n6 、String、StringBuffer、StringBuilder有什么区别？\nString、StringBuffer、StringBuilder最大的不同是String不可变，后者可变。StringBuffer是线 程安全的，StringBuilder线程不安全速度较快。\n7 、String.trim()方法去掉的是哪些字符？\ntrim去掉字符串首尾的空白字符。\n8 、String可以被子类继承吗？\n既然String是final的，所以不能被继承。\n9 、可以自定义java.lang.String类并使用吗？\n可以自定义java.lang.String类并编译成功，但不能被加载使用，具体请学习类加载机制。\n10 、String与byte[]两者相互之间如何转换？\nString \u0026gt; byte[] 通过String类的getBytes方法；byte[] \u0026gt; String通过new String(byte[])构造器。\n","pubDate":"2021-02-15","title":"10个Java经典的String面试题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_10%E9%81%93java%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%9D%A2%E8%AF%95%E9%A2%98/","plain":"**1.**请列举出在 JDK 中几个常用的设计模式？\n单例模式（Singleton pattern）用于 Runtime，Calendar 和其他的一些类中。工厂模式（Factory pattern）被用于各种不可变的类如 Boolean，像 Boolean.valueOf，观察者模式（Observer pattern）被用于 Swing 和很多的事件监听中。装饰器设计模式（Decorator design pattern）被用于多个 Java IO 类中。\n**2.**什么是设计模式？你是否在你的代码里面使用过任何设计模式？\n设计模式是世界上各种各样程序员用来解决特定设计问题的尝试和测试的方法。设计模式是代码可用性的延伸\n3.Java 中什么叫单例设计模式？请用 Java 写出线程安全的单例模式\n单例模式重点在于在整个系统上共享一些创建时较耗资源的对象。整个应用中只维护一个特定类实例，它被所有组件共同使用。Java.lang.Runtime 是单例模式的经典例子。从 Java 5 开始你可以使用枚举（enum）来实现线程安全的单例。\n**4.**在 Java 中，什么叫观察者设计模式（observer design pattern）？\n观察者模式是基于对象的状态变化和观察者的通讯，以便他们作出相应的操作。简单的例子就是一个天气系统，当天气变化时必须在展示给公众的视图中进行反映。这个视图对象是一个主体，而不同的视图是观察者。\n**5.**使用工厂模式最主要的好处是什么？在哪里使用？\n工厂模式的最大好处是增加了创建对象时的封装层次。如果你使用工厂来创建对象，之后你可以使用更高级和更高性能的实现来替换原始的产品实现或类，这不需要在调用层做任何修改。\n6.举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？\n装饰模式增加强了单个对象的能力。Java IO 到处都使用了装饰模式，典型例子就是 Buffered 系列类如 BufferedReader 和 BufferedWriter，它们增强了 Reader 和 Writer 对象，以实现提升性能的 Buffer 层次的读取和写入。\n**7.**在 Java 中，为什么不允许从静态方法中访问非静态变量？\n{width=\u0026ldquo;1.3041666666666667in\u0026rdquo; height=\u0026ldquo;1.336111111111111in\u0026rdquo;}\n更多关注 Java 大后端公众号\nJava 中不能从静态上下文访问非静态数据只是因为非静态变量是跟具体的对象实例关联的，而静态的却没有和任何实例关联。\n**8.**设计一个 ATM 机，请说出你的设计思路？\n比如设计金融系统来说，必须知道它们应该在任何情况下都能够正常工作。不管是断电还是\n其他情况，ATM 应该保持正确的状态（事务） , 想想 加锁（locking）、事务（transaction）、错误条件（error condition）、边界条件（boundary condition） 等等。尽管你不能想到具体的设计，但如果你可以指出非功能性需求，提出一些问题，想到关于边界条件，这些都会是很好的。\n**9.**在 Java 中，什么时候用重载，什么时候用重写？\n如果你看到一个类的不同实现有着不同的方式来做同一件事，那么就应该用重写\n（overriding），而重载（overloading）是用不同的输入做同一件事。在 Java 中，重载的方法签名不同，而重写并不是。\n**10.**举例说明什么情况下会更倾向于使用抽象类而不是接口？\n接口和抽象类都遵循\u0026quot;面向接口而不是实现编码\u0026quot;设计原则，它可以增加代码的灵活性，可以适应不断变化的需求。下面有几个点可以帮助你回答这个问题：\n在 Java 中，你只能继承一个类，但可以实现多个接口。所以一旦你继承了一个类，你就失去了继承其他类的机会了。\n接口通常被用来表示附属描述或行为如：Runnable、Clonable、Serializable 等等，因此当你使用抽象类来表示行为时，你的类就不能同时是 Runnable 和 Clonable(注：这里的意思是指如果把 Runnable 等实现为抽象类的情况)，因为在 Java 中你不能继承两个类，但当你使用接口时，你的类就可以同时拥有多个不同的行为。 在一些对时间要求比较高的应用中，倾向于使用抽象类，它会比接口稍快一点。 如果希望把一系列行为都规范在类继承层次内，并且可以更好地在同一个地方进行编码，那么抽象类是一个更好的选择。有时，接口和抽象类可以一起使用，接口中定义函数，而在抽象类中定义默认的实现。\n{width=\u0026ldquo;1.3041666666666667in\u0026rdquo; height=\u0026ldquo;1.336111111111111in\u0026rdquo;}\n","pubDate":"2021-02-15","title":"10道Java面试必备的设计模式面试题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_10%E9%81%93java%E9%AB%98%E7%BA%A7%E5%BF%85%E5%A4%87%E7%9A%84netty%E9%9D%A2%E8%AF%95%E9%A2%98/","plain":"1.BIO、NIO和AIO的区别？ BIO：一个连接一个线程，客户端有连接请求时服务器端就需要启动一个线程进行处理。线 程开销大。 伪异步IO：将请求连接放入线程池，一对多，但线程还是很宝贵的资源。 NIO：一个请求一个线程，但客户端发送的连接请求都会注册到多路复用器上，多路复用器 轮询到连接有I/O请求时才启动一个线程进行处理。 AIO：一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启 动线程进行处理， BIO是面向流的，NIO是面向缓冲区的；BIO的各种流是阻塞的。而NIO是非阻塞的；BIO的 Stream是单向的，而NIO的channel是双向的。\nNIO的特点：事件驱动模型、单线程处理多任务、非阻塞I/O，I/O读写不再阻塞，而是返回 0 、基于block的传输比基于流的传输更高效、更高级的IO函数zero-copy、IO多路复用大大 提高了Java网络应用的可伸缩性和实用性。基于Reactor线程模型。\n在Reactor模式中，事件分发器等待某个事件或者可应用或个操作的状态发生，事件分发器 就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。如 在Reactor中实现读：注册读就绪事件和相应的事件处理器、事件分发器等待事件、事件到 来，激活分发器，分发器调用事件对应的处理器、事件处理器完成实际的读操作，处理读到 的数据，注册新的事件，然后返还控制权。\n2.NIO的组成？ Buffer：与Channel进行交互，数据是从Channel读入缓冲区，从缓冲区写入Channel中的\nflip方法 ： 反转此缓冲区，将position给limit，然后将position置为 0 ，其实就是切换读写 模式 clear方法 ：清除此缓冲区，将position置为 0 ，把capacity的值给limit。 rewind方法 ： 重绕此缓冲区，将position置为 0 DirectByteBuffer可减少一次系统空间到用户空间的拷贝。但Buffer创建和销毁的成本更高， 不可控，通常会用内存池来提高性能。直接缓冲区主要分配给那些易受基础系统的本机I/O 操作影响的大型、持久的缓冲区。如果数据量比较小的中小应用情况下，可以考虑使用 heapBuffer，由JVM进行管理。\nChannel：表示 IO 源与目标打开的连接，是双向的，但不能直接访问数据，只能与Buffer 进 行交互。通过源码可知，FileChannel的read方法和write方法都导致数据复制了两次！\nSelector可使一个单独的线程管理多个Channel，open方法可创建Selector，register方法向\n多路复用器器注册通道，可以监听的事件类型：读、写、连接、accept。注册事件后会产生 一个SelectionKey：它表示SelectableChannel 和Selector 之间的注册关系，wakeup方法： 使尚未返回的第一个选择操作立即返回，唤醒的原因是：注册了新的 channel或者事件； channel关闭，取消注册；优先级更高的事件触发（如定时器事件），希望及时处理。\nSelector在Linux的实现类是EPollSelectorImpl，委托给EPollArrayWrapper实现，其中三个 native方法是对epoll的封装，而EPollSelectorImpl. implRegister方法，通过调用epoll_ctl向 epoll实例中注册事件，还将注册的文件描述符(fd)与SelectionKey的对应关系添加到fdToKey 中，这个map维护了文件描述符与SelectionKey的映射。\nfdToKey有时会变得非常大，因为注册到Selector上的Channel非常多（百万连接）；过期或 失效的Channel没有及时关闭。fdToKey总是串行读取的，而读取是在select方法中进行的， 该方法是非线程安全的。\nPipe：两个线程之间的单向数据连接，数据会被写到sink通道，从source通道读取\nNIO的服务端建立过程：Selector.open()：打开一个Selector；ServerSocketChannel.open()：创 建服务端的Channel；bind()：绑定到某个端口上。并配置非阻塞模式；register()：注册Channel 和关注的事件到Selector上；select()轮询拿到已经就绪的事件\n3.Netty的特点？ 一个高性能、异步事件驱动的NIO框架，它提供了对TCP、UDP和文件传输的支持 使用更高效的socket底层，对epoll空轮询引起的cpu占用飙升在内部进行了处理，避免了 直接使用NIO的陷阱，简化了NIO的处理方式。 采用多种decoder/encoder 支持，对TCP粘包/分包进行自动化处理 可使用接受/处理线程池，提高连接效率，对重连、心跳检测的简单支持 可配置IO线程数、TCP参数， TCP接收和发送缓冲区使用直接内存代替堆内存，通过内存 池的方式循环利用ByteBuf 通过引用计数器及时申请释放不再引用的对象，降低了GC频率 使用单线程串行化的方式，高效的Reactor线程模型 大量使用了volitale、使用了CAS和原子类、线程安全类的使用、读写锁的使用 4.Netty的线程模型？ Netty通过Reactor模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，boss 线程池和work线程池，其中boss线程池的线程负责处理请求的accept事件，当接收到accept 事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池，其 中work线程池负责请求的read和write事件，由对应的Handler处理。\n单线程模型：所有I/O操作都由一个线程完成，即多路复用、事件分发和处理都是在一个\nReactor线程上完成的。既要接收客户端的连接请求,向服务端发起连接，又要发送/读取请求 或应答/响应消息。一个NIO 线程同时处理成百上千的链路，性能上无法支撑，速度慢，若 线程进入死循环，整个程序不可用，对于高负载、大并发的应用场景不合适。\n多线程模型：有一个NIO 线程（Acceptor） 只负责监听服务端，接收客户端的TCP 连接请 求；NIO 线程池负责网络IO 的操作，即消息的读取、解码、编码和发送； 1 个NIO 线程可 以同时处理N 条链路，但是 1 个链路只对应 1 个NIO 线程，这是为了防止发生并发操作 问题。但在并发百万客户端连接或需要安全认证时，一个Acceptor 线程可能会存在性能不 足问题。\n主从多线程模型：Acceptor 线程用于绑定监听端口，接收客户端连接，将SocketChannel 从 主线程池的Reactor 线程的多路复用器上移除，重新注册到Sub 线程池的线程上，用于处 理I/O 的读写等操作，从而保证mainReactor只负责接入认证、握手等操作；\n5.TCP 粘包/拆包的原因及解决方法？ TCP是以流的方式来处理数据，一个完整的包可能会被TCP拆分成多个包进行发送，也可能 把小的封装成一个大的数据包发送。\nTCP粘包/分包的原因：\n应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象，而应用程序写入 数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包现 象； 进行MSS大小的TCP分段，当TCP报文长度-TCP头部长度\u0026gt;MSS的时候将发生拆包 以太网帧的payload（净荷）大于MTU（ 1500 字节）进行ip分片。 解决方法\n消息定长：FixedLengthFrameDecoder类 包尾增加特殊字符分割：行分隔符类：LineBasedFrameDecoder 或自定义分隔符类 ： DelimiterBasedFrameDecoder 将消息分为消息头和消息体：LengthFieldBasedFrameDecoder类。分为有头部的拆包与粘包、 长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。 6.了解哪几种序列化协议？ 序列化（编码）是将对象序列化为二进制形式（字节数组），主要用于网络传输、数据持久 化等；而反序列化（解码）则是将从网络、磁盘等读取的字节数组还原成原始对象，主要用 于网络传输对象的解码，以便完成远程调用。\n影响序列化性能的关键因素：序列化后的码流大小（网络带宽的占用）、序列化的性能（CPU\n资源占用）；是否支持跨语言（异构系统的对接和开发语言切换）。 Java默认提供的序列化：无法跨语言、序列化后的码流太大、序列化的性能差\nXML，优点：人机可读性好，可指定元素或特性的名称。缺点：序列化数据只包含数据本身 以及类的结构，不包括类型标识和程序集信息；只能序列化公共属性和字段；不能序列化方 法；文件庞大，文件格式复杂，传输占带宽。适用场景：当做配置文件存储数据，实时数据 转换。\nJSON，是一种轻量级的数据交换格式，优点：兼容性高、数据格式比较简单，易于读写、 序列化后数据较小，可扩展性好，兼容性好、与XML相比，其协议比较简单，解析速度比 较快。缺点：数据的描述性比XML差、不适合性能要求为ms级别的情况、额外空间开销比 较大。适用场景（可替代ＸＭＬ）：跨防火墙访问、可调式性要求高、基于Web browser的 Ajax请求、传输数据量相对小，实时性要求相对低（例如秒级别）的服务。\nFastjson，采用一种“假定有序快速匹配”的算法。优点：接口简单易用、目前java语言中 最快的json库。缺点：过于注重快，而偏离了“标准”及功能性、代码质量不高，文档不 全。适用场景：协议交互、Web输出、Android客户端\nThrift，不仅是序列化协议，还是一个RPC框架。优点：序列化后的体积小, 速度快、支持 多种语言和丰富的数据类型、对于数据字段的增删具有较强的兼容性、支持二进制压缩编码。 缺点：使用者较少、跨防火墙访问时，不安全、不具有可读性，调试代码时相对困难、不能 与其他传输层协议共同使用（例如HTTP）、无法支持向持久层直接读写数据，即不适合做数 据持久化序列化协议。适用场景：分布式系统的RPC解决方案\nAvro，Hadoop的一个子项目，解决了JSON的冗长和没有IDL的问题。优点：支持丰富的数 据类型、简单的动态语言结合功能、具有自我描述属性、提高了数据解析速度、快速可压缩 的二进制数据形式、可以实现远程过程调用RPC、支持跨编程语言实现。缺点：对于习惯于 静态类型语言的用户不直观。适用场景：在Hadoop中做Hive、Pig和MapReduce的持久化 数据格式。\nProtobuf，将数据结构以.proto文件进行描述，通过代码生成工具可以生成对应数据结构的 POJO对象和Protobuf相关的方法和属性。优点：序列化后码流小，性能高、结构化数据存 储格式（XML JSON等）、通过标识字段的顺序，可以实现协议的前向兼容、结构化的文档更 容易管理和维护。缺点：需要依赖于工具生成代码、支持的语言相对较少，官方只支持Java 、 C++ 、python。适用场景：对性能要求高的RPC调用、具有良好的跨防火墙的访问属性、适 合应用层对象的持久化\n其它 protostuff 基于protobuf协议，但不需要配置proto文件，直接导包即可 Jboss marshaling 可以直接序列化java类， 无须实java.io.Serializable接口 Message pack 一个高效的二进制序列化格式 Hessian 采用二进制协议的轻量级remoting onhttp工具 kryo 基于protobuf协议，只支持java语言,需要注册（Registration），然后序列化（Output）， 反序列化（Input） 7.如何选择序列化协议？ 具体场景\n对于公司间的系统调用，如果性能要求在100ms以上的服务，基于XML的SOAP协议是一 个值得考虑的方案。 基于Web browser的Ajax，以及Mobile app与服务端之间的通讯，JSON协议是首选。对于 性能要求不太高，或者以动态类型语言为主，或者传输数据载荷很小的的运用场景，JSON 也是非常不错的选择。 对于调试环境比较恶劣的场景，采用JSON或XML能够极大的提高调试效率，降低系统开发 成本。 当对性能和简洁性有极高要求的场景，Protobuf，Thrift，Avro之间具有一定的竞争关系。 对于T级别的数据的持久化应用场景，Protobuf和Avro是首要选择。如果持久化后的数据 存储在hadoop子项目里，Avro会是更好的选择。 对于持久层非Hadoop项目，以静态类型语言为主的应用场景，Protobuf会更符合静态类型 语言工程师的开发习惯。由于Avro的设计理念偏向于动态类型语言，对于动态语言为主的 应用场景，Avro是更好的选择。 如果需要提供一个完整的RPC解决方案，Thrift是一个好的选择。 如果序列化之后需要支持不同的传输层协议，或者需要跨防火墙访问的高性能场景， Protobuf可以优先考虑。 protobuf的数据类型有多种：bool、double、float、int32、int64、string、bytes、enum、message。 protobuf的限定符：required: 必须赋值，不能为空、optional:字段可以赋值，也可以不赋值、 repeated: 该字段可以重复任意次数（包括 0 次）、枚举；只能用指定的常量集中的一个值作 为其值；\nprotobuf的基本规则：每个消息中必须至少留有一个required类型的字段、包含 0 个或多个 optional类型的字段；repeated表示的字段可以包含 0 个或多个数据；[1,15]之内的标识号在 编码的时候会占用一个字节（常用），[16,2047]之内的标识号则占用 2 个字节，标识号一定 不能重复、使用消息类型，也可以将消息嵌套任意多层，可用嵌套消息类型来代替组。\nprotobuf的消息升级原则：不要更改任何已有的字段的数值标识；不能移除已经存在的\nrequired字段，optional和repeated类型的字段可以被移除，但要保留标号不能被重用。新 添加的字段必须是optional或repeated。因为旧版本程序无法读取或写入新增的required限 定符的字段。\n编译器为每一个消息类型生成了一个.java文件，以及一个特殊的Builder类（该类是用来创 建 消 息 类 接 口 的 ） 。 如 ： UserProto.User.Builder builder = UserProto.User.newBuilder();builder.build()；\nNetty 中的使用：ProtobufVarint32FrameDecoder 是用于处理半包消息的解码类； ProtobufDecoder(UserProto.User.getDefaultInstance())这是创建的UserProto.java文件中的解码 类；ProtobufVarint32LengthFieldPrepender 对protobuf协议的消息头上加上一个长度为 32 的整形字段，用于标志这个消息的长度的类；ProtobufEncoder 是编码类\n将StringBuilder转换为ByteBuf类型：copiedBuffer()方法\n8.Netty的零拷贝实现？ Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写， 不需要进行字节缓冲区的二次拷贝。堆内存多了一次内存拷贝，JVM会将堆内存Buffer拷贝 一份到直接内存中，然后才写入Socket中。ByteBuffer由ChannelConfig分配，而ChannelConfig 创建ByteBufAllocator默认使用Direct Buffer\nCompositeByteBuf 类可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了传统通过 内存拷贝的方式将几个小Buffer合并成一个大的Buffer。addComponents方法将 header 与 body 合并为一个逻辑上的 ByteBuf, 这两个 ByteBuf 在CompositeByteBuf 内部都是单独存 在的, CompositeByteBuf 只是逻辑上是一个整体\n通过 FileRegion 包装的FileChannel.tranferTo方法 实现文件传输, 可以直接将文件缓冲区的 数据发送到目标 Channel，避免了传统通过循环write方式导致的内存拷贝问题。\n通过 wrap方法, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作。\nSelector BUG：若Selector的轮询结果为空，也没有wakeup或新消息处理，则发生空轮询， CPU使用率100%，\nNetty的解决办法：对Selector的select操作周期进行统计，每完成一次空的select操作进行 一次计数，若在某个周期内连续发生N次空轮询，则触发了epoll死循环bug。重建Selector， 判断是否是其他线程发起的重建请求，若不是则将原SocketChannel从旧的Selector上去除\n注册，重新注册到新的Selector上，并将原来的Selector关闭。\n9.Netty的高性能表现在哪些方面？ 心跳，对服务端：会定时清除闲置会话inactive(netty5)，对客户端:用来检测会话是否断开， 是否重来，检测网络延迟，其中idleStateHandler类 用来检测会话状态\n串行无锁化设计，即消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就 避免了多线程竞争和同步锁。表面上看，串行化设计似乎CPU利用率不高，并发程度不够。 但是，通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种 局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优。\n可靠性，链路有效性检测：链路空闲检测机制，读/写空闲超时机制；内存保护机制：通过 内存池重用ByteBuf;ByteBuf的解码保护；优雅停机：不再接收新消息、退出前的预处理操 作、资源的释放操作。\nNetty安全性：支持的安全协议：SSL V2和V3，TLS，SSL单向认证、双向认证和第三方CA 认证。\n高效并发编程的体现：volatile的大量、正确使用；CAS和原子类的广泛使用；线程安全容器 的使用；通过读写锁提升并发性能。IO通信性能三原则：传输（AIO）、协议（Http）、线程 （主从多线程）\n流量整型的作用（变压器）：防止由于上下游网元性能不均衡导致下游网元被压垮，业务流 中断；防止由于通信模块接受消息过快，后端业务线程处理不及时导致撑死问题。\nTCP参数配置：SO_RCVBUF和SO_SNDBUF：通常建议值为128K或者256K；SO_TCPNODELAY： NAGLE算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻 塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法；\n10.NIOEventLoopGroup源码？\nNioEventLoopGroup(其实是 MultithreadEventExecutorGroup) 内部维护一个类型为 EventExecutor children [], 默认大小是处理器核数 * 2, 这样就构成了一个线程池，初始化 EventExecutor时NioEventLoopGroup重载newChild方法，所以children元素的实际类型为 NioEventLoop。\n线程启动时调用SingleThreadEventExecutor的构造方法，执行NioEventLoop类的run方法，\n首先会调用hasTasks()方法判断当前taskQueue是否有元素。如果taskQueue中有元素，执 行 selectNow() 方法，最终执行selector.selectNow()，该方法会立即返回。如果 taskQueue 没有元素，执行 select(oldWakenUp) 方法\nselect ( oldWakenUp) 方法解决了 Nio 中的 bug，selectCnt 用来记录selector.select方法的 执行次数和标识是否执行过selector.selectNow()，若触发了epoll的空轮询bug，则会反复执 行selector.select(timeoutMillis)，变量selectCnt 会逐渐变大，当selectCnt 达到阈值（默认 512 ），则执行rebuildSelector方法，进行selector重建，解决cpu占用100%的bug。\nrebuildSelector方法先通过openSelector方法创建一个新的selector。然后将old selector的 selectionKey执行cancel。最后将old selector的channel重新注册到新的selector中。rebuild 后，需要重新执行方法selectNow，检查是否有已ready的selectionKey。\n接下来调用processSelectedKeys 方法（处理I/O任务），当selectedKeys != null时，调用 processSelectedKeysOptimized方法，迭代 selectedKeys 获取就绪的 IO 事件的selectkey存 放在数组 selectedKeys 中, 然后为每个事件都调用 processSelectedKey 来处理它， processSelectedKey 中分别处理OP_READ；OP_WRITE；OP_CONNECT事件。\n最后调用runAllTasks方法（非IO任务），该方法首先会调用fetchFromScheduledTaskQueue 方法，把scheduledTaskQueue中已经超过延迟执行时间的任务移到taskQueue中等待被执行， 然后依次从taskQueue中取任务执行，每执行 64 个任务，进行耗时检查，如果已执行时间 超过预先设定的执行时间，则停止执行非IO任务，避免非IO任务太多，影响IO任务的执 行。\n每个NioEventLoop对应一个线程和一个Selector，NioServerSocketChannel会主动注册到某一 个NioEventLoop的Selector上，NioEventLoop负责事件轮询。\nOutbound 事件都是请求事件, 发起者是 Channel，处理者是 unsafe，通过 Outbound 事件 进行通知，传播方向是 tail到head。Inbound 事件发起者是 unsafe，事件的处理者是 Channel, 是通知事件，传播方向是从头到尾。\n内存管理机制，首先会预申请一大块内存Arena，Arena由许多Chunk组成，而每个Chunk 默认由 2048 个page组成。Chunk通过AVL树的形式组织Page，每个叶子节点表示一个Page， 而中间节点表示内存区域，节点自己记录它在整个Arena中的偏移地址。当区域被分配出去 后，中间节点上的标记位会被标记，这样就表示这个中间节点以下的所有节点都已被分配了。 大于8k的内存分配在poolChunkList中，而PoolSubpage用于分配小于8k的内存，它会把一 个page分割成多段，进行内存分配。\nByteBuf的特点：支持自动扩容（4M），保证put方法不会抛出异常、通过内置的复合缓冲 类型，实现零拷贝（zero-copy）；不需要调用flip()来切换读/写模式，读取和写入索引分开； 方法链；引用计数基于AtomicIntegerFieldUpdater用于内存回收；PooledByteBuf采用二叉树 来实现一个内存池，集中管理内存的分配和释放，不用每次使用都新建一个缓冲区对象。 UnpooledHeapByteBuf每次都会新建一个缓冲区对象。\n","pubDate":"2021-02-15","title":"10道Java高级必备的Netty面试题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_15%E9%81%93%E7%BB%8F%E5%85%B8%E7%9A%84tomcat%E9%9D%A2%E8%AF%95%E9%A2%98/","plain":" 1、Tomcat 的缺省端口是多少，怎么修改？ 1）找到 Tomcat 目录下的 conf 文件夹2）进入 conf 文件夹里面找到 server.xml 文件3）打开 server.xml 文件\n 4）在 server.xml 文件里面找到下列信息\n\u0026lt;Connector connectionTimeout=\u0026quot;20000\u0026quot; port=\u0026quot;8080\u0026quot; protocol=\u0026quot;HTTP/1.1\u0026quot; redirectPort=\u0026quot;8443\u0026quot; uriEncoding=\u0026quot;utf-8\u0026quot;/\u0026gt;\nport=\u0026quot;8080\u0026quot;改成你想要的端口\n2、tomcat 有哪几种 Connector 运行模式(优化)？ bio：传统的 Java I/O 操作，同步且阻塞 IO。\nmaxThreads=\u0026ldquo;150\u0026rdquo;//Tomcat 使用线程来处理接收的每个请求。这个值表示Tomcat 可创建的最大的线程数。默认值 200。可以根据机器的时期性能和内存大小调整，一般可以在 400-500。最大可以在 800 左右。minSpareThreads=\u0026ldquo;25\u0026rdquo;\u0026mdash;Tomcat 初始化时创建的线程数。默认值 4。如果当前没有空闲线程，且没有超过 maxThreads，一次性创建的空闲线程数量。Tomcat初始化时创建的线程数量也由此值设置。\nmaxSpareThreads=\u0026ldquo;75\u0026rdquo;\u0026ndash;一旦创建的线程超过这个值，Tomcat 就会关闭不再需要的 socket 线程。默认值 50。一旦创建的线程超过此数值，Tomcat 会关闭不再需要的线程。线程数可以大致上用 \u0026ldquo;同时在线人数每秒用户操作次数系统平均操作时间\u0026rdquo; 来计算。\nacceptCount=\u0026ldquo;100\u0026rdquo;\u0026mdash;-指定当所有可以使用的处理请求的线程数都被使用时， 可以放到处理队列中的请求数，超过这个数的请求将不予处理。默认值 10。如果当前可用线程数为 0，则将请求放入处理队列中。这个值限定了请求队列的大小，超过这个数值的请求将不予处理。\nconnectionTimeout=\u0026ldquo;20000\u0026rdquo; \u0026ndash;网络连接超时，默认值 20000，单位：毫秒。设置为 0 表示永不超时，这样设置有隐患的。通常可设置为 30000 毫秒。\nnio：JDK1.4 开始支持，同步阻塞或同步非阻塞 IO。指定使用 NIO 模型来接受 HTTP 请求\nprotocol=\u0026ldquo;org.apache.coyote.http11.Http11NioProtocol\u0026rdquo; 指定使用 NIO 模型\n来接受 HTTP 请求。默认是 BlockingIO，配置为 protocol=\u0026ldquo;HTTP/1.1\u0026rdquo; acceptorThreadCount=\u0026ldquo;2\u0026rdquo; 使用 NIO 模型时接收线程的数目\naio(nio.2)：JDK7 开始支持，异步非阻塞 IO。\napr：Tomcat 将以 JNI 的形式调用 Apache HTTP 服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地 提高Tomcat 对静态文件的处理性能。\n\u0026lt;!--\n\u0026lt;Connector connectionTimeout=\u0026quot;20000\u0026quot; port=\u0026quot;8000\u0026quot; protocol=\u0026quot;HTTP/1.1\u0026quot; redirectPort=\u0026quot;8443\u0026quot; uriEncoding=\u0026quot;utf-8\u0026quot;/\u0026gt;\n --\u0026gt;\n \u0026lt;!-- protocol 启用 nio 模式，(tomcat8 默认使用的是 nio)(apr 模式利用系统级异步 io) --\u0026gt;\n \u0026lt;!-- minProcessors 最小空闲连接线程数--\u0026gt;\n\u0026lt;!-- maxProcessors 最大连接线程数--\u0026gt;\n\u0026lt;!-- acceptCount 允许的最大连接数，应大于等于 maxProcessors--\u0026gt;\n \u0026lt;!-- enableLookups 如果为 true,requst.getRemoteHost 会执行 DNS 查找， 反向解析 ip 对应域名或主机名--\u0026gt;\n \u0026lt;Connector port=\u0026quot;8080\u0026quot;\nprotocol=\u0026quot;org.apache.coyote.http11.Http11NioProtocol\u0026quot; connectionTimeout=\u0026quot;20000\u0026quot; redirectPort=\u0026quot;8443\nmaxThreads=\u0026ldquo;500\u0026rdquo; minSpareThreads=\u0026ldquo;100\u0026rdquo; maxSpareThreads=\u0026ldquo;200\u0026rdquo; acceptCount=\u0026quot;200\u0026quot; enableLookups=\u0026quot;false\u0026quot;\n/\u0026gt;\n 其他配置\nmaxHttpHeaderSize=\u0026quot;8192\u0026quot; http 请求头信息的最大程度，超过此长度的部分不予处理。一般 8K。\nURIEncoding=\u0026quot;UTF-8\u0026quot; 指定 Tomcat 容器的 URL 编码格式。disableUploadTimeout=\u0026quot;true\u0026quot; 上传时是否使用超时机制enableLookups=\u0026quot;false\u0026quot;--是否反查域名，默认值为 true。为了提高处理能力，应设置为 false\ncompression=\u0026quot;on\u0026quot; 打开压缩功能\ncompressionMinSize=\u0026quot;10240\u0026quot; 启用压缩的输出内容大小，默认为 2KB noCompressionUserAgents=\u0026quot;gozilla, traviata\u0026quot; 对于以下的浏览器，不启用压\n缩compressableMimeType=\u0026quot;text/html,text/xml,text/javascript,text/css,text/plain\u0026quot; 哪些资源类型需要压缩\n3、Tomcat 有几种部署方式？   直接把Web 项目放在 webapps 下，Tomcat 会自动将其部署\n  在 server.xml 文件上配置\u0026lt;Context\u0026gt;节点，设置相关的属性即可\n  通过 Catalina 来进行配置:进入到 conf\\Catalina\\localhost 文件下，创建一个\n  xml 文件，该文件的名字就是站点的名字。编写 XML 的方式来进行设置。\n4、tomcat 容器是如何创建 servlet 类实例？用到了什么原理？ 当容器启动时，会读取在 webapps 目录下所有的 web 应用中的 web.xml 文件， 然后对 xml 文件进行解析，\n并读取 servlet 注册信息。然后，将每个应用中注册的 servlet 类都进行加载，并通过反射的方式实例化。\n（有时候也是在第一次请求时实例化）在 servlet 注册时加上如果为正数，则在一开始就实例化，\n如果不写或为负数，则第一次请求实例化。\ntomcat 如何优化？ 1、优化连接配置.这里以 tomcat7 的参数配置为例，需要修改 conf/server.xml\n文件，修改连接数，关闭客户端 dns 查询。参数解释：\nURIEncoding=\u0026ldquo;UTF-8″ :使得 tomcat 可以解析含有中文名的文件的 url，真方便，不像 apache 里还有搞个 mod_encoding，还要手工编译\nmaxSpareThreads : 如果空闲状态的线程数多于设置的数目，则将这些线程中止，减少这个池中的线程总数。\nminSpareThreads : 最小备用线程数，tomcat 启动时的初始化的线程数。enableLookups : 这个功效和Apache 中的HostnameLookups 一样，设为关闭。connectionTimeout : connectionTimeout 为网络连接超时时间毫秒数。\nmaxThreads : maxThreads Tomcat 使用线程来处理接收的每个请求。这个值表示 Tomcat 可创建的最大的线程数，即最大并发数。\nacceptCount : acceptCount 是当线程数达到maxThreads 后，后续请求会被放入一个等待队列，这个 acceptCount 是这个队列的大小，如果这个队列也满了， 就直接 refuse connection\nmaxProcessors 与minProcessors : 在 Java 中线程是程序运行时的路径，是在一个程序中与其它控制线程无关的、能够独立运行的代码段。它们共享相同的地址空间。多线程帮助程序员写出 CPU 最 大利用率的高效程序，使空闲时间保持最低，从而接受更多的请求。\n通常Windows 是 1000 个左右，Linux 是 2000 个左右。\nuseURIValidationHack:\n我们来看一下 tomcat 中的一段源码：\n【security】\nif (connector.getUseURIValidationHack()) { String uri = validate(request.getRequestURI()); if (uri == null) {\nres.setStatus(400);\nres.setMessage(\u0026ldquo;Invalid URI\u0026rdquo;);\nthrow new IOException(\u0026ldquo;Invalid URI\u0026rdquo;);\n} else { req.requestURI().setString(uri);\n// Redoing the URI decoding req.decodedURI().duplicate(req.requestURI()); req.getURLDecoder().convert(req.decodedURI(), true);\n可以看到如果把 useURIValidationHack 设成\u0026quot;false\u0026rdquo;，可以减少它对一些 url\n的不必要的检查从而减省开销。\nenableLookups=\u0026ldquo;false\u0026rdquo; ： 为了消除 DNS 查询对性能的影响我们可以关闭\nDNS 查询，方式是修改 server.xml 文件中的 enableLookups 参数值。\ndisableUploadTimeout ：类似于 Apache 中的 keeyalive 一样给 Tomcat 配置 gzip 压缩(HTTP 压缩)功能compression=\u0026ldquo;on\u0026rdquo; compressionMinSize=\u0026ldquo;2048″\ncompressableMimeType=\u0026ldquo;text/html,text/xml,text/JavaScript,text/css,text/plain\u0026rdquo;\nHTTP 压缩可以大大提高浏览网站的速度，它的原理是，在客户端请求网页后， 从服务器端将网页文件压缩，再下载到客户端，由客户端的浏览器负责解压缩并浏览。相对于普通的浏览过程 HTML,CSS,javascript , Text ，它可以节省 40% 左右的流量。更为重要的是，它可以对动态生成的，包括 CGI、PHP , JSP , ASP , Servlet,SHTML 等输出的网页也能进行压缩，压缩效率惊人。\n  compression=\u0026ldquo;on\u0026rdquo; 打开压缩功能\n  compressionMinSize=\u0026ldquo;2048″ 启用压缩的输出内容大小，这里面默认为 2KB\n  noCompressionUserAgents=\u0026ldquo;gozilla, traviata\u0026rdquo; 对于以下的浏览器，不启用压缩\n  compressableMimeType=\u0026ldquo;text/html,text/xml\u0026rdquo; 压缩类型\n  最后不要忘了把 8443 端口的地方也加上同样的配置，因为如果我们走 https 协议的话，我们将会用到 8443 端口这个段的配置，对吧？\n\u0026lt;!\u0026ndash;enable tomcat ssl\u0026ndash;\u0026gt;\n\u0026lt;Connector port=\u0026ldquo;8443″ protocol=\u0026ldquo;HTTP/1.1″\nURIEncoding=\u0026ldquo;UTF-8″ minSpareThreads=\u0026ldquo;25″ maxSpareThreads=\u0026ldquo;75″\nenableLookups=\u0026ldquo;false\u0026quot;disableUploadTimeout=\u0026ldquo;true\u0026quot;connectionTimeout=\u0026rdquo; 20000″\nacceptCount= \u0026quot; 300 ″ maxThreads= \u0026quot; 300 ″ maxProcessors= \u0026quot; 1000 ″\nminProcessors=\u0026ldquo;5″ useURIValidationHack=\u0026ldquo;false\u0026rdquo;\ncompression=\u0026ldquo;on\u0026rdquo; compressionMinSize=\u0026ldquo;2048″ compressableMimeType=\u0026ldquo;text/html,text/xml,text/javascript,text/css,text/plain\u0026rdquo; SSLEnabled=\u0026ldquo;true\u0026rdquo;\nscheme=\u0026ldquo;https\u0026rdquo; secure=\u0026ldquo;true\u0026rdquo; clientAuth=\u0026ldquo;false\u0026rdquo; sslProtocol=\u0026ldquo;TLS\u0026rdquo;\nkeystoreFile=\u0026ldquo;d:/tomcat2/conf/shnlap93.jks\u0026rdquo; keystorePass=\u0026ldquo;aaaaaa\u0026rdquo;\n/\u0026gt;\n好了，所有的 Tomcat 优化的地方都加上了。\n内存调优 内存方式的设置是在 catalina.sh 中，调整一下 JAVA_OPTS 变量即可，因为后面的启动参数会把 JAVA_OPTS 作为 JVM 的启动参数来处理。\n具体设置如下：\nJAVA_OPTS=\u0026quot;$JAVA_OPTS -Xmx3550m -Xms3550m -Xss128k\n-XX:NewRatio=4 -XX:SurvivorRatio=4\u0026quot;\n其各项参数如下：\n-Xmx3550m：设置 JVM 最大可用内存为 3550M。\n-Xms3550m：设置 JVM 促使内存为 3550m。此值可以设置与-Xmx 相同，以避免每次垃圾回收完成后 JVM 重新分配内存。\n-Xmn2g：设置年轻代大小为 2G。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为 64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun 官方推荐配置为整个堆的 3/8。\n-Xss128k：设置每个线程的堆栈大小。JDK5.0 以后每个线程堆栈大小为 1M， 以前每个线程堆栈大小为 256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在 3000~5000 左右。\n-XX:NewRatio=4:设置年轻代（包括 Eden 和两个 Survivor 区）与年老代的比值\n（除去持久代）。设置为 4，则年轻代与年老代所占比值为 1：4，年轻代占整个堆栈的 1/5\n-XX:SurvivorRatio=4：设置年轻代中 Eden 区与 Survivor 区的大小比值。设置为4，则两个 Survivor 区与一个 Eden 区的比值为 2:4，一个 Survivor 区占整个年轻代的 1/6\n-XX:MaxPermSize=16m:设置持久代大小为 16m。\n-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为 0 的话，则年轻代对象不经过 Survivor 区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在 Survivor 区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。\n垃圾回收策略调优 垃圾回收的设置也是在 catalina.sh 中，调整 JAVA_OPTS 变量。具体设置如下：\nJAVA_OPTS=\u0026quot;$JAVA_OPTS -Xmx3550m -Xms3550m -Xss128k\n-XX:+UseParallelGC -XX:MaxGCPauseMillis=100\u0026quot; 具体的垃圾回收策略及相应策略的各项参数如下： 串行收集器（JDK1.5 以前主要的回收方式）\n-XX:+UseSerialGC:设置串行收集器并行收集器（吞吐量优先）\n示例：\njava -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC\n-XX:MaxGCPauseMillis=100\n-XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。\n-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。\n-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0 支持对年老代并行收集\n-XX:MaxGCPauseMillis=100:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM 会自动调整年轻代大小，以满足此值。\n-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的 Survivor 区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。\n并发收集器（响应时间优先）\n示 例 ： java -Xmx3550m -Xms3550m -Xmn2g -Xss128k\n-XX:+UseConcMarkSweepGC\n-XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，\n-XX:NewRatio=4 的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn 设置。\n-XX:+UseParNewGC: 设置年轻代为并行收集。可与 CMS 收集同时使用。\nJDK5.0 以上，JVM 会根据系统配置自行设置，所以无需再设置此值。\n-XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生\u0026quot;碎片\u0026rdquo;，使得运行效率降低。此值设置运行多少次 GC 以后对内存空间进行压缩、整理。\n-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片\n共享 session 处理 目前的处理方式有如下几种：\n 使用 Tomcat 本身的 Session 复制功能  参考 http://ajita.iteye.com/blog/1715312（Session 复制的配置）\n方案的有点是配置简单，缺点是当集群数量较多时，Session 复制的时间会比较长，影响响应的效率\n 使用第三方来存放共享 Session  目 前 用的 较多 的是使 用 memcached 来 管 理共 享 Session ， 借 助 于\nmemcached-sesson-manager 来进行 Tomcat 的 Session 管理\n参考http://ajita.iteye.com/blog/1716320（使用MSM 管理Tomcat 集群session） 3).使用黏性 session 的策略\n对于会话要求不太强（不涉及到计费，失败了允许重新请求下等）的场合，同一个用户的 session 可以由 nginx 或者 apache 交给同一个 Tomcat 来处理，这就是所谓的 session sticky 策略，目前应用也比较多\n参考：http://ajita.iteye.com/blog/1848665（tomcat session sticky）\nnginx 默认不包含 session sticky 模块，需要重新编译才行（windows 下我也不知道怎么重新编译）\n优点是处理效率高多了，缺点是强会话要求的场合不合适\n添加 JMS 远程监控 对于部署在局域网内其它机器上的 Tomcat，可以打开 JMX 监控端口，局域网其它机器就可以通过这个端口查看一些常用的参数（但一些比较复杂的功能不支持），同样是在 JVM 启动参数中配置即可，配置如下：\n-Dcom.sun.management.jmxremote.ssl=false\n-Dcom.sun.management.jmxremote.authenticate=false\n-Djava.rmi.server.hostname=192.168.71.38 设置 JVM 的 JMS 监控监听的 IP\n地址，主要是为了防止错误的监听成 127.0.0.1 这个内网地址\n-Dcom.sun.management.jmxremote.port=1090 设置 JVM 的 JMS 监控的端口\n-Dcom.sun.management.jmxremote.ssl=false 设置 JVM 的 JMS 监控不实用\nSSL\n-Dcom.sun.management.jmxremote.authenticate=false 设置 JVM 的 JMS 监控不需要认证\n专业点的分析工具有 IBM ISA，JProfiler、probe 等，具体监控及分析方式去网上搜索即可\n关于 Tomcat 的 session 数目 这个可以直接从 Tomcat 的 web 管理界面去查看即可 ；\n或者借助于第三方工具 Lambda Probe 来查看，它相对于 Tomcat 自带的管理稍微多了点功能，但也不多 ；\n监视 Tomcat 的内存使用情况 使用 JDK 自带的 jconsole 可以比较明了的看到内存的使用情况，线程的状态， 当前加载的类的总量等；\nJDK 自带的 jvisualvm 可以下载插件（如 GC 等），可以查看更丰富的信息。如果是分析本地的 Tomcat 的话，还可以进行内存抽样等，检查每个类的使用情况\n打印类的加载情况及对象的回收情况 这个可以通过配置 JVM 的启动参数，打印这些信息（到屏幕（默认也会到\ncatalina.log 中）或者文件），具体参数如下：\n-XX:+PrintGC：输出形式：[GC 118250K-\u0026gt;113543K(130112K), 0.0094143 secs] [Full GC 121376K-\u0026gt;10414K(130112K), 0.0650971 secs]\n-XX:+PrintGCDetails ：输出形式： [GC [DefNew: 8614K-\u0026gt;781K(9088K), 0.0123035 secs] 118250K-\u0026gt;113543K(130112K), 0.0124633 secs] [GC [DefNew: 8614K-\u0026gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-\u0026gt;10414K(121024K), 0.0433488 secs] 121376K-\u0026gt;10414K(130112K),\n0.0436268 secs]\n-XX:+PrintGCTimeStamps -XX:+PrintGC：PrintGCTimeStamps 可与上面两个混合使用，输出形式：11.851: [GC 98328K-\u0026gt;93620K(130112K), 0.0082960\nsecs]\n-XX:+PrintGCApplicationConcurrentTime：打印每次垃圾回收前，程序未中断的执行时间。可与上面混合使用。输出形式： Application time: 0.5291524 seconds\n-XX:+PrintGCApplicationStoppedTime：打印垃圾回收期间程序暂停的时间。可与上面混合使用。输出形式：Total time for which application threads were stopped: 0.0468229 seconds\n-XX:PrintHeapAtGC: 打印 GC 前后的详细堆栈信息\n-Xloggc:filename:与上面几个配合使用，把相关日志信息记录到文件以便分析\n-verbose:class 监视加载的类的情况\n-verbose:gc 在虚拟机发生内存回收时在输出设备显示信息\n-verbose:jni 输出 native 方法调用的相关情况，一般用于诊断 jni 调用错误信息\nTomcat 一个请求的完整过程 Ng:(nginx) upstream yy_001{\n server 10.99.99.99:8080;\nserver 10.99.99.100:8080;\nhash $**;\nhealthcheck_enabled; healthcheck_delay 3000;\nhealthcheck_timeout 1000;\nhealthcheck_failcount 2;\n healthcheck_send 'GET /healthcheck.html HTTP/1.0' 'Host: wo.com' 'Connection: close';\n }\nserver {\ninclude base.conf; server_name wo.de.tian;\n...\nlocation /yy/ {\nproxy_pass http://yy_001;\n}\n 首先 dns 解析 wo.de.tian 机器，一般是 ng 服务器 ip 地址\n然后 ng 根据 server 的配置，寻找路径为 yy/的机器列表，ip 和端口最后 选择其中一台机器进行访问\u0026mdash;-\u0026gt;下面为详细过程\n 请求被发送到本机端口 8080，被在那里侦听的 Coyote HTTP/1.1 Connector  获得\n Connector 把该请求交给它所在的 Service 的 Engine 来处理，并等待来自  Engine 的回应\n  Engine 获得请求 localhost/yy/index.jsp，匹配它所拥有的所有虚拟主机 Host\n  Engine 匹配到名为 localhost 的 Host（即使匹配不到也把请求交给该 Host 处理，因为该 Host 被定义为该 Engine 的默认主机）\n  localhost Host 获得请求/yy/index.jsp，匹配它所拥有的所有 Context\n  Host 匹配到路径为/yy 的 Context（如果匹配不到就把该请求交给路径名为\u0026rdquo; \u0026ldquo;的 Context 去处理）\n  path=\u0026quot;/yy\u0026quot;的 Context 获得请求/index.jsp，在它的 mapping table 中寻找对应的 servlet\n  Context 匹配到 URL PATTERN 为*.jsp 的 servlet，对应于 JspServlet 类\n  构造 HttpServletRequest 对象和 HttpServletResponse 对象，作为参数调用\n  JspServlet 的 doGet 或 doPost 方法\n Context 把执行完了之后的 HttpServletResponse 对象返回给 Host 11)Host 把 HttpServletResponse 对象返回给Engine  12)Engine 把 HttpServletResponse 对象返回给 Connector 13)Connector 把 HttpServletResponse 对象返回给客户 browser\nTomcat 工作模式？ Tomcat 是一个 JSP/Servlet 容器。其作为 Servlet 容器，有三种工作模式：独立的 Servlet 容器、进程内的 Servlet 容器和进程外的 Servlet 容器。\n进入 Tomcat 的请求可以根据 Tomcat 的工作模式分为如下两类：\nTomcat 作为应用程序服务器：请求来自于前端的 web 服务器，这可能是 Apache, IIS, Nginx 等；\nTomcat 作为独立服务器：请求来自于 web 浏览器；\n 更多请关注微信公众号：Java 技术栈，回复：面试\n ","pubDate":"2021-02-15","title":"15道经典的Tomcat面试题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_15%E9%81%93%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E7%9A%84java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/","plain":" 现在有 T1、T2、T3 三个线程，你怎样保证 T2 在 T1 执行完后执行，T3 在 T2 执行完后执行？   这个线程问题通常会在第一轮或电话面试阶段被问到，目的是检测你对\u0026quot;join\u0026quot;方法是否熟悉。这个多线程问题比较简单，可以用 join 方法实现。\n  在 Java 中 Lock 接口比 synchronized 块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？   lock 接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁，它能满足你写像ConcurrentHashMap 这样的高性能数据结构和有条件的阻塞。Java 线程面试的问题越来越会根据面试者的回答来提问。我强烈建议在你去参加多线程的面试之前认真读一下 Locks，因为当前其大量用于构建电子交易终统的客户端缓存和交易连接空间。\n  在 java 中 wait 和 sleep 方法的不同？   通常会在电话面试中经常被问到的 Java 线程面试问题。最大的不同是在等待时 wait 会释放锁，而 sleep 一直持有锁。Wait 通常被用于线程间交互，sleep 通常被用于暂停执行。\n 用 Java 实现阻塞队列。   这是一个相对艰难的多线程面试问题，它能达到很多的目的。第一，它可以检测侯选者是否能实际的用 Java 线程写程序；第二，可以检测侯选者对并发场景的理解，并且你可以根据这个问很多问题。如果他用wait()和notify()方法来实现阻塞队列，你可以要求他用最新的Java 5 中的并发类来再写一次。\n 用 Java 写代码来解决生产者\u0026mdash;\u0026mdash;消费者问题。   与上面的问题很类似，但这个问题更经典，有些时候面试都会问下面的问题。在 Java 中怎么解决生产者\u0026mdash;\u0026mdash;消费者问题，当然有很多解决方法，我已经分享了一种用阻塞队列实现的方法。有些时候他们甚至会问怎么实现哲学家进餐问题。\n 用 Java 编程一个会导致死锁的程序，你将怎么解决？   这是我最喜欢的 Java 线程面试问题，因为即使死锁问题在写多线程并发程序时非常普遍， 但是很多侯选者并不能写 deadlock free code（无死锁代码？），他们很挣扎。只要告诉他们，你有 N 个资源和 N 个线程，并且你需要所有的资源来完成一个操作。为了简单这里的 n 可以替换为 2，越大的数据会使问题看起来更复杂。通过避免 Java 中的死锁来得到关于死锁的更多信息。\n 什么是原子操作，Java 中的原子操作是什么？   非常简单的 java 线程面试问题，接下来的问题是你需要同步一个原子操作。\n Java 中的 volatile 关键是什么作用？怎样使用它？在 Java 中它跟 synchronized 方法有什么不同？   自从 Java 5 和 Java 内存模型改变以后，基于 volatile 关键字的线程问题越来越流行。应该准备好回答关于 volatile 变量怎样在并发环境中确保可见性。\n 什么是竞争条件？你怎样发现和解决竞争？   这是一道出现在多线程面试的高级阶段的问题。大多数的面试官会问最近你遇到的竞争条件， 以及你是怎么解决的。有些时间他们会写简单的代码，然后让你检测出代码的竞争条件。可以参考我之前发布的关于 Java 竞争条件的文章。在我看来这是最好的 java 线程面试问题之一，它可以确切的检测候选者解决竞争条件的经验，or writing code which is free of data race or anyother race condition。关于这方面最好的书是《Concurrency practices in Java》。\n 你将如何使用threaddump？你将如何分析 Thread dump？   在 UNIX 中你可以使用 kill -3，然后 thread dump 将会打印日志，在windows 中你可以使用\u0026quot;\nCTRL+Break\u0026quot;。非常简单和专业的线程面试问题，但是如果他问你怎样分析它，就会很棘手。\n 为什么我们调用start()方法时会执行 run()方法，为什么我们不能直接调用 run()方法？   这是另一个非常经典的 java 多线程面试问题。这也是我刚开始写线程程序时候的困惑。现在这个问题通常在电话面试或者是在初中级 Java 面试的第一轮被问到。这个问题的回答应该是这样的，当你调用 start()方法时你将创建新的线程，并且执行在 run()方法里的代码。但是如果你直接调用 run()方法，它不会创建新的线程也不会执行调用线程的代码。阅读我之前写的《start 与run 方法的区别》这篇文章来获得更多信息。\n Java 中你怎样唤醒一个阻塞的线程？   这是个关于线程和阻塞的棘手的问题，它有很多解决方法。如果线程遇到了 IO 阻塞，我并且不认为有一种方法可以中止线程。如果线程因为调用wait()、sleep()、或者 join()方法而导致的阻塞，你可以中断线程，并且通过抛出 InterruptedException 来唤醒它。我之前写的《How to deal with blocking methods in java》有很多关于处理线程阻塞的信息。\n 在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？   这个线程问题主要用来检测你是否熟悉 JDK5 中的并发包。这两个的区别是 CyclicBarrier 可以重复使用已经通过的障碍，而 CountdownLatch 不能重复使用。\n 什么是不可变对象，它对写并发应用有什么帮助？   另一个多线程经典面试问题，并不直接跟线程有关，但间接帮助很多。这个 java 面试问题可以变的非常棘手，如果他要求你写一个不可变对象，或者问你为什么 String 是不可变的。\n 你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的？   多线程和并发程序中常遇到的有 Memory-interface、竞争条件、死锁、活锁和饥饿。问题是没有止境的，如果你弄错了，将很难发现和调试。这是大多数基于面试的，而不是基于实际应用的 Java 线程问题。\n ","pubDate":"2021-02-15","title":"15道面试常问的Java多线程面试题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_17%E9%81%93%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97kafka%E9%9D%A2%E8%AF%95%E9%A2%98/","plain":" Kafka 的设计时什么样的呢？  Kafka 将消息以 topic 为单位进行归纳\n将向Kafka topic 发布消息的程序成为 producers.\n将预订 topics 并消费消息的程序成为 consumer.\nKafka 以集群的方式运行，可以由一个或多个服务组成，每个服务叫做一个 broker. producers 通过网络将消息发送到Kafka 集群，集群向消费者提供消息\n 数据传输的事物定义有哪三种？  数据传输的事务定义通常有以下三种级别：\n  最多一次: 消息不会被重复发送，最多被传输一次，但也有可能一次不传输\n  最少一次: 消息不会被漏发送，最少被传输一次，但也有可能被重复传输.\n  精确的一次（Exactly once）: 不会漏传输也不会重复传输,每个消息都传输被一次而且仅仅被传输一次，这是大家所期望的\n   Kafka 判断一个节点是否还活着有那两个条件？    节点必须可以维护和 ZooKeeper 的连接，Zookeeper 通过心跳机制检查每个节点的连接\n  如果节点是个follower,他必须能及时的同步 leader 的写操作，延时不能太久\n   producer 是否直接将数据发送到 broker 的 leader(主节点)？  producer 直接将数据发送到 broker 的 leader(主节点)，不需要在多个节点进行分发，为了帮助 producer 做到这点，所有的 Kafka 节点都可以及时的告知:哪些节点是活动的，目标 topic 目标分区的leader 在哪。这样 producer 就可以直接将消息发送到目的地了\n5、Kafa consumer 是否可以消费指定分区消息？\nKafa consumer 消费消息时，向 broker 发出\u0026quot;fetch\u0026quot;请求去消费特定分区的消息，consumer 指定消息在日志中的偏移量（offset），就可以消费从这个位置开始的消息，customer 拥有了 offset 的控制权，可以向后回滚去重新消费之前的消息，这是很有意义的\n6、Kafka 消息是采用Pull 模式，还是 Push 模式？\nKafka 最初考虑的问题是，customer 应该从 brokes 拉取消息还是 brokers 将消息推送到consumer，也就是 pull 还 push。在这方面，Kafka 遵循了一种大部分消息系统共同的传统的设计：producer 将消息推送到 broker，consumer 从 broker 拉取消息\n一些消息系统比如Scribe 和Apache Flume 采用了 push 模式，将消息推送到下游的 consumer。这样做有好处也有坏处：由 broker 决定消息推送的速率，对于不同消费速率的 consumer 就不太好处理了。消息系统都致力于让 consumer 以最大的速率最快速的消费消息，但不幸的是，push 模式下，当 broker 推送的速率远大于 consumer 消费的速率时，consumer 恐怕就要崩溃了。最终Kafka 还是选取了传统的 pull 模式\nPull 模式的另外一个好处是 consumer 可以自主决定是否批量的从 broker 拉取数据。Push 模式必须在不知道下游 consumer 消费能力和消费策略的情况下决定是立即推送每条消息还是缓存之后批量推送。如果为了避免 consumer 崩溃而采用较低的推送速率，将可能导致一次只推送较少的消息而造成浪费。Pull 模式下，consumer 就可以根据自己的消费能力去决定这些策略\nPull 有个缺点是，如果 broker 没有可供消费的消息，将导致 consumer 不断在循环中轮询， 直到新消息到t 达。为了避免这点，Kafka 有个参数可以让 consumer 阻塞知道新消息到达(当然也可以阻塞知道消息的数量达到某个特定的量这样就可以批量发\nKafka 存储在硬盘上的消息格式是什么？  消息由一个固定长度的头部和可变长度的字节数组组成。头部包含了一个版本号和 CRC32\n校验码。\n 消息长度: 4 bytes (value: 1+4+n)\n版本号: 1 byte\n {width=\u0026ldquo;0.5208333333333334in\u0026rdquo; height=\u0026ldquo;0.17833333333333334in\u0026rdquo;}校验码: 4 bytes\n具体的消息: n bytes\nKafka 高效文件存储设计特点：  (1).Kafka 把 topic 中一个 parition 大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完文件，减少磁盘占用。\n 通过索引信息可以快速定位 message 和确定response 的最大大小。\n  通过 index 元数据全部映射到 memory，可以避免 segment file 的 IO 磁盘操作。\n  通过索引文件稀疏存储，可以大幅降低 index 文件元数据占用空间大小。\n  Kafka 与传统消息系统之间有三个关键区别  (1).Kafka 持久化日志，这些日志可以被重复读取和无限期保留\n(2).Kafka 是一个分布式系统：它以集群的方式运行，可以灵活伸缩，在内部通过复制数据提升容错能力和高可用性\n(3).Kafka 支持实时的流式处理\nKafka 创建 Topic 时如何将分区放置到不同的 Broker 中副本因子不能大于 Broker 的个数；   第一个分区（编号为 0）的第一个副本放置位置是随机从 brokerList 选择的；\n 其他分区的第一个副本放置位置相对于第 0 个分区依次往后移。也就是如果我们有 5 个Broker，5 个分区，假设第一个分区放在第四个 Broker 上，那么第二个分区将会放在第五个 Broker 上；第三个分区将会放在第一个 Broker 上；第四个分区将会放在第二个 Broker\n上，依次类推；\n剩余的副本相对于第一个副本放置位置其实是由 nextReplicaShift 决定的，而这个数也是随机产生的\nKafka 新建的分区会在哪个目录下创建  在启动 Kafka 集群之前，我们需要配置好 log.dirs 参数，其值是 Kafka 数据的存放目录， 这个参数可以配置多个目录，目录之间使用逗号分隔，通常这些目录是分布在不同的磁盘上用于提高读写性能。\n当然我们也可以配置 log.dir 参数，含义一样。只需要设置其中一个即可。\n如果 log.dirs 参数只配置了一个目录，那么分配到各个 Broker 上的分区肯定只能在这个目录下创建文件夹用于存放数据。\n但是如果 log.dirs 参数配置了多个目录，那么 Kafka 会在哪个文件夹中创建分区目录呢？ 答案是：Kafka 会在含有分区目录最少的文件夹中创建新的分区目录，分区目录名为 Topic 名+分区 ID。注意，是分区文件夹总数最少的目录，而不是磁盘使用量最少的目录！也就是说，如果你给 log.dirs 参数新增了一个新的磁盘，新的分区目录肯定是先在这个新的磁盘上创建直到这个新的磁盘目录拥有的分区目录不是最少为止。\npartition 的数据如何保存到硬盘  topic 中的多个 partition 以文件夹的形式保存到 broker，每个分区序号从 0 递增， 且消息有序\nPartition 文件下有多个 segment（xxx.index，xxx.log）\nsegment 文件里的 大小和配置文件大小一致可以根据要求修改 默认为 1g\n如果大小大于 1g 时，会滚动一个新的 segment 并且以上一个 segment 最后一条消息的偏移量命名\nkafka 的 ack 机制  request.required.acks 有三个值 0 1 -1\n0:生产者不会等待broker 的 ack，这个延迟最低但是存储的保证最弱当 server 挂掉的时候就会丢数据\n1：服务端会等待 ack 值 leader 副本确认接收到消息后发送 ack 但是如果 leader 挂掉后他不确保是否复制完成新leader 也会导致数据丢失\n-1：同样在 1 的基础上 服务端会等所有的 follower 的副本受到数据后才会受到 leader 发出的 ack，这样数据不会丢失\nKafka 的消费者如何消费数据  消费者每次消费数据的时候，消费者都会记录消费的物理偏移量（offset）的位置等到下次消费时，他会接着上次位置继续消费\n消费者负载均衡策略  一个消费者组中的一个分片对应一个消费者成员，他能保证每个消费者成员都能访问，如果组中成员太多会有空闲的成员\n数据有序  一个消费者组里它的内部是有序的消费者组与消费者组之间是无序的\nkafaka 生产数据时数据的分组策略  生产者决定数据产生到集群的哪个 partition 中每一条消息都是以（key，value）格式\nKey 是由生产者发送数据传入\n所以生产者（key）决定了数据产生到集群的哪个 partition\n更多请关注微信公众号：Java 技术栈，回复：面试\n","pubDate":"2021-02-15","title":"17道消息队列Kafka面试题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_18%E9%81%93%E9%9D%9E%E5%B8%B8%E7%89%9B%E9%80%BC%E7%9A%84nginx%E9%9D%A2%E8%AF%95%E9%A2%98/","plain":"1、请解释一下什么是 Nginx?  Nginx 是一个 web 服务器和反向代理服务器，用于 HTTP、HTTPS、SMTP、POP3 和IMAP 协议。\n**2、请列举 Nginx 的一些特性。**Nginx 服务器的特性包括：\n反向代理/L7 负载均衡器嵌入式 Perl 解释器\n动态二进制升级\n可用于重新编写 URL，具有非常好的 PCRE 支持3、请列举 Nginx 和 Apache 之间的不同点\n 4、请解释 Nginx 如何处理 HTTP 请求。  Nginx 使用反应器模式。主事件循环等待操作系统发出准备事件的信号，这样数据就可以从套接字读取，在该实例中读取到缓冲区并进行处理。单个线程可以提供数万个并发连接。\n5、在 Nginx 中，如何使用未定义的服务器名称来阻止处理请求? 只需将请求删除的服务器就可以定义为：\nServer {listen 80;server_name \u0026quot; \u0026quot; ;return 444;\n}\n这里，服务器名被保留为一个空字符串，它将在没有\u0026quot;主机\u0026quot;头字段的情况下匹配请求，而一个特殊的 Nginx 的非标准代码 444 被返回，从而终止连接。\n 6、 使用\u0026quot;反向代理服务器\u0026quot;的优点是什么?  反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和 web 服务器之间的中间层。这对于安全方面来说是很好的，特别是当您使用 web 托管服务时。\n 7、请列举 Nginx 服务器的最佳用途。  Nginx 服务器的最佳用法是在网络上部署动态 HTTP 内容，使用 SCGI、WSGI 应用程序服务器、用于脚本的 FastCGI 处理程序。它还可以作为负载均衡器。\n8、请解释 Nginx 服务器上的 Master 和 Worker 进程分别是什么? Master 进程：读取及评估配置和维持\nWorker 进程：处理请求\n 9、请解释你如何通过不同于 80 的端口开启 Nginx?  为了通过一个不同的端口开启 Nginx，你必须进入/etc/Nginx/sites-enabled/， 如果这是默认文件，那么你必须打开名为\u0026quot;default\u0026quot;的文件。编辑文件，并放置在你想要的端口：\nLike server { listen 81; }\n 10、请解释是否有可能将 Nginx 的错误替换为 502 错误、503?  502 =错误网关\n503 =服务器超载\n有可能，但是您可以确保 fastcgi_intercept_errors 被设置为 ON，并使用错误页面指令。\nLocation / {fastcgi_pass 127.0.01:9001;fastcgi_intercept_errors on;error_page 502 =503/error_page.html;#\u0026hellip;}\n 11、在 Nginx 中，解释如何在 URL 中保留双斜线?  要在 URL 中保留双斜线，就必须使用 merge_slashes_off; 语法:merge_slashes [on/off]\n默认值: merge_slashes on 环境: http，server\n 12、请解释 ngx_http_upstream_module 的作用是什么?  ngx_http_upstream_module 用于定义可通过 fastcgi 传递、proxy 传递、uwsgi 传递、memcached 传递和 scgi 传递指令来引用的服务器组。\n 13、请解释什么是 C10K 问题?  C10K 问题是指无法同时处理大量客户端(10,000)的网络套接字。14、请陈述 stub_status 和 sub_filter 指令的作用是什么?\nStub_status 指令：该指令用于了解 Nginx 当前状态的当前状态，如当前的活动连接，接受和处理当前读/写/等待连接的总数\nSub_filter 指令：它用于搜索和替换响应中的内容，并快速修复陈旧的数据 15、解释 Nginx 是否支持将请求压缩到上游?\n您可以使用 Nginx 模块 gunzip 将请求压缩到上游。gunzip 模块是一个过滤器， 它可以对不支持\u0026quot;gzip\u0026quot;编码方法的客户机或服务器使用\u0026quot;内容编码:gzip\u0026quot;来解压缩响应。\n 16、解释如何在 Nginx 中获得当前的时间?  要获得 Nginx 的当前时间，必须使用 SSI 模块、$date_gmt 和$date_local 的变量。\nProxy_set_header THE-TIME $date_gmt; 17、用 Nginx 服务器解释-s 的目的是什么? 用于运行 Nginx -s 参数的可执行文件。18、解释如何在 Nginx 服务器上添加模块?\n在编译过程中，必须选择 Nginx 模块，因为 Nginx 不支持模块的运行时间选择。\n更多请关注微信公众号：Java 技术栈，回复：面试\n ","pubDate":"2021-02-15","title":"18道非常牛逼的Nginx面试题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E4%BF%A1%E6%81%AF%E5%92%A8%E8%AF%A2_1ch/","plain":"信息系统概述 信息   什么是社会的标志\n  答:信息是当今社会的标志\n  一:信息的含义 (填空题，单选题，简答题)   1:) 信息的存在不以主体(如人、生物或机器系统) 存在为转移,即使主体根本不存在，信息也可以存在，他在客观上反映某一客观事物的现实情况。\n  2:) 信息在主观上可以接受和利用，并指导人们的行动。\n  信息与数据是信息系统中最基本的术语 ;\r信息是数据加工的结果,是数据的含义，而数据是信息的载体;\r二:信息的性质 (简答题)  一共分为6个方面\n  1:) 客观性 (信息的核心)  客观性也称事实性\r 2:) 时效性  信息的时效性是指从信息源发送信息，经过接收、加工、传递和利用所经历的时间间隔及其效率。\r 时间间隔越短，使用信息越及时，使用程度越高，则时效性越强。\n  3:) 等级性  信息系统是分等级的，对同一问题，处于不同管理层次，所要求的信息不同。\r分为:战略级、管理级、操作级\r 4:) 扩散性  信息的扩散是其本性，它总是力图冲破保密的非自然约束，通过各种渠道和手段向四面八方传播。\r信息的扩散存在两面性，一方面它有利于知识的传播，另一方面可能造成信息的贬值\r 5:) 可传递性  信息在扩散的过程中，可以通过多种传输渠道、采用多种传输方式进行传递。\r 6:) 价值性  信息是经过加工的、有意义的数据，是一种资源，因而是有价值的\r信息系统  信息系统工作的好坏与整个组织的效益关系极大，可以说信息系统是整个系统的神经系统  一:系统的概念   什么是系统\n  答:系统是为了达到某种目的而对单一群单元作出有规律的安排，使之成为一个相关联的整体\n   系统必须依赖于环境而存在，不能孤立。系统与其环境之间相互交流，相互影响。\n  一个实际物理模型从宏观上来看有输入、处理和输出三部份  二:信息系统的概念  信息系统是一个人造系统，它由人，计算机硬件，软件和数据资源组成，目的是及时，正确的收集、加工、存储、传递和提供决策所需的信息\n  目前普遍认同的信息系统是指基于计算机、通信网络等现代化的工具和手段，服务于管理领域的信息处理系统\n  信息系统包括输入、处理、输出和反馈四个部分 (系统观点)  三:信息系统的功能   信息系统是对信息进行采集、处理、存储、管理、检索和传输 (考过7次简答)\n  1:) 信息的采集\n  信息采集是信息系统的重要环节。\r 2:) 信息的处理  现代化的信息系统都是依赖规模大小不同的计算机来处理数据，并且处理能力越来越强。\r 3:) 信息的存储  数据被采集进入信息系统之后，经过加工处理，形成对管理有用的信息，然后由信息系统负责对这些信息进行存储保管\r存储技术有物理存储和逻辑组织两个问题\r 4:) 信息的管理  论述题:\r信息管理的内容:规定应采集数据的种类、名称、代码等,规定应存储数据的存储介质、逻辑组织方式，规定数据传输方式和保存时间等\r  5:) 信息的检索 (非重点)\n  6:) 信息的传输 (非重点)\n  四:信息系统的演化   信息技术在企业广泛应用分为两部分:辅助生产过程，实现生产过程自动化 ,辅助企业管理，实现管理自动化\n  名词解释:计算机辅助设计(CAD)，计算机辅助制造(CAM)属于辅助生产;计算机信息系统(CIS)属于辅助企业管理\n  数据处理系统(DPS) 一般指天天重复，但变化不大的各种过程处理和事务处理如工资计算\n  管理信息系统(MIS) 是为实现系统的整体管理目标，对各类管理信息进行系统、综合处理，并辅助各级管理人员进行管理决策的信息处理系统\n  MIS主要由信息收集、信息存储、信息加工、人机交互与输出等部分以及管理者所组成\r 决策支持系统(DSS)是MIS的发展与深化 一句话就是指导我们怎么做,然后就是面向中、低层管理人员  DSS通常具有以下特点:较强的语言处理和人机交互能力，以知识为基础的存储能力，将数学模型、算法和推理方法结合起来的问题处理能力\r 企业资源计划ERP是信息系统的进一步发展  ERP就是信息技术在管理领域的一种应用，把管理的东西用软件固化下来，就变成了现代化的管理手段\r  主管信息系统EIS的主要目标是帮助企业高层领导规划、控制企业运作，获得整个企业内部和外部信息，以辅助决策\n  办公自动化系统(OAS)的建立主要是为了有效的应用信息技术，提高办公人员的工作效率\n  专家系统(ES) 能对复杂情况作出诊断，能处理不确定情况，并能对方案作出解释\n   专家系统只是一个高级的计算机智能程序系统\n  战略信息系统 SIS 主要功能是支持企业形成竞争策略，使企业获得保持竞争优势   战略系统是面对高级管理者，重点是辅助进行长期决策\n  企业过程重组 BPR   所谓企业过程重组，一般认为是对企业经营过程进行根本性的再思考和彻底的重新设计，以求在成本质量、速度、服务等绩效标准上取得重大改善\n  集成型信息系统是当今企业信息系统的主要发展方向之一  五:信息系统的发展趋势   1:) 从系统开发到系统集成\n  2:) 从以程序为中心到以信息内容或者以用户为中心\n  3:) 从孤立封闭的集中控制式系统到协同开放的分布式系统\n  4:) 系统的外在表现方面，从设计者固定的界面到用户可以调节的界面，再到适应性用户界面等\n  信息系统工程  信息系统工程是用系统工程的原理、方法来指导信息系统建设与管理的一门工程技术学科。最基本特点是研究方法的 整体性 ,技术应用的综合性和管理学上的科学性。(名词解释，填空题)  ~ 这些内容称为工程管理，管理的**科学性**是系统工程的**关键**\r  信息系统工程研究范围 (简单题，论述题)\n  1:)\n  信息系统建设与管理的概念、方法、评价、规划、工具和标准等一系列相关问题,即信息系统的系统工程\r 2:)  依据信息系统工程自身发展的规律和特点，发展和研究实现信息化建设的工程方法\r 3:)  数据库是信息系统的基础，一方面要研究系统核心的数据库设计与实现，另一方面要研究围绕数据库进行的各种应用软件及其他软件的设计与实现\r 4:)  总体数据规划，涉及数据的稳定性和共享性的统一\r 5:)  系统集成\r","pubDate":"2021-02-15","title":"1ch"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_20%E9%81%93%E9%9D%A2%E8%AF%95%E5%AE%98%E5%B8%B8%E9%97%AE%E7%9A%84jvm%E9%9D%A2%E8%AF%95%E9%A2%98/","plain":"  内存模型以及分区，需要详细到每个区放什么。\n  堆里面的分区：Eden，survival （from+ to），老年代，各自的特点。\n  对象创建方法，对象的内存分配，对象的访问定位。\n   new 一个对象\n   GC 的两种判定方法：\n  SafePoint 是什么\n  GC 的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在\n   什么地方，如果让你优化收集方法，有什么思路？\n   GC 收集器有哪些？CMS 收集器与 G1 收集器的特点。\n  Minor GC 与 Full GC 分别在什么时候发生？\n   新生代内存不够用时候发生 MGC 也叫 YGC，JVM 内存不够的时候发生 FGC\n   几种常用的内存调试工具：jmap、jstack、jconsole、jhat\n  类加载的几个过程：\n  JVM 内存分哪几个区，每个区的作用是什么?\n  如和判断一个对象是否存活?(或者 GC 对象的判定方法)\n  {width=\u0026ldquo;5.8093055555555555in\u0026rdquo; height=\u0026ldquo;3.4669444444444446in\u0026rdquo;}\n  {width=\u0026ldquo;5.8093055555555555in\u0026rdquo; height=\u0026ldquo;1.733665791776028in\u0026rdquo;}{width=\u0026ldquo;5.8093055555555555in\u0026rdquo; height=\u0026ldquo;5.884444444444444in\u0026rdquo;}虚拟机栈中引用的对象\n  方法区类静态属性引用的对象\n  方法区常量池引用的对象\n  本地方法栈 JNI 引用的对象\n   虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比不一定\n会被回收。当一个对象不可达 GC Root 时，这个对象并\n不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记\n如果对象在可达性分析中没有与 GC Root 的引用链，那么此时就会被第一次标记并且进行\n一次筛选，筛选的条件是是否有必要执行finalize()方法。当对象没有覆盖 finalize()方法或\n者已被虚拟机调用过，那么就认为是没必要的。\n如果该对象有必要执行finalize()方法，那么这个对象将会放在一个称为 F-Queue 的对队列\n中，虚拟机会触发一个Finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承诺\n一直等待它运行完，这是因为如果finalize()执行缓慢或者发生了死锁，那么就会造成\n   简述 java 垃圾回收机制?\n  java 中垃圾收集的方法有哪些?\n  {width=\u0026ldquo;5.6426388888888885in\u0026rdquo; height=\u0026ldquo;4.4173600174978125in\u0026rdquo;}\n {width=\u0026ldquo;5.6426388888888885in\u0026rdquo; height=\u0026ldquo;6.234360236220472in\u0026rdquo;}于是将该算法进行了改进，内存区域不再是按照 1：1 去划分，而是将内存划分为 8:1:1\n三部分，较大那份内存交Eden 区，其余是两块较小的内存区叫 Survior 区。每次都\n会优先使用Eden 区，若 Eden 区满，就将对象复制到第二块内存区上，然后清除 Eden\n区，如果此时存活的对象太多，以至于 Survivor 不够时，会将这些对象通过分配担\n保机制复制到老年代中。(java 堆又分为新生代和老年代)\n 标记-整理  该算法主要是为了解决标记-清除，产生大量内存碎片的问题；当对象存活率较高时，\n也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收对象\n移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。\n 分代收集  现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代\n和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这\n时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所\n以可以使用标记-整理 或者 标记-清除。\n   java 内存模型\n  java 类加载过程?\n  {width=\u0026ldquo;5.8093055555555555in\u0026rdquo; height=\u0026ldquo;5.6343602362204726in\u0026rdquo;}元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被   继承的类等。\n 字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，   确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指\n令是否正确等。\n 符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执   行。\n 准备  准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行\n分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起\n分配在 Java 堆中。\npublic static int value=123;//在准备阶段 value 初始值为 0 。在初始化阶段才会变\n为 123 。\n   1\n  2\n   {width=\u0026ldquo;5.8093055555555555in\u0026rdquo; height=\u0026ldquo;3.0340824584426946in\u0026rdquo;}简述java 类加载机制?\n  类加载器双亲委派模型机制？\n  什么是类加载器，类加载器有哪些?\n  简述 java 内存分配与回收策率以及 Minor GC 和Major GC\n  ","pubDate":"2021-02-15","title":"20道面试官常问的JVM面试题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_20%E9%81%93%E9%A1%B6%E5%B0%96%E7%9A%84springoot%E9%9D%A2%E8%AF%95%E9%A2%98/","plain":" 面试了一些人，简历上都说自己熟悉 Spring Boot, 或者说正在学习 Spring Boot，一问他们时，都只停留在简单的使用阶段，很多东西都不清楚，也让我对面试者大失所望。\n下面，我给大家总结下有哪些 Spring Boot 的面试题，这是我经常拿来问面试者的，希望对你有帮助。\n 1、什么是 Spring Boot？  Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。\n更多 Spring Boot 详细介绍请看这篇文章《什么是 Spring Boot?》。\n 2、为什么要用 Spring Boot？  Spring Boot 优点非常多，如：\n   独立运行\n  简化配置\n  自动配置\n  无代码生成和 XML 配置\n  应用监控\n  上手容易\n  ...\n   Spring Boot 集这么多优点于一身，还有理由不使用它呢？\n 3、Spring Boot 的核心配置文件有哪几个？它们的区别是什么？  Spring Boot 的核心配置文件是 application 和 bootstrap 配置文件。application 配置文件这个容易理解，主要用于 Spring Boot 项目的自动化配置。bootstrap 配置文件有以下几个应用场景。\n   使用 Spring Cloud Config 配置中心时，这时需要在 bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息；\n  一些固定的不能被覆盖的属性；\n  一些加密/解密的场景；\n   具体请看这篇文章《Spring Boot 核心配置文件详解》。\n 4、Spring Boot 的配置文件有哪几种格式？它们有什么区别？  .properties 和 .yml，它们的区别主要是书写格式不同。1).properties\napp.user.name = javastack\n2).yml\n另外，.yml 格式不支持 @PropertySource 注解导入配置。\n 5、Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？  启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：\n@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。\n@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项， 如关闭数据源自动配置功能： @SpringBootApplication(exclude =\n{ DataSourceAutoConfiguration.class })。@ComponentScan：Spring 组件扫描。\n 6、开启 Spring Boot 特性有哪几种方式？   继承spring-boot-starter-parent 项目\n  导入spring-boot-dependencies 项目依赖\n   具体请参考这篇文章《Spring Boot 开启的2 种方式》。\n 7、Spring Boot 需要独立的容器运行吗？  可以不需要，内置了 Tomcat/ Jetty 等容器。\n8、运行 Spring Boot 有哪几种方式？ 1）打包用命令或者放到容器中运行 2）用 Maven/ Gradle 插件运行\n  直接执行 main 方法运行  9、Spring Boot 自动配置原理是什么？  注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配置的核心，首先它得是一个配置文件，其次根据类路径下是否有这个类去自动配置。\n具体看这篇文章《Spring Boot 自动配置原理、实战》。\n 10、Spring Boot 的目录结构是怎样的？  这个目录结构是主流及推荐的做法，而在主入口类上加上 @SpringBootApplication 注解来开启 Spring Boot 的各项能力，如自动配置、组件扫描等。具体看这篇文章《Spring Boot 主类及目录结构介绍》。\n 11、你如何理解 Spring Boot 中的 Starters？  Starters 可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成 Spring 及其他技术，而不需要到处找示例代码和依赖包。如你想使用 Spring JPA 访问数据库，只要加入 spring-boot-starter-data-jpa 启动器依赖就能使用了。\nStarters 包含了许多项目中需要用到的依赖，它们能快速持续的运行，都是一系列得到支持的管理传递性依赖。具体请看这篇文章《Spring Boot Starters 启动器》。\n 12、如何在 Spring Boot 启动的时候运行一些特定的代码？  可以实现接口 ApplicationRunner 或者 CommandLineRunner，这两个接口实现方式一样，它们都只提供了一个 run 方法，具体请看这篇文章《Spring Boot Runner 启动器》。\n 13、Spring Boot 有哪几种读取配置的方式？  Spring Boot 可以通过 @PropertySource,@Value,@Environment, @ConfigurationProperties 来绑定变量，具体请看这篇文章《Spring Boot 读取配置的几种方式》。\n 14、Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？  Spring Boot 支持 Java Util Logging, Log4j2, Lockback 作为日志框架，如果你使用Starters 启动器，Spring Boot 将使用 Logback 作为默认日志框架，具体请看这篇文章\n《Spring Boot 日志集成》。\n 15、SpringBoot 实现热部署有哪几种方式？  主要有两种方式：\n   Spring Loaded\n  Spring-boot-devtools\n   Spring-boot-devtools 使用方式可以参考这篇文章《Spring Boot 实现热部署》。\n 16、你如何理解 Spring Boot 配置加载顺序？  在 Spring Boot 里面，可以使用以下几种方式来加载配置。1）properties 文件；\n  YAML 文件；\n  系统环境变量；\n  命令行参数； 等等\u0026hellip;\u0026hellip;\n   具体请看这篇文章《Spring Boot 配置加载顺序详解》。\n 17、Spring Boot 如何定义多套不同环境配置？  提供多套配置文件，如：\n运行时指定具体的配置文件，具体请看这篇文章《Spring Boot Profile 不同环境配置》。\n 18、Spring Boot 可以兼容老 Spring 项目吗，如何做？  可以兼容，使用 @ImportResource 注解导入老 Spring 项目配置文件。\n 19、保护 Spring Boot 应用有哪些方法？   在生产中使用 HTTPS\n  使用 Snyk 检查你的依赖关系\n  升级到最新版本\n  启用CSRF 保护\n  使用内容安全策略防止 XSS 攻击\n  ...\n   更多请看这篇文章《10 种保护 Spring Boot 应用的绝佳方法》。\n 20、Spring Boot 2.X 有什么新特性？与 1.X 有什么区别？   配置变更\n  JDK 版本升级\n  第三方类库升级\n  响应式 Spring 编程支持\n  HTTP/2 支持\n  配置属性绑定\n  更多改进与加强...\n   具体请看这篇文章《Spring Boot 2.x 新特性总结及迁移指南》。\n{width=\u0026ldquo;5.768055555555556in\u0026rdquo; height=\u0026ldquo;4.1666666666666664e-2in\u0026rdquo;}\n更多请关注微信公众号：Java 技术栈，回复：资料\n {width=\u0026ldquo;2.3099989063867015in\u0026rdquo; height=\u0026ldquo;2.3409372265966755in\u0026rdquo;}\n","pubDate":"2021-02-15","title":"20道顶尖的Springoot面试题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_22%E9%81%93%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E7%9A%84springmvc%E9%9D%A2%E8%AF%95%E9%A2%98/","plain":"1、什么是SpringMvc？\n答：SpringMvc 是 spring 的一个模块，基于MVC 的一个框架，无需中间整合层来整合。\n2、Spring MVC 的优点： 答：\n 它是基于组件技术的.全部的应用对象,无论控制器和视图,还是业务对象之类的都是 java  组件.并且和 Spring 提供的其他基础结构紧密集成.\n  不依赖于Servlet API(目标虽是如此,但是在实现的时候确实是依赖于 Servlet 的)\n  可以任意使用各种视图技术,而不仅仅局限于JSP\n  支持各种请求资源的映射策略\n  它应是易于扩展的\n  3、SpringMVC 工作原理？ 答：\n  客户端发送请求到 DispatcherServlet\n  DispatcherServlet 查询 handlerMapping 找到处理请求的 Controller 3）Controller 调用业务逻辑后，返回 ModelAndView 4）DispatcherServlet 查询 ModelAndView，找到指定视图\n   5）视图将结果返回到客户端\n 4、SpringMVC 流程？ 答：\n 1）用户发送请求至前端控制器 DispatcherServlet。2）DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。\n  处理器映射器找到具体的处理器(可以根据 xml 配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给 DispatcherServlet。\n  DispatcherServlet 调用 HandlerAdapter 处理器适配器。\n  HandlerAdapter 经过适配调用具体的处理器(Controller，也叫后端控制器)。\n  Controller 执行完成返回 ModelAndView。\n  HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet。8）DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。9）ViewReslover 解析后返回具体 View。\n   DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。\n  DispatcherServlet 响应用户。\n  6、SpringMvc 的控制器是不是单例模式,如果是,有什么问题,怎么解决？\n答：是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。\n7、如果你也用过struts2.简单介绍下 springMVC 和 struts2 的区别有哪些? 答：\n  springmvc 的入口是一个 servlet 即前端控制器，而 struts2 入口是一个 filter 过虑器。\n  springmvc 是基于方法开发(一个 url 对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2 是基于类开发，传递参数是通过类的属性，只能设计为多例。\n  Struts 采用值栈存储请求和响应的数据，通过 OGNL 存取数据，springmvc 通过参数解析器是将 request 请求内容解析，并给方法形参赋值，将数据和视图封装成 ModelAndView 对象，最后又将ModelAndView 中的模型数据通过reques 域传输到页面。Jsp 视图解析器默认使用 jstl。\n  8、SpingMvc 中的控制器的注解一般用那个,有没有别的注解可以替代？ 答：一般用@Conntroller 注解,表示是表现层,不能用用别的注解代替。9、 @RequestMapping 注解用在类上面有什么作用？\n答：是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\n10、怎么样把某个请求映射到特定的方法上面？\n答：直接在方法上面加上注解@RequestMapping,并且在这个注解里面写上要拦截的路径\n11、如果在拦截请求中,我想拦截 get 方式提交的方法,怎么配置？\n答：可以在@RequestMapping 注解里面加上 method=RequestMethod.GET 12、怎么样在方法里面得到 Request,或者 Session？\n答：直接在方法的形参中声明request,SpringMvc 就自动把 request 对象传入\n13、我想在拦截的方法里面得到从前台传入的参数,怎么得到？\n答：直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样\n14、如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？\n答：直接在方法中声明这个对象,SpringMvc 就自动会把属性赋值到这个对象里面。\n15、SpringMvc 中函数的返回值是什么？\n答：返回值可以有很多类型,有 String, ModelAndView,当一般用 String 比较好。\n16、SpringMVC 怎么样设定重定向和转发的？\n答：在返回值前面加\u0026quot;forward:\u0026quot;就可以让结果转发,譬如\u0026quot;forward:user.do?name=method4\u0026quot; 在返回值前面加\u0026quot;redirect:\u0026quot;就可以让返回值重定向,譬如\u0026quot;redirect:http://www.baidu.com\u0026quot;\n17、SpringMvc 用什么对象从后台向前台传递数据的？\n答：通过 ModelMap 对象,可以在这个对象里面用 put 方法,把对象加到里面,前台就可以通过\nel 表达式拿到。\n18、SpringMvc 中有个类把视图和数据都合并的一起的,叫什么？ 答：叫 ModelAndView。\n19、怎么样把 ModelMap 里面的数据放入Session 里面？\n答：可以在类上面加上@SessionAttributes 注解,里面包含的字符串就是要放入 session 里面的\nkey\n20、SpringMvc 怎么和AJAX 相互调用的？ 答：\n 通过 Jackson 框架就可以把 Java 里面的对象直接转化成 Js 可以识别的 Json 对象。具体步骤如下 ：\n1）加入 Jackson.jar\n  在配置文件中配置 json 的映射\n  在接受 Ajax 方法里面可以直接返回 Object,List 等,但方法前面要加上@ResponseBody\n  注解\n21、当一个方法向AJAX 返回特殊对象,譬如 Object,List 等,需要做什么处理？ 答：要加上@ResponseBody 注解\n22、SpringMvc 里面拦截器是怎么写的\n答：有两种写法,一种是实现接口,另外一种是继承适配器类,然后在 SpringMvc 的配置文件中配置拦截器即可：\n\u0026lt;!-- 配置 SpringMvc 的拦截器 --\u0026gt;\n\u0026lt;mvc:interceptors\u0026gt;\n \u0026lt;!-- 配置一个拦截器的 Bean 就可以了 默认是对所有请求都拦截 --\u0026gt;\n\u0026lt;bean id=\u0026quot;myInterceptor\u0026quot; class=\u0026quot;com.et.action.MyHandlerInterceptor\u0026quot;\u0026gt;\u0026lt;/bean\u0026gt;\n\u0026lt;!-- 只针对部分请求拦截 --\u0026gt;\n\u0026lt;mvc:interceptor\u0026gt;\n\u0026lt;mvc:mapping path=\u0026quot;/modelMap.do\u0026quot; /\u0026gt;\n\u0026lt;bean class=\u0026quot;com.et.action.MyHandlerInterceptorAdapter\u0026quot; /\u0026gt;\n\u0026lt;/mvc:interceptor\u0026gt;\n \u0026lt;/mvc:interceptors\u0026gt;\n23、讲下 SpringMvc 的执行流程\n答：系统启动的时候根据配置文件创建 spring 的容器, 首先是发送 http 请求到核心控制器disPatherServlet，spring 容器通过映射器去寻找业务控制器，使用适配器找到相应的业务类，在进业务类时进行数据封装，在封装前可能会涉及到类型转换，执行完业务类后使用ModelAndView 进行视图转发，数据放在 model 中，用 map 传递数据进行页面显示。\n","pubDate":"2021-02-15","title":"22道面试常问的SpringMVC面试题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_24%E9%81%93%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97rabbitmq%E9%9D%A2%E8%AF%95%E9%A2%98/","plain":"问题一：RabbitMQ 中的 broker 是指什么？cluster 又是指什么？\n答：broker 是指一个或多个 erlang node 的逻辑分组，且 node 上运行着 RabbitMQ 应用程序。cluster 是在 broker 的基础之上，增加了 node 之间共享元数据的约束。\n问题二：什么是元数据？元数据分为哪些类型？包括哪些内容？与 cluster 相关的元数据有哪些？元数据是如何保存的？元数据在 cluster 中是如何分布的？\n答：在非 cluster 模式下，元数据主要分为 Queue 元数据（queue 名字和属性等）、Exchange 元数据（exchange 名字、类型和属性等）、Binding 元数据（存放路由关系的查找表）、Vhost 元数据（vhost 范围内针对前三者的名字空间约束和安全属性设置）。在 cluster 模式下，还包括 cluster 中 node 位置信息和 node 关系信息。元数据按照 erlang node 的类型确定是仅保存于 RAM 中，还是同时保存在 RAM 和 disk 上。元数据在 cluster 中是全 node 分布的。\n下图所示为 queue 的元数据在单 node 和 cluster 两种模式下的分布图。\n问题三：RAM node 和 disk node 的区别？\n答：RAM node 仅将 fabric（即 queue、exchange 和 binding 等 RabbitMQ 基础构件）相关元数据保存到内存中，但 disk node 会在内存和磁盘中均进行存储。RAM node 上唯一会存储到磁盘上的元数据是 cluster 中使用的 disk node 的地址。要求在 RabbitMQ cluster 中至少存在一个 disk node 。\n问题四：RabbitMQ 上的一个 queue 中存放的 message 是否有数量限制？\n答：可以认为是无限制，因为限制取决于机器的内存，但是消息过多会导致处理效率的下降。\n问题五：RabbitMQ 概念里的 channel、exchange 和 queue 这些东东是逻辑概念，还是对应着进程实体？这些东东分别起什么作用？\n答：queue 具有自己的 erlang 进程；exchange 内部实现为保存 binding 关系的查找表； channel 是实际进行路由工作的实体，即负责按照 routing_key 将 message 投递给 queue 。由 AMQP 协议描述可知，channel 是真实 TCP 连接之上的虚拟连接，所有 AMQP 命令都是通过 channel 发送的，且每一个 channel 有唯一的 ID。一个 channel 只能被单独一个操作系统线程使用，故投递到特定 channel 上的 message 是有顺序的。但一个操作系统线程上允许使用多个 channel 。channel 号为 0 的 channel 用于处理所有对于当前 connection 全局有效的帧，而 1-65535 号 channel 用于处理和特定 channel 相关的帧。AMQP 协议给 出的 channel 复用模型如下\n其中每一个 channel 运行在一个独立的线程上，多线程共享同一个 socket。\n问题六：vhost 是什么？起什么作用？\n答：vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ server。其内部均含有独立的 queue、 exchange 和 binding 等，但最最重要的是，其拥有独立的权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段（一个典型的例子就是不同的应用可以跑在不同的 vhost 中）。\n【cluster 相关】\n问题七：在单 node 系统和多 node 构成的 cluster 系统中声明 queue、exchange ，以及进行 binding 会有什么不同？\n答：当你在单 node 上声明 queue 时，只要该 node 上相关元数据进行了变更，你就会得到 Queue.Declare-ok 回应；而在 cluster 上声明 queue ，则要求 cluster 上的全部 node 都要进行元数据成功更新，才会得到 Queue.Declare-ok 回应。另外，若 node 类型为 RAM node 则变更的数据仅保存在内存中，若类型为 disk node 则还要变更保存在磁盘上的数据。\n问题八：客户端连接到 cluster 中的任意 node 上是否都能正常工作？ 答：是的。客户端感觉不到有何不同。\n问题九：若 cluster 中拥有某个 queue 的 owner node 失效了，且该 queue 被声明具有\ndurable 属性，是否能够成功从其他 node 上重新声明该 queue ？\n答：不能，在这种情况下，将得到 404 NOT_FOUND 错误。只能等 queue 所属的 node 恢复后才能使用该 queue 。但若该 queue 本身不具有 durable 属性，则可在其他 node 上重新声明。\n问题十：cluster 中 node 的失效会对 consumer 产生什么影响？若是在 cluster 中创建了\nmirrored queue ，这时 node 失效会对 consumer 产生什么影响？\n答：若是 consumer 所连接的那个 node 失效（无论该 node 是否为 consumer 所订阅queue 的 owner node），则 consumer 会在发现 TCP 连接断开时，按标准行为执行重连逻辑，并根据\u0026quot;Assume Nothing\u0026quot;原则重建相应的 fabric 即可。若是失效的 node 为 consumer 订阅 queue 的 owner node，则 consumer 只能通过 Consumer Cancellation Notification 机制来检测与该 queue 订阅关系的终止，否则会出现傻等却没有任何消息来到的问题。\n问题十一：能够在地理上分开的不同数据中心使用 RabbitMQ cluster 么？\n答：不能。第一，你无法控制所创建的 queue 实际分布在 cluster 里的哪个 node 上（一般使用 HAProxy + cluster 模型时都是这样），这可能会导致各种跨地域访问时的常见问题；第二，Erlang 的 OTP 通信框架对延迟的容忍度有限，这可能会触发各种超时，导致业务疲于处理；第三，在广域网上的连接失效问题将导致经典的\u0026quot;脑裂\u0026quot;问题，而 RabbitMQ 目\n前无法处理（该问题主要是说 Mnesia）。\n【综合问题】\n问题十二：为什么 heavy RPC 的使用场景下不建议采用 disk node ？\n答：heavy RPC 是指在业务逻辑中高频调用 RabbitMQ 提供的 RPC 机制，导致不断创建、销毁 reply queue ，进而造成 disk node 的性能问题（因为会针对元数据不断写盘）。所以在使用 RPC 机制时需要考虑自身的业务场景。\n问题十三：向不存在的 exchange 发 publish 消息会发生什么？向不存在的 queue 执行\nconsume 动作会发生什么？\n答：都会收到 Channel.Close 信令告之不存在（内含原因 404 NOT_FOUND）。\n问题十四：routing_key 和 binding_key 的最大长度是多少？ 答：255 字节。\n问题十五：RabbitMQ 允许发送的 message 最大可达多大？\n答：根据 AMQP 协议规定，消息体的大小由 64-bit 的值来指定，所以你就可以知道到底能发多大的数据了。\n问题十六：什么情况下 producer 不主动创建 queue 是安全的？\n答：1.message 是允许丢失的；2.实现了针对未处理消息的 republish 功能（例如采用\nPublisher Confirm 机制）。\n问题十七：\u0026ldquo;dead letter\u0026quot;queue 的用途？\n答：当消息被 RabbitMQ server 投递到 consumer 后，但 consumer 却通过 Basic.Reject 进行了拒绝时（同时设置 requeue=false），那么该消息会被放入\u0026quot;dead letter\u0026quot;queue 中。该 queue 可用于排查 message 被 reject 或 undeliver 的原因。\n问题十八：为什么说保证 message 被可靠持久化的条件是 queue 和 exchange 具有\ndurable 属性，同时 message 具有 persistent 属性才行？\n答：binding 关系可以表示为 exchange \u0026ndash; binding \u0026ndash; queue 。从文档中我们知道，若要求投递的 message 能够不丢失，要求 message 本身设置 persistent 属性，要求 exchange 和queue 都设置 durable 属性。其实这问题可以这么想，若 exchange 或 queue 未设置durable 属性，则在其 crash 之后就会无法恢复，那么即使 message 设置了 persistent 属性，仍然存在 message 虽然能恢复但却无处容身的问题；同理，若 message 本身未设置persistent 属性，则 message 的持久化更无从谈起。\n问题十九：什么情况下会出现 blackholed 问题？\n答：blackholed 问题是指，向 exchange 投递了 message ，而由于各种原因导致该 message 丢失，但发送者却不知道。可导致 blackholed 的情况：1.向未绑定 queue 的 exchange 发送 message；2.exchange 以 binding_key key_A 绑定了 queue queue_A，但向该 exchange 发送 message 使用的 routing_key 却是 key_B。\n问题二十：如何防止出现 blackholed 问题？\n答：没有特别好的办法，只能在具体实践中通过各种方式保证相关 fabric 的存在。另外， 如果在执行 Basic.Publish 时设置 mandatory=true ，则在遇到可能出现 blackholed 情况时， 服务器会通过返回 Basic.Return 告之当前 message 无法被正确投递（ 内含原因 312 NO_ROUTE）。\n问题二十一：Consumer Cancellation Notification 机制用于什么场景？\n答：用于保证当镜像 queue 中 master 挂掉时，连接到 slave 上的 consumer 可以收到自身 consume 被取消的通知，进而可以重新执行 consume 动作从新选出的 master 出获得消息。若不采用该机制，连接到 slave 上的 consumer 将不会感知 master 挂掉这个事情， 导致后续无法再收到新 master 广播出来的 message 。另外，因为在镜像 queue 模式下， 存在将 message 进行 requeue 的可能，所以实现 consumer 的逻辑时需要能够正确处理出现重复 message 的情况。\n问题二十二：Basic.Reject 的用法是什么？\n答：该信令可用于 consumer 对收到的 message 进行 reject 。若在该信令中设置requeue=true，则当 RabbitMQ server 收到该拒绝信令后，会将该 message 重新发送到下一个处于 consume 状态的 consumer 处（理论上仍可能将该消息发送给当前 consumer）。若设置 requeue=false ，则 RabbitMQ server 在收到拒绝信令后，将直接将该 message 从queue 中移除。\n另外一种移除 queue 中 message 的小技巧是，consumer 回复 Basic.Ack 但不对获取到的\nmessage 做任何处理。\n而 Basic.Nack 是对 Basic.Reject 的扩展，以支持一次拒绝多条 message 的能力。\n问题二十三：为什么不应该对所有的 message 都使用持久化机制？\n答：首先，必然导致性能的下降，因为写磁盘比写 RAM 慢的多，message 的吞吐量可能有10 倍的差距。其次，message 的持久化机制用在 RabbitMQ 的内置 cluster 方案时会出现\u0026quot;坑爹\u0026quot;问题。矛盾点在于，若 message 设置了 persistent 属性，但 queue 未设置 durable 属性，那么当该 queue 的 owner node 出现异常后，在未重建该 queue 前，发往该 queue 的 message 将被 blackholed ；若 message 设置了 persistent 属性，同时 queue 也设置了durable 属性，那么当 queue 的 owner node 异常且无法重启的情况下，则该 queue 无法在其他 node 上重建，只能等待其 owner node 重启后，才能恢复该 queue 的使用，而在\n这段时间内发送给该 queue 的 message 将被 blackholed 。所以，是否要对 message 进行 持久化，需要综合考虑性能需要，以及可能遇到的问题。若想达到 100,000 条/秒以上的消息吞吐量（单 RabbitMQ 服务器），则要么使用其他的方式来确保 message 的可靠 delivery ， 要么使用非常快速的存储系统以支持全持久化（例如使用 SSD）。另外一种处理原则是：仅 对关键消息作持久化处理（根据业务重要程度），且应该保证关键消息的量不会导致性能瓶 颈。\n问题二十四：RabbitMQ 中的 cluster、mirrored queue，以及 warrens 机制分别用于解决什么问题？存在哪些问题？\n答：cluster 是为了解决当 cluster 中的任意 node 失效后，producer 和 consumer 均可以通过其他 node 继续工作，即提高了可用性；另外可以通过增加 node 数量增加 cluster 的消息吞吐量的目的。cluster 本身不负责 message 的可靠性问题（该问题由 producer 通过各种机制自行解决）；cluster 无法解决跨数据中心的问题（即脑裂问题）。另外，在 cluster 前使用 HAProxy 可以解决 node 的选择问题，即业务无需知道 cluster 中多个 node 的 ip 地址。可以利用 HAProxy 进行失效 node 的探测，可以作负载均衡。下图为 HAProxy + cluster 的模型。\nMirrored queue 是为了解决使用 cluster 时所创建的 queue 的完整信息仅存在于单一 node 上的问题，从另一个角度增加可用性。若想正确使用该功能，需要保证：1.consumer 需要支持 Consumer Cancellation Notification 机制； 2.consumer 必须能够正确处理重复message 。\nWarrens 是为了解决 cluster 中 message 可能被 blackholed 的问题，即不能接受 producer 不停 republish message 但 RabbitMQ server 无回应的情况。Warrens 有两种构成方式，一种模型是两台独立的 RabbitMQ server + HAProxy ，其中两个 server 的状态分别为 active 和 hot-standby 。该模型的特点为：两台 server 之间无任何数据共享和协议交互，两台server 可以基于不同的 RabbitMQ 版本。如下图所示\n另一种模型为两台共享存储的 RabbitMQ server + keepalived ，其中两个 server 的状态分别为 active 和 cold-standby 。该模型的特点为：两台 server 基于共享存储可以做到完全恢复，要求必须基于完全相同的 RabbitMQ 版本。如下图所示\nWarrens 模型存在的问题：对于第一种模型，虽然理论上讲不会丢失消息，但若在该模型上使用持久化机制，就会出现这样一种情况，即若作为 active 的 server 异常后，持久化在该server 上的消息将暂时无法被 consume ，因为此时该 queue 将无法在作为 hot-standby\n的 server 上被重建，所以，只能等到异常的 active server 恢复后，才能从其上的 queue 中获取相应的 message 进行处理。而对于业务来说，需要具有：a.感知 AMQP 连接断开后重建各种 fabric 的能力；b.感知 active server 恢复的能力；c.切换回 active server 的时机控制，以及切回后，针对 message 先后顺序产生的变化进行处理的能力。对于第二种模型， 因为是基于共享存储的模式，所以导致 active server 异常的条件，可能同样会导致cold-standby server 异常；另外，在该模型下，要求 active 和 cold-standby 的 server 必须具有相同的 node 名和 UID ，否则将产生访问权限问题；最后，由于该模型是冷备方案， 故无法保证 cold-standby server 能在你要求的时限内成功启动。\n 更多请关注微信公众号：Java 技术栈，回复：面试\n ","pubDate":"2021-02-15","title":"24道消息队列RabbitMQ面试题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_24%E9%81%93%E7%BB%8F%E5%85%B8%E7%9A%84%E8%8B%B1%E8%AF%AD%E9%9D%A2%E8%AF%95%E9%A2%98/","plain":"Q： Can you sell yourself in two minutes？ Go for it. （你能在两分钟內自我推荐吗？大胆试试吧！）\nA： With my qualifications and experience, I feel I am hardworking, responsible and diligent in any project I undertake. Your organization could benefit from my analytical and interpersonal skills.(依我的资格和经验，我觉得我对所从事的每一个项目都很努力、负责、勤勉。我的分析能力和与人相处的技巧，对贵单位必有价值。)\nQ：Give me a summary of your current job description. (对你目前的工作， 能否做个概括的说明。)\nA：I have been working as a computer programmer for five years. To be specific, I do system analysis, trouble shooting and provide software support. (我干了五年的电脑程序员。具体地说，我做系统分析，解决问题以及软件供应方面的支持。）\nQ：Why did you leave your last job？(你为什么离职呢？)\nA： Well, I am hoping to get an offer of a better position. If opportunity knocks, I will take it.（我希望能获得一份更好的工作，如果机会来临，我会抓住。）\nA：I feel I have reached the \u0026quot;glass ceiling\u0026quot; in my current job. / I feel there is no opportunity for advancement. （我觉得目前的工作，已经达到顶峰，即沒有升迁机会。)\nQ：How do you rate yourself as a professional？(你如何评估自己是位专业人员呢？)\nA： With my strong academic background, I am capable and competent. (凭 借我良好的学术背景，我可以胜任自己的工作，而且我认为自己很有竞争力。）\nA：With my teaching experience, I am confident that I can relate to students very well. (依我的教学经验，我相信能与学生相处的很好。)\nQ： What contribution did you make to your current (previous) organization？(你对目前/从前的工作单位有何贡献？)\nA： I have finished three new projects, and I am sure I can apply my experience to this position. (我已经完成三个新项目，我相信我能将我的经验用在这份工作上。)\nQ：What do you think you are worth to us？(你怎么认为你对我们有价值呢？)\nA：I feel I can make some positive contributions to your company in the future. (我觉得我对贵公司能做些积极性的贡献。)\nQ：What make you think you would be a success in this position？ (你如何知道你能胜任这份工作？）\nA：My graduate school training combined with my internship should qualify me for this particular job. I am sure I will be successful. (我在研究所的训练，加上实习工作，使我适合这份工作。我相信我能成功。)\nQ：Are you a multi-tasked individual？(你是一位可以同时承担数项工作的人吗？) or\nDo you work well under stress or pressure？(你能承受工作上的压力吗?)\nA：Yes, I think so.\nA：The trait is needed in my current（or previous) position and I know I can handle it well. (这种特点就是我目前（先前）工作所需要的，我知道我能应付自如。)\nQ：What is your strongest trait(s)？(你个性上最大的特点是什么？)\nA：Helpfulness and caring.（乐于助人和关心他人。）\nA：Adaptability and sense of humor.（适应能力和幽默感。）\nA：Cheerfulness and friendliness.（乐观和友爱。）\nQ： How would your friends or colleagues describe you？（你的朋友或同事怎样形容你？）\nA： (pause a few seconds) (稍等几秒钟再答，表示慎重考虑。)\nThey say Mr. Chen is an honest, hardworking and responsible man who deeply cares for his family and friends. (他们说陈先生是位诚实、工作努力，负责任的人，他对家庭和朋友都很关心。)\nA：They say Mr. Chen is a friendly, sensitive, caring and determined person. (他们说陈先生是位很友好、敏感、关心他人和有决心的人。)\nQ：What personality traits do you admire？(你欣赏哪种性格的人？)\nA： (I admire a person who is）honest, flexible and easy-going. (诚实、不死板而且容易相处的人。)\nA： (I like) people who possess the \u0026quot;can do\u0026quot; spirit. (有\u0026quot;实际行动\u0026quot;的人。)\nQ：What leadership qualities did you develop as an administrative personnel？(作为行政人员，你有什么样的领导才能？)\nA：I feel that learning how to motivate people and to work together as a team will be the major goal of my leadership. (我觉得学习如何把人们的积极性调动起来，以及如何配合协同的团队精神，是我行政工作的主要目标。)\nA：I have refined my management style by using an open-door policy. (我以开放式的政策，改进我的行政管理方式。)\nQ：How do you normally handle criticism？(你通常如何处理別人的批评？)\nA：Silence is golden. Just don't say anything; otherwise the situation could become worse. I do, however, accept constructive criticism. (沈默是金。不必说什么，否则情况更糟，不过我会接受建设性的批评。)\nA：When we cool off, we will discuss it later. (我会等大家冷靜下来再讨论。)\nQ： What do you find frustrating in a work situation？(在工作中，什么事令你不高兴？)\nA： Sometimes, the narrow-minded people make me frustrated. (胸襟狭窄的人，有时使我泄气。)\nA：Minds that are not receptive to new ideas. (不能接受新思想的那些取。)\nQ：How do you handle your conflict with your colleagues in your work? (你如何处理与同事在工作中的意见不和？)\nA：I will try to present my ideas in a more clear and civilized manner in order to get my points across. (我要以更清楚文明的方式，提出我的看法，使对方了解我的观点。)\nQ：How do you handle your failure？(你怎样对待自己的失敗？)\nA： None of us was born \u0026quot;perfect\u0026quot;. I am sure I will be given a second chance to correct my mistake. （我们大家生来都不是十全十美的，我相信我有第二个机会改正我的错误。)\nQ：What provide you with a sense of accomplishment. （什么会让你有成就感？）\nA：Doing my best job for your company. (为贵公司竭力效劳。)\nA：Finishing a project to the best of my ability. (尽我所能，完成一个项目。)\nQ：If you had a lot of money to donate, where would you donate it to？ Why？(假如你有很多钱可以捐赠，你会捐给什么单位？为什么？)\nA：I would donate it to the medical research because I want to do something to help others. (我会捐给医药研究，因为我要为他人做点事。)\nA：I prefer to donate it to educational institutions. (我乐意捐给教育机构。)\nQ：What is most important in your life right now？(眼下你生活中最重要的是什么？)\nA：To get a job in my field is most important to me. (对我来说，能在这个领域找到工作是最重要的。)\nA：To secure employment hopefully with your company. (希望能在贵公司任职对我来说最重要。)\nQ：What current issues concern you the most？(目前什么事是你最关心的？)\nA：The general state of our economy and the impact of China' entry to WTO on our industry. (目前中国经济的总体情況以及中国入世对我们行业的影响。)\nQ： How long would you like to stay with this company？(你会在本公司服务多久呢？)\nA： I will stay as long as I can continue to learn and to grow in my field. (只要我能在我的行业力继续学习和长进，我就会留在这里。)\nQ：Could you project what you would like to be doing five years from now？ (你能预料五年后你会做什么吗？)\nA：As I have some administrative experience in my last job, I may use my organizational and planning skills in the future.\n(我在上一个工作中积累了一些行政经验，我将来也许要运用我组织和计划上的经验和技巧。)\nA：I hope to demonstrate my ability and talents in my field adequately. (我希望能充分展示我在这个行业的能力和智慧。)\nA：Perhaps, an opportunity at a management position would be exciting.\n（也许有机会，我将会从事管理工作。）\n如果不愿正面回答，也可以说：\nIt would be premature for me to predict this. （现在对此问题的预测，尚嫌过早。）\n甚至还可以打趣的说：\nHypothetically speaking, I might be able to do your current job as a director.（或 CEO 或 president）((说不定，我也能做你现在主任的工作呢！)\nQ： What range of pay-scale are you interested in？(你喜欢那一种薪水层次标准？)\nA： Money is important, but the responsibility that goes along with this job is what interests me the most. (薪水固然重要，但这工作伴随而来的责任更吸引我。)\nA： 假如你有家眷，可以说：\nTo be frank and open with you, I like this job, but I have a family to support. (坦白地说，我喜欢这份工作，不过我必须要负担我的家庭。)\nOther Tips (其它建议)\nKnow something about the organization you are applying to. (了解一些你申请工作单位的情况)\nDress properly. Don't shake hand with the interviewer until he/she extends his/her hand. (穿着要得体，人家伸手时才握手。)\nDon't sit down until invited to do so by the interviewer. (人家未请， 先別坐下。)\nMake eye-contact with the interviewer during the interview. (面试时， 眼睛要看着对方。)\nListen actively and stay calm. (注意听，保持冷静。)\nIf invited to a meal, be especially careful about your table manners. (被邀吃饭时，要特別注意餐桌礼节。)\nDon't talk with your mouth full. (嘴里有食物，不可开口说话)\nDon't make much noise while you eat. (吃东西不要出声音)\nDon't blow your nose or use the toothpick at table. (不要拧鼻涕或用牙签剔牙)\nDon't appear to be pushy or overly anxious to get a job.（不必过分表现急着要工作)\nBe honest but not too modest.（要诚实，但不必太谦虚)\nDon't put yourself down or cut yourself up. (不可妄自菲薄或自贬)\nTry to avoid discussing politics or religion with your interviewer. (避免与面试人谈政治或宗教)\nI：Interviewer（面试者）A：Applicant（求职者）\n教育背景：简明扼要，实话实说\n尽管你在简历中对自己的教育背景作了介绍，但在面试时，面试官还有可能就此方面提问。还是事先做点准备吧。\n①I:what is your major?\nA:My major is Business Administration. I am especially interested in\u0026quot;Marketing\u0026quot;.\n（不仅回答了问题，还顺带一句介绍了自己较为感兴趣的方面，简明扼要。）\n②I:Which university are you attending? A:I am attending×××University.\n③I:Have you received any degrees?\nA:Yes. First, I received my Bachelor degree in English Literature, and then an MBA degree.\n④I:What course did you like best?\nA:Project Management. I was very interested in this course when I was a student. And I think it's very useful for my present work.\n⑤I:Do you feel that you have received a good general training? A:Yes, I have studied in an English train-ing program and a computer training program since I graduated from university. I am currently studying Finance at a training school.\n工作经验：显露实力，避免炫耀\n①I:Have you ever been employed?\n②I:Your resume says you have had one-year experience working in a foreign representative office in Shanghai, may I ask why you left?\nA:I worked in a foreign rep.office for one year.However,I left there two years ago because the work they gave me was rather dull.I found another job that is more interesting.\n③I:Have you done any work in this field?\n④I:What qualifications do you have that make you feel you will be successful in your field?\n⑤I:What have you learned from the jobs you have had?\nA:I have learned a lot about business know how and basic office skills. In addition, I learned at my previous job show to cooperate with my colleagues.\n⑥I:What's you major weak point?\nA:I haven't been involved in international business, so I don't have any experience, but I have studied this course in the International Business Training Center of the×××Company.\n⑦I:What are your greatest strengths?（实话实说好了，不必客气，但应注意语气和表情，不要给人炫耀之感。）\n⑧I:Please tell me about your working experience.\n⑨I:Does your present employer know you are looking for another job? A:No, I haven't discussed my career plans with my present employer, but I am sure he will understand.\n性格爱好：表现积极、合作的一面\n①I:How do you spend your spare time?\n②I:Are you interested in sports?\n③I:Do you think you are introverted or extroverted?\n④I:What kind of personality do you think you have?\nA:I always approach things very enthusiastically. When I beg in something, I don't like to leave it halfdone. I can't concentrate on something new until the first thing is finished.\n⑤I:What is the most important thing for you to be happy? A:Different people have different ideas. I think the most important thing for me is having a good relationship with my family members and my friends. My family has always been very closeknit, and my friend sand I spend a\nlot of time together. Without that I would be much less happy than I am.\n⑥I:What makes you angry? A:Dishonesty. It's unacceptable.\n⑦I:What are your personal weaknesses?\nA:I'm afraid I'm a poor talker. I'm not comfortable talking with the people whom I have just met for the first time. That is not very good for business, so I have been studying public speaking.\n⑧I:Are you more of a leader or a follower?\nA:I don't try to lead people. I'd rather cooperate with everybody, and get the job done by working together.\n工作要求：我能胜任\n①I:Do you think you can make yourself easily understood in English? A:Yes, in most circumstances.\n②I:Are you available for travel?\nA:Yes, I like traveling. I am young, and unmarried. It's no problem for me to travel frequently.\n③I:How about overtime work?\nA:Overtime work is very common in companies. I can work overtime if it's necessary, but I don't think we will work overtime everyday.\n④I:How long do you think we can depend on your working here?\n⑤I:Do you like regular work?\nA:No, I don't like regular work. I am interested in different projects with new opport unities and new challenge, but I can do regular work if the company needs me to do so.\n⑥I:What salary do you expect\nA:Shall we discuss my responsibilities with your company first?I think salary is closely related to the responsibilities of the job.\n⑦I:Do you work well under pressure\nA:Working under pressure is exciting and challenging. I don't mind working under pressure. I work well under the secircum stances. People can, I Can.\n⑧I:Do you have any particular conditions that you would like the company to take into consideration?\nA:No,nothing in particular.\n⑨I:How soon can you begin working for us?\nA:I need about two to three weeks for necessary formalities. I will quit then transfer to your company.\n面试结束：礼貌道别\n①I:Any questions?\nA:When will I know your decision?\n②I:How can we get in touch with you?\n③I:We will notify you of our decision by mail, is this convenient for you?\n④I:Thank you for your interest in our company.\nA:Thank you, Mr.Smith. Goodbye.(Thank you for your time.)\n⑤I:You will be hearing from us very soon. Please send the next applicantin on your way out.\nA:OK.Thank you very much.\n此外，面试官还可能问及你的家庭情况，如家人对你的影响等，也应事先有所准备。 （郭影）\n","pubDate":"2021-02-15","title":"24道经典的英语面试题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_27%E9%81%93%E9%A1%B6%E5%B0%96%E7%9A%84java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%94%81%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/","plain":"Synchronized 相关问题 问题一： Synchronized 用过吗， 其原理是什么？\n这是一道 Java 面试中几乎百分百会问到的问题，因为没有任何写过并发程序的开发者会没听说或者没接触过 Synchronized。\nSynchronized 是由 JVM 实现的一种实现互斥同步的一种方式， 如果你查看被 Synchronized 修饰过的程序块编译后的字节码， 会发现， 被Synchronized 修 饰 过 的 程 序 块 ， 在 编 译 前 后 被 编 译 器 生 成了 monitorenter 和 monitorexit 两个字节码指令。\n这两个指令是什么意思呢？\n在虚拟机执行到 monitorenter 指令时， 首先要尝试获取对象的锁：\n如果这个对象没有锁定，或者当前线程已经拥有了这个对象的锁，把锁的计数器 +1 ；当执行 monitorexit 指令时将锁计数器 - 1 ；当计数器为 0 时， 锁就被释放了。\n如果获取对象失败了，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。\nJava 中 Synchronize 通过在对象头设置标记， 达到了获取锁和释放锁的目的。\n**问题二：**你刚才提到获取对象的锁，这个\u0026quot; 锁\u0026quot;到底是什么？ 如何确定对象的锁？\n\u0026quot; 锁\u0026quot; 的本质其实是 monitorenter 和 monitorexit 字节码指令的一个Reference 类型的参数， 即要锁定和解锁的对象。 我们知道， 使用\nSynchronized 可以修饰不同的对象 ，因 此 ，对 应的对象锁可以这么确定。\n  如果 Synchronized 明确指定了锁对象 ，比 如 Synchronize d（ 变量名 ）、Synchronized( this) 等， 说明加解锁对象为该对象。\n  如果没有明确指定：\n   若 Synchronized 修饰的方法为非静态方法， 表示此方法对应的对象为锁对象；\n若 Synchronized 修饰的方法为静态方法， 则表示此方法对应的类对象为锁对象。\n 注意， 当一个对象被锁住时， 对象里面所有用 Synchronized 修饰的方 法都将产生堵塞， 而对象里非 Synchronized 修饰的方法可正常被调用， 不受锁影响。\n问题三： 什么是可重入性， 为什么说 Synchronized 是可重入锁？ 可重入性是锁的一个基本要求， 是为了解决自己锁死自己的情况。\n比 如 下 面 的 伪 代 码 ， 一 个 类 中 的 同 步 方 法 调 用 另 一 个 同 步 方 法 ， 假 如Synchronized 不支持重入， 进入 method 2 方法时当前线程获得锁， method 2 方法里面执行 method 1 时当前线程又要去尝试获取锁， 这时如果不支持重入， 它就要等释放， 把自己阻塞， 导致自己锁死自己。\n · 点 击 图 片 ， 放 大 查 看 ·\n 对 Synchronized 来 说 ， 可 重 入 性 是 显 而 易 见 的 ， 刚 才 提 到 ， 在 执行 monitorenter 指令时，如果这个对象没有锁定，或者当前线程已经拥有了这个对象的锁（ 而不是已拥有了锁则不能继续获取），就把锁的计数器 +1 ， 其实本质上就通过这种方式实现了可重入性。\n问题四： JVM 对 Java 的原生锁做了哪些优化？\n在 Java 6 之前， Monitor 的实现完全依赖底层操作系统的互斥锁来实现， 也就是我们刚才在问题二中所阐述的获取/ 释放锁的逻辑。\n由于 Java 层面的线程与操作系统的原生线程有映射关系，如果要将一个线程进行阻塞或唤起都需要操作系统的协助 ，这 就需要从用户态切换到内核态来执行，这种切换代价十分昂贵，很耗处理器时间，现代 JDK 中做了大量的优化。\n\u0026mdash; 种优化是使用自旋锁 ，即 在把线程进行阻塞操作之前先让线程自旋等待一段时间，可能在等待期间其他线程已经解锁，这时就无需再让线程执行阻塞操作， 避免了用户态到内核态的切换。\n现代 JDK 中还提供了三种不同的 Monitor 实现 ，也 就是三种不同的锁：\n  偏向锁（ Biased Locking）\n  轻量级锁\n  重量级锁\n  这三种锁使得 JDK 得以优化 Synchronized 的运行， 当 JVM 检测到不同的竞争状况时 ，会 自动切换到适合的锁实现 ，这 就是锁的升级 、降 级。\n 当没有竞争出现时， 默认会使用偏向锁。  JVM 会利用 CAS 操作， 在对象头上的 Mark Word 部分设置线程 ID， 以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁，因为在很 多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜 锁可以降低无竞争开销。\n  如果有另一线程试图锁定某个被偏斜过的对象， JVM 就撤销偏斜锁， 切换到轻量级锁实现。\n  轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁， 如果重试成功， 就使用普通的轻量级锁； 否则， 进一步升级为重量级锁。\n  问题五： 为什么说 Synchronized 是非公平锁？\n非公平主要表现在获取锁的行为上 ，并 非是按照申请锁的时间前后给等待线程分配锁的，每当锁被释放后，任何一个线程都有机会竞争到锁，这样做的目的是为了提高执行性能， 缺点是可能会产生线程饥饿现象。\n 问题六： 什么是锁消除和锁粗化？\n  锁消除：指虚拟机即时编译器在运行时，对一些代码上要求同步，但被检测到不可能存在共享数据竞争的锁进行消除。 主要根据逃逸分析。  程序员怎么会在明知道不存在数据竞争的情况下使用同步呢？ 很多不是程序员自己加入的。\n 锁粗化：原则上，同步块的作用范围要尽量小。但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作在循环体内，频繁地进行互斥同步操作也会导致不必要的性能损耗。  锁粗化就是增大锁的作用域。\n问题七： 为什么说 Synchronized 是一个悲观锁？ 乐观锁的实现原理又是什么？ 什么是 CAS， 它有什么特性？\nSynchronized 显然是一个悲观锁， 因为它的并发策略是悲观的：\n不管是否会产生竞争 ，任 何的数据操作都必须要加锁 、用 户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等操作。\n随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略。先进行操作， 如果没有其他线程征用数据， 那操作就成功了；\n如果共享数据有征用，产生了冲突，那就再进行其他的补偿措施。这种乐观的并发策略的许多实现不需要线程挂起， 所以被称为非阻塞同步。\n乐观锁的核心算法是 CAS（ Compareand Swap ，比较并交换） ， 它涉及到三个操作数：内存值、预期值、新值。当且仅当预期值和内存值相等时才将内存值修改为新值。\n这样处理的逻辑是， 首先检查某块内存的值是否跟之前我读取时的一样， 如不一样则表示期间此内存值已经被别的线程更改过，舍弃本次操作，否则说明期间没有其他线程对此内存值操作， 可以把新值设置给此块内存。CAS 具有原子性， 它的原子性由 CPU 硬件指令实现保证， 即使用 JNI 调用 Native 方 法 调用 由 C++ 编 写 的 硬件 级 别 指令 ， JDK 中提 供 了Unsafe 类执行这些操作。\n 问题八： 乐观锁一定就是好的吗？\n 乐观锁避免了悲观锁独占对象的现象，同时也提高了并发性能，但它也有缺点：\n 乐观锁只能保证一个共享变量的原子操作。如果多一个或几个变量，乐观  锁将变得力不从心，但互斥锁能轻易解决，不管对象数量多少及对象颗粒度大小。\n 长时间自旋可能导致开销大。 假如 CAS 长时间不成功而一直自旋， 会  给 CPU 带来很大的开销。\n ABA 问题 。C AS 的核心思想是通过比对内存值与预期值是否一样而判断内存值是否被改过， 但这个判断逻辑不严谨， 假如内存值原来是 A，后  来被一条线程改为 B， 最后又被改成了 A，则 CAS 认为此内存值并没有发生改变，但实际上是有被其他线程改过的，这种情况对依赖过程值的\n情景的运算结果影响很大。解决的思路是引入版本号，每次变量更新都把版本号加一。\n可重入锁 Reentrant Lock 及其他显式锁相关问题 问题一： 跟 Synchronized 相比， 可重入锁 Reentrant Lock 其实现原理有什么不同？\n其实， 锁的实现原理基本是为了达到一个目的： 让所有的线程都能看到某种标记。\nSynchronized 通过在对象头中设置标记实现了这一目的，是一种 JVM 原生的锁实现方式， 而 Reentrant Lock 以及所有的基于 Lock 接口的实现类，都是通过用一个 volitile 修饰的 int 型变量，并保证每个线程都能拥有对该 int 的可见性和原子修改，其本质是基于所谓的 AQS 框架。\n问题二： 那么请谈谈 AQS 框架是怎么回事儿？\nAQS（ Abstract Queued Synchronizer 类） 是一个用来构建锁和同步器的 框 架 ， 各 种 Lock 包 中 的 锁 （ 常 用 的 有 Reentrant Lock 、Read Write Lock ） ， 以 及 其 他 如 Semaphore 、 Count Down Latch ，甚至是早期的 Future Task 等， 都是基于 AQS 来构建。\n AQS 在内部定义了一个 volatile int state 变量， 表示同步状态： 当线程调用 lock 方法时 ，如 果 state= 0 ，说 明没有任何线程占有共享资源的锁，   可以获得锁并将 state= 1 ；如果 state= 1 ， 则说明有线程目前正在使用共享变量， 其他线程必须加入同步队列进行等待。\n  AQS 通过 Node 内部类构成的一个双向链表结构的同步队列， 来完成线   程获取锁的排队工作， 当有线程获取锁失败后， 就被添加到队列末尾。\n   Node 类是对要访问同步代码的线程的封装， 包含了线程本身及其状态叫wait Status（ 有五种不同 取值， 分别表示是否被阻塞， 是否等待唤醒， 是否已经被取消等） ， 每个 Node 结点关联其 prev 结点和 next 结点， 方便线程释放锁后快速唤醒下一个在等待的线程， 是一个 FIFO 的过程。\n  Node 类有两个常量， SHARED 和 EXCLUSIVE， 分别代表共享模式和独占 模 式 。 所 谓 共 享 模 式 是 一 个 锁 允 许 多 条 线 程 同 时 操 作 （ 信 号 量Semaphore 就是基于 AQS 的共享模式实现的） ， 独占模式是同一个 时间段只能有一个线程对共享资源进行操作， 多余的请求线程需要排队等待\n   （如 Reentran Lock）。\n  AQS 通 过 内 部 类 Condition Object 构 建 等 待 队 列 （ 可 有 多 个 ） ， 当Condition 调 用 wait() 方 法 后 ， 线 程 将 会 加 入 等 待 队 列 中 ， 而 当   Condition 调用 s ignal() 方法后， 线程将从等待队列转移动同步队列中进行锁竞争。\n  AQS 和 Condition 各 自 维 护 了 不 同 的 队 列 ， 在 使 用 Lock 和Condition 的时候， 其实就是两个队列的互相移动。  问题三： 请尽可能详尽地对比下 Synchronized 和 Reentrant Lock 的异同。\nReentrant Lock 是 Lock 的实现类， 是一个互斥的同步锁。\n从功能角度，Reentrant Lock 比 Synchronized 的同步操作更精细（ 因为可以像普通对象一样使用） ， 甚至实现 Synchronized 没有的高级功能，如：\n  等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待， 对处理执行时间非常长的同步块很有用。\n  带超时的获取锁尝试：在指定的时间范围内获取锁，如果时间到了仍然无法获取则返回。\n  可以判断是否有线程在排队等待获取锁。\n  可以响应中断请求： 与 Synchronized 不同， 当获取到锁的线程被中断时， 能够响应中断， 中断异常将会被抛出， 同时锁会被释放。\n  可以实现公平锁。\n  从锁释放角度， Synchronized 在 JVM 层面上实现的， 不但可以通过 一些监控工具监控 Synchronized 的锁定， 而且在代码执行出现异常时，\nJVM 会自动释放锁定； 但是使用 Lock 则不行， Lock 是通过代码实现的 ，要 保证锁定一定会被释放 ，就 必须将 un Lock() 放到 f inally{} 中。从性能角度 ，S ynchronized 早期实现比较低效 ，对 比 Reentrant Lock， 大多数场景性能都相差较大。\n但 是 在 Java 6 中 对 其 进 行 了 非 常 多 的 改 进 ， 在 竞 争 不 激 烈 时 ， Synchronized 的 性 能 要 优 于 Reetrant Lock ； 在 高 竞 争 情 况 下 ， Synchronized 的性能会下降几十倍， 但是 Reetrant Lock 的性能能维持常态。\n问题四： Reentrant Lock 是如何实现可重入性的？\nReentrant Lock 内部自定义了同步器 Sync（ Sync 既实现了 AQS，又实现了 AOS，而 AOS 提供了一种互斥锁持有的方式）， 其实就是加锁的时候通过 CAS 算法， 将线程对象放到一个双向链表中， 每次获取锁的时候 ，看 下当前维护的那个线程 ID 和当前请求的线程 ID 是否一样， 一样就可重入了。\n问题五： 除了 Reetrant Lock， 你还接触过 JUC 中的哪些并发工具？ 通常所说的并发包（ JUC ） 也就是 java. util. concurrent 及其子包， 集中了 Java 并发的各种基础工具类， 具体主要包括几个方面：\n  提 供 了 Count Down Latch 、 Cyclic Barrier 、 Semaphore 等 ， 比Synchronized 更加高级， 可以实现更加丰富多线程操作的同步结构。\n  提供了 Concurrent Hash Map、有序的 Concunrrent Skip List Map，或者通过类似快照机制实现线程安全的动态数组 Copy On Write Array List 等， 各种线程安全的容器。\n  提供了 Array Blocking Queue 、 Synchorous Queue 或针对特定场景的Priority Blocking Queue 等， 各种并发队列实现。\n  强大的 Executor 框架， 可以创建各种不同类型的线程池， 调度任务运行等。\n  问题六： 请谈谈 Read Write Lock 和 Stamped Lock。\n虽然 Reentrant Lock 和 Synchronized 简单实用， 但是行为上有一定局限性，要么不占，要么独占。实际应用场景中，有时候不需要大量竞争的写操作，而是以并发读取为主，为了进一步优化并发操作的粒度，Java 提供了读写锁。\n读写锁基于的原理是多个读操作不需要互斥，如果读锁试图锁定时，写锁是被某个线程持有，读锁将无法获得，而只好等待对方操作结束，这样就可以自动保证不会读取到有争议的数据。\nRead Write Lock 代表了一对锁，下面是一个基于读写锁实现的数据结构， 当数据量较大，并发读多、并发写少的时候，能够比纯同步版本凸显出优 势：\n {width=\u0026ldquo;5.77499343832021in\u0026rdquo; height=\u0026ldquo;3.815in\u0026rdquo;}\n·\n 读写锁看起来比 Synchronized 的粒度似乎细一些， 但在实际应用中， 其表现也并不尽如人意， 主要还是因为相对比较大的开销。\n所以， JDK 在后期引入了 Stamped Lock ，在提供类似读写锁的同时， 还支持优化读模式。优化读基于假设，大多数情况下读操作并不会和写操作冲突，其逻辑是先试着修改，然后通过 validate 方法确认是否进入了写模式 ，如 果没有进入 ，就 成功避免了开销 ；如 果进入 ，则 尝试获取读锁。\n {width=\u0026ldquo;5.784022309711286in\u0026rdquo; height=\u0026ldquo;4.025in\u0026rdquo;}\n·\n 问题七： 如何让 Java 的线程彼此同步？ 你了解过哪些同步器？ 请分别介绍下。\nJUC 中的同步器三个主要的成员：Count Down Latch、Cyclic Barrier 和Semaphore， 通过它们可以方便地实现很多线程之间协作的功能。\nCount Down Latch 叫倒计数， 允许一个或多个线程等待某些操作完成。看几个场景：\n  跑步比赛， 裁判需要等到所有的运动员（\u0026quot; 其他线程\u0026quot;） 都跑到终点（ 达到目标） ， 才能去算排名和颁奖。\n  模拟并发，我需要启动 100 个线程去同时访问某一个地址，我希望它们能同时并发， 而不是一个一个的去执行。\n  {width=\u0026ldquo;5.768054461942257in\u0026rdquo; height=\u0026ldquo;4.479166666666667in\u0026rdquo;}用 法 ： Count Down Latch 构 造 方 法 指 明 计 数 数 量 ， 被 等 待 线 程 调 用count Down 将计数器减 1 ，等待线程使用 await 进行线程等待。一个简单的例子：\nCyclic Barrier 叫循环栅栏， 它实现让一组线程等待至某个状态之后再全部同时执行， 而且当所有等待线程被释放后， Cyclic Barrier 可以被重复使用。 Cyclic Barrier 的典型应用场景是用来等待并发线程结束。\nCyclic Barrier 的主要方法是 await()， await() 每被调用一次，计数便会减少 1 ， 并阻塞住当前线程。当计数减至 0 时， 阻塞解除，所有在此Cyclic Barrier 上面阻塞的线程开始运行。\n在这之后，如果再次调用 await()，计数就又会变成 N- 1 ， 新一轮重新开始 ，这 便是 Cyclic 的含义所在 。C yclic Barrier. await() 带有返回值， 用来表示当前线程是第几个到达这个 Barrier 的线程。\n举例说明如下：\n{width=\u0026ldquo;5.74864501312336in\u0026rdquo; height=\u0026ldquo;3.9899989063867016in\u0026rdquo;}\n ·\n Semaphore， Java 版本的信号量实现， 用于控制同时访问的线程个数， 来达到限制通用资源访问的目的，其原理是通过 acquire() 获取一个许可， 如果没有就等待， 而 release() 释放一个许可。\n {width=\u0026ldquo;5.798959973753281in\u0026rdquo; height=\u0026ldquo;3.9899989063867016in\u0026rdquo;}\n 如 果 Semaphore 的 数 值 被 初 始 化 为 1 ， 那 么 一 个 线 程 就 可 以 通 过acquire 进入互斥状态， 本质上和互斥锁是非常相似的。 但是区别也非常明显， 比如互斥锁是有持有者的， 而对于 Semaphore 这种计数器结构，虽然有类似功能，但其实不存在真正意义的持有者，除非我们进行扩展包装。\n**问题八：**Cyclic Barrier 和 Count Down Latch 看起来很相似，请对比下呢？\n它们的行为有一定相似度， 区别主要在于：\n  Count Down Latch 是不可以重置的， 所以无法重用， Cyclic Barrier 没有这种限制， 可以重用。\n  Count Down Latch 的基本操作组合是 count Down/ await，调用 await 的线程阻塞等待 count Down 足够的次数， 不管你是在一个线程还是多个线程里 count Down ， 只要次数足够即可。 Cyclic Barrier 的基本操作组合就是 await ，当 所有的伙伴都调用了 await ，才 会继续进行任务， 并自动进行重置。\n  Count Down Latch 目 的 是 让 一 个 线 程 等 待 其 他 N 个 线 程 达 到 某 个 条件后 ，自 己再去做某个 事（ 通过 Cyclic Barrier 的第二个构造方法 public Cyclic Barrier( int part ies, Runnable barrier Action) ， 在新线程里做事可以达到同样的效果） 。 而 Cyclic Barrier 的目的是让 N 多线程互相等待直到所有的都达到某个状态 ，然 后这 N 个线程再继续执行各自后续\n（通过 Count Down Latch 在某些场合也能完成类似的效果） 。\nJava 线程池相关问题  问题一： Java 中的线程池是如何实现的？\n   在 Java 中， 所谓的线程池中的\u0026quot; 线程\u0026quot; ， 其实是被抽象为了一个静态内部类 Worker ，它 基于 AQS 实现 ，存 放在线程池的 Hash Set\u0026lt;Worker\u0026gt; workers 成员变量中；\n  而 需 要 执 行 的 任 务 则 存 放 在 成 员 变 量 work Queue\n  （ Blocking Queue\u0026lt;Runnable\u0026gt; work Queue ）中。\n这样， 整个线程池实现的基本思想就是： 从 work Queue 中不断取出需要执行的任务， 放在 Workers 中进行处理。\n 问题二： 创建线程池的几个核心构造参数？\n Java 中的线程池的创建其实非常灵活， 我们可以通过配置不同的参数， 创建出行为不同的线程池， 这几个参数包括：\n  core Pool Size： 线程池的核心线程数。\n  maximum Pool Size： 线程池允许的最大线程数。\n  keep Alive Time： 超过核心线程数时闲置线程的存活时间。\n  work Queue： 任务执行前保存任务的队列， 保存由 execute 方法提交的 Runnable 任务。\n  **问题三 ：**线 程池中的线程是怎么创建的？ 是一开始就随着线程池的启动创建好的吗？\n显然不是的。 线程池默认初始化后不启动 Worker ， 等待有请求时才启动。\n每当我们调用 exe cute ( ) 方法添加一个任务时， 线程池会做如下判断：\n  如果正在运行的线程数量小于 core Pool Size，那么马上创建线程运行这个任务；\n  如果正在运行的线程数量大于或等于 core Pool Size，那么将这个任务放入队列；\n  如 果 这 时 候 队 列 满 了 ， 而 且 正 在 运 行 的 线 程 数 量 小 于maximum Pool Size， 那么还是要创建非核心线程立刻运行这个任务；\n  如 果 队 列 满 了 ， 而 且 正 在 运 行 的 线 程 数 量 大 于 或 等 于maximum Pool Size ， 那 么 线 程 池 会 抛 出 异 常Reject Execution Exception。\n  当一个线程完成任务时， 它会从队列中取下一个任务来执行。 当一个线程无事可做， 超过一定的时间（ keep Alive Time） 时， 线程池会判断。 如果当前运行的线程数大于 core Pool Size， 那么这个线程就被停掉。所以线程池的所有任务完成后， 它最终会收缩到 core Pool Size 的大小。问 题 四 ： 既 然 提 到 可 以 通 过 配 置 不 同 参 数 创 建 出 不 同 的 线 程 池 ， 那 么Java 中默认实现好的线程池又有哪些呢？ 请比较它们的异同。\n. Single Thread Executor 线程池 这个线程池只有一个核心线程在工作 ，也 就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。 此线程池保证所有任务的执行顺序按照任务的提交顺序执行。\n  core Pool Size： 1 ， 只有一个核心线程在工作。\n  maximum Pool Size： 1 。\n  keep Alive Time： 0L。\n  work Queue： new Linked Blocking Queue\u0026lt;Runnable\u0026gt;() ， 其缓冲队列是无界的。\n  . Fixed Thread Pool 线程池 Fixed Thread Pool 是固定大小的线程池， 只有核心线程。 每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。\nFixed Thread Pool 多数针对一些很稳定很固定的正规并发线程， 多用于服务器。\n  core Pool Size： n Threads\n  maximum Pool Size： n Threads\n  keep Alive Time： 0L\n  work Queue： new Linked Blocking Queue\u0026lt;Runnable\u0026gt;() ， 其缓冲队列是无界的。\n  . Cached Thread Pool 线程池 Cached Thread Pool 是无界线程池， 如果线程池的大小超过了处理任务所需要的线程， 那么就会回收部分空闲（ 60 秒不执行任务） 线程， 当任务数增加时， 此线程池又可以智能的添加新线程来处理任务。\n线程池大小完全依赖于操作系统（ 或者说 JVM） 能够创建的最大线程大小。 Synchronous Queue 是一个是缓冲区为 1 的阻塞队列。\n缓存型池子通常用于执行一些生存期很短的异步型任务 ，因 此在一些面向连接的 daemon 型 SERVER 中用得不多。但对于生存期短的异步任务， 它是 Executor 的首选。\n  core Pool Size： 0\n  maximum Pool Size： Integer. MAX_VALUE\n  keep Alive Time： 60L\n  work Queue： new Synchronous Queue\u0026lt;Runnable\u0026gt;() ， 一个是缓冲区为 1 的阻塞队列。\n  . Scheduled Thread Pool 线程池 Scheduled Thread Pool ： 核心线程池固定， 大小无限的线程池。 此线程池支持定时以及周期性执行任务的需求 。创 建一个周期性执行任务的线程\n池。如果闲置，非核心线程池会在 DEFAULT_KEEPALIVEMILLIS 时间内回收。\n  core Pool Size： core Pool Size\n  maximum Pool Size： Integer. MAX_VALUE\n  keep Alive Time： DEFAULT_KEEPALIVE_MILLIS\n  work Queue： new Delayed Work Queue() 问题六： 如何在 Java 线程池中提交线程？ 线程池最常用的提交任务的方法有两种：\n   {width=\u0026ldquo;5.768054461942257in\u0026rdquo; height=\u0026ldquo;0.3319433508311461in\u0026rdquo;}. execute()： Executor Service. execute 方法接收一个 Runable 实例， 它用来执行一个任务：   ·\n  {width=\u0026ldquo;5.768054461942257in\u0026rdquo; height=\u0026ldquo;0.5847211286089239in\u0026rdquo;}. submit()： Executor Service. s ubmit ( ) 方法返回的是 F uture 对象。可以用 is Done() 来查询 Future 是否已经完成， 当任务完成时， 它具有一个结果， 可以调用 get() 来获取结果。也可以不用 is Done() 进行检查就直接调用 get()， 在这种情况下， get() 将阻塞， 直至结果准备就绪。  Java 内存模型相关问题 **问题一：**什么是 Java 的内存模型，Java 中各个线程是怎么彼此看到对方的变量的？\nJava 的内存模型定义了程序中各个变量的访问规则， 即在虚拟机中将变量存储到内存和从内存中取出这样的底层细节。\n此处的变量包括实例字段、静态字段和构成数组对象的元素，但是不包括局部变量和方法参数，因为这些是线程私有的，不会被共享，所以不存在竞争问题。\nJava 中各个线程是怎么彼此看到对方的变量的呢？ Java 中定义了主内存与工作内存的概念：\n所有的变量都存储在主内存，每条线程还有自己的工作内存，保存了被该线程使用到的变量的主内存副本拷贝。\n线程对变量的所有操作（ 读取、赋值）都必须在工作内存中进行，不能直接读写主内存的变量 。不 同的线程之间也无法直接访问对方工作内存的变量， 线程间变量值的传递需要通过主内存。\n**问题二：**请谈谈 volatile 有什么特点，为什么它能保证变量对所有线程的可见性？\n关键字 volatile 是 Java 虚拟机提供的最轻量级的同步机制 。当 一个变量被定义成 volatile 之后， 具备两种特性：\n 保证此变量对所有线程的可见性。当一条线程修改了这个变量的值，新值  对于其他线程是可以立即得知的。 而普通变量做不到这一点。\n 禁止指令重排序优化。普通变量仅仅能保证在该方法执行过程中，得到正确结果， 但是不保证程序代码的执行顺序。  Java 的内存模型定义了 8 种内存间操作： lock 和 unlock   把一个变量标识为一条线程独占的状态。\n  把一个处于锁定状态的变量释放出来 ，释 放之后的变量才能被其他线程锁定。\n  read 和 write   把一个变量值从主内存传输到线程的工作内存， 以便 load。\n  把 store 操作从工作内存得到的变量的值， 放入主内存的变量中。\n  load 和 store   把 read 操作从主内存得到的变量值放入工作内存的变量副本中。\n  把工作内存的变量值传送到主内存， 以便 write。\n  use 和 assgin   把工作内存变量值传递给执行引擎。\n  将执行引擎值传递给工作内存变量值。\n  volatile 的实现基于这 8 种内存间操作， 保证了一个线程对某个\nvolatile 变量的修改， 一定会被另一个线程看见， 即保证了可见性。\n**问题三：**既然 volatile 能够保证线程间的变量可见性，是不是就意味着基于 volatile 变量的运算就是并发安全的？\n显然不是的。 基于 volatile 变量的运算在并发下不一定是安全的。\nvolatile 变量在各个线程的工作内存， 不存在一致性问题（ 各个线程的工作内存中 volatile 变量， 每次使用前都要刷新到主内存） 。\n但是 Java 里面的运算并非原子操作 ，导 致 volatile 变量的运算在并发下一样是不安全的。\n问题四： 请对比下 volatile 对比 Synchronized 的异同。\nSynchronized 既能保证可见性， 又能保证原子性， 而 volatile 只能保证可见性， 无法保证原子性。\nThread Local 和 Synchonized 都用于解决多线程并发访问， 防止任务在共享资源上产生冲突。 但是 Thread Local 与 Synchronized 有本质的区别。\nSynchronized 用于实现同步机制 ，是 利用锁的机制使变量或代码块在某一时该只能被一个线程访问， 是一种 \u0026quot; 以时间换空间\u0026quot; 的方式。\n而 Thread Local 为每一个线程都提供了变量的副本 ，使 得每个线程在某一时间访问到的并不是同一个对象， 根除了对变量的共享， 是一种 \u0026ldquo;以空间换时间\u0026rdquo; 的方式。\n问题五： 请谈谈 Thread Local 是怎么解决并发安全的？\nThread Local 这是 Java 提供的一种保存线程私有信息的机制， 因为其在整个线程生命周期内有效 ，所 以可以方便地在一个线程关联的不同业务模块之间传递信息， 比如事务 ID、 Cookie 等上下文相关信息。\nThread Local 为每一个线程维护变量的副本， 把共享数据的可见范围限制在同一个线程之内， 其实现原理是， 在 Thread Local 类中有一个\nMap， 用于存储每一个线程的变量的副本。\n问题六： 很多人都说要慎用 Thread Local， 谈谈你的理解， 使用Thread Local 需要注意些什么？\n使用 Thread Local 要注意 remove！ Thread Local 的实现是基于一个所谓的 Thread Local Map，在Thread Local Map 中，它的 key 是一个弱引用。\n通常弱引用都会和引用队列配合清理机制使用 ，但 是 Thread Local 是个例外， 它并没有这么做。\n这意味着， 废弃项目的回收依赖于显式地触发， 否则就要等待线程结束， 进而回收相应 Thread Local Map！这就是很多 OOM 的来源，所以通常\n都会建议， 应用一定要自己负责 remove， 并且不要和线程池配合， 因为 worker 线程往往是不会退出的。\n","pubDate":"2021-02-15","title":"27道顶尖的Java多线程锁、内存模型面试题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_29%E9%81%93%E5%B8%B8%E8%A7%81%E7%9A%84spring%E9%9D%A2%E8%AF%95%E9%A2%98/","plain":" 以下为 spring 常见面试问题：\n1、什么是 Spring 框架？Spring 框架有哪些主要模块？\nSpring 框架是一个为 Java 应用程序的开发提供了综合、广泛的基础性支持的 Java 平台。\nSpring 帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。\nSpring 框架本身亦是按照[设计模式]{.underline}精心打造，这使得我们可以在开发环境中安心的集成 Spring 框架，不必担心 Spring 是如何在后台进行工作的。\nSpring 框架至今已集成了 20 多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、\nWeb、AOP（面向切面编程）、工具、消息和测试模块。\n2、使用 Spring 框架能带来哪些好处？\n下面列举了一些使用 Spring 框架带来的主要好处：\n   [Dependency Injection(DI)]{.underline} 方法使得构造器和 JavaBean properties 文件中的依赖关系一目了然。\n  与 EJB 容器相比较，IoC 容器更加趋向于轻量级。这样一来 IoC 容器在有限的内存和 CPU 资源的情况下进行应用程序的开发和发布就变得十分有利。\n  Spring 并没有闭门造车，Spring 利用了已有的技术比如 ORM 框架、logging 框架、J2EE、Q uartz 和 JDK Timer，以及其他视图技术。\n  Spring 框架是按照模块的形式来组织的。由包和类的编号就可以看出其所属的模块，开发者仅仅需要选用他们需要的模块即可。\n  要[测试一项用 Spring 开发的应用程序]{.underline}十分简单，因为测试相关的环境代码都已经囊括在框架中了。更加简单的是，利用 JavaBean 形式的 POJO 类，可以很方便的利用依赖注入来写入测试数据。\n  Spring 的 Web 框架亦是一个精心设计的 Web MVC 框架，为开发者们在 web 框架的选择上提供了一个除了主流框架比如 Struts、过度设计的、不流行 web 框架的以外的有力选项。\n  Spring 提供了一个便捷的事务管理接口，适用于小型的本地事物处理（比如在单 DB 的环境下） 和复杂的共同事物处理（比如利用 JTA 的复杂 DB 环境）。\n   3、什么是控制反转(IOC)？什么是依赖注入？\n控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象 之间耦合关系在编译时通常是未知的。在传统的编程方式中，业 务逻辑的流程是由应用程序中的早已被设定好关联关系的对象来决定的。在使用控制反转的情况下，业务逻辑的流程是由对象关系图来 决定的，该对象关系图由装配 器负责实例化，这种实现方式还可以将对象之间的关联关系的定义抽象化。而绑定的过程是通过\u0026quot;依赖注入\u0026quot;实现的。\n控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在我们的实际工作中起到了 有效的作用。\n依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实 例化的模式。这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的 基础。否则如果在组件不受框架控制的情况下，框架又怎么知道要创建哪个组件？\n在 Java 中依然注入有以下三种实现方式：\n   构造器注入\n  Setter 方法注入\n  接口注入\n   4、请解释下 Spring 框架中的 IoC？\nSpring 中的 org.springframework.beans 包和 org.springframework.context 包构成了 Spring 框架 IoC 容器的基础。\nBeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。ApplicationContex 接口对 BeanFactory（是一个子接口）进行了扩展，在 BeanFactory 的基础上添加了其他功能，比如与 [Spring 的 AOP]{.underline} 更容易集成，也提供了处理 [message resource的机制]{.underline}（用于国际化）、事件传播以及应用层的特别配置，比如针对 Web 应用的WebApplicationContext。\norg.springframework.beans.factory.BeanFactory 是 Spring IoC 容器的具体实现， 用来包装和管理前面提到的各种 bean。BeanFactory 接口是 Spring IoC 容器的核心接口。\nIOC:把对象的创建、初始化、销毁交给 spring 来管理，而不是由开发者控制，实现控制反转。\n5、BeanFactory 和 ApplicationContext 有什么区别？\nBeanFactory 可以理解为含有 bean 集合的工厂类。BeanFactory 包含了种 bean 的定义，以便在接收到客户端请求时将对应的 bean 实例化。\nBeanFactory 还能在实例化对象的时生成协作类之间的关系。此举将 bean 自身与 bean 客户端的配置中解放出来。BeanFactory 还包含 了 bean 生命周期的控制，调用客户端的初始化方法\n（initialization methods）和销毁方法（destruction methods）。\n从表面上看，application context 如同 bean factory 一样具有 bean 定义、bean 关联关系的设置，根据请求分发 bean 的功能。但 applicationcontext 在此基础上还提供了其他的功能。\n   提供了支持国际化的文本消息\n  统一的资源文件读取方式\n  已在监听器中注册的 bean 的事件\n   以下是三种较常见的 ApplicationContext 实现方式：\n1、ClassPathXmlApplicationContext：从 classpath 的 XML 配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中\n2、FileSystemXmlApplicationContext ：由文件系统中的 XML 配置文件读取上下文。\n3、XmlWebApplicationContext：由 Web 应用的 XML 文件读取上下文。\n  AnnotationConfigApplicationContext(基于 Java 配置启动容器)   {width=\u0026ldquo;6.075382764654418in\u0026rdquo; height=\u0026ldquo;3.5520833333333335in\u0026rdquo;}\n6、Spring 有几种配置方式？\n将 Spring 配置到应用开发中有以下三种方式：\n   基于 XML 的配置\n  基于注解的配置\n  基于 Java 的配置\n   7、如何用基于 XML 配置的方式配置 Spring？\n在 Spring 框架中，依赖和服务需要在专门的配置文件来实现，我常用的 XML 格式的配置文件。这些配置文件的格式通常用\u0026lt;beans\u0026gt;开头，然后一系列的 bean 定义和专门的应用配置选项组成。\nSpringXML 配置的主要目的时候是使所有的 Spring 组件都可以用 xml 文件的形式来进行配置。这意味着不会出现其他的 Spring 配置类型（比如声明的方式或基于 Java Class 的配置方式）\nSpring 的XML 配置方式是使用被Spring 命名空间的所支持的一系列的 XML 标签来实现的。Spring 有以下主要的命名空间：context、beans、jdbc、tx、aop、mvc 和 aso。\n如：\n {width=\u0026ldquo;5.8093055555555555in\u0026rdquo; height=\u0026ldquo;2.600416666666667in\u0026rdquo;}\n {width=\u0026ldquo;5.8093055555555555in\u0026rdquo; height=\u0026ldquo;3.7606944444444443in\u0026rdquo;}下面这个 web.xml 仅仅配置了 DispatcherServlet，这件最简单的配置便能满足应用程序配置运行时组件的需求。\n{width=\u0026ldquo;5.840027340332458in\u0026rdquo; height=\u0026ldquo;0.21781167979002625in\u0026rdquo;}\n8、如何用基于 Java 配置的方式配置 Spring？\nSpring 对 Java 配置的支持是由@Configuration 注解和@Bean 注解来实现的。由@Bean 注解的方法将会实例化、配置和初始化一个 新对象，这个对象将由 Spring 的 IoC 容器来管理。@Bean 声明所起到的作用与\u0026lt;bean/\u0026gt; 元素类似。被 @Configuration 所注解的类则表示这个类的主要目的是作为 bean 定义的资源。被@Configuration 声明的类可以通过在同一个类的 内部调用@bean 方法来设置嵌入 bean 的依赖关系。\n最简单的@Configuration 声明类请参考下面的代码：\n {width=\u0026ldquo;5.8093055555555555in\u0026rdquo; height=\u0026ldquo;2.3219991251093615in\u0026rdquo;}\n 对于上面的@Beans 配置文件相同的 XML 配置文件如下：\n{width=\u0026ldquo;5.8093055555555555in\u0026rdquo; height=\u0026ldquo;1.0216666666666667in\u0026rdquo;}\u0026lt;beans\u0026gt;\n\u0026lt;bean id=\u0026quot;myService\u0026quot; class=\u0026quot;com.somnus.services.MyServiceImpl\u0026quot;/\u0026gt;\n\u0026lt;/beans\u0026gt;\n上述配置方式的实例化方式如下：利用 AnnotationConfigApplicationContext 类进行实例化\n{width=\u0026ldquo;5.839630358705162in\u0026rdquo; height=\u0026ldquo;0.2968744531933508in\u0026rdquo;}\n要使用组件组建扫描，仅需用@Configuration 进行注解即可：\n在上面的例子中，com.acme 包首先会被扫到，然后再容器内查找被@Component 声明的类，找到后将这些类按照 Sring bean 定义进行注册。\n{width=\u0026ldquo;5.8093055555555555in\u0026rdquo; height=\u0026ldquo;4.550693350831146in\u0026rdquo;}如果你要在你的 web 应用开发中选用上述的配置的方式的话，需要用AnnotationConfigWebApplicationContext 类来读 取配置文件，可以用来配置 Spring 的Servlet 监听器 ContextLoaderListener 或者 Spring MVC 的 DispatcherServlet。\n{width=\u0026ldquo;5.8093055555555555in\u0026rdquo; height=\u0026ldquo;8.234722222222222in\u0026rdquo;} \u0026lt;param-value\u0026gt;com.howtodoinjava.AppConfig\u0026lt;/param-value\u0026gt;\n\u0026lt;/context-param\u0026gt;\n\u0026lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --\u0026gt;\n\u0026lt;listener\u0026gt;\n\u0026lt;listener-class\u0026gt;org.springframework.web.context.ContextLoaderListener\n\u0026lt;/listener-class\u0026gt;\n\u0026lt;/listener\u0026gt;\n\u0026lt;!-- Declare a Spring MVC DispatcherServlet as usual --\u0026gt;\n\u0026lt;servlet\u0026gt;\n\u0026lt;servlet-name\u0026gt;dispatcher\u0026lt;/servlet-name\u0026gt;\n\u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/ser vlet-class\u0026gt;\n\u0026lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext\ninstead of the default XmlWebApplicationContext --\u0026gt;\n\u0026lt;init-param\u0026gt;\n\u0026lt;param-name\u0026gt;contextClass\u0026lt;/param-name\u0026gt;\n\u0026lt;param-value\u0026gt;\norg.springframework.web.context.support.AnnotationConfigWebApplicatio nContext\n\u0026lt;/param-value\u0026gt;\n\u0026lt;/init-param\u0026gt;\n\u0026lt;!-- Again, config locations must consist of one or more comma- or space-delimited\nand fully-qualified @Configuration classes --\u0026gt;\n\u0026lt;init-param\u0026gt;\n\u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt;\n\u0026lt;param-value\u0026gt;com.howtodoinjava.web.MvcConfig\u0026lt;/param-value\u0026gt;\n\u0026lt;/init-param\u0026gt;\n\u0026lt;/servlet\u0026gt;\n{width=\u0026ldquo;5.8093055555555555in\u0026rdquo; height=\u0026ldquo;2.105277777777778in\u0026rdquo;}9、怎样用注解的方式配置 Spring？\nSpring 在 2.5 版本以后开始支持用注解的方式来配置依赖注入。可以用注解的方式来替代 XML 方式的 bean 描述，可以将 bean 描述转移到组件类的 内部，只需要在相关类上、方法上或者字段声明上使用注解即可。注解注入将会被容器在 XML 注入之前被处理，所以后者会覆盖掉前者对于同一个属性的处理结 果。\n注解装配在 Spring 中是默认关闭的。所以需要在 Spring 文件中配置一下才能使用基于注解的装配模式。如果你想要在你的应用程序中使用关于注解的方法的话，请参考如下的配置。\n在 \u0026lt;context:annotation-config/\u0026gt;标签配置完成以后，就可以用注解的方式在 Spring 中向属性、方法和构造方法中自动装配变量。\n下面是几种比较重要的注解类型：\n   @Required：该注解应用于设值方法。\n  @Autowired：该注解应用于有值设值方法、非设值方法、构造方法和变量。\n  @Qualifier：该注解和@Autowired 注解搭配使用，用于消除特定 bean 自动装配的歧义。\n  JSR-250 Annotations：Spring 支持基于 JSR-250 注解的以下注解，@Resource、\n   @PostConstruct 和 @PreDestroy。\n10、请解释 Spring Bean 的生命周期？\nSpring Bean 的生命周期简单易懂。在一个 bean 实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个 bean 不在被调用时需要进行相关的析构操作，并从 bean 容器中移除。\nSpring bean factory 负责管理在 spring 容器中被创建的 bean 的生命周期。Bean 的生命周期由两组回调（call back）方法组成。\n   初始化之后调用的回调方法。\n  销毁之前调用的回调方法。\n   Spring 框架提供了以下四种方式来管理 bean 的生命周期事件：\n   InitializingBean 和 DisposableBean 回调接口\n  针对特殊行为的其他 Aware 接口\n  Bean 配置文件中的 Custom init()方法和 destroy()方法\n  @PostConstruct 和@PreDestroy 注解方式\n   使用 customInit()和 customDestroy()方法管理 bean 生命周期的代码样例如下：\n11、Spring Bean 的作用域之间有什么区别？\nSpring 容器中的 bean 可以分为 5 个范围。所有范围的名称都是自说明的，但是为了避免混淆，还是让我们来解释一下：\n  singleton：这种 bean 范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个   bean 的实例，单例的模式由 bean factory 自身来维护。\n   prototype：原形范围与单例范围相反，为每一个 bean 请求提供一个实例。\n  request：在请求 bean 范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。\n  Session：与请求范围类似，确保每个 session 中有一个 bean 的实例，在 session 过期后，bean 会随之失效。\n  global- session：global-session 和 Portlet 应用相关。当你的应用部署在 Portlet 容器中工作时， 它包含很多 portlet。如果 你想要声明让所有的 portlet 共用全局的存储变量的话，那么这全局变量需要存储在 global-session 中。\n   全局作用域与 Servlet 中的 session 作用域效果相同。\n12、什么是 Spring inner beans？\n在Spring 框架中，无论何时 bean 被使用时，当仅被调用了一个属性。一个明智的做法是将这个 bean\n声明为内部 bean。内部 bean 可以用 setter 注入\u0026quot;属性\u0026quot;和构造方法注入\u0026quot;构造参数\u0026quot;的方式来实现。\n比如，在我们的应用程序中，一个 Customer 类引用了一个 Person 类，我们的要做的是创建一个\nPerson 的实例，然后在 Customer 内部使用。\n {width=\u0026ldquo;5.8093055555555555in\u0026rdquo; height=\u0026ldquo;2.9719444444444445in\u0026rdquo;}\n 内部 bean 的声明方式如下：\n {width=\u0026ldquo;5.8093055555555555in\u0026rdquo; height=\u0026ldquo;3.18875in\u0026rdquo;}\n 13、Spring 框架中的单例 Beans 是线程安全的么？\nSpring 框架并没有对[单例]{.underline} bean 进行任何多线程的封装处理。关于单例 bean 的[线程安全]{.underline}和并发问题需要开发者自行去搞定。但实际上，大部分的 Spring bean 并没有可变的状态(比如 Serview 类和 DAO 类)，所以在某种程度上说 Spring 的单例 bean 是线程安全的。如果你的 bean 有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。\n最浅显的解决办法就是将多态 bean 的作用域由\u0026quot;singleton\u0026quot;变更为\u0026quot;prototype\u0026quot;。\n14、请举例说明如何在 Spring 中注入一个 Java Collection？\nSpring 提供了以下四种集合类的配置元素：\n   \u0026lt;list\u0026gt; : 该标签用来装配可重复的 list 值。\n  \u0026lt;set\u0026gt; : 该标签用来装配没有重复的 set 值。\n  \u0026lt;map\u0026gt;: 该标签可用来注入键和值可以为任何类型的键值对。\n  \u0026lt;props\u0026gt; : 该标签支持注入键和值都是字符串类型的键值对。下面看一下具体的例子：\n   {width=\u0026ldquo;5.8093055555555555in\u0026rdquo; height=\u0026ldquo;7.151111111111111in\u0026rdquo;}\u0026lt;beans\u0026gt;\n\u0026lt;!-- Definition for javaCollection --\u0026gt;\n\u0026lt;bean id=\u0026quot;javaCollection\u0026quot; class=\u0026quot;com.howtodoinjava.JavaCollection\u0026quot;\u0026gt;\n\u0026lt;!-- java.util.List --\u0026gt;\n\u0026lt;property name=\u0026quot;customList\u0026quot;\u0026gt;\n\u0026lt;list\u0026gt;\n\u0026lt;value\u0026gt;INDIA\u0026lt;/value\u0026gt;\n\u0026lt;value\u0026gt;Pakistan\u0026lt;/value\u0026gt;\n\u0026lt;value\u0026gt;USA\u0026lt;/value\u0026gt;\n\u0026lt;value\u0026gt;UK\u0026lt;/value\u0026gt;\n\u0026lt;/list\u0026gt;\n\u0026lt;/property\u0026gt;\n\u0026lt;!-- java.util.Set --\u0026gt;\n\u0026lt;property name=\u0026quot;customSet\u0026quot;\u0026gt;\n\u0026lt;set\u0026gt;\n\u0026lt;value\u0026gt;INDIA\u0026lt;/value\u0026gt;\n\u0026lt;value\u0026gt;Pakistan\u0026lt;/value\u0026gt;\n\u0026lt;value\u0026gt;USA\u0026lt;/value\u0026gt;\n\u0026lt;value\u0026gt;UK\u0026lt;/value\u0026gt;\n\u0026lt;/set\u0026gt;\n\u0026lt;/property\u0026gt;\n\u0026lt;!-- java.util.Map --\u0026gt;\n\u0026lt;property name=\u0026quot;customMap\u0026quot;\u0026gt;\n\u0026lt;map\u0026gt;\n\u0026lt;entry key=\u0026quot;1\u0026quot; value=\u0026quot;INDIA\u0026quot;/\u0026gt;\n\u0026lt;entry key=\u0026quot;2\u0026quot; value=\u0026quot;Pakistan\u0026quot;/\u0026gt;\n\u0026lt;entry key=\u0026quot;3\u0026quot; value=\u0026quot;USA\u0026quot;/\u0026gt;\n\u0026lt;entry key=\u0026quot;4\u0026quot; value=\u0026quot;UK\u0026quot;/\u0026gt;\n\u0026lt;/map\u0026gt;\n\u0026lt;/property\u0026gt;\n{width=\u0026ldquo;5.8093055555555555in\u0026rdquo; height=\u0026ldquo;3.1890277777777776in\u0026rdquo;}15、如何向 Spring Bean 中注入一个 Java.util.Properties？\n第一种方法是使用如下面代码所示的\u0026lt;props\u0026gt; 标签：\n {width=\u0026ldquo;5.8093055555555555in\u0026rdquo; height=\u0026ldquo;3.1886111111111113in\u0026rdquo;}\n 也可用\u0026quot;util:\u0026ldquo;命名空间来从 properties 文件中创建出一个 propertiesbean，然后利用 setter 方法注入 bean 的引用。\n16、请解释 Spring Bean 的自动装配？\n在 Spring 框架中，在配置文件中设定 bean 的依赖关系是一个很好的机制，Spring 容器还可以自动装配合作关系 bean 之间的关联关系。这意味着 Spring 可以通过向 Bean Factory 中注入的方式自动搞定 bean 之间的依赖关系。自动装配可以设置在每个 bean 上，也可以设定在特定的 bean 上。\n下面的 XML 配置文件表明了如何根据名称将一个 bean 设置为自动装配：\n除了 bean 配置文件中提供的自动装配模式，还可以使用@Autowired 注解来自动装配指定的bean。在使用@Autowired 注解之前需要在按照如下的配置方式在 Spring 配置文件进行配置才可以使用。\n也可以通过在配置文件中配置AutowiredAnnotationBeanPostProcessor 达到相同的效果。\n {width=\u0026ldquo;5.716722440944882in\u0026rdquo; height=\u0026ldquo;0.2135411198600175in\u0026rdquo;}\n 配置好以后就可以使用@Autowired 来标注了。\n17、请解释自动装配模式的区别？\n在 Spring 框架中共有 5 种自动装配，让我们逐一分析。\n   no：这是 Spring 框架的默认设置，在该设置下自动装配是关闭的，开发者需要自行在 bean 定义中用标签明确的设置依赖关系。\n  byName：该选项可以根据 bean 名称设置依赖关系。当向一个 bean 中自动装配一个属性时，容器将根据 bean 的名称自动在在配置文件中查询一个匹配的 bean。如果找到的话，就装配这个属性， 如果没找到的话就报错。\n  byType：该选项可以根据 bean 类型设置依赖关系。当向一个 bean 中自动装配一个属性时，容器将根据 bean 的类型自动在在配置文件中查询一个匹配的 bean。如果找到的话，就装配这个属性， 如果没找到的话就报错。\n  constructor：造器的自动装配和 byType 模式类似，但是仅仅适用于与有构造器相同参数的 bean，如果在容器中没有找到与构造器参数类型一致的 bean，那么将会抛出异常。\n  autodetect：该模式自动探测使用构造器自动装配或者 byType 自动装配。首先，首先会尝试找合适的带参数的构造器，如果找到的话就是用构造器自动装配，如果在 bean 内部没有找到相应的构造器或者是无参构造器，容器就会自动选择 byTpe 的自动装配方式。\n   18、如何开启基于注解的自动装配？\n要使用 @Autowired，需要注册 AutowiredAnnotationBeanPostProcessor，可以有以下两种方式来实现：\n1、引入配置文件中的\u0026lt;bean\u0026gt;下引入 \u0026lt;context:annotation-config\u0026gt;\n\u0026lt;beans\u0026gt;\n2、在 bean 配置文件中直接引入 AutowiredAnnotationBeanPostProcessor\n19、请举例解释@Required 注解？\n在产品级别的应用中，IoC 容器可能声明了数十万了 bean，bean 与 bean 之间有着复杂的依赖关系。设值注解方法的短板之一就是验证所有的属性是否被注解是一项十分困难的操作。可以通过在\n\u0026lt;bean\u0026gt;中设置\u0026quot;dependency-check\u0026quot;来解决这个问题。\n在应用程序的生命周期中，你可能不大愿意花时间在验证所有 bean 的属性是否按照上下文文件正确配置。或者你宁可验证某个 bean 的特定属性是否被正确的设置。即使是用\u0026quot;dependency-check\u0026rdquo; 属性也不能很好的解决这个问题，在这种情况下，你需要使用@Required 注解。\n需要用如下的方式使用来标明 bean 的设值方法。\n{width=\u0026ldquo;5.8093055555555555in\u0026rdquo; height=\u0026ldquo;1.9504166666666667in\u0026rdquo;}\npublic class EmployeeFactoryBean extends AbstractFactoryBean\u0026lt;Object\u0026gt;{\nprivate String designation;\npublic String getDesignation() {\nreturn designation;\n}\n@Required\npublic void setDesignation(String designation) {\nthis.designation = designation;\n{width=\u0026ldquo;5.8093055555555555in\u0026rdquo; height=\u0026ldquo;1.4552777777777777in\u0026rdquo;}RequiredAnnotationBeanPostProcessor 是 Spring 中的后置处理用来验证被 @Required 注解的 bean 属性是否被正确的设置了。在使用RequiredAnnotationBeanPostProcesso 来验证 bean 属性之前，首先要在 IoC 容器中对其进行注册：\n {width=\u0026ldquo;5.840027340332458in\u0026rdquo; height=\u0026ldquo;0.21781167979002625in\u0026rdquo;}\n 但是如果没有属性被用 @Required 注解过的话，后置处理器会抛出一个\nBeanInitializationException 异常。\n20、请举例解释@Autowired 注解？\n@Autowired 注解对自动装配何时何处被实现提供了更多细粒度的控制。@Autowired 注解可以像@Required 注解、构造器一样被用于在 bean 的设值方法上自动装配 bean 的属性，一个参数或者带有任意名称或带有多个参数的方法。\n比如，可以在设值方法上使用@Autowired 注解来替代配置文件中的 \u0026lt;property\u0026gt;元素。当 Spring 容器在 setter 方法上找到@Autowired 注解时，会尝试用 byType 自动 装配。\n当然我们也可以在构造方法上使用@Autowired 注解。带有@Autowired 注解的构造方法意味着在创建一个 bean 时将会被自动装配，即便在配置文件中使用\u0026lt;constructor-arg\u0026gt; 元素。\n{width=\u0026ldquo;5.8093055555555555in\u0026rdquo; height=\u0026ldquo;3.1890277777777776in\u0026rdquo;}下面是没有构造参数的配置方式：\n {width=\u0026ldquo;5.8093055555555555in\u0026rdquo; height=\u0026ldquo;3.4069444444444446in\u0026rdquo;}\n 21、请举例说明@Qualifier 注解？\n@Qualifier 注解意味着可以在被标注 bean 的字段上可以自动装配。Qualifier 注解可以用来取消 Spring 不能取消的 bean 应用。\n下面的示例将会在 Customer 的 person 属性中自动装配 person 的值。\n下面我们要在配置文件中来配置 Person 类。\n {width=\u0026ldquo;5.8093055555555555in\u0026rdquo; height=\u0026ldquo;2.973611111111111in\u0026rdquo;}\n Spring 会知道要自动装配哪个 person bean 么？不会的，但是运行上面的示例时，会抛出下面的异常：\n{width=\u0026ldquo;5.8093055555555555in\u0026rdquo; height=\u0026ldquo;1.455in\u0026rdquo;}Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException:\nNo unique bean of type [com.howtodoinjava.common.Person] is defined:\nexpected single matching bean but found 2: [personA, personB]\n要解决上面的问题，需要使用 @Quanlifier 注解来告诉 Spring 容器要装配哪个 bean：\n {width=\u0026ldquo;5.865164041994751in\u0026rdquo; height=\u0026ldquo;0.21875in\u0026rdquo;}\n 22、构造方法注入和设值注入有什么区别？\n请注意以下明显的区别：\n   在设值注入方法支持大部分的依赖注入，如果我们仅需 要注入 int、string 和 long 型的变量，我们不要用设值的方法注入。对于基本类型，如果我们没有注入的话，可以为基本类型设置默认值。在构 造方法 注入不支持大部分的依赖注入，因为在调用构造方法中必须传入正确的构造参数，否则的话为报错。\n  设值注入不会重写构造方法的值。如果我们对同一个变量同时使用了构造方法注入又使用了设置方法 注入的话，那么构造方法将不能覆盖由设值方法注入的值。很明显，因为构造方法尽在对象被创建时 调用。\n  在使用设值注入时有可能还不能保证某种依赖是否已经被注入，也就是说这时对象的依赖关系有可能 是不完整的。而在另一种情况下，构造器注入则不允许生成依赖关系不完整的对象。\n  在设值注入时如果对象 A 和对象 B 互相依赖，在创建对象 A 时 Spring 会抛出sObjectCurrentlyInCreationException 异常，因为在 B 对象被创建之前 A 对象是不能被创建的，反之亦然。所以 Spring 用设值注入的方法解决了循环依赖的问题，因对象的设值方法是在对象被创建之前被调用的。\n   23、Spring 框架中有哪些不同类型的事件？\nSpring 的 ApplicationContext 提供了支持事件和代码中监听器的功能。\n我们可以创建 bean 用来监听在 ApplicationContext 中发布的事件。ApplicationEvent 类和在 ApplicationContext 接口中处理的事件，如果一个 bean 实现了ApplicationListener 接口，当一个 ApplicationEvent 被发布以后，bean 会自动被通知。\n{width=\u0026ldquo;5.8093055555555555in\u0026rdquo; height=\u0026ldquo;2.7554166666666666in\u0026rdquo;}public class AllApplicationEventListener implements ApplicationListener\n\u0026lt; ApplicationEvent \u0026gt;{\n@Override\npublic void onApplicationEvent(ApplicationEvent applicationEvent)\n{\n//process event\n}\n}\nSpring 提供了以下 5 中标准的事件：\n   上下文更新事件（ContextRefreshedEvent）：该事件会在 ApplicationContext 被初始化或者更新时发布。也可以在调用 ConfigurableApplicationContext 接口中的 refresh()方法时被触发。\n  上下文开始事件（ContextStartedEvent）：当容器调用 ConfigurableApplicationContext 的\n   Start()方法开始/重新开始容器时触发该事件。\n  上下文停止事件（ContextStoppedEvent）：当容器调用 ConfigurableApplicationContext 的   Stop()方法停止容器时触发该事件。\n   上下文关闭事件（ContextClosedEvent）：当 ApplicationContext 被关闭时触发该事件。容器被关闭时，其管理的所有单例 Bean 都被销毁。\n  请求处理事件（RequestHandledEvent）：在 Web 应用中，当一个 http 请求（request）结束触发该事件。\n   除了上面介绍的事件以外，还可以通过扩展 ApplicationEvent 类来开发自定义的事件。\n{width=\u0026ldquo;5.8093055555555555in\u0026rdquo; height=\u0026ldquo;1.8883333333333334in\u0026rdquo;}public class CustomApplicationEvent extends ApplicationEvent{\npublic CustomApplicationEvent ( Object source, final String msg ){\nsuper(source);\nSystem.out.println(\u0026quot;Created a Custom event\u0026quot;);\n}\n}\n为了监听这个事件，还需要创建一个监听器：\n之后通过 applicationContext 接口的 publishEvent()方法来发布自定义事件。\n24、FileSystemResource 和 ClassPathResource 有何区别？\n在 FileSystemResource 中需要给出 spring-config.xml 文件在你项目中的相对路径或者绝对路径。在 ClassPathResource 中 spring 会在 ClassPath 中自动搜寻配置文件，所以要把ClassPathResource 文件放在 ClassPath 下。\n如果将 spring-config.xml 保存在了 src 文件夹下的话，只需给出配置文件的名称即可，因为\nsrc 文件夹是默认。\n简而言之，ClassPathResource 在环境变量中读取配置文件，FileSystemResource 在配置文件中读取配置文件。\n25、Spring 框架中都用到了哪些设计模式？\nSpring 框架中使用到了大量的设计模式，下面列举了比较有代表性的：\n   代理模式\u0026mdash;在 AOP 和 remoting 中被用的比较多。\n  单例模式\u0026mdash;在 spring 配置文件中定义的 bean 默认为单例模式。\n  模板方法\u0026mdash;用来解决代码重复的问题。比如. [RestTemplate]{.underline}, JmsTemplate, JpaTempl ate。\n  前端控制器\u0026mdash;Spring 提供了 DispatcherServlet 来对请求进行分发。\n  视图帮助(View Helper )\u0026mdash;Spring 提供了一系列的 JSP 标签，高效宏来辅助将分散的代码整合在视图里。\n  依赖注入\u0026mdash;贯穿于 BeanFactory / ApplicationContext 接口的核心理念。\n  工厂模式\u0026mdash;BeanFactory 用来创建对象的实例\n开发中主要使用 Spring 的什么技术 ?     ①. IOC 容器管理各层的组件\n②. 使用 AOP 配置声明式事务\n③. 整合其他框架.\n 简述 AOP 和 IOC 概念 AOP:   Aspect Oriented Program, 面向(方面)切面的编程;Filter(过滤器) 也是一种 AOP. AOP 是一种新的方法论, 是对传统 OOP(Object-Oriented Programming, 面向对象编程) 的补充. AOP 的主要编程对象是切面(aspect), 而切面模块化横切关注点.可以举例通过事务说明.\nIOC: Invert Of Control, 控制反转. 也成为 DI(依赖注入)其思想是反转 资源获取的方向. 传统的资源查找方式要求组件向容器发起请求查找资源.作为 回应, 容器适时的返回资源. 而应用了 IOC 之后, 则是容器主动地将资源推送 给它所管理的组件,组件所要做的仅是选择一种合适的方式来接受资源. 这种行 为也被称为查找的被动形式\n 在 Spring 中如何配置 Bean ?   Bean 的配置方式: 通过全类名（反射）、通过工厂方法（静态工厂方法 \u0026amp; 实 例工厂方法）、\nFactoryBean\n IOC 容器对 Bean 的生命周期:   ①. 通过构造器或工厂方法创建 Bean 实例\n②. 为 Bean 的属性设置值和对其他 Bean 的引用\n③ . 将 Bean 实 例 传 递 给 Bean 后 置 处 理 器 的 postProcessBeforeInitialization 方法\n④. 调用 Bean 的初始化方法(init-method)\n⑤ . 将 Bean 实 例 传 递 给 Bean 后 置 处 理 器 的 postProcessAfterInitialization 方法\n⑦. Bean 可以使用了\n⑧. 当容器关闭时, 调用 Bean 的销毁方法(destroy-method)\n更多请关注微信公众号：Java 技术栈，回复：面试\n ","pubDate":"2021-02-15","title":"29道常见的Spring面试题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E4%BF%A1%E6%81%AF%E5%92%A8%E8%AF%A2_2ch/","plain":"信息系统开发方法论  问信息系统开发方法有哪些  生命周期法、原型法、结构化方法、面向对象方法、构件法、面向服务方法、敏捷开发方法\r概述 1  信息系统开发方法的研究内容:  1:在较高层次上分析和总结以往的经验，研究信息系统开发的一般规律，建立具有一般意义的系统开发指导思想的基本原则\r2:从系统工程的角度,为分析人员提供一个协调局部与整体利益的思维方法，以及具体的分析设计原则\r3:围绕已建立的各种开发方法、指导思想的原则，建立相应的实施步骤\r4:研制一整套与系统开发思想相对应的、适合于各实施步骤的描述和开发工具\r5:信息系统开发的组织、实施方法\r6:系统开发成功的关键因素、必要条件以及促使系统开发成功的组织运行机制等\r  生命周期法 强调结构化分析、结构化设计\n  原型法 快速构造系统雏形，然后对原型系统进行扩展\n  结构化方法 将开发过程分成多个阶段，每个阶段有其明确的任务和目标\n  面向对象方法 略\n  构件法 它是基于面向对象\n  面向服务方法 略\n  敏捷开发方法 略\n  生命周期法 2  1 生命周期法:描述和定义  信息系统工程采用的“生命周期法”，就是从时间角度对信息系统开发和维护的复杂问题进行分解，把信息系统生存的漫长周期依次划分为若干个阶段，每个阶段有相对独立的任务，然后再逐步完成每个阶段的任务\r生命周期法就是按信息系统工程生命周期的各个阶段划分任务，按一定的规则和步骤，有效地进行信息系统开发的方法\r 2 生命周期划分   一个信息系统工程的生命周期可分为系统定义、系统设计、系统实施与维护 三个时期九个阶段\n   主要的阶段包括可行性研究、需求分析、系统设计、系统实施与维护等\n  1):可行性研究\n    (1) 明确任务\n  (2) 环境调查\n  (3) 提出方案\n  (4) 可行性分析\n   2):需求分析  ","pubDate":"2021-02-15","title":"2ch"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_30%E4%B8%AAjava%E7%BB%8F%E5%85%B8%E7%9A%84%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/","plain":" Java 集合框架是什么？说出一些集合框架的优点？  每种编程语言中都有集合，最初的 Java 版本包含几种集合类：Vector、Stack、HashTable 和\nArray。\n随着集合的广泛使用，Java1.2 提出了囊括所有集合接口、实现和算法的集合框架。在保证线程安全的情况下使用泛型和并发集合类，Java 已经经历了很久。它还包括在 Java 并发包中，阻塞接口以及它们的实现。\n集合框架的部分优点如下：\n  使用核心集合类降低开发成本，而非实现我们自己的集合类。\n  随着使用经过严格测试的集合框架类，代码质量会得到提高。\n  通过使用 JDK 附带的集合类，可以降低代码维护成本。\n  复用性和可操作性。\n   集合框架中的泛型有什么优点？    Java1.5 引入了泛型，所有的集合接口和实现都大量地使用它。\n  泛型允许我们为集合提供一个可以容纳的对象类型，因此，如果你添加其它类型的任何元素，它会在编译时报错。\n  这避免了在运行时出现 ClassCastException，因为你将会在编译时得到报错信息。4.泛型也使得代码整洁，我们不需要使用显式转换和 instanceOf 操作符。\n  5.它也给运行时带来好处，因为不会产生类型检查的字节码指令。\n3.Java 集合框架的基础接口有哪些？\nCollection 为集合层级的根接口。一个集合代表一组对象，这些对象即为它的元素。Java 平台不提供这个接口任何直接的实现。\nSet 是一个不能包含重复元素的集合。这个接口对数学集合抽象进行建模，被用来代表集合， 就如一副牌。\nList 是一个有序集合，可以包含重复元素。你可以通过它的索引来访问任何元素。List 更像长度动态变换的数组。\nMap 是一个将 key 映射到 value 的对象.一个 Map 不能包含重复的 key：每个 key 最多只能映射一个 value。\n一些其它的接口有Queue、Dequeue、SortedSet、SortedMap 和 ListIterator。4.为何 Collection 不从 Cloneable 和 Serializable 接口继承？\nCollection 接口指定一组对象，对象即为它的元素。如何维护这些元素由 Collection 的具体实现决定。例如，一些如 List 的 Collection 实现允许重复的元素，而其它的如 Set 就不允许。\n很多 Collection 实现有一个公有的 clone 方法。然而，把它放到集合的所有实现中也是没有意义的。这是因为 Collection 是一个抽象表现。重要的是实现。\n当与具体实现打交道的时候，克隆或序列化的语义和含义才发挥作用。所以，具体实现应该决定如何对它进行克隆或序列化，或它是否可以被克隆或序列化。点击这里一文学会序列化。\n在所有的实现中授权克隆和序列化，最终导致更少的灵活性和更多的限制。特定的实现应该决定它是否可以被克隆和序列化。点击这里一文学会序列化。\n为何 Map 接口不继承 Collection 接口？  尽管 Map 接口和它的实现也是集合框架的一部分，但 Map 不是集合，集合也不是 Map。因此，Map 继承 Collection 毫无意义，反之亦然。\n如果 Map 继承 Collection 接口，那么元素去哪儿？Map 包含 key-value 对，它提供抽取 key\n或 value 列表集合的方法，但是它不适合\u0026quot;一组对象\u0026quot;规范。\nIterator 是什么？  Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration。迭代器允许调用者在迭代过程中移除元素。\nEnumeration 和 Iterator 接口的区别？  Enumeration 的速度是 Iterator 的两倍，也使用更少的内存。Enumeration 是非常基础的，也满足了基础的需要。但是，与 Enumeration 相比，Iterator 更加安全，因为当一个集合正在被遍历的时候，它会阻止其它线程去修改集合。\n迭代器取代了 Java 集合框架中的 Enumeration。迭代器允许调用者从集合中移除元素，而Enumeration 不能做到。为了使它的功能更加清晰，迭代器方法名已经经过改善。\n为何没有像Iterator.add()这样的方法，向集合中添加元素？  语义不明，已知的是，Iterator 的协议不能确保迭代的次序。然而要注意，ListIterator 没有提供一个 add 操作，它要确保迭代的顺序。\n为何迭代器没有一个方法可以直接获取下一个元素，而不需要移动游标？  它可以在当前Iterator 的顶层实现，但是它用得很少，如果将它加到接口中，每个继承都要去实现它，这没有意义。\nIterater 和 ListIterator 之间有什么区别？    我们可以使用Iterator 来遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。\n  Iterator 只可以向前遍历，而 LIstIterator 可以双向遍历。\n  ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。\n  通过迭代器 fail-fast 属性，你明白了什么？  每次我们尝试获取下一个元素的时候，Iterator fail-fast 属性检查当前集合结构里的任何改动。如果发现任何改动，它抛出 ConcurrentModificationException。Collection 中所有 Iterator 的实现都是按 fail-fast 来设计的（ConcurrentHashMap 和 CopyOnWriteArrayList 这类并发集合类除外）。\nfail-fast 与 fail-safe 有什么区别？  Iterator 的 fail-fast 属性与当前的集合共同起作用，因此它不会受到集合中任何改动的影响。\nJava.util 包中的所有集合类都被设计为 fail-fast 的， 而 java.util.concurrent 中的集合类都为 fail-safe 的。\nFall\u0026mdash;fast 迭代器抛出 ConcurrentModificationException， fall\u0026mdash;safe 迭代器从不抛出 ConcurrentModificationException。\n在迭代一个集合的时候，如何避免？ ConcurrentModificationException？  在遍历一个集合的时候我们可以使用并发集合类来避免 ConcurrentModificationException，比\n如使用 CopyOnWriteArrayList，而不是 ArrayList。14.为何 Iterator 接口没有具体的实现？\nIterator 接口定义了遍历集合的方法，但它的实现则是集合实现类的责任。每个能够返回用于遍历的 Iterator 的集合类都有它自己的 Iterator 实现内部类。\n这就允许集合类去选择迭代器是 fail-fast 还是 fail-safe 的。比如，ArrayList 迭代器是 fail-fast\n的，而 CopyOnWriteArrayList 迭代器是 fail-safe 的。\nUnsupportedOperationException 是什么？  UnsupportedOperationException 是用于表明操作不支持的异常。在 JDK 类中已被大量运用， 在集合框架java.util.Collections.UnmodifiableCollection 将会在所有 add 和remove 操作中抛出这个异常。\nhashCode()和 equals()方法有何重要性？  HashMap 使用 Key 对象的 hashCode()和 equals()方法去决定 key-value 对的索引。点击这里一文搞懂它们之间的关系。\n当我们试着从 HashMap 中获取值的时候，这些方法也会被用到。如果这些方法没有被正确地实现，在这种情况下，两个不同 Key 也许会产生相同的 hashCode()和 equals()输出，HashMap将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。\n同样的，所有不允许存储重复数据的集合类都使用 hashCode()和 equals()去查找重复，所以正确实现它们非常重要。equals()和 hashCode()的实现应该遵循以下规则：\n  如果 o1.equals(o2)，那么 o1.hashCode() == o2.hashCode()总是为 true 的。\n  如果 o1.hashCode() == o2.hashCode()，并不意味着 o1.equals(o2)会为 true。17.Map 接口提供了哪些不同的集合视图？\n  Map 接口提供三个集合视图：\n Set keyset()：返回 map 中包含的所有 key 的一个 Set 视图。集合是受map 支持的，map 的变化会在集合中反映出来，反之亦然。当一个迭代器正在遍历一个集合时，若 map 被修改了（除迭代器自身的移除操作以外），迭代器的结果会变为未定义。集合支持通过 Iterator  的 Remove、Set.remove、removeAll、retainAll 和 clear 操作进行元素移除，从 map 中移除对应的映射。\n它不支持 add 和 addAll 操作。\n  Collection values()：返回一个map 中包含的所有value 的一个Collection 视图。这个collection受 map 支持的，map 的变化会在 collection 中反映出来，反之亦然。当一个迭代器正在遍历一个 collection 时，若 map 被修改了（除迭代器自身的移除操作以外），迭代器的结果会变为未定义。集合支持通过 Iterator 的 Remove、Set.remove、removeAll、retainAll 和clear 操作进行元素移除，从map 中移除对应的映射。它不支持 add 和 addAll 操作。\n  Set\u0026lt;Map.Entry\u0026lt;K,V\u0026gt;\u0026gt; entrySet()：返回一个 map 钟包含的所有映射的一个集合视图。这个集合受 map 支持的，map 的变化会在 collection 中反映出来，反之亦然。当一个迭代器正在遍历一个集合时，若map 被修改了（除迭代器自身的移除操作，以及对迭代器返回的entry 进行setValue 外），迭代器的结果会变为未定义。集合支持通过 Iterator 的Remove、Set.remove、removeAll、retainAll 和 clear 操作进行元素移除，从 map 中移除对应的映射。它不支持 add 和 addAll 操作。\n  HashMap 和 HashTable 有何不同？    HashMap 允许 key 和 value 为 null，而 HashTable 不允许。\n  HashTable 是同步的，而 HashMap 不是。所以 HashMap 适合单线程环境，HashTable 适合多线程环境。\n  在 Java1.4 中引入了 LinkedHashMap，HashMap 的一个子类，假如你想要遍历顺序，你很容易从 HashMap 转向 LinkedHashMap，但是 HashTable 不是这样的，它的顺序是不可预知的。\n  HashMap 提供对 key 的 Set 进行遍历，因此它是 fail-fast 的，但 HashTable 提供对 key\n  的 Enumeration 进行遍历，它不支持 fail-fast。\n HashTable 被认为是个遗留的类，如果你寻求在迭代的时候修改 Map，你应该使用CocurrentHashMap。  如何决定选用 HashMap 还是TreeMap？  对于在 Map 中插入、删除和定位元素这类操作，HashMap 是最好的选择。然而，假如你需要对一个有序的 key 集合进行遍历，TreeMap 是更好的选择。基于你的 collection 的大小， 也许向 HashMap 中添加元素会更快，将 map 换为 TreeMap 进行有序 key 的遍历。\nArrayList 和Vector 有何异同点？  ArrayList 和 Vector 在很多时候都很类似。\n  两者都是基于索引的，内部由一个数组支持。\n  两者维护插入的顺序，我们可以根据插入顺序来获取元素。\n  ArrayList 和Vector 的迭代器实现都是fail-fast 的。\n  ArrayList 和Vector 两者允许 null 值，也可以使用索引值对元素进行随机访问。以下是 ArrayList 和Vector 的不同点。\n    Vector 是同步的，而 ArrayList 不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用 CopyOnWriteArrayList。\n  ArrayList 比Vector 快，它因为有同步，不会过载。\n  ArrayList 更加通用，因为我们可以使用 Collections 工具类轻易地获取同步列表和只读列表。\n  Array 和 ArrayList 有何区别？什么时候更适合用Array？ Array 可以容纳基本类型和对象，而 ArrayList 只能容纳对象。  Array 是指定大小的，而ArrayList 大小是固定的。\nArray 没有提供 ArrayList 那么多功能，比如 addAll、removeAll 和 iterator 等。尽管 ArrayList\n明显是更好的选择，但也有些时候 Array 比较好用。\n  如果列表的大小已经指定，大部分情况下是存储和遍历它们。\n  对于遍历基本数据类型，尽管 Collections 使用自动装箱来减轻编码任务，在指定大小的基本类型的列表上工作也会变得很慢。\n  如果你要使用多维数组，使用[][]比 List\u0026lt;List\u0026lt;\u0026gt;\u0026gt;更容易。22.ArrayList 和 LinkedList 有何区别？\n  ArrayList 和 LinkedList 两者都实现了 List 接口，但是它们之间有些不同。\n  ArrayList 是由 Array 所支持的基于一个索引的数据结构，所以它提供对元素的随机访问， 复杂度为 O(1)，但 LinkedList 存储一系列的节点数据，每个节点都与前一个和下一个节点相连接。所以，尽管有使用索引获取元素的方法，内部实现是从起始点开始遍历，遍历到索引的节点然后返回元素，时间复杂度为 O(n)，比 ArrayList 要慢。\n  与 ArrayList 相比，在 LinkedList 中插入、添加和删除一个元素会更快，因为在一个元素被插入到中间的时候，不会涉及改变数组的大小，或更新索引。\n  LinkedList 比 ArrayList 消耗更多的内存，因为 LinkedList 中的每个节点存储了前后节点的引用。\n  哪些集合类提供对元素的随机访问？  ArrayList、HashMap、TreeMap 和 HashTable 类提供对元素的随机访问。\n哪些集合类是线程安全的？  Vector、HashTable、Properties 和 Stack 是同步类，所以它们是线程安全的，可以在多线程环境下使用。Java1.5 并发 API 包括一些集合类，允许迭代时修改，因为它们都工作在集合的克隆上，所以它们在多线程环境中是安全的。点击这里一文搞懂问什么线程不安全。\n并发集合类是什么？  Java1.5 并发包（java.util.concurrent）包含线程安全集合类，允许在迭代时修改集合。迭代器被设计为 fail-fast 的， 会抛出 ConcurrentModificationException 。 一部分类为： CopyOnWriteArrayList、 ConcurrentHashMap、CopyOnWriteArraySet。\n队列和栈是什么，列出它们的区别？  栈和队列两者都被用来预存储数据。java.util.Queue 是一个接口，它的实现类在 Java 并发包中。队列允许先进先出（FIFO）检索元素，但并非总是这样。Deque 接口允许从两端检索元素。栈与队列很相似，但它允许对元素进行后进先出（LIFO）进行检索。Stack 是一个扩展自 Vector 的类，而 Queue 是一个接口。\nCollections 类是什么？  Java.util.Collections 是一个工具类仅包含静态方法，它们操作或返回集合。\n它包含操作集合的多态算法，返回一个由指定集合支持的新集合和其它一些内容。这个类包含集合框架算法的方法，比如折半搜索、排序、混编和逆序等。\nComparable 和 Comparator 接口有何区别？  Comparable 和 Comparator 接口被用来对对象集合或者数组进行排序。Comparable 接口被用来提供对象的自然排序，我们可以使用它来提供基于单个逻辑的排序。\nComparator 接口被用来提供不同的排序算法，我们可以选择需要使用的 Comparator 来对给定的对象集合进行排序。\n我们如何对一组对象进行排序？  如果我们需要对一个对象数组进行排序，我们可以使用 Arrays.sort()方法。如果我们需要排序一个对象列表，我们可以使用 Collection.sort()方法。\n两个类都有用于自然排序（使用 Comparable）或基于标准的排序（使用 Comparator）的重载方法 sort()。Collections 内部使用数组排序方法，所有它们两者都有相同的性能，只是Collections 需要花时间将列表转换为数组。\n当一个集合被作为参数传递给一个函数时，如何才可以确保函数不能修改它？  在作为参数传递之前，我们可以使用 Collections.unmodifiableCollection(Collection c)方法创建一个只读集合，\n这将确保改变集合的任何操作都会抛出 UnsupportedOperationException。更多请关注Java 技术栈微信公众号，回复：面试。\n","pubDate":"2021-02-15","title":"30个Java经典的集合面试题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_36%E9%81%93%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E7%9A%84mybatis%E9%9D%A2%E8%AF%95%E9%A2%98/","plain":"1、什么是MyBatis？\n答：MyBatis 是一个可以自定义 SQL、存储过程和高级映射的持久层框架。2、讲下 MyBatis 的缓存\n答：MyBatis 的缓存分为一级缓存和二级缓存,一级缓存放在 session 里面,默认就有,二级缓存放在它的命名空间里,默认是不打开的,使用二级缓存属性类需要实现Serializable 序列化接口 (可用来保存对象的状态),可在它的映射文件中配置\u0026lt;cache/\u0026gt;\n3、Mybatis 是如何进行分页的？分页插件的原理是什么？ 答：\n Mybatis 使用 RowBounds 对象进行分页，也可以直接编写 sql 实现分页，也可以使用 Mybatis  的分页插件。\n 分页插件的原理：实现 Mybatis 提供的接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写 sql。  举例：select * from student，拦截 sql 后重写为：select t.* from （select * from student）t limit 0，10\n4、简述 Mybatis 的插件运行原理，以及如何编写一个插件？ 答：\n  Mybatis 仅可以编写针对 ParameterHandler、ResultSetHandler、StatementHandler、Executor这 4 种接口的插件，Mybatis 通过动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时， 就会进入拦截方法， 具体就是 InvocationHandler 的 invoke()方法，当然，只会拦截那些你指定需要拦截的方法。\n  实现 Mybatis 的 Interceptor 接口并复写 intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。\n  5、Mybatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？ 答：\n  Mybatis 动态 sql 可以让我们在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接sql 的功能。\n  Mybatis 提供了9 种动态sql 标签：trim|where|set|foreach|if|choose|when|otherwise|bind。\n  其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接\n  sql，以此来完成动态 sql 的功能。\n6、#{}和${}的区别是什么？ 答：\n  #{}是预编译处理，${}是字符串替换。\n  Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的 set 方法来赋值；\n  Mybatis 在处理${}时，就是把${}替换成变量的值。\n  使用#{}可以有效的防止 SQL 注入，提高系统安全性。\n  7、为什么说Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？\n答：Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 Mybatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。\n8、Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？ 答：\n  Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在 Mybatis 配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。\n  它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理。\n  9、MyBatis 与 Hibernate 有哪些不同？ 答：\n  Mybatis 和 hibernate 不同，它不完全是一个 ORM 框架，因为 MyBatis 需要程序员自己编写 Sql 语句，不过 mybatis 可以通过 XML 或注解方式灵活配置要运行的 sql 语句，并将 java 对象和 sql 语句映射生成最终执行的 sql，最后将 sql 执行的结果再映射生成java 对象。\n  Mybatis 学习门槛低，简单易学，程序员直接编写原生态 sql，可严格控制 sql 执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是 mybatis 无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套 sql映射文件，工作量大。\n  Hibernate 对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用 hibernate 开发可以节省很多代码，提高效率。但是 Hibernate 的缺点是学习门槛高，要精通门槛更高，而且怎么设计 O/R 映射，在性能和对象模型之间如何权衡，以及怎样用好 Hibernate 需要具有很强的经验和能力才行。\n  总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。\n10、MyBatis 的好处是什么？ 答：\n  MyBatis 把 sql 语句从 Java 源程序中独立出来，放在单独的 XML 文件中编写，给程序的维护带来了很大便利。\n  MyBatis 封装了底层 JDBC API 的调用细节，并能自动将结果集转换成 Java Bean 对象，大大简化了 Java 数据库编程的重复工作。\n  因为 MyBatis 需要程序员自己去编写 sql 语句，程序员可以结合数据库自身的特点灵活控制 sql 语句，因此能够实现比 Hibernate 等全自动 orm 框架更高的查询效率，能够完成复杂查询。\n  11、简述 Mybatis 的 Xml 映射文件和 Mybatis 内部数据结构之间的映射关系？\n答：Mybatis 将所有 Xml 配置信息都封装到All-In-One 重量级对象 Configuration 内部。在 Xml 映射文件中，\u0026lt;parameterMap\u0026gt;标签会被解析为 ParameterMap 对象，其每个子元素会被解析为 ParameterMapping 对象。\u0026lt;resultMap\u0026gt;标签会被解析为 ResultMap 对象，其每个子元素会被解析为 ResultMapping 对象。每一个\u0026lt;select\u0026gt;、\u0026lt;insert\u0026gt;、\u0026lt;update\u0026gt;、\u0026lt;delete\u0026gt;标签均会被解析为 MappedStatement 对象，标签内的sql 会被解析为 BoundSql 对象。\n12、什么是MyBatis 的接口绑定,有什么好处？\n答：接口映射就是在 MyBatis 中任意定义接口,然后把接口里面的方法和 SQL 语句绑定,我们直接调用接口方法就可以,这样比起原来了 SqlSession 提供的方法我们可以有更加灵活的选择和设置.\n13、接口绑定有几种实现方式,分别是怎么实现的?\n答： 接口绑定有两种实现方式, 一种是通过注解绑定, 就是在接口的方法上面加上@Select@Update 等注解里面包含Sql 语句来绑定,另外一种就是通过xml 里面写SQL 来绑定, 在这种情况下,要指定 xml 映射文件里面的 namespace 必须为接口的全路径名.\n14、什么情况下用注解绑定,什么情况下用 xml 绑定？\n答：当 Sql 语句比较简单时候,用注解绑定；当 SQL 语句比较复杂时候,用 xml 绑定,一般用 xml\n绑定的比较多\n15、MyBatis 实现一对一有几种方式?具体怎么操作的？\n答：有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次,通过在 resultMap 里面配置 association 节点配置一对一的类就可以完成;嵌套查询是先查一个表,根据这个表里面的结果的外键id,去再另外一个表里面查询数据,也是通过association 配置,但另外一个表的查询通过 select 属性配置。\n16、Mybatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？\n答：能，Mybatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把 selectOne()修改为 selectList()即可； 多对多查询，其实就是一对多查询，只需要把 selectOne()修改为 selectList()即可。\n关联对象查询，有两种实现方式，一种是单独发送一个 sql 去查询关联对象，赋给主对象， 然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用 join 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql 查询，就可以把主对象和其关联对象查出来。\n17、MyBatis 里面的动态 Sql 是怎么设定的?用什么语法?\n答：MyBatis 里面的动态 Sql 一般是通过 if 节点来实现,通过 OGNL 语法来实现,但是如果要写的完整,必须配合 where,trim 节点,where 节点是判断包含节点有内容就插入 where,否则不插入,trim 节点是用来判断如果动态语句是以 and 或 or 开始,那么会自动把这个 and 或者 or 取掉。\n18、Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？ 答：\n第一种是使用\u0026lt;resultMap\u0026gt;标签，逐一定义列名和对象属性名之间的映射关系。\n第二种是使用sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，Mybatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，Mybatis 一样可以正常工作。\n有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。\n19、Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？ 答：还有很多其他的标签，\u0026lt;resultMap\u0026gt;、\u0026lt;parameterMap\u0026gt;、\u0026lt;sql\u0026gt;、\u0026lt;include\u0026gt;、\u0026lt;selectKey\u0026gt;， 加上动态 sql 的 9 个标签，trim|where|set|foreach|if|choose|when|otherwise|bind 等，其中\n\u0026lt;sql\u0026gt;为 sql 片段标签，通过\u0026lt;include\u0026gt;标签引入 sql 片段，\u0026lt;selectKey\u0026gt;为不支持自增的主键生成策略标签。\n20、当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定 pojo？ 答：\n  通过在查询的sql 语句中定义字段名的别名。\n  通过\u0026lt;resultMap\u0026gt;来映射字段名和实体类属性名的一一对应的关系。\n  21、模糊查询 like 语句该怎么写答：\n  在 java 中拼接通配符，通过#{}赋值\n  在 Sql 语句中拼接通配符 （不安全 会引起 Sql 注入）\n  22、通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应, Dao 的工作原理，是否可以重载？\n答：不能重载，因为通过 Dao 寻找Xml 对应的 sql 的时候全限名+方法名的保存和寻找策略。接口工作原理为 jdk 动态代理原理，运行时会为 dao 生成 proxy，代理对象会拦截接口方法， 去执行对应的sql 返回数据。\n23、Mybatis 映射文件中，如果A 标签通过 include 引用了B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？\n答：虽然 Mybatis 解析 Xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可以定义在任何地方，Mybatis 都可以正确识别。原理是，Mybatis 解析 A 标签，发现 A 标签引用了 B 标签，但是B 标签尚未解析到，尚不存在，此时，Mybatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。\n24、Mybatis 的Xml 映射文件中，不同的Xml 映射文件，id 是否可以重复？\n答：不同的Xml 映射文件，如果配置了namespace，那么id 可以重复；如果没有配置namespace，那么 id 不能重复；毕竟 namespace 不是必须的，只是最佳实践而已。原因就是 namespace+id 是作为 Map\u0026lt;String, MappedStatement\u0026gt;的 key 使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，\nnamespace+id 自然也就不同。\n25、Mybatis 中如何执行批处理？\n答：使用 BatchExecutor 完成批处理。\n26、Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？\n答：Mybatis 有三种基本的 Executor 执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。1）SimpleExecutor：每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。2）ReuseExecutor：执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map3） BatchExecutor：完成批处理。\n27、Mybatis 中如何指定使用哪一种 Executor 执行器？\n答：在 Mybatis 配置文件中，可以指定默认的 ExecutorType 执行器类型，也可以手动给\nDefaultSqlSessionFactory 的创建 SqlSession 的方法传递 ExecutorType 类型参数。\n28、Mybatis 执行批量插入，能返回数据库主键列表吗？ 答：能，JDBC 都能，Mybatis 当然也能。\n29、Mybatis 是否可以映射 Enum 枚举类？\n答：Mybatis 可以映射枚举类，不单可以映射枚举类，Mybatis 可以映射任何对象到表的一列上。映射方式为自定义一个 TypeHandler，实现 TypeHandler 的 setParameter()和 getResult() 接口方法。TypeHandler 有两个作用，一是完成从 javaType 至 jdbcType 的转换，二是完成jdbcType 至 javaType 的转换，体现为 setParameter()和 getResult()两个方法，分别代表设置 sql 问号占位符参数和获取列查询结果。\n30、如何获取自动生成的(主)键值？\n答：配置文件设置 usegeneratedkeys 为 true 31、在mapper 中如何传递多个参数？\n答：\n  直接在方法中传递参数，xml 文件用#{0} #{1}来获取\n  使用 @param 注解:这样可以直接在 xml 文件中通过#{name}来获取\n  32、resultType resultMap 的区别？ 答：\n  类的名字和数据库相同时，可以直接设置resultType 参数为 Pojo 类\n  若不同，需要设置resultMap 将结果名字和 Pojo 名字进行转换\n  33、使用 MyBatis 的 mapper 接口调用时有哪些要求？ 答：\n  Mapper 接口方法名和mapper.xml 中定义的每个 sql 的 id 相同\n  Mapper 接口方法的输入参数类型和 mapper.xml 中定义的每个sql 的 parameterType 的类型相同\n  Mapper 接口方法的输出参数类型和 mapper.xml 中定义的每个 sql 的 resultType 的类型相同\n  Mapper.xml 文件中的 namespace 即是 mapper 接口的类路径。\n  34、Mybatis 比 IBatis 比较大的几个改进是什么？ 答：\n  有接口绑定,包括注解绑定 sql 和 xml 绑定 Sql\n  动态sql 由原来的节点配置变成OGNL 表达式3）在一对一,一对多的时候引进了association,\n  在一对多的时候引入了 collection 节点,不过都是在 resultMap 里面配置\n35、IBatis 和 MyBatis 在核心处理类分别叫什么？\n答：IBatis 里面的核心处理类交 SqlMapClient,MyBatis 里面的核心处理类叫做SqlSession。\n36、IBatis 和 MyBatis 在细节上的不同有哪些？ 答：\n  在 sql 里面变量命名有原来的#变量# 变成了#{变量}\n  原来的$变量$变成了${变量}\n  原来在sql 节点里面的class 都换名字交 type\n  原来的 queryForObject queryForList 变成了 selectOne selectList5）原来的别名设置在映射文件里面放在了核心配置文件里。\n  更多请关注微信公众号：Java 技术栈，回复：面试\n","pubDate":"2021-02-15","title":"36道面试常问的MyBatis面试题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_40%E9%81%93%E5%B8%B8%E9%97%AE%E7%9A%84java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/","plain":"这些多线程的问题，有些来源于各大网站、有些来源于自己的思考。可能有些问题网上有、可能有些问题对应的答案也有、也可能有些各位网友也都看过， 但是本文写作的重心就是所有的问题都会按照自己的理解回答一遍，不会去看网上的答案，因此可能有些问题讲的不对，能指正的希望大家不吝指教。\n1、多线程有什么用？ 一个可能在很多人看来很扯淡的一个问题：我会用多线程就好了，还管它有什么用？在我看来，这个回答更扯淡。所谓\u0026quot;知其然知其所以然\u0026quot;，\u0026quot;会用\u0026quot;只是\u0026quot; 知其然\u0026quot;，\u0026quot;为什么用\u0026quot;才是\u0026quot;知其所以然\u0026quot;，只有达到\u0026quot;知其然知其所以然\u0026quot;的程度才可以说是把一个知识点运用自如。OK，下面说说我对这个问题的看法： 1）发挥多核 CPU 的优势\n 随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4 核、8 核甚至 16 核的也都不少见，如果是单线程的程序，那么在双核 CPU 上就浪费了 50%，在 4 核 CPU 上就浪费了 75%。单核 CPU 上所谓的\u0026quot;多线程\u0026quot;那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程\u0026quot;同时\u0026quot;运行罢了。多核 CPU 上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核 CPU 的优势来，达到充分利用 CPU 的目的。\n 防止阻塞 从程序运行效率的角度来看，单核 CPU 不但不会发挥出多线程的优势，反而会因为在单核 CPU 上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核 CPU 我们还是要应用多线程，就是为了防止阻塞。试想，如果单核 CPU 使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。\n便于建模 这是另外一个没有这么明显的优点了。假设有一个大的任务 A，单线程编程， 那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务 A 分解成几个小任务，任务 B、任务 C、任务 D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。\n2、创建线程的方式 比较常见的一个问题了，一般就是两种：\n  继承 Thread 类\n  实现 Runnable 接口\n  至于哪个好，不用说肯定是后者好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，面向接口编程也是设计模式 6 大原则的核心。其实还有第 3 种，点击[这里]{.underline}了解更多。\n3、start()方法和 run()方法的区别 只有调用了 start()方法，才会表现出多线程的特性，不同线程的 run()方法里面的代码交替执行。如果只是调用 run()方法，那么代码还是同步执行的， 必须等待一个线程的 run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其 run()方法里面的代码。\n4、Runnable 接口和 Callable 接口的区别 有点深的问题了，也看出一个 Java 程序员学习知识的广度。\nRunnable 接口中的 run()方法的返回值是 void，它做的事情只是纯粹地去执行 run()方法中的代码而已；Callable 接口中的 call()方法是有返回值的，是一个泛型，和 Future、FutureTask 配合可以用来获取异步执行的结果。\n这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能 做 的 只 是 等 待 这 条 多 线 程 的 任 务 执 行 完 毕 而 已 。 而Callable+Future/FutureTask 却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。\n5、CyclicBarrier 和 CountDownLatch 的区别 两个看上去有点像的类，都在 java.util.concurrent 下，都可以用来表示代码运行到某个点上，二者的区别在于：\n1）CyclicBarrier 的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行； CountDownLatch 则不是，某线程运行到某个点上之后，只是给某个数值-1 而已，该线程继续运行。2）CyclicBarrier 只能唤起一个任务，CountDownLatch 可以唤起多个任务。\n3) CyclicBarrier 可重用， CountDownLatch 不可重用， 计数值为 0 该\nCountDownLatch 就不可再用了。\n6、volatile 关键字的作用 一个非常重要的问题，是每个学习、应用多线程的 Java 程序员都必须掌握的。理解 volatile 关键字的作用的前提是要理解 Java 内存模型，这里就不讲 Java 内存模型了，可以参见第 31 点，volatile 关键字的作用主要有两个：\n  多线程主要围绕可见性和原子性两个特性而展开，使用 volatile 关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到 volatile 变量，一定是最新的数据。\n  代码底层执行不像我们看到的高级语言 Java 程序这么简单，它的执行\n  是 Java 代码 --\u0026gt; 字节码 --\u0026gt; 根据字节码执行对应的 C/C++ 代码  --\u0026gt;C/C++代码被编译成汇编语言--\u0026gt;和硬件电路交互，现实中，为了获取\n 更好的性能 JVM 可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用 volatile 则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率。\n从实践角度而言，volatile 的一个重要作用就是和 CAS 结合，保证了原子性， 详 细 的 可 以 参 见 java.util.concurrent.atomic 包 下 的 类 ， 比 如AtomicInteger，更多详情请点击[这里]{.underline}进行学习。\n7、什么是线程安全  又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释地最好的：如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。\n 这个问题有值得一提的地方，就是线程安全也是有几个级别的：\n不可变 像 String、Integer、Long 这些，都是 final 类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用\n绝对线程安全 不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java 中标注自己是线程安全的类，实际上绝大多数都不是线程安全的， 不过绝对线程安全的类， Java 中也有， 比方说CopyOnWriteArrayList、CopyOnWriteArraySet\n相对线程安全 相对线程安全也就是我们通常意义上所说的线程安全，像 Vector 这种，add、remove 方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个 Vector、有个线程同时在 add 这个 Vector，99%的情况下都会出现ConcurrentModificationException，也就是 fail-fast 机制。 4）线程非安全\n这个就没什么好说的了，ArrayList、LinkedList、HashMap 等都是线程非安全的类，点击[这里]{.underline}了解为什么不安全。\n8、Java 中如何获取到线程 dump 文件 死循环、死锁、阻塞、页面打开慢等问题，打线程 dump 是最好的解决问题的途径。所谓线程 dump 也就是线程堆栈，获取到线程堆栈有两步：\n 获取到线程的 pid，可以通过使用 jps 命令，在 Linux 环境下还可以使用  ps -ef | grep java\n 打印线程堆栈，可以通过使用 jstack pid 命令，在 Linux 环境下还可以使用 kill -3 pid  另外提一点，Thread 类提供了一个 getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈。\n9、一个线程如果出现了运行时异常会怎么样  如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是： 如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放\n 10、如何在两个线程之间共享数据 通过在线程之间共享对象就可以了， 然后通过 wait/notify/notifyAll 、await/signal/signalAll 进行唤起和等待，比方说阻塞队列 BlockingQueue 就是为线程之间共享数据而设计的\n11、sleep 方法和 wait 方法有什么区别 这个问题常问，sleep 方法和 wait 方法都可以用来放弃 CPU 一定的时间，不同点在于如果线程持有某个对象的监视器，sleep 方法不会放弃这个对象的监视器，wait 方法会放弃这个对象的监视器\n12、生产者消费者模型的作用是什么 这个问题很理论，但是很重要：\n  通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用\n  解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约\n  13、ThreadLocal 有什么用 简单说 ThreadLocal 就是一种以空间换时间的做法，在每个 Thread 里面维护了一个以开地址法实现的 ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了\n 14、为什么 wait()方法和 notify()/notifyAll()方法要在同步块中被调用这是 JDK 强制的，wait()方法和 notify()/notifyAll()方法在调用前都必须先获得对象的锁\n 15、wait()方法和 notify()/notifyAll()方法在放弃对象监视器时有什么区别  wait()方法和 notify()/notifyAll()方法在放弃对象监视器的时候的区别在于： wait()方法立即释放对象监视器， notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。\n 16、为什么要使用线程池 避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。点击[这里]{.underline}学习线程池详解。\n17、怎么检测一个线程是否持有对象监视器 我也是在网上看到一道多线程面试题才知道有方法可以判断某个线程是否持有对象监视器：Thread 类提供了一个 holdsLock(Object obj)方法，当且仅当对象 obj 的监视器被某条线程持有的时候才会返回 true， 注意这是一个static 方法，这意味着**\u0026quot;某条线程\u0026quot;指的是当前线程**。\n18、synchronized 和 ReentrantLock 的区别 synchronized 是和 if、else、for、while 一样的关键字，ReentrantLock 是类，这是二者的本质区别。既然 ReentrantLock 是类，那么它就提供了比synchronized 更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock 比 synchronized 的扩展性体现在几点上：\n  ReentrantLock 可以对获取锁的等待时间进行设置，这样就避免了死锁\n  ReentrantLock 可以获取各种锁的信息\n  ReentrantLock 可以灵活地实现多路通知\n  另外， 二者的锁机制其实也是不一样的。 ReentrantLock 底层调用的是Unsafe 的park 方法加锁，synchronized 操作的应该是对象头中 mark word，这点我不能确定。\n19、ConcurrentHashMap 的并发度是什么 ConcurrentHashMap 的并发度就是 segment 的大小，默认为 16，这意味着 最 多 同 时 可 以 有 16 条线程 操作 ConcurrentHashMap ，这也是\nConcurrentHashMap 对 Hashtable 的最大优势，任何情况下，Hashtable 能同时有两条线程获取 Hashtable 中的数据吗？\n20、ReadWriteLock 是什么 首先明确一下，不是说 ReentrantLock 不好，只是 ReentrantLock 某些时候有局限。如果使用 ReentrantLock，可能本身是为了防止线程 A 在写数据、线程 B 在读数据造成的数据不一致，但这样，如果线程 C 在读数据、线程 D 也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。\n因为这个，才诞生了读写锁 ReadWriteLock。ReadWriteLock 是一个读写锁接口，ReentrantReadWriteLock 是 ReadWriteLock 接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥， 读和写、写和读、写和写之间才会互斥，提升了读写的性能。\n21、FutureTask 是什么 这个其实前面有提到过，FutureTask 表示一个异步运算的任务。FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于 FutureTask 也是 Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。\n22、Linux 环境下如何查找哪个线程使用 CPU 最长 这是一个比较偏实践的问题，这种问题我觉得挺有意义的。可以这么做：\n  获取项目的 pid，jps 或者 ps -ef | grep java，这个前面有讲过\n  top -H -p pid，顺序不能改变\n  这样就可以打印出当前的项目，每条线程占用 CPU 时间的百分比。注意这里打出的是 LWP， 也就是操作系统原生线程的线程号， 我笔记本山没有部署\nLinux 环境下的 Java 工程，因此没有办法截图演示，网友朋友们如果公司是使用 Linux 环境部署项目的话，可以尝试一下。\n使用\u0026quot;top -H -p pid\u0026quot;+\u0026quot;jps pid\u0026quot;可以很容易地找到某条占用 CPU 高的线程的线程堆栈，从而定位占用 CPU 高的原因，一般是因为不当的代码操作导致了死循环。\n最后提一点，\u0026quot;top -H -p pid\u0026quot;打出来的 LWP 是十进制的，\u0026quot;jps pid\u0026quot;打出来的本地线程号是十六进制的，转换一下，就能定位到占用 CPU 高的线程的当前线程堆栈了。\n23、Java 编程写一个会导致死锁的程序 第一次看到这个题目，觉得这是一个非常好的问题。很多人都知道死锁是怎么一回事儿：线程 A 和线程 B 相互等待对方持有的锁导致程序无限死循环下去。当然也仅限于此了，问一下怎么写一个死锁的程序就不知道了，这种情况说白了就是不懂什么是死锁，懂一个理论就完事儿了，实践中碰到死锁的问题基本上是看不出来的。\n真正理解什么是死锁，这个问题其实不难，几个步骤：\n1）两个线程里面分别持有两个 Object 对象：lock1 和 lock2。这两个 lock\n作为同步代码块的锁；\n2 ） 线 程 1 的 run() 方 法 中 同 步 代 码 块 先 获 取 lock1 的 对 象 锁 ， Thread.sleep(xxx)，时间不需要太多，50 毫秒差不多了，然后接着获取 lock2的对象锁。这么做主要是为了防止线程 1 启动一下子就连续获得了 lock1 和lock2 两个对象的对象锁\n3）线程 2 的 run)(方法中同步代码块先获取 lock2 的对象锁，接着获取 lock1的对象锁，当然这时 lock1 的对象锁已经被线程 1 锁持有，线程 2 肯定是要等待线程 1 释放 lock1 的对象锁的\n这样，线程 1\u0026quot;睡觉\u0026quot;睡完，线程 2 已经获取了 lock2 的对象锁了，线程 1 此时尝试获取 lock2 的对象锁，便被阻塞，此时一个死锁就形成了。代码就不写了，\n占的篇幅有点多，Java 多线程 7：死锁这篇文章里面有，就是上面步骤的代码实现。\n点击[这里]{.underline}提供了一个死锁的案例。\n24、怎么唤醒一个阻塞的线程 如果线程是因为调用了 wait()、sleep()或者 join()方法而导致的阻塞，可以中断线程，并且通过抛出 InterruptedException 来唤醒它；如果线程遇到了IO 阻塞，无能为力，因为 IO 是操作系统实现的，Java 代码并没有办法直接接触到操作系统。\n25、不可变对象对多线程有什么帮助 前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。\n26、什么是多线程的上下文切换 多线程的上下文切换是指 CPU 控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取 CPU 执行权的线程的过程。\n27、如果你提交任务时，线程池队列已满，这时会发生什么 这里区分一下：\n  如果使用的是无界队列 LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为 LinkedBlockingQueue 可以近乎认为是一个无穷大的队列，可以无限存放任务\n  如果使用的是有界队列比如 ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue 中 ， ArrayBlockingQueue 满 了 ， 会 根 据maximumPoolSize 的值增加线程数量，如果增加了线程数量还是处理不过来， ArrayBlockingQueue 继 续 满 ， 那 么 则 会 使 用 拒 绝 策 略RejectedExecutionHandler 处理满了的任务，默认是 AbortPolicy\n  28、Java 中用到的线程调度算法是什么 抢占式。一个线程用完 CPU 之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。\n29、Thread.sleep(0)的作用是什么 这个问题和上面那个问题是相关的，我就连在一起了。由于 Java 采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到 CPU 控制权的情况， 为了让某些优先级比较低的线程也能获取到 CPU 控制权， 可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡 CPU 控制权的一种操作。\n30、什么是自旋 很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然 synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在 synchronized 的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。\n31、什么是 Java 内存模型 Java 内存模型定义了一种多线程访问 Java 内存的规范。Java 内存模型要完整讲不是这里几句话能说清楚的，我简单总结一下 Java 内存模型的几部分内容：\n  Java 内存模型将内存分为了主内存和工作内存。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次 Java 线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去\n  定义了几个原子操作，用于操作主内存和工作内存中的变量3）定义了 volatile 变量的使用规则\n  4）happens-before，即先行发生原则，定义了操作 A 必然先行发生于操作B 的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁 unlock 的动作一定先行发生于后面对于同一个锁进行锁定 lock 的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的 happens-before 规则，则这段代码一定是线程非安全的\n32、什么是 CAS  CAS，全称为 Compare and Swap，即比较-替换。假设有三个操作数：内存值 V、旧的预期值 A、要修改的值 B，当且仅当预期值 A 和内存值 V 相同时，才会将内存值修改为 B 并返回 true，否则什么都不做并返回 false。当然 CAS 一定要 volatile 变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值 A 对某条线程来说，永远是一个不会变的值 A， 只要某次 CAS 操作失败，永远都不可能成功。更多 CAS 详情请点击[这里]{.underline}学习。\n 33、什么是乐观锁和悲观锁   乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。\n  悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像 synchronized，不管三七二十一，直接上了锁就操作资源了。\n  点击[这里]{.underline}了解更多乐观锁与悲观锁详情。\n34、什么是 AQS 简单说一下 AQS，AQS 全称为 AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。\n如果说 java.util.concurrent 的基础是 CAS 的话，那么 AQS 就是整个 Java 并发包的核心了，ReentrantLock、CountDownLatch、Semaphore 等等都用到了它。AQS 实际上以双向队列的形式连接所有的 Entry，比方说ReentrantLock，所有等待的线程都被放在一个 Entry 中并连成双向队列， 前面一个线程使用 ReentrantLock 好了，则双向队列实际上的第一个 Entry 开始运行。\nAQS 定义了对双向队列所有的操作，而只开放了 tryLock 和 tryRelease 方法给开发者使用，开发者可以根据自己的实现重写 tryLock 和 tryRelease 方法，以实现自己的并发功能。\n35、单例模式的线程安全性  老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下： 1）饿汉式单例模式的写法：线程安全\n  懒汉式单例模式的写法：非线程安全\n  双检锁单例模式的写法：线程安全\n  36、Semaphore 有什么作用 Semaphore 就是一个信号量， 它的作用是 限制某段代码块的并发数 。Semaphore 有一个构造函数，可以传入一个 int 型整数 n，表示某段代码最多只有 n 个线程可以访问，如果超出了 n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果 Semaphore 构造函数中传入的 int 型整数 n=1，相当于变成了一个 synchronized 了。\n37、Hashtable 的 size()方法中明明只有一条语句\u0026quot;return count\u0026quot;，为什么还要做同步？ 这是我之前的一个困惑，不知道大家有没有想过这个问题。某个方法中如果有多条语句，并且都在操作同一个类变量，那么在多线程环境下不加锁，势必会引发线程安全问题，这很好理解，但是 size()方法明明只有一条语句，为什么还要加锁？\n关于这个问题，在慢慢地工作、学习中，有了理解，主要原因有两点：\n 同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法， 可以多条线程同时访问。所以，这样就有问题了，可能线程 A 在执行Hashtable 的 put 方法添加数据，线程 B 则可以正常调用 size()方法读取Hashtable 中当前元素的个数，那读取到的值可能不是最新的，可能线程 A 添加了完了数据，但是没有对 size++，线程 B 就已经读取 size 了，那么对于线程B 来说读取到的size 一定是不准确的。而给 size()方法加了同步之后，  意味着线程 B 调用 size()方法只有在线程 A 调用 put 方法完毕之后才可以调用，这样就保证了线程安全性\n CPU 执行代码，执行的不是 Java 代码，这点很关键，一定得记住。Java 代码最终是被翻译成机器码执行的，机器码才是真正可以和硬件电路交互的代码。即使你看到 Java 代码只有一行，甚至你看到 Java 代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个。一句\u0026quot;return count\u0026quot;假设被翻译成了三句汇编语句执行，一句汇编语句和其机器码做对应，完全可能执行完第一句，线程就切换了。  38、线程类的构造方法、静态块是被哪个线程调用的 这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new 这个线程类所在的线程所调用的，而 run 方法里面的代码才是被线程自身所调用的。\n如果说上面的说法让你感到困惑，那么我举个例子，假设 Thread2 中 new 了\nThread1，main 函数中 new 了 Thread2，那么：\n Thread2 的构造方法、静态块是 main 线程调用的，Thread2 的 run()  方法是 Thread2 自己调用的\n Thread1 的构造方法、静态块是 Thread2 调用的，Thread1 的 run()方法是 Thread1 自己调用的  39、同步方法和同步块，哪个是更好的选择 同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。\n借着这一条，我额外提一点，虽说同步的范围越少越好，但是在 Java 虚拟机中还是存在着一种叫做锁粗化的优化方法，这种方法就是把同步范围变大。这是有用的， 比方说 StringBuffer， 它是一个线程安全的类， 自然最常用的append()方法是一个同步方法，我们写代码的时候会反复 append 字符串，\n这意味着要进行反复的加锁-\u0026gt;解锁，这对性能不利，因为这意味着 Java 虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此 Java 虚拟机会将多次 append 方法调用的代码进行一个锁粗化的操作，将多次的 append 的操作扩展到 append 方法的头尾，变成一个大的同步块，这样就减少了加锁\n--\u0026gt;解锁的次数，有效地提升了代码执行的效率。\n40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？ 这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是：\n  高并发、任务执行时间短的业务，线程池线程数可以设置为 CPU 核数+1，减少线程上下文的切换\n  并发不高、任务执行时间长的业务要区分开看：\n  a）假如是业务时间长集中在 IO 操作上，也就是 IO 密集型的任务，因为 IO 操作并不占用 CPU，所以不要让所有的 CPU 闲下来，可以加大线程池中的线程数目，让 CPU 处理更多的业务b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换\nc）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考其他有关线程池的文章。最后， 业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。\n{width=\u0026ldquo;5.768055555555556in\u0026rdquo; height=\u0026ldquo;4.1666666666666664e-2in\u0026rdquo;}\n 更多请关注微信公众号：Java 技术栈，回复：资料\n {width=\u0026ldquo;2.3099989063867015in\u0026rdquo; height=\u0026ldquo;2.3409372265966755in\u0026rdquo;}\n","pubDate":"2021-02-15","title":"40道常问的Java多线程面试题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_55%E9%81%93bat%E7%B2%BE%E9%80%89%E7%9A%84mysql%E9%9D%A2%E8%AF%95%E9%A2%98/","plain":" {width=\u0026ldquo;6.857017716535433in\u0026rdquo; height=\u0026ldquo;1.6727821522309712in\u0026rdquo;}1、一张表，里面有 ID 自增主键，当 insert 了 17 条记录之后，删除了第 15,16,17 条记录， 再把 Mysql 重启，再 insert 一条记录，这条记录的 ID 是 18 还是 15 ？\n2、Mysql 的技术特点是什么？\n Mysql 数据库软件是一个客户端或服务器系统，其中包括：支持各种客户端程序和库的多线程 SQL 服务器、不同的后端、广泛的应用程序编程接口和管理工具。\n 3、Heap 表是什么？\n HEAP 表存在于内存中，用于临时高速存储。\n  BLOB 或 TEXT 字段是不允许的\n  只能使用比较运算符=，\u0026lt;，\u0026gt;，=\u0026gt;，= \u0026lt;\n  HEAP 表不支持 AUTO_INCREMENT\n  索引不可为 NULL\n   4、Mysql 服务器默认端口是什么？ Mysql 服务器的默认端口是 3306。\n5、与 Oracle 相比，Mysql 有什么优势？\n   Mysql 是开源软件，随时可用，无需付费。\n  Mysql 是便携式的\n  带有命令提示符的 GUI。\n  使用 Mysql 查询浏览器支持管理\n   6、如何区分 FLOAT 和 DOUBLE？\n 以下是 FLOAT 和 DOUBLE 的区别：\n  浮点数以 8 位精度存储在 FLOAT 中，并且有四个字节。\n  浮点数存储在 DOUBLE 中，精度为 18 位，有八个字节。7、区分 CHAR_LENGTH 和 LENGTH？\n  CHAR_LENGTH 是字符数，而 LENGTH 是字节数。Latin 字符的这两个数据是相同的，但是对于 Unicode 和其他编码，它们是不同的。\n 8、请简洁描述 Mysql 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？\n SQL 标准定义的四个隔离级别为：\n  read uncommited ：读到未提交数据\n  read committed：脏读，不可重复读\n  repeatable read：可重读\n  serializable ：串行事物\n  {width=\u0026ldquo;6.58367125984252in\u0026rdquo; height=\u0026ldquo;2.4166666666666665in\u0026rdquo;}\n{width=\u0026ldquo;6.520924103237095in\u0026rdquo; height=\u0026ldquo;2.4028116797900263in\u0026rdquo;}\n 9、在 Mysql 中 ENUM 的用法是什么？\n ENUM 是一个字符串对象，用于指定一组预定义的值，并可在创建表时使用。Create table size(name ENUM('Smail,'Medium','Large');\n 10、如何定义 REGEXP？\n REGEXP 是模式匹配，其中匹配模式在搜索值的任何位置。11、CHAR 和 VARCHAR 的区别？\n以下是 CHAR 和 VARCHAR 的区别：\n  CHAR 和 VARCHAR 类型在存储和检索方面有所不同\n  CHAR 列长度固定为创建表时声明的长度，长度值范围是 1 到 255\n  当 CHAR 值被存储时，它们被用空格填充到特定长度，检索 CHAR 值时需删除尾随空格。\n 12、列的字符串类型可以是什么？\n 字符串类型是：\n  SET\n  BLOB\n  ENUM\n  CHAR\n  TEXT\n  VARCHAR\n   13、如何获取当前的 Mysql 版本？\n SELECT VERSION();用于获取当前 Mysql 的版本。14、Mysql 中使用什么存储引擎？\n存储引擎称为表类型，数据使用各种技术存储在文件中。 技术涉及：\n  Storage mechanism\n  Locking levels\n  Indexing\n  Capabilities and functions.\n   15、Mysql 驱动程序是什么？\n 以下是 Mysql 中可用的驱动程序：\n  PHP 驱动程序\n  JDBC 驱动程序\n  ODBC 驱动程序\n  CWRAPPER\n  PYTHON 驱动程序\n  PERL 驱动程序\n  RUBY 驱动程序\n  CAP11PHP 驱动程序\n  Ado.net5.mxj\n   16、TIMESTAMP 在 UPDATE CURRENT_TIMESTAMP 数据类型上做什么？\n 创建表时 TIMESTAMP 列用 Zero 更新。只要表中的其他字段发生更改，UPDATE CURRENT_TIMESTAMP 修饰符就将时间戳字段更新为当前时间。\n 17、主键和候选键有什么区别？\n 表格的每一行都由主键唯一标识,一个表只有一个主键。\n主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引 用。\n 18、如何使用 Unix shell 登录 Mysql？\n 我们可以通过以下命令登录：\n# [mysql dir]/bin/mysql -h hostname -u \u0026lt;UserName\u0026gt; -p \u0026lt;password\u0026gt; 19、 myisamchk 是用来做什么的？\n 它用来压缩 MyISAM 表，这减少了磁盘或内存使用。20、MYSQL 数据库服务器性能分析的方法命令有哪些?\n {width=\u0026ldquo;3.257571084864392in\u0026rdquo; height=\u0026ldquo;3.6770833333333335in\u0026rdquo;}\n 21、如何控制 HEAP 表的最大尺寸？\n Heal 表的大小可通过称为 max_heap_table_size 的 Mysql 配置变量来控制。22、MyISAM Static 和 MyISAM Dynamic 有什么区别？\n在 MyISAM Static 上的所有字段有固定宽度。动态 MyISAM 表将具有像 TEXT，BLOB 等字段，以适应不同长度的数据类型。\nMyISAM Static 在受损情况下更容易恢复。23、federated 表是什么？\nfederated 表，允许访问位于其他服务器数据库上的表。24、如果一个表有一列定义为 TIMESTAMP，将发生什么？ 每当行被更改时，时间戳字段将获取当前时间戳。\n 25、列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？ 它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。\n 26、怎样才能找出最后一次插入时分配了哪个自动增量？ LAST_INSERT_ID 将返回由 Auto_increment 分配的最后一个值，并且不需要指定表名称。\n 27、你怎么看到为表格定义的所有索引？ 索引是通过以下方式为表格定义的： SHOW INDEX FROM \u0026lt;tablename\u0026gt;;\n28.、LIKE 声明中的％和_是什么意思？\n％对应于 0 个或更多字符，_只是 LIKE 语句中的一个字符。29、如何在 Unix 和 Mysql 时间戳之间进行转换？\n   UNIX_TIMESTAMP 是从 Mysql 时间戳转换为 Unix 时间戳的命令\n  FROM_UNIXTIME 是从 Unix 时间戳转换为 Mysql 时间戳的命令\n   30、列对比运算符是什么？\n 在 SELECT 语句的列比较中使用=，\u0026lt;\u0026gt;，\u0026lt;=，\u0026lt;，\u0026gt; =，\u0026gt;，\u0026lt;\u0026lt;，\u0026gt;\u0026gt;，\u0026lt;=\u0026gt;，AND，OR\n或 LIKE 运算符。\n 31、我们如何得到受查询影响的行数？\n 行数可以通过以下代码获得： SELECT COUNT(user_id)FROM users;\n 32、Mysql 查询是否区分大小写？ 不区分\n SELECT VERSION(), CURRENT_DATE;\nSeLect version(), current_date; seleCt vErSiOn(), current_DATE;\n所有这些例子都是一样的，Mysql 不区分大小写。33.、LIKE 和 REGEXP 操作有什么区别？\nLIKE 和 REGEXP 运算符用于表示^和％。\n+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 1 | SELECT * FROM employee WHERE | | | emp_name REGEXP \u0026quot;^b\u0026quot;; SELECT | | 2 | * FROM employee WHERE emp_name | | | LIKE \u0026quot;%b\u0026quot;; | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\n 34.、BLOB 和 TEXT 有什么区别？\n BLOB 是一个二进制对象，可以容纳可变数量的数据。有四种类型的 BLOB -\n  TINYBLOB\n  BLOB\n  MEDIUMBLOB 和\n  LONGBLOB\n  它们只能在所能容纳价值的最大长度上有所不同。TEXT 是一个不区分大小写的 BLOB。四种 TEXT 类型\n  TINYTEXT\n  TEXT\n  MEDIUMTEXT 和\n  LONGTEXT\n  它们对应于四种 BLOB 类型，并具有相同的最大长度和存储要求。\nBLOB 和 TEXT 类型之间的唯一区别在于对 BLOB 值进行排序和比较时区分大小写，对\nTEXT 值不区分大小写。\n35、mysql_fetch_array 和 mysql_fetch_object 的区别是什么？ 以下是 mysql_fetch_array 和 mysql_fetch_object 的区别：\nmysql_fetch_array（） - 将结果行作为关联数组或来自数据库的常规数组返回。mysql_fetch_object - 从数据库返回结果行作为对象。\n 36、我们如何在 mysql 中运行批处理模式？ 以下命令用于在批处理模式下运行： mysql;\n mysql mysql.out\n 37、MyISAM 表格将在哪里存储，并且还提供其存储格式？ 每个 MyISAM 表格以三种格式存储在磁盘上：\n ·\u0026quot;.frm\u0026quot;文件存储表定义\n·数据文件具有\u0026quot;.MYD\u0026quot;（MYData）扩展名索引文件具有\u0026quot;.MYI\u0026quot;（MYIndex）扩展名38.、Mysql 中有哪些不同的表格？\n共有 5 种类型的表格：\n  MyISAM\n  Heap\n  Merge\n  INNODB\n  ISAM\n  MyISAM 是 Mysql 的默认存储引擎。39、ISAM 是什么？\nISAM 简称为索引顺序访问方法。它是由 IBM 开发的，用于在磁带等辅助存储系统上存储和检索数据。\n 40、InnoDB 是什么？\n lnnoDB 是一个由 Oracle 公司开发的 Innobase Oy 事务安全存储引擎。41、Mysql 如何优化 DISTINCT？\nDISTINCT 在所有列上转换为 GROUP BY，并与 ORDER BY 子句结合使用。\n 1 SELECT DISTINCT t1.a FROM t1,t2 where t1.a=t2.a;\n  42、如何输入字符为十六进制数字？\n 如果想输入字符为十六进制数字，可以输入带有单引号的十六进制数字和前缀（X）， 或者只用（Ox）前缀输入十六进制数字。\n如果表达式上下文是字符串，则十六进制数字串将自动转换为字符串。\n 43、如何显示前 50 行？\n 在 Mysql 中，使用以下代码查询显示前 50 行： SELECT*FROM\nLIMIT 0,50;\n 44、可以使用多少列创建索引？\n 任何标准表最多可以创建 16 个索引列。\n 45、NOW（）和 CURRENT_DATE（）有什么区别？\n NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。CURRENT_DATE（）仅显示当前年份，月份和日期。\n 46、什么样的对象可以使用 CREATE 语句创建？ 以下对象是使用 CREATE 语句创建的：\n   DATABASE\n  EVENT\n  FUNCTION\n  INDEX\n  PROCEDURE\n  TABLE\n  TRIGGER\n  USER\n  VIEW\n   47.、Mysql 表中允许有多少个 TRIGGERS？\n 在 Mysql 表中允许有六个触发器，如下：\n  BEFORE INSERT\n  AFTER INSERT\n  BEFORE UPDATE\n  AFTER UPDATE\n  BEFORE DELETE and\n  AFTER DELETE\n   48、什么是非标准字符串类型？\n 以下是非标准字符串类型：\n  TINYTEXT\n  TEXT\n  MEDIUMTEXT\n  LONGTEXT\n   49、什么是通用 SQL 函数？\n   CONCAT(A, B) - 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个字段。\n  FORMAT(X, D)- 格式化数字 X 到 D 有效数字。\n  CURRDATE(), CURRTIME()- 返回当前日期或时间。\n  NOW（） - 将当前日期和时间作为一个值返回。\n  MONTH（），DAY（），YEAR（），WEEK（），WEEKDAY（） - 从日期值中提取给定数据。\n  HOUR（），MINUTE（），SECOND（） - 从时间值中提取给定数据。\n  DATEDIFF（A，B） - 确定两个日期之间的差异，通常用于计算年龄\n  SUBTIMES（A，B） - 确定两次之间的差异。\n  FROMDAYS（INT） - 将整数天数转换为日期值。50、解释访问控制列表\n  ACL（访问控制列表）是与对象关联的权限列表。这个列表是 Mysql 服务器安全模型的基础，它有助于排除用户无法连接的问题。\nMysql 将 ACL（也称为授权表）缓存在内存中。当用户尝试认证或运行命令时，Mysql\n会按照预定的顺序检查 ACL 的认证信息和权限。51、MYSQL 支持事务吗？\n在缺省模式下，MYSQL 是 autocommit 模式的，所有的数据库更新操作都会即时提交， 所以在缺省情况下，mysql 是不支持事务的。\n但是如果你的 MYSQL 表类型是使用 InnoDB Tables 或 BDB tables 的话，你的 MYSQL 就可以使用事务处理,使用 SET AUTOCOMMIT=0 就可以使 MYSQL 允许在非 autocommit 模式，在非 autocommit 模式下，你必须使用 COMMIT 来提交你的更改，或者用ROLLBACK 来回滚你的更改。\n 示例如下： 一\n START TRANSACTION;\nSELECT @A:=SUM(salary) FROM table1 WHERE type=1; UPDATE table2 SET summmary=@A WHERE type=1; COMMIT;\n 52、 mysql 里记录货币用什么字段类型好\n NUMERIC 和 DECIMAL 类型被 Mysql 实现为同样的类型，这在 SQL92 标准允许。他们被用于保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据。当声明一个 类是这些类型之一时，精度和规模的能被(并且通常是)指定；\n例如：\nsalary DECIMAL(9,2)\n在这个例子中，9(precision)代表将被用于存储值的总的小数位数，而 2(scale)代表将被用于存储小数点后的位数。\n因此，在这种情况下，能被存储在 salary 列中的值的范围是从-9999999.99 到\n9999999.99。在 ANSI/ISO SQL92 中，句法 DECIMAL(p)等价于 DECIMAL(p,0)。\n同样，句法 DECIMAL 等价于 DECIMAL(p,0)，这里实现被允许决定值 p。Mysql 当前不支持 DECIMAL/NUMERIC 数据类型的这些变种形式的任一种。\n这一般说来不是一个严重的问题，因为这些类型的主要益处得自于明显地控制精度和 规模的能力。\nDECIMAL 和 NUMERIC 值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小数精度。\n一个字符用于值的每一位、小数点(如果 scale\u0026gt;0)和\u0026quot;-\u0026ldquo;符号(对于负值)。如果 scale 是 0， DECIMAL 和 NUMERIC 值不包含小数点或小数部分。\nDECIMAL 和 NUMERIC 值得最大的范围与 DOUBLE 一样，但是对于一个给定的 DECIMAL\n或 NUMERIC 列，实际的范围可由制由给定列的 precision 或 scale 限制。\n当这样的列赋给了小数点后面的位超过指定 scale 所允许的位的值，该值根据 scale 四舍五入。\n当一个 DECIMAL 或 NUMERIC 列被赋给了其大小超过指定(或缺省的）precision 和 scale\n隐含的范围的值，Mysql 存储表示那个范围的相应的端点值。\n我希望本文可以帮助你提升技术水平。那些，感觉学的好难，甚至会令你沮丧的人， 别担心，我认为，如果你愿意试一试本文介绍的几点，会向前迈进，克服这种感觉。 这些要点也许对你不适用，但你会明确一个重要的道理：接受自己觉得受困这个事实 是摆脱这个困境的第一步。\n 53、MYSQL 数据表在什么情况下容易损坏？ 服务器突然断电导致数据文件损坏。\n 强制关机，没有先关闭 mysql 服务等。\n54、mysql 有关权限的表都有哪几个？ Mysql 服务器通过权限表来控制用户对数据库的访问，权限表存放在 mysql 数据库里， 由 mysql_install_db 脚本初始化。这些权限表分别 user，db，table_priv，columns_priv 和host。\n55、Mysql 中有哪几种锁？   MyISAM 支持表锁，InnoDB 支持表锁和行锁，默认为行锁\n  表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并 发量最低\n  行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最 高\n  ","pubDate":"2021-02-15","title":"55道BAT精选的Mysql面试题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_60%E9%81%93%E5%BF%85%E5%A4%87%E7%9A%84java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98/","plain":"1、作用域 public,private,protected,以及不写时的区别 +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | **答：**区别如下： | | +====================+==========+================+==========+================+ | 作用域 | \u0026gt; 当前类 | \u0026gt; 同一 package | \u0026gt; 子孙类 | \u0026gt; 其他 package | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | public | \u0026gt; √ | \u0026gt; √ | \u0026gt; √ | \u0026gt; √ | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | protected | \u0026gt; √ | \u0026gt; √ | \u0026gt; √ | \u0026gt; × | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | friendly | \u0026gt; √ | \u0026gt; √ | \u0026gt; × | \u0026gt; × | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | private | \u0026gt; √ | \u0026gt; × | × | \u0026gt; × | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\n不写时默认为 friendly\n2、Anonymous Inner Class (匿名内部类) 是否可以 extends(继承)其它类，是否可以 implements(实现)interface(接口) **答：**匿名的内部类是没有名字的内部类。不能 extends(继承) 其它类，但一个内部类可以作为一个接口，由另一个内部类实现\n3、Static Nested Class 和 Inner Class 的不同 **答：**Nested Class （一般是 C++的说法），Inner Class (一般是 JAVA 的说法)。Java 内部类与C++嵌套类最大的不同就在于是否有指向外部的引用上。注： 静态内部类（Inner Class）意味着 1 创建一个 static 内部类的对象，不需要一个外部类对象，2 不能从一个 static 内部类的一个对象访问一个外部类对象\n4、\u0026amp;和\u0026amp;\u0026amp;的区别 答：\u0026amp;是位运算符，表示按位与运算，\u0026amp;\u0026amp;是逻辑运算符，表示逻辑与（and）\n5、Collection 和 Collections 的区别 **答：**Collection 是集合类的上级接口，继承与他的接口主要有 Set 和 List.\nCollections 是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作\n6、什么时候用 assert **答：**assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。 在实现中，assertion 就是在程序中的一条语句，它对一个 boolean 表达式进行检查，一个正确程序必须保证这个 boolean 表达式的值为 true；如果该值为 false，说明程序已经处于不正确的状态下，系统将给出警告或退出。一般来说，assertion 用于保证程序最基本、关键的正确性。assertion 检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion 检查通常是关闭的\n7、String s = new String(\u0026quot;xyz\u0026quot;);创建了几个 String Object **答：**两个，一个字符对象，一个字符对象引用对象\n8、Math.round(11.5)等於多少? Math.round(-11.5)等於多少 答: Math.round(11.5)==12;Math.round(-11.5)==-11;round 方法返回与参数最接近的长整数，参数加 1/2 后求其 floor\n **9、short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错 答：**short s1 = 1; s1 = s1 + 1; （s1+1 运算结果是 int 型，需要强制转换类型）short s 1 = 1; s1 += 1;（可以正确编译）\n 10、Java 有没有 goto **答：**java 中的保留字，现在没有在 java 中使用\n11、数组有没有 length()这个方法? String 有没有 length()这个方法 **答：**数组没有 length()这个方法，有 length 的属性。String 有有 length()这个方法\n **12、Overload 和 Override 的区别。Overloaded 的方法是否可以改变返回值的类型答：**方法的重写 Overriding 和重载 Overloading 是Java 多态性的不同表现。重写 Overriding\n 是父类与子类之间多态性的一种表现，重载 Overloading 是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被\u0026quot;屏蔽\u0026quot;了。如果在 一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的\n重载(Overloading)。Overloaded 的方法是可以改变返回值的类型\n13、Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是 equals ()? 它们有何区别 **答：**Set 里的元素是不能重复的，那么用 iterator()方法来区分重复与否。equals()是判读两个Set 是否相等\nequals()和==方法决定引用值是否指向同一对象 equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值\n 14、给我一个你最常见到的 runtime exception\n **答：**常见的运行时异常有如下这些 ArithmeticException, ArrayStoreException, BufferOve rflowException, BufferUnderflowException, CannotRedoException, CannotUndoExcepti on, ClassCastException, CMMException, ConcurrentModificationException, DOMExcep tion, EmptyStackException, IllegalArgumentException, IllegalMonitorStateExceptio n, IllegalPathStateException, IllegalStateException, ImagingOpException, IndexO utOfBoundsException, MissingResourceException, NegativeArraySizeException, NoSuc hElementException, NullPointerException, ProfileDataException, ProviderExceptio n, RasterFormatException, SecurityException, SystemException, UndeclaredThrowab leException, UnmodifiableSetException, UnsupportedOperationException\n15、error 和 exception 有什么区别 **答：**error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况\nexception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况\n 16、List, Set, Map 是否继承自 Collection 接口答： List，Set 是，Map 不是\n 17、abstract class 和 interface 有什么区别 **答：**声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建 abstra ct 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法\n接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义 static f inal 成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的 类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常 的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口\n18、abstract 的 method 是否可同时是 static,是否可同时是 native，是否可同时是 syn chronized  **答：**都不能\n 19、接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concrete class) **答：**接口可以继承接口。抽象类可以实现(implements)接口，抽象类是否可继承实体类，但前 提是实体类必须有明确的构造函数\n20、构造器 Constructor 是否可被 override **答：**构造器 Constructor 不能被继承，因此不能重写 Overriding，但可以被重载 Overloadin g\n21、是否可以继承 String 类 **答：**String 类是 final 类故不可以继承\n22、try {}里有一个 return 语句，那么紧跟在这个 try 后的 finally {}里的 code 会不会被执行，什么时候被执行，在 return 前还是后 **答：**会执行，在 return 前执行\n23、用最有效率的方法算出 2 乘以 8 等於几  **答：**2 \u0026lt;\u0026lt; 3\n 24、两个对象值相同(x.equals(y) == true)，但却可有不同的 hash code，这句话对不对 **答：**不对，有相同的 hash code\n25、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化 后的结果，那么这里到底是值传递还是引用传递 **答：**是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永 远不会改变的\n26、swtich 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上 **答：**witch（expr1）中，expr1 是一个整数表达式。因此传递给 switch 和 case 语句的参数应该是 int、 short、 char 或者 byte。long,string 都不能作用于 swtich\n **27、ArrayList 和 Vector 的区别,HashMap 和 Hashtable 的区别答：**就 ArrayList 与 Vector 主要从二方面来说.\n 一.同步性:Vector 是线程安全的，也就是说是同步的，而 ArrayList 是线程序不安全的，不是同步的\n二.数据增长:当需要增长时,Vector 默认增长为原来一培，而 ArrayList 却是原来的一半就 HashMap 与 HashTable 主要从三方面来说。\n一.历史原因:Hashtable 是基于陈旧的 Dictionary 类的，HashMap 是 Java 1.2 引进的 Map\n接口的一个实现\n二.同步性:Hashtable 是线程安全的，也就是说是同步的，而 HashMap 是线程序不安全的，\n不是同步的\n三.值：只有 HashMap 可以让你将空值作为一个表的条目的 key 或 value\n28、char 型变量中能不能存贮一个中文汉字?为什么? **答：**是能够定义成为一个中文的，因为 java 中以 unicode 编码，一个 char 占 16 个字节，所以放一个中文是没问题的\n29、GC 是什么? 为什么要有 GC **答：**GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方， 忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。\n30、float 型 float f=3.4 是否正确? **答:**不正确。精度不准确,应该用强制类型转换，如下所示：float f=(float)3.4\n31、介绍 JAVA 中的 Collection FrameWork(包括如何写自己的数据结构)? **答：**Collection FrameWork 如下：\nCollection\n├List\n│├LinkedList\n│├ArrayList\n│└Vector\n│ └Stack\n└Set Map\n├Hashtable\n├HashMap\n└WeakHashMap\nCollection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素（E lements）\nMap 提供 key 到 value 的映射\n32、抽象类与接口？ **答：**抽象类与接口都用于抽象，但是抽象类(JAVA 中)可以有自己的部分实现，而接口则完全是一个标识(同时有多重继承的功能)。\nJAVA 类实现序例化的方法是实现 java.io.Serializable 接口\nCollection 框架中实现比较要实现 Comparable 接口和 Comparator 接口\n33、STRING 与 STRINGBUFFER 的区别。 **答：**STRING 的长度是不可变的，STRINGBUFFER 的长度是可变的。如果你对字符串中的内容经常进行操作，特别是内容要修改时，那么使用 StringBuffer，如果最后需要 String，那么使用 StringBuffer 的 toString()方法\n 34、谈谈 final, finally, finalize 的区别\n **答：**final\u0026mdash;修饰符（关键字）如果一个类被声明为 final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract 的，又被声明为 final 的。将变量或方法声明为 final，可以保证它们在使用中不被改变。被声明为 final 的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为 final 的方法也同样只能使用，不能重载finally\u0026mdash;再异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）\nfinalize\u0026mdash;方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用 的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的\n **35、面向对象的特征有哪些方面答：**主要有以下四方面：\n  抽象：  抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个 方面，一是过程抽象，二是数据抽象。\n 继承：  继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。 对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。\n 封装：  封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基 本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接 口访问其他对象。\n 多态性：  多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多\n态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。\n36、String 是最基本的数据类型吗 **答：**基本数据类型包括 byte、int、char、long、float、double、boolean 和 short。java.lang.String 类是 final 类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用 StringBuffer 类\n37、int 和 Integer 有什么区别 **答：**Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int 是 java 的原始数据类型，Integer 是 java 为 int 提供的封装类。Java 为每个原始类型提供了封装类。\n原始类型封装类,booleanBoolean,charCharacter,byteByte,shortShort,intInteger,longLong, floatFloat,doubleDouble\n引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同 的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型 和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关\n38、运行时异常与一般异常有何异同 **答：**异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能 遇到的异常，是一种常见运行错误。java 编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。\n39、说出 ArrayList,Vector, LinkedList 的存储性能和特性 **答：**ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操 作，所以索引数据快而插入数据慢，Vector 由于使用了 synchronized 方法（线程安全），通常性能上较 ArrayList 差，而 LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。\n40、HashMap 和 Hashtable 的区别 **答：**HashMap 是 Hashtable 的轻量级实现（非线程安全的实现），他们都完成了 Map 接口，主要区别在于 HashMap 允许空（null）键值（key）,由于非线程安全，效率上可能高于 Hashtable。HashMap 允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。\nHashMap 把Hashtable 的contains 方法去掉了，改成 containsvalue 和 containsKey。因为 con tains 方法容易让人引起误解。\nHashtable 继承自 Dictionary 类，而 HashMap 是Java1.2 引进的 Map interface 的一个实现。最大的不同是，Hashtable 的方法是 Synchronize 的，而 HashMap 不是，在多个线程访问 Hasht able 时，不需要自己为它的方法实现同步，而 HashMap 就必须为之提供外同步。Hashtable 和 HashMap 采用的 hash/rehash 算法都大概一样，所以性能不会有很大的差异。\n41、heap 和 stack 有什么区别 **答：**栈是一种线形集合，其添加和删除元素的操作应在同一段完成。栈按照后进先出的方式进行 处理。堆是栈的一个组成元素\n42、Java 的接口和 C++的虚类的相同和不同处 **答：**由于 Java 不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或属性，现有的单继承机制就不能满足要求。与继承相比，接口有更高的灵活性，因为接口中没有 任何实现代码。当一个类实现了接口以后，该类要实现接口里面所有的方法和属性，并且接口里 面的属性在默认状态下面都是 public static,所有方法默认情况下是 public.一个类可以实现多个接口。\n43、Java 中的异常处理机制的简单原理和应用 **答：**当 JAVA 程序违反了 JAVA 的语义规则时，JAVA 虚拟机就会将发生的错误表示为一个异常。违反语义规则包括 2 种情况。一种是 JAVA 类库内置的语义检查。例如数组下标越界,会引发 Ind exOutOfBoundsException;访问 null 的对象时会引发 NullPointerException。另一种情况就是 J AVA 允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用 throw 关键字引发异常。所有的异常都是 java.lang.Thowable 的子类。\n43、垃圾回收的优点和原理。并考虑 2 种回收机制 **答：**Java 语言中一个显著的特点就是引入了垃圾回收机制，使 c++程序员最头疼的内存管理的问题迎刃而解，它使得 Java 程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java 中的对象不再有\u0026quot;作用域\u0026quot;的概念，只有对象的引用才有\u0026quot;作用域\u0026quot;。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收， 程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。\n44、你所知道的集合类都有哪些？主要方法？ **答：**最常用的集合类是 List 和 Map。 List 的具体实现包括 ArrayList 和 Vector， 它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。 List 适用于按数值索引访问元素的情形。\nMap 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作\u0026quot;键\u0026quot;和\u0026quot;值\u0026quot;）， 其中每个键映射到一个值。\n45、描述一下 JVM 加载 class 文件的原理机制? **答：**JVM 中类的装载是由 ClassLoader 和它的子类来实现的,Java ClassLoader 是一个重要的Java 运行时系统组件。它负责在运行时查找和装入类文件的类。\n46、排序都有哪几种方法？请列举 答： 排序的方法有：插入排序（直接插入排序、希尔排序），交换排序（冒泡排序、快速排序）， 选择排序（直接选择排序、堆排序），归并排序，分配排序（箱排序、基数排序）\n快速排序的伪代码。\n/ /使用快速排序方法对 a[ 0 :n- 1 ]排序\n从 a[ 0 :n- 1 ]中选择一个元素作为 m i d d l e，该元素为支点\n把余下的元素分割为两段 left 和 r i g h t，使得 l e f t 中的元素都小于等于支点，而 right 中的元素都大于等于支点\n递归地使用快速排序方法对 left 进行排序递归地使用快速排序方法对 right 进行排序\n所得结果为 l e f t + m i d d l e + r i g h t\n47、JAVA 语言如何进行异常处理，关键字：throws,throw,try,catch,finally 分别代表什么意义？在 try 块中可以抛出异常吗？ **答：**Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在 Java 中，每个异常都是一个对象，它是 Throwable 类或其它子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、catch、throw、throws 和 finally。一般情况下是用 try 来执行一段程序，如果出现异常，系统会抛出（throws）一个 异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。用 try 来指定一块预防所有\u0026quot;异常\u0026quot;的程序。紧跟在 try 程序后面，应包含一个 catch 子句来指定你想要捕捉的\u0026quot;异常\u0026quot;的类型。\nthrow 语句用来明确地抛出一个\u0026quot;异常\u0026quot;。\nthrows 用来标明一个成员函数可能抛出的各种\u0026quot;异常\u0026quot;。\nFinally 为确保一段代码不管发生什么\u0026quot;异常\u0026quot;都被执行一段代码。\n可以在一个成员函数调用的外面写一个 try 语句，在这个成员函数内部写另一个 try 语句保护其他代码。每当遇到一个 try 语句，\u0026quot;异常\u0026quot;的框架就放到堆栈上面，直到所有的 try 语句都完成。如果下一级的 try 语句没有对某种\u0026quot;异常\u0026quot;进行处理，堆栈就会展开，直到遇到有处理这种\u0026quot;异常\u0026quot; 的 try 语句。\n **48、一个\u0026quot;.java\u0026quot;源文件中是否可以包括多个类（不是内部类）？有什么限制？ 答：**可以。必须只有一个类名与文件名相同。\n 49、java 中有几种类型的流？JDK 为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？ **答：**字节流，字符流。字节流继承于 InputStream OutputStream，字符流继承于 InputStream Reader OutputStreamWriter。在 java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。\n50、java 中会存在内存泄漏吗，请简单描述。 **答：**会。自己实现堆载的数据结构时有可能会出现内存泄露，可参看 effective java.\n51、java 中实现多态的机制是什么？ **答：**方法的重写 Overriding 和重载 Overloading 是Java 多态性的不同表现。重写 Overriding 是父类与子类之间多态性的一种表现，重载 Overloading 是一个类中多态性的一种表现。\n52、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚 拟机进行垃圾回收 **答：**对于 GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及使用情况。通常，GC 采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是\u0026quot; 可达的\u0026quot;，哪些对象是\u0026quot;不可达的\u0026quot;。当 GC 确定一些对象为\u0026quot;不可达\u0026quot;时，GC 就有责任回收这些内存空间。可以。程序员可以手动执行 System.gc()，通知 GC 运行，但是 Java 语言规范并不保证GC 一定会执行。\n53、静态变量和实例变量的区别？ **答：**static i = 10; //常量 class A a; a.i =10;//可变\n54、什么是 java 序列化，如何实现 java 序列化？ **答：**序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对 流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象 流进行读写操作时所引发的问题。\n序列化的实现：将需要被序列化的类实现 Serializable 接口，该接口没有需要实现的方法，im plements Serializable 只是为了标注该对象是可被序列化的，然后使用一个输出流(如：File OutputStream)来构造一个 ObjectOutputStream(对象流)对象，接着，使用 ObjectOutputStrea m 对象的 writeObject(Object obj)方法就可以将参数为 obj 的对象写出(即保存其状态)，要恢复的话则用输入流。\n **55、是否可以从一个 static 方法内部发出对非 static 方法的调用？ 答：**不可以,如果其中包含对象的 method()；不能保证对象初始化. 56、写 clone()方法时，通常都有一行代码，是什么？\n **答：**Clone 有缺省行为，super.clone();他负责产生正确大小的空间，并逐位复制。\n **57、在 JAVA 中，如何跳出当前的多重嵌套循环？ 答：**用 break; return 方法。\n 58、List、Map、Set 三个接口，存取元素时，各有什么特点？ **答：**List 以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素,内部排序。Map 保存 key-value 值，value 可多值。\n59、说出一些常用的类，包，接口，请各举 5 个 **答：**常用的类：BufferedReader BufferedWriter FileReader FileWirter Strin g Integer\n常用的包：java.lang java.awt java.io java.util java.sql 常用的接口：Remote List Map Document NodeList\n","pubDate":"2021-02-15","title":"60道必备的Java核心技术面试题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_7%E9%81%93%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97activemq%E9%9D%A2%E8%AF%95%E9%A2%98/","plain":"1.什么是 ActiveMQ? activeMQ 是一种开源的，实现了 JMS1.1 规范的，面向消息(MOM)的中间件，为应用程序提供高效的、 可扩展的、稳定的和安全的企业级消息通信 2. ActiveMQ 服务器宕机怎么办？ 这得从 ActiveMQ 的储存机制说起。在通常的情况下，非持久化消息是存储在内存中的，持久化消息是存 储在文件中的，它们的最大限制在配置文件的节点中配置。但是，在非持久化消息堆积 到一定程度，内存告急的时候，ActiveMQ 会将内存中的非持久化消息写入临时文件中，以腾出内存。虽 然都保存到了文件里，但它和持久化消息的区别是，重启后持久化消息会从文件中恢复，非持久化的临时 文件会直接删除。 那如果文件增大到达了配置中的最大限制的时候会发生什么？我做了以下实验： 设置 2G 左右的持久化文件限制，大量生产持久化消息直到文件达到最大限制，此时生产者阻塞，但消费 者可正常连接并消费消息，等消息消费掉一部分，文件删除又腾出空间之后，生产者又可继续发送消息， 服务自动恢复正常。 设置 2G 左右的临时文件限制，大量生产非持久化消息并写入临时文件，在达到最大限制时，生产者阻塞， 消费者可正常连接但不能消费消息，或者原本慢速消费的消费者，消费突然停止。整个系统可连接，但是 无法提供服务，就这样挂了。 具体原因不详，解决方案：尽量不要用非持久化消息，非要用的话，将临时文件限制尽可能的调大。 3. 丢消息怎么办？ 这得从 java 的 java.net.SocketException 异常说起。简单点说就是当网络发送方发送一堆数据，然后调 用 close 关闭连接之后。这些发送的数据都在接收者的缓存里，接收者如果调用 read 方法仍旧能从缓存中 读取这些数据，尽管对方已经关闭了连接。但是当接收者尝试发送数据时，由于此时连接已关闭，所以会 发生异常，这个很好理解。不过需要注意的是，当发生 SocketException 后，原本缓存区中数据也作废了， 此时接收者再次调用 read 方法去读取缓存中的数据，就会报 Software caused connection abort: recv failed 错误。 通过抓包得知，ActiveMQ 会每隔 10 秒发送一个心跳包，这个心跳包是服务器发送给客户端的，用来判 断客户端死没死。如果你看过上面第一条，就会知道非持久化消息堆积到一定程度会写到文件里，这个写 的过程会阻塞所有动作，而且会持续 20 到 30 秒，并且随着内存的增大而增大。当客户端发完消息调用 connection.close()时，会期待服务器对于关闭连接的回答，如果超过 15 秒没回答就直接调用 socket 层 的 close 关闭 tcp 连接了。这时客户端发出的消息其实还在服务器的缓存里等待处理，不过由于服务器心 跳包的设置，导致发生了 java.net.SocketException 异常，把缓存里的数据作废了，没处理的消息全部丢 失。 更多关注 Java 大后端公众号 解决方案：用持久化消息，或者非持久化消息及时处理不要堆积，或者启动事务，启动事务后，commit() 方法会负责任的等待服务器的返回，也就不会关闭连接导致消息丢失了。 4. 持久化消息非常慢。 默认的情况下，非持久化的消息是异步发送的，持久化的消息是同步发送的，遇到慢一点的硬盘，发送消 息的速度是无法忍受的。但是在开启事务的情况下，消息都是异步发送的，效率会有 2 个数量级的提升。 所以在发送持久化消息时，请务必开启事务模式。其实发送非持久化消息时也建议开启事务，因为根本不 会影响性能。 5. 消息的不均匀消费。 有时在发送一些消息之后，开启 2 个消费者去处理消息。会发现一个消费者处理了所有的消息，另一个消 费者根本没收到消息。原因在于 ActiveMQ 的 prefetch 机制。当消费者去获取消息时，不会一条一条去 获取，而是一次性获取一批，默认是 1000 条。这些预获取的消息，在还没确认消费之前，在管理控制台 还是可以看见这些消息的，但是不会再分配给其他消费者，此时这些消息的状态应该算作“已分配未消费”， 如果消息最后被消费，则会在服务器端被删除，如果消费者崩溃，则这些消息会被重新分配给新的消费者。 但是如果消费者既不消费确认，又不崩溃，那这些消息就永远躺在消费者的缓存区里无法处理。更通常的 情况是，消费这些消息非常耗时，你开了 10 个消费者去处理，结果发现只有一台机器吭哧吭哧处理，另 外 9 台啥事不干。 解决方案：将 prefetch 设为 1，每次处理 1 条消息，处理完再去取，这样也慢不了多少。 6. 死信队列。 如果你想在消息处理失败后，不被服务器删除，还能被其他消费者处理或重试，可以关闭 AUTO_ACKNOWLEDGE，将 ack 交由程序自己处理。那如果使用了 AUTO_ACKNOWLEDGE，消息是什 么时候被确认的，还有没有阻止消息确认的方法？有！ 更多关注 Java 大后端公众号 消费消息有 2 种方法，一种是调用 consumer.receive()方法，该方法将阻塞直到获得并返回一条消息。这 种情况下，消息返回给方法调用者之后就自动被确认了。另一种方法是采用 listener 回调函数，在有消息 到达时，会调用 listener 接口的 onMessage 方法。在这种情况下，在 onMessage 方法执行完毕后，消 息才会被确认，此时只要在方法中抛出异常，该消息就不会被确认。那么问题来了，如果一条消息不能被 处理，会被退回服务器重新分配，如果只有一个消费者，该消息又会重新被获取，重新抛异常。就算有多 个消费者，往往在一个服务器上不能处理的消息，在另外的服务器上依然不能被处理。难道就这么退回\u0026ndash; 获取\u0026ndash;报错死循环了吗？ 在重试 6 次后，ActiveMQ 认为这条消息是“有毒”的，将会把消息丢到死信队列里。如果你的消息不见 了，去 ActiveMQ.DLQ 里找找，说不定就躺在那里。 7. ActiveMQ 中的消息重发时间间隔和重发次数吗？ ActiveMQ：是 Apache 出品，最流行的，能力强劲的开源消息总线。是一个完全支持 JMS1.1 和 J2EE 1.4 规范的 JMS Provider 实现。JMS（Java 消息服务）：是一个 Java 平台中关于面向消息中间件（MOM） 的 API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。 首先，我们得大概了解下，在哪些情况下，ActiveMQ 服务器会将消息重发给消费者，这里为简单起见， 假定采用的消息发送模式为队列（即消息发送者和消息接收者）。 ① 如果消息接收者在处理完一条消息的处理过程后没有对 MOM 进行应答，则该消息将由 MOM 重发. ② 如果我们队某个队列设置了预读参数（consumer.prefetchSize），如果消息接收者在处理第一条消息 时（没向 MOM 发送消息接收确认）就宕机了，则预读数量的所有消息都将被重发! ③ 如果 Session 是事务的，则只要消息接收者有一条消息没有确认，或发送消息期间 MOM 或客户端某 一方突然宕机了，则该事务范围中的所有消息 MOM 都将重发。 ④ 说到这里，大家可能会有疑问，ActiveMQ 消息服务器怎么知道消费者客户端到底是消息正在处理中还 没来得急对消息进行应答还是已经处理完成了没有应答或是宕机了根本没机会应答呢？其实在所有的客户 端机器上，内存中都运行着一套客户端的 ActiveMQ 环境，该环境负责缓存发来的消息，负责维持着和 ActiveMQ 服务器的消息通讯，负责失效转移（fail-over）等，所有的判断和处理都是由这套客户端环境 来完成的。 我们可以来对 ActiveMQ 的重发策略（Redelivery Policy）来进行自定义配置，其中的配置参数主要有以 下几个： 更多关注 Java 大后端公众号 可用的属性 属性 默认值 说明 l collisionAvoidanceFactor 默认值 0.15 , 设置防止冲突范围的正负百分比，只有启用 useCollisionAvoidance 参数时才生效。 l maximumRedeliveries 默认值 6 , 最大重传次数，达到最大重连次数后抛出异常。为-1 时不限制次 数，为 0 时表示不进行重传。 l maximumRedeliveryDelay 默认值-1, 最大传送延迟，只在 useExponentialBackOff 为 true 时有效 （V5.5），假设首次重连间隔为 10ms，倍数为 2，那么第二次重连时间间隔为 20ms，第三次重连时间 间隔为 40ms，当重连时间间隔大的最大重连时间间隔时，以后每次重连时间间隔都为最大重连时间间隔。 l initialRedeliveryDelay 默认值 1000L, 初始重发延迟时间 l redeliveryDelay 默认值 1000L, 重发延迟时间，当 initialRedeliveryDelay=0 时生效（v5.4） l useCollisionAvoidance 默认值 false, 启用防止冲突功能，因为消息接收时是可以使用多线程并发处 理的，应该是为了重发的安全性，避开所有并发线程都在同一个时间点进行消息接收处理。所有线程在同 一个时间点处理时会发生什么问题呢？应该没有问题，只是为了平衡 broker 处理性能，不会有时很忙， 有时很空闲。 l useExponentialBackOff 默认值 false, 启用指数倍数递增的方式增加延迟时间。 l backOffMultiplier 默认值 5, 重连时间间隔递增倍数，只有值大于 1 和启用 useExponentialBackOff\n","pubDate":"2021-02-15","title":"7道消息队列ActiveMQ面试题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_tool_apache-common%E5%B7%A5%E5%85%B7%E5%8C%85/","plain":"Apache Commons 工具类介绍及简单使用    组件 功能介绍     BeanUtils Commons-BeanUtils 提供对 Java 反射和自省API的包装, 提供了对于JavaBean进行各种操作，克隆对象,属性等等.   Betwixt XML与Java对象之间相互转换.   Codec 处理常用的编码方法的工具类包 例如DES、SHA1、MD5、Base64等.   Collections java集合框架操作.   Compress java提供文件打包 压缩类库.   Configuration Commons-Configuration 工具对各种各式的配置和参考文件提供读取帮助,java应用程序的配置管理类库.   DBCP 提供数据库连接池服务.   DbUtils DbUtils 是一个 JDBC helper 类库，完成数据库任务的简单的资源清除代码,提供对jdbc 的操作封装来简化数据查询和记录读取操作   Email java发送邮件 对javamail的封装.   FileUpload 提供文件上传功能.   HttpClient 提供HTTP客户端与服务器的各种通讯操作. 现在已改成HttpComponents   Lang Java基本对象方法的工具类包 如：StringUtils,ArrayUtils等等.   Logging 提供的是一个Java 的日志接口.   Validator 提供了客户端和服务器端的数据验证框架.   Primitives Commons-Primitives提供了一个更小，更快和更易使用的对Java基本类型的支持。当前主要是针对基本类型的 collection。   Math Math 是一个轻量的，自包含的数学和统计组件，解决了许多非常通用但没有及时出现在Java标准语言中的实践问题   EL Commons-EL 提供在JSP2.0规范中定义的EL表达式的解释器.   Discovery Commons-Discovery 提供工具来定位资源 (包括类) ，通过使用各种模式来映射服务/引用名称和资源名称。   Digester Commons-Digester 是一个 XML-Java对象的映射工具，用于解析 XML配置文件.   Chain Chain 提供实现组织复杂的处理流程的“责任链模式”   Modeler Commons-Modeler 提供了建模兼容JMX规范的Mbean的机制.   Net Net 是一个网络工具集，基于 NetComponents 代码，包括 FTP 客户端等等    一:org.apache.commons.lang  ArrayUtils – 用于对数组的操作，如添加、查找、删除、子数组、倒序、元素类型转换等；  ArrayUtils类\rArrayUtils.toString(array) 将数组转为为字符串，格式如：{2,4,8,16}\rArrayUtils.contains(array,8) 判断数组中是否包含数字8，（一维数组）\rArrayUtils.indexOf(array,8) 判断数组中第一个8的位置（一维数组）\rArrayUtils.lastIndexOf(array,8) 判断数组中最后一个8的位置。（一维数组）\rArrayUtils.clone(array) 给一个一维数组来个拷贝\rArrayUtils.reverse(array); 翻转该一维数组\rArrayUtils.toMap(array); 将一个二维数组转换为map，二维数组中至少与两列，第一列为key第二列为value == \u0026gt;注意的是传入toMap()中的二维数组必须是对象如Integer\r  BitField – 用于操作位元，提供了一些方便而安全的方法；\n  BooleanUtils – 用于操作和转换 boolean 或者 Boolean 及相应的数组；\n   boolean[] booleans = new boolean[]{true, false, true};\r//和，并且\rSystem.out.println(BooleanUtils.and(booleans));//false\r//或者\rSystem.out.println(BooleanUtils.or(booleans));//true\rProjectInfo projectInfo = null;\rif (projectInfo != null \u0026amp;\u0026amp; projectInfo.getId() != 0);\r//可以用上面的改为\rBooleanUtils.and(new boolean[]{projectInfo != null,projectInfo.getId() != 0});\rInteger integer = 0;\rSystem.out.println(BooleanUtils.toBooleanObject(integer));//false\r CharEncoding – 包含了 Java 环境支持的字符编码，提供是否支持某种编码的判断；  System.out.println(CharEncoding.ISO_8859_1);\rSystem.out.println(CharEncoding.US_ASCII);\rSystem.out.println(CharEncoding.UTF_8);\rSystem.out.println(CharEncoding.UTF_16);\rSystem.out.println(CharEncoding.UTF_16BE);\rSystem.out.println(CharEncoding.UTF_16LE);\r CharRange – 用于设定字符范围并做相应检查；  System.out.println(CharUtils.toChar(\u0026quot;hello\u0026quot;,'o'));\rint assii = CharUtils.toIntValue('2');//检查字符是否在0-9\rSystem.out.println(assii);\r CharSet – 用于设定一组字符作为范围并做相应检查；(我的理解是可以用作正则表达式的判断)  System.out.println(CharSet.ASCII_ALPHA.toString());//[a-z, A-Z]\rSystem.out.println(CharSet.ASCII_ALPHA.contains('B'));//判断char是否在这个范围内\rSystem.out.println(CharSet.ASCII_ALPHA_LOWER.contains('l'));//判断char是否在这个范围内\rSystem.out.println(CharSet.ASCII_NUMERIC.contains('8'));//判断char是否在这个范围内\rSystem.out.println(CharSet.getInstance(\u0026quot;s\u0026quot;));//[s]\r CharSetUtils – 用于操作 CharSet ；   /*这里面所以的输入字符串都会被拆成char[]来判定*/\r//删除指定的字符(假如删除的这个会重复那么也会被删除掉)\rSystem.out.println(CharSetUtils.delete(\u0026quot;hello World !\u0026quot;,\u0026quot; o\u0026quot;));//helloWorld! , hellWrld! ==\u0026gt; input [ o]和[o] 结果都不同\r//是否包含任意一个字符\rSystem.out.println(CharSetUtils.containsAny(\u0026quot;xudaollong\u0026quot;,\u0026quot;k\u0026quot;,\u0026quot;o\u0026quot;));\r//当有重复的时候只删除第一次的\rSystem.out.println(CharSetUtils.squeeze(\u0026quot;china dong kk a\u0026quot;,\u0026quot;k\u0026quot;));\r//保留指定的char 要注意的是指定的char,这虽然输入的是字符串dong,但是在判定的时候实际上是把这个字符串拆成char[]\rSystem.out.println(CharSetUtils.keep(\u0026quot;china g dong\u0026quot;,\u0026quot;dong\u0026quot;));\r//统计char出现的次数\rSystem.out.println(CharSetUtils.count(\u0026quot;hello world\u0026quot;, \u0026quot;o\u0026quot;));\r CharUtils – 用于操作 char 值和 Character 对象；  System.out.println(CharUtils.toChar(\u0026quot;hello\u0026quot;,'o'));\rint num = CharUtils.toIntValue('2');//获取int类型的char但是char必须在Ascii码中\rSystem.out.println(num);\rSystem.out.println(CharUtils.isAsciiNumeric('u'));//false\rSystem.out.println(CharUtils.isAsciiNumeric('7'));//true\rSystem.out.println(CharUtils.isAscii('h'));//判断是否在Ascii 128 范围类,是否属于Ascii\r ClassUtils – 用于对 Java 类的操作，不使用反射；  System.out.println(ClassUtils.getShortClassName(UserDO.class));//返回 UserDO\rSystem.out.println(ClassUtils.getName(UserDO.class));//返回 包名.UserDO\rSystem.out.println(ClassUtils.getPackageName(UserDO.class));//返回 包名\rSystem.out.println(ClassUtils.getShortCanonicalName(UserDO.class));//返回 UserDO\rSystem.out.println(ClassUtils.getSimpleName(UserDO.class));//返回 UserDO\rSystem.out.println(ClassUtils.getAbbreviatedName(UserDO.class,2));\rClassUtils.getAllSuperclasses(UserDO.class).stream().forEachOrdered(System.out::println);//获取父类\rClassUtils.getAllInterfaces(UserDO.class).stream().forEachOrdered(System.out::println);//获取接口\r ObjectUtils – 用于操作 Java 对象，提供 null 安全的访问和其他一些功能；  UserDO userDO = new UserDO(Zhou_Word.getEnglishName());\rUserDO userDO1 = ObjectUtils.clone(userDO);\ruserDO1 = null;\ruserDO = Preconditions.checkNotNull(userDO, \u0026quot;不能为null\u0026quot;);//不会抛出NullPointerException\r/**如果一个类没有重写toString方法本身，将会通过Object类的toString方法获取对象的字符串对象，*/\rSystem.out.println(ObjectUtils.identityToString(null));//null\rSystem.out.println(ObjectUtils.identityToString(\u0026quot;\u0026quot;));//java.lang.String@12843fce\rSystem.out.println(ObjectUtils.identityToString(Boolean.TRUE));//java.lang.Boolean@3dd3bcd\r/**\r* 累加对象产生的toString\r* 两个参数任意一个为null都会抛出空指针异常\r* buffer-要追加的缓冲区\r* object-要创建对象的toString\r*/\rStringBuffer buffer = new StringBuffer();\rObjectUtils.identityToString(buffer, \u0026quot;\u0026quot;);\rObjectUtils.identityToString(buffer, Boolean.TRUE);\rObjectUtils.identityToString(buffer, 12);\rSystem.out.println(buffer.toString());//java.lang.String@12843fcejava.lang.Boolean@3dd3bcdjava.lang.Integer@97e1986 调用了Object类的toString方法\r//封装类型的数字比较\rInteger a = 10, b = null, c = 15;\r//比较两个封装类型的数字,默认null为小\rObjectUtils.compare(a, b);\r//比较两个封装类型的数字,设置null为大\rObjectUtils.compare(a, b, true);\r//获取最大的值,默认null为最小\rObjectUtils.max(a, b);\r RandomStringUtils – 用于生成随机的字符串；  System.out.println(RandomStringUtils.random(4).length());\rSystem.out.println(RandomStringUtils.random(23));//生成指定长度任意的随机字符\rSystem.out.println(RandomStringUtils.randomNumeric(22));//生成数字组成的随机字符\rSystem.out.println(RandomStringUtils.randomAscii(22));//生成ascii 128内的随机字符\rSystem.out.println(RandomStringUtils.randomAlphabetic(21));//生成大写或者小写或者都有组成的随机字符\r  SerializationUtils – 用于处理对象序列化，提供比一般 Java 序列化更高级的处理能力；\n  StringEscapeUtils – 用于正确处理转义字符，产生正确的 Java 、 JavaScript 、 HTML 、 XML 和 SQL 代码；\n  String str = \u0026quot;thi is a test 这是一个测试\u0026quot;;\rString xml = \u0026quot;\u0026lt;?xml version=\\\u0026quot;1.0\\\u0026quot; encoding=\\\u0026quot;UTF-8\\\u0026quot;?\u0026gt;\\n\u0026quot; +\r\u0026quot;\u0026lt;persons\u0026gt;\\n\u0026quot; +\r\u0026quot; \u0026lt;person id=\\\u0026quot;23\\\u0026quot;\u0026gt;\\n\u0026quot; +\r\u0026quot; \u0026lt;name\u0026gt;张 三\u0026lt;/name\u0026gt;\\n\u0026quot; +\r\u0026quot; \u0026lt;age\u0026gt;26\u0026lt;/age\u0026gt;\\n\u0026quot; +\r\u0026quot; \u0026lt;/person\u0026gt;\\n\u0026quot; +\r\u0026quot; \u0026lt;person id=\\\u0026quot;22\\\u0026quot;\u0026gt;\\n\u0026quot; +\r\u0026quot; \u0026lt;name\u0026gt;李四\u0026lt;/name\u0026gt;\\n\u0026quot; +\r\u0026quot; \u0026lt;age\u0026gt;25\u0026lt;/age\u0026gt;\\n\u0026quot; +\r\u0026quot; \u0026lt;/person\u0026gt;\\n\u0026quot; +\r\u0026quot;\u0026lt;/persons\u0026gt;\u0026quot;;\rSystem.out.println(\u0026quot;用escapeJava方法转义之后的字符串为:\u0026quot; + org.apache.commons.lang.StringEscapeUtils.escapeJava(str));\rSystem.out.println(\u0026quot;用unescapeJava方法反转义之后的字符串为:\u0026quot; + org.apache.commons.lang.StringEscapeUtils.unescapeJava(org.apache.commons.lang.StringEscapeUtils.escapeJava(str)));\rSystem.out.println(\u0026quot;用escapeHtml方法转义之后的字符串为:\u0026quot; + org.apache.commons.lang.StringEscapeUtils.escapeHtml(str));\rSystem.out.println(\u0026quot;用unescapeHtml方法反转义之后的字符串为:\u0026quot; + org.apache.commons.lang.StringEscapeUtils.unescapeHtml(org.apache.commons.lang.StringEscapeUtils.escapeHtml(str)));\rSystem.out.println(\u0026quot;用escapeXml方法转义之后的字符串为:\u0026quot; + org.apache.commons.lang.StringEscapeUtils.escapeXml(xml));\rSystem.out.println(\u0026quot;用unescapeXml方法反转义之后的字符串为:\u0026quot; + org.apache.commons.lang.StringEscapeUtils.unescapeXml(org.apache.commons.lang.StringEscapeUtils.escapeXml(xml)));\rSystem.out.println(\u0026quot;用escapeJavaScript方法转义之后的字符串为:\u0026quot; + org.apache.commons.lang.StringEscapeUtils.escapeJavaScript(str));\rSystem.out.println(\u0026quot;用unescapeJavaScript方法反转义之后的字符串为:\u0026quot; + org.apache.commons.lang.StringEscapeUtils.unescapeJavaScript(org.apache.commons.lang.StringEscapeUtils.unescapeJavaScript(str)));\r StringUtils – 处理 String 的核心类，提供了相当多的功能；  System.out.println(StringUtils.isNotEmpty(\u0026quot; \u0026quot;)); //true\rSystem.out.println(StringUtils.isNotBlank(\u0026quot; \u0026quot;));//这个方法里面字符串空白会删除空白 false\rSystem.out.println( StringUtils.repeat( \u0026quot;China \u0026quot;, 5));//将目标字符串累加5次\rSystem.out.println( StringUtils.center( \u0026quot;China\u0026quot;, 10,\u0026quot;*\u0026quot;));//**China*** size=10指的是得到的长度为10 将china用*前后包围然后目标长度截取为10\rSystem.out.println(StringUtils.countMatches( \u0026quot;Chinese People\u0026quot;, \u0026quot;e\u0026quot;));//取得某字符串在另一字符串中出现的次数\rString formatted = \u0026quot; 25 * (30,40) [50,60] | 30\u0026quot;;\rSystem.out.print(\u0026quot;N0: \u0026quot; + StringUtils.substringBeforeLast( formatted, \u0026quot;*\u0026quot; ) );//取得最后一个指定字符串之前的字符串\rSystem.out.print(\u0026quot;, N1: \u0026quot; + StringUtils.substringBetween( formatted, \u0026quot;(\u0026quot;, \u0026quot;,\u0026quot; ) );//取得两字符之间的字符串\rSystem.out.print(\u0026quot;, N2: \u0026quot; + StringUtils.substringBetween( formatted, \u0026quot;,\u0026quot;, \u0026quot;)\u0026quot; ) );\rSystem.out.print(\u0026quot;, N3: \u0026quot; + StringUtils.substringBetween( formatted, \u0026quot;[\u0026quot;, \u0026quot;,\u0026quot; ) );\rSystem.out.print(\u0026quot;, N4: \u0026quot; + StringUtils.substringBetween( formatted, \u0026quot;,\u0026quot;, \u0026quot;]\u0026quot; ) );\rSystem.out.print(\u0026quot;, N5: \u0026quot; + StringUtils.substringAfterLast( formatted, \u0026quot;|\u0026quot; ) );//取得最后一个指定字符串之后的字符串\rSystem.out.println( StringUtils.reverse(\u0026quot;ABCDE\u0026quot;));//颠倒字符串 EDCBA\r根据指定分隔符进行反转，分隔符之间的字符不进行反转\rStringUtils.reverseDelimited(\u0026quot;china\u0026quot;, ',')); // china\rStringUtils.reverseDelimited(\u0026quot;cxhinxa\u0026quot;, 'x')); // axhinxz\rStringUtils.reverseDelimited(\u0026quot;c.hin.a\u0026quot;, '.')); // a.hin.c\rStringUtils.reverseDelimited(\u0026quot;c.hina\u0026quot;, '.')); // hina.c\rSystem.out.println(StringUtils.capitalize(\u0026quot;hello\u0026quot;));//首字母大写\rSystem.out.println(StringUtils.uncapitalize(this.getClass().getSimpleName()));//首字母小写\rSystem.out.println(StringUtils.isAllUpperCase(this.getClass().getSimpleName()));//是否全是大写 false\rSystem.out.println(StringUtils.isAllLowerCase(this.getClass().getSimpleName()));//是否全是小写 false\rSystem.out.println(StringUtils.swapCase(\u0026quot;I am a-A*a\u0026quot;));//大小写转换，空格不动 i AM A-a*A\rSystem.out.println(StringUtils.join(new String[] {\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot; ,\u0026quot;c\u0026quot;},\u0026quot;,\u0026quot;));//分割字符串 a,b,c\r判断字符串中是否包含指定的字符或字符序列\r1:区分大小写\rStringUtils.contains(null, 'a'); // false StringUtils.contains(\u0026quot;china\u0026quot;, 'a');// true\r2:不区分大小写\rStringUtils.containsIgnoreCase(\u0026quot;china\u0026quot;, 'a');// true\rStringUtils.containsIgnoreCase(\u0026quot;china\u0026quot;, 'A');// true\r3:只需要包含任意一个字符即可 判断字符串中是否包含指定字符集合中或指定字符串中任一字符，区分大小写\rStringUtils.containsAny(\u0026quot;abc\u0026quot;, \u0026quot;ab\u0026quot;);// true\rStringUtils.containsAny(\u0026quot;abc\u0026quot;, \u0026quot;ax\u0026quot;);// true\rStringUtils.containsAny(\u0026quot;abc\u0026quot;, \u0026quot;xy\u0026quot;);// false\r4:判断字符串中是否不包含指定的字符或指定的字符串中的字符，区分大小写\rStringUtils.containsNone(null, 'a'); // true\rStringUtils.containsNone(\u0026quot;\u0026quot;, 'a'); // true 注意这里，空串总是返回true\rStringUtils.containsNone(\u0026quot;china\u0026quot;, ' '); // true 注意包含空白符为true\r从字符串中移除匹配的字符或字符序列，如果要移除的字符或字符序列在字符串中不存在，即无匹配，则不进行移除\r1:移除单个字符\rStringUtils.remove(null, 'a')); // null (注意此处及下一行为null)\rStringUtils.remove('china', null) // china StringUtils.remove(\u0026quot;china\u0026quot;, 'i')); // chna\rStringUtils.remove(\u0026quot;china\u0026quot;, 'b')); // china (如果要移除的字符不存在，则返回原字符串)\r2:移除指定字符序列\rStringUtils.remove(\u0026quot;china\u0026quot;, \u0026quot;in\u0026quot;)); // cha\rStringUtils.remove(\u0026quot;china\u0026quot;, \u0026quot;nin\u0026quot;)); // china\r3:移除开头匹配的字符序列\rStringUtils.removeStart(\u0026quot;china\u0026quot;, \u0026quot;ch\u0026quot;)); // ina\rStringUtils.removeStartIgnoreCase(\u0026quot;china\u0026quot;, \u0026quot;CHI\u0026quot;)); // na (忽略大小写)\r4:移除结尾匹配的字符序列\rStringUtils.removeEnd(\u0026quot;china\u0026quot;, \u0026quot;na\u0026quot;)); // chi\rStringUtils.removeEndIgnoreCase(\u0026quot;china\u0026quot;, \u0026quot;NA\u0026quot;)); // chi (忽略大小写)\r5:移除空白字符\rStringUtils.deleteWhitespace(null)); //null\rStringUtils.deleteWhitespace(\u0026quot; c h i\\tn\\ra\u0026quot;)); // china\r SystemUtils – 在 java.lang.System 基础上提供更方便的访问，如用户路径、 Java 版本、时区、操作系统等判断；  System.out.println(SystemUtils.getHostName());//DESKTOP-AS9FA6P\rSystem.out.println(SystemUtils.getUserDir().getPath());//E:\\IdeaProjects\\z-utils\rSystem.out.println(SystemUtils.getUserHome().getPath());//C:\\Users\\noatn\rSystem.out.println(SystemUtils.getJavaHome().getPath());//C:\\Program Files\\Java\\jdk1.8.0_181\\jre\rSystem.out.println(SystemUtils.getJavaIoTmpDir().getPath());//C:\\Users\\noatn\\AppData\\Local\\Temp\rSystem.out.println(SystemUtils.IS_JAVA_1_8);//true\rSystem.out.println(SystemUtils.IS_OS_WINDOWS);//true\rSystem.out.println(SystemUtils.IS_OS_WINDOWS_10);//true\rSystem.out.println(SystemUtils.USER_NAME);//noatn\rSystem.out.println(SystemUtils.USER_DIR);//E:\\IdeaProjects\\z-utils\rSystem.out.println(SystemUtils.USER_HOME);//C:\\Users\\noatn\r  Validate – 提供验证的操作，有点类似 assert 断言；\n  WordUtils – 用于处理单词大小写、换行等。\n  二:org.apache.commons.lang.math  处理分数的Fraction类；  {\rFraction fraction = Fraction.getFraction(1,2);// first prams 分子 ,second params 分母\rSystem.out.println(fraction.doubleValue());//输出具体值 0.5\rSystem.out.println(fraction.toString());//输出具字符串值 1/2\rSystem.out.println(fraction.toProperString());//输出具字符串值 1/2\r}\r{\r//当第一个参数大于0的情况 (2*3+1) / 3\rFraction fraction = Fraction.getFraction(2,1,3);\rSystem.out.println(fraction.doubleValue());//输出具体值 2.3333333333333335\r//当第一个参数大于0的情况 (-2*3-1) / 3\rfraction = Fraction.getFraction(-2,1,3);\rSystem.out.println(fraction.doubleValue());\rfraction = Fraction.getFraction(\u0026quot;1/2\u0026quot;);//可以自动解析为分子1分母2\rSystem.out.println(fraction.doubleValue());\r}\r{\r//获取绝对值 即|-1| == 1\rSystem.out.println(Fraction.getFraction(-1, 2).abs());\r//两个分数相加\rSystem.out.println(Fraction.getFraction(1, 2).add(Fraction.getFraction(\u0026quot;1/2\u0026quot;)));\r//两个分数相减\rSystem.out.println(Fraction.getFraction(1, 2).subtract(\rFraction.getFraction(1, 2)));\r//两个分数相乘\rSystem.out.println(Fraction.getFraction(1, 2).multiplyBy(\rFraction.getFraction(1, 2)));\r//两个分数相除\rSystem.out.println(Fraction.getFraction(1, 2).divideBy(\rFraction.getFraction(1, 2)));\r//约数\rSystem.out.println(Fraction.getFraction(1, 2).pow(2));\r}\r 处理数值的NumberUtils和IEEE754rUtils类，这里IEEE745r代表的是IEEE 754的标准，是一种浮点数的处理标准。 处理随机数的JVMRandom和RandomUtils类。  // JVMRandom继承了java.util.Random类，其功能和Random差不多，只不过封装了返回不同数据类型的方法而已。而RandomUtils则把JVMRandom的方法静态化了。\rfor (int i = 0; i \u0026lt; 5; i++) {\rSystem.out.println(RandomUtils.nextInt(100));\r}\r 处理数值范围的Range, DoubleRange, FloatRange, IntRange, LangRange, NumberRange类   Range normalScoreRange = new DoubleRange(90, 120);\rdouble score1 = 102.5;\rdouble score2 = 79.9;\rSystem.out.println(\u0026quot;Normal score range is: \u0026quot; + normalScoreRange);//[90.0,120.0] 打印一个范围\rSystem.out.println(\u0026quot;Is \u0026quot; + score1 + \u0026quot; a normal score? \u0026quot; + normalScoreRange.containsDouble(score1));//是否在这个范围 true\rSystem.out.println(\u0026quot;Is \u0026quot; + score2 + \u0026quot; a normal score? \u0026quot; + normalScoreRange.containsDouble(score2));//是否在这个范围 false\rSystem.out.println(normalScoreRange.overlapsRange(new IntRange(92,119)));//此范围是否在我们预定的范围中 true\r三:Commons Collections  CollectionUtils  org.apache.commons.collections4.CollectionUtils.isEqualCollection(java.util.Collection\u0026lt;?\u0026gt;, java.util.Collection\u0026lt;?\u0026gt;) 集合是否相等\rorg.apache.commons.collections4.CollectionUtils.union(Collection\u0026lt;?\u0026gt; a,Collection\u0026lt;?\u0026gt; b) 合集\rorg.apache.commons.collections4.CollectionUtils.subtract(java.lang.Iterable\u0026lt;? extends O\u0026gt;, java.lang.Iterable\u0026lt;? extends O\u0026gt;) 差集\rorg.apache.commons.collections4.CollectionUtils.intersection (Collection\u0026lt;?\u0026gt; a,Collection\u0026lt;?\u0026gt; b) 交集\rorg.apache.commons.collections4.CollectionUtils.isSubCollection(Collection\u0026lt;?\u0026gt; a,Collection\u0026lt;?\u0026gt; b) 集合包含\rorg.apache.commons.collections4.CollectionUtils.collate(java.lang.Iterable\u0026lt;? extends O\u0026gt;, java.lang.Iterable\u0026lt;? extends O\u0026gt;) 合并\rorg.apache.commons.collections4.CollectionUtils.isNotEmpty(Collection\u0026lt;?\u0026gt; a) 判断是否为null并且是否包含元素\rorg.apache.commons.collections4.CollectionUtils.addIgnoreNull(Collection\u0026lt;T\u0026gt; collection, final T object)添加非空的对象到集合中\r","pubDate":"2021-02-15","title":"apache-common工具包"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_jquery-cookie_changelog/","plain":"HEAD 1.4.0   Support for AMD.\n  Removed deprecated method $.cookie('name', null) for deleting a cookie, use $.removeCookie('name').\n  $.cookie('name') now returns undefined in case such cookie does not exist (was null). Because the return value is still falsy, testing for existence of a cookie like if ( $.cookie('foo') ) keeps working without change.\n  Renamed bower package definition (component.json -\u0026gt; bower.json) for usage with up-to-date bower.\n  Badly encoded cookies no longer throw exception upon reading but do return undefined (similar to how we handle JSON parse errors with json = true).\n  Added conversion function as optional last argument for reading, so that values can be changed to a different representation easily on the fly. Useful for parsing numbers for instance:\n1 2  $.cookie(\u0026#39;foo\u0026#39;, \u0026#39;42\u0026#39;); $.cookie(\u0026#39;foo\u0026#39;, Number); // =\u0026gt; 42     1.3.1   Fixed issue where it was no longer possible to check for an arbitrary cookie, while json is set to true, there was a SyntaxError thrown from JSON.parse.\n  Fixed issue where RFC 2068 decoded cookies were not properly read.\n  1.3.0   Configuration options: raw, json. Replaces raw option, becomes config:\n1 2  $.cookie.raw = true; // bypass encoding/decoding the cookie value $.cookie.json = true; // automatically JSON stringify/parse value   Thus the default options now cleanly contain cookie attributes only.\n  Removing licensing under GPL Version 2, the plugin is now released under MIT License only (keeping it simple and following the jQuery library itself here).\n  Bugfix: Properly handle RFC 2068 quoted cookie values.\n  Added component.json for bower.\n  Added jQuery plugin package manifest.\n  $.cookie() returns all available cookies.\n  1.2.0  Adding $.removeCookie('foo') for deleting a cookie, using $.cookie('foo', null) is now deprecated.  1.1  Adding default options.  ","pubDate":"2021-02-15","title":"CHANGELOG"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_bootstrap-switch_contributing/","plain":"If you want help us to fix bugs or add a extension please use our develop branch\nhttps://github.com/nostalgiaz/bootstrap-switch/tree/develop\nFirst step:\nPlease merge your branch develop with nostalgiaz/bootstrap-switch/tree/develop\nsecond step:\nWork in the branch develop for fixes\nthird step:\nregularly reviews the branch develop for updates and then merge this with your branch develop\nfourth step:\nWhen you\u0026rsquo;re done in your branch send us a PR to merge the two branches\n","pubDate":"2021-02-15","title":"CONTRIBUTING"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_jquery-cookie_contributing/","plain":"##Issues\n Report issues or feature requests on GitHub Issues. If reporting a bug, please add a simplified example.  ##Pull requests\n Create a new topic branch for every separate change you make. Create a test case if you are fixing a bug or implementing an important feature. Make sure the build runs successfully.  Development ###Tools We use the following tools for development:\n Qunit for tests. NodeJS required to run grunt and the test server only. Grunt for task management.  ###Getting started Install NodeJS.\nInstall globally grunt-cli using the following command:\n$ npm install -g grunt-cli\r Browse to the project root directory and install the dev dependencies:\n$ npm install -d\r To execute the build and tests run the following command in the root of the project:\n$ grunt\r You should see a green message in the console:\nDone, without errors.\r ###Tests You can also run the tests in the browser.\nStart a test server from the project root:\n$ node test/server.js\r Open the following URL in a browser:\n$ open http://0.0.0.0:8124/test/index.html\r Note: we recommend cleaning all the browser cookies before running the tests, that can avoid false positive failures.\n###Automatic build You can build automatically after a file change using the following command:\n$ grunt watch\r ","pubDate":"2021-02-15","title":"CONTRIBUTING"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_select2_contributing/","plain":"Contributing to Select2 Looking to contribute something to Select2? Here\u0026rsquo;s how you can help.\nPlease take a moment to review this document in order to make the contribution process easy and effective for everyone involved.\nFollowing these guidelines helps to communicate that you respect the time of the developers managing and developing this open source project. In return, they should reciprocate that respect in addressing your issue or assessing patches and features.\nUsing the issue tracker When reporting bugs or requesting features, the issue tracker on GitHub is the recommended channel to use.\nThe issue tracker is not a place for support requests. The mailing list or IRC channel are better places to get help.\nReporting bugs with Select2 We really appreciate clear bug reports that consistently show an issue within Select2.\nThe ideal bug report follows these guidelines:\n Use the GitHub issue search — Check if the issue has already been reported. Check if the issue has been fixed — Try to reproduce the problem using the code in the master branch. Isolate the problem — Try to create an isolated test case that consistently reproduces the problem.  Please try to be as detailed as possible in your bug report, especially if an isolated test case cannot be made. Some useful questions to include the answer to are:\n What steps can be used to reproduce the issue? What is the bug and what is the expected outcome? What browser(s) and Operating System have you tested with? Does the bug happen consistently across all tested browsers? What version of jQuery are you using? And what version of Select2? Are you using Select2 with other plugins?  All of these questions will help people fix and identify any potential bugs.\nRequesting features in Select2 Select2 is a large library that carries with it a lot of functionality. Because of this, many feature requests will not be implemented in the core library.\nBefore starting work on a major feature for Select2, contact the community first or you may risk spending a considerable amount of time on something which the project developers are not interested in bringing into the project.\nSelect2 4.0 Many feature requests will be closed off until 4.0, where Select2 plans to adopt a more flexible API. If you are interested in helping with the development of the next major Select2 release, please send a message to the mailing list or irc channel for more information.\nTriaging issues and pull requests Anyone can help the project maintainers triage issues and review pull requests.\nHandling new issues Select2 regularly receives new issues which need to be tested and organized.\nWhen a new issue that comes in that is similar to another existing issue, it should be checked to make sure it is not a duplicate. Duplicates issues should be marked by replying to the issue with \u0026ldquo;Duplicate of #[issue number]\u0026rdquo; where [issue number] is the url or issue number for the existing issue. This will allow the project maintainers to quickly close off additional issues and keep the discussion focused within a single issue.\nIf you can test issues that are reported to Select2 that contain test cases and confirm under what conditions bugs happen, that will allow others to identify what causes a bug quicker.\nReviewing pull requests It is very common for pull requests to be opened for issues that contain a clear solution to the problem. These pull requests should be rigorously reviewed by the community before being accepted. If you are not sure about a piece of submitted code, or know of a better way to do something, do not hesitate to make a comment on the pull request.\nIt should also be made clear that all code contributed to Select must be licensable under the Apache 2 or GPL 2 licenses. Code that cannot be released under either of these licenses cannot be accepted into the project.\n","pubDate":"2021-02-15","title":"CONTRIBUTING"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_tool_dom4j/","plain":"dom4j  选取节点\n   nodename 选取当前节点的所有子节点\n  / 从根节点选取\n  // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置\n  . 选取当前节点\n  .. 选取当前节点的父节点\n  @ 选取属性\n   实例\n   路径表达式 结果\n  bookstore 选取 bookstore 元素的所有子节点\n  /bookstore 选取根元素 bookstore\n  bookstore/book 选取bookstore 下名字为 book的所有子元素。\n  //book 选取所有 book 子元素，而不管它们在文档中的位置。\n  bookstore//book 选取bookstore 下名字为 book的所有后代元素，而不管它们位于 bookstore 之下的什么位置。\n  //@lang 选取所有名为 lang 的属性。\n   常见的谓语的一些路径表达式\n  /bookstore/book[1] 选取属于 bookstore 子元素的第一个 book 元素。 /bookstore/book[last()] 选取属于 bookstore 子元素的最后一个 book 元素。 /bookstore/book[last()-1] 选取属于 bookstore 子元素的倒数第二个 book 元素。 /bookstore/book[position()\u0026lt;3] 选取最前面的两个属于 bookstore 元素的子元素的 book 元素。 //title[@lang] 选取所有拥有名为 lang 的属性的 title 元素。 //title[@lang=\u0026lsquo;eng\u0026rsquo;] 选取所有 title 元素，要求这些元素拥有值为 eng 的 lang 属性。 /bookstore/book[price\u0026gt;35.00] 选取所有 bookstore 元素的 book 元素，要求book元素的子元素 price 元素的值须大于 35.00。 /bookstore/book[price\u0026gt;35.00]/title 选取所有 bookstore 元素中的 book 元素的 title 元素，要求book元素的子元素 price 元素的值须大于 35.00   选取未知节点\n  通配符 描述   匹配任何元素节点   @* 匹配任何属性节点 node() 匹配任何类型的节点 路径表达式 结果 //book/title | //book/price 选取所有 book 元素的 title 和 price 元素。 //title | //price 选取所有文档中的 title 和 price 元素。 /bookstore/book/title|//price 选取所有属于 bookstore 元素的 book 元素的title 元素，以及文档中所有的 price 元素。  ","pubDate":"2021-02-15","title":"dom4j"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_windows_dos_basic/","plain":"DOS基本命令  wing+r ==\u0026gt; cmd 进入dos控制台   打开屏幕键盘  C:\\Users\\noatn\u0026gt;osk;\r dos各种操作查看参数用法 command params ==? command /?  C:\\Users\\noatn\u0026gt;cd /?\r显示当前目录名或改变当前目录。\rCHDIR [/D] [drive:][path]\rCHDIR [..]\rCD [/D] [drive:][path]\rCD [..]\r.. 指定要改成父目录。\r键入 CD drive: 显示指定驱动器中的当前目录。\r不带参数只键入 CD，则显示当前驱动器和目录。\r使用 /D 开关，除了改变驱动器的当前目录之外，\r还可改变当前驱动器。\r如果命令扩展被启用，CHDIR 会如下改变:\r当前的目录字符串会被转换成使用磁盘名上的大小写。所以，\r如果磁盘上的大小写如此，CD C:\\TEMP 会将当前目录设为\rC:\\Temp。\rCHDIR 命令不把空格当作分隔符，因此有可能将目录名改为一个\r带有空格但不带有引号的子目录名。例如:\rcd \\winnt\\profiles\\username\\programs\\start menu\r与下列相同:\rcd \u0026quot;\\winnt\\profiles\\username\\programs\\start menu\u0026quot;\r在扩展停用的情况下，你必须键入以上命令。\r  显示文件夹列表 dir\n  改变目录 cd\n  返回上一级目录 cd ..\n  返回根目录 cd \\\n  创建子目录 md\n  删除目录 rd\n  清理屏幕 cls\n  cd s ==\u0026gt; 按住tab键切换\n  DOS窗口中创建用户并设定为管理员  查看本机用户数量 net user  PS E:\\\u0026gt; net user; \\\\DESKTOP-GN2SF7M 的用户帐户\r-------------------------------------------------------------------------------\rAdministrator DefaultAccount Guest\rWDAGUtilityAccount zch\r命令成功完成。\r 创建一个新用户 net user name password /add  PS E:\\\u0026gt; net user blake 123456 /add ; 命令成功完成。\r 提升到管理员权限 net localgroup administrators 用户名 /add  PS E:\\\u0026gt; net localgroup administrators blake /add; 命令成功完成。\rPS E:\\\u0026gt;  删除某个用户名 net user user1 /del  PS E:\\\u0026gt; net user alice /del 命令成功完成。\rPS E:\\\u0026gt;  修改用户密码 net user user1 （直接输入新密码）即可  PS E:\\\u0026gt; net user alice 000000 命令成功完成。\rPS E:\\\u0026gt;  dos备份磁盘   XCOPY D: E:\\backup /s/e/c/h/j/g\rPS E:\\\u0026gt; XCOPY D: E:\\kao /e/h/k/y/c\r","pubDate":"2021-02-15","title":"DOS \u003e basic"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_windows_dos_file/","plain":"DOS基本文件操作命令   wing+r ==\u0026gt; cmd 进入dos控制台\n  D:\n  进入D盘\r cd命令  CD命令是更改目录命令 如果要进入D盘不用这个命令直接输入 D: 回车 即可\r例如:\rC:\\Users\\HP\u0026gt;D:\rD:\\\u0026gt;\rD:\\\u0026gt;dir\r驱动器 D 中的卷是 新加卷\r卷的序列号是 DAB4-11FE\rD:\\ 的目录\r2019-10-10 14:15 \u0026lt;DIR\u0026gt; 360极速浏览器下载\r2020-01-13 13:47 \u0026lt;DIR\u0026gt; BaiduNetdiskDownload\r2020-01-20 13:59 \u0026lt;DIR\u0026gt; CS\r2019-12-13 16:53 \u0026lt;DIR\u0026gt; data\r2020-02-10 15:55 \u0026lt;DIR\u0026gt; IdeaProjects\r2019-12-06 15:01 \u0026lt;DIR\u0026gt; log\r2019-10-23 10:40 \u0026lt;DIR\u0026gt; MailMasterData\r2019-09-29 10:43 \u0026lt;DIR\u0026gt; output\r2020-01-13 13:40 \u0026lt;DIR\u0026gt; soft\r2020-02-04 17:43 \u0026lt;DIR\u0026gt; temp\r2020-01-15 18:05 \u0026lt;DIR\u0026gt; ultraeditWork\r2019-12-10 09:47 \u0026lt;DIR\u0026gt; workspace\r0 个文件 0 字节\r12 个目录 463,738,040,320 可用字节\rD:\\\u0026gt;cd CS\rD:\\CS\u0026gt; /*进入了CS目录**/\r cd .. (进入当前磁盘的上一级)  \r类似于 linux 下的cd ~\rzch@zch MINGW64 /d/data\r$ cd ~\r已经在某个磁盘下的情况下可以用cd 进入目录\rC:\\Users\\noatn\u0026gt;cd d:\\tencent\rC:\\Users\\noatn\u0026gt;cd C:\\Users\\noatn\\.android\rC:\\Users\\noatn\\.android\u0026gt;\r这里进入d盘失败但是成功进入了C盘预计的目录\r 创建文件 echo \u0026gt;fileName或者 echo [this content] \u0026gt; fileName  \recho \u0026gt;d.txt;\r============\u0026gt;\rE:\\temp\u0026gt;echo \u0026gt;d.txt;\rE:\\temp\u0026gt;dir\r驱动器 E 中的卷是 新加卷\r卷的序列号是 64E8-4ABF\rE:\\temp 的目录\r2020/02/14 18:56 \u0026lt;DIR\u0026gt; .\r2020/02/14 18:56 \u0026lt;DIR\u0026gt; ..\r2020/02/14 18:56 3 d.txt\r1 个文件 3 字节\r2 个目录 264,645,689,344 可用字节\r 查看文件内容 type fileName  E:\\temp\u0026gt;type d.txt\rthis is a text file\r 创建目录 md pathName  E:\\temp\u0026gt;md cc\rE:\\temp\u0026gt;dir\r驱动器 E 中的卷是 新加卷\r卷的序列号是 64E8-4ABF\rE:\\temp 的目录\r2020/02/14 19:02 \u0026lt;DIR\u0026gt; .\r2020/02/14 19:02 \u0026lt;DIR\u0026gt; ..\r2020/02/14 19:02 \u0026lt;DIR\u0026gt; cc\r2020/02/14 18:59 19 d.txt\r1 个文件 19 字节\r3 个目录 264,645,689,344 可用字节\r 复制文件 copy fileName path+fileName  E:\\temp\u0026gt;copy d.txt E:\\temp\\cc;\r已复制 1 个文件。\r 深复制 XCOPY  H:\\\u0026gt;xcopy /?\r复制文件和目录树。\rXCOPY source [destination] [/A | /M] [/D[:date]] [/P] [/S [/E]] [/V] [/W]\r[/C] [/I] [/Q] [/F] [/L] [/G] [/H] [/R] [/T] [/U]\r[/K] [/N] [/O] [/X] [/Y] [/-Y] [/Z] [/B] [/J]\r[/EXCLUDE:file1[+file2][+file3]...]\rsource 指定要复制的文件。\rdestination 指定新文件的位置和/或名称。\r/A 仅复制有存档属性集的文件，\r但不更改属性。\r/M 仅复制有存档属性集的文件，\r并关闭存档属性。\r/D:m-d-y 复制在指定日期或指定日期以后更改的文件。\r如果没有提供日期，只复制那些\r源时间比目标时间新的文件。\r/EXCLUDE:file1[+file2][+file3]...\r指定含有字符串的文件列表。每个字符串\r在文件中应位于单独的一行。如果任何\r字符串与复制文件的绝对路径的任何部分相符，\r则排除复制该文件。例如，\r指定如 \\obj\\ 或 .obj 的字符串会分别\r排除目录 obj 下面的所有文件或带有\r.obj 扩展名的所有文件。\r/P 创建每个目标文件之前提示你。\r/S 复制目录和子目录，不包括空目录。\r/E 复制目录和子目录，包括空目录。\r与 /S /E 相同。可以用来修改 /T。\r/V 验证每个新文件的大小。\r/W 提示你在复制前按键。\r/C 即使有错误，也继续复制。\r/I 如果目标不存在，且要复制多个文件，\r则假定目标必须是目录。\r/Q 复制时不显示文件名。\r/F 复制时显示完整的源文件名和目标文件名。\r/L 显示要复制的文件。\r/G 允许将加密文件复制到\r不支持加密的目标。\r/H 也复制隐藏文件和系统文件。\r/R 覆盖只读文件。\r/T 创建目录结构，但不复制文件。不\r包括空目录或子目录。/T /E 包括\r空目录和子目录。\r/U 只复制已经存在于目标中的文件。\r/K 复制属性。一般的 Xcopy 会重置只读属性。\r/N 用生成的短名称复制。\r/O 复制文件所有权和 ACL 信息。\r/X 复制文件审核设置(隐含 /O)。\r/Y 取消提示以确认要覆盖\r现有目标文件。\r/-Y 要提示以确认要覆盖\r现有目标文件。\r/Z 在可重新启动模式下复制网络文件。\r/B 复制符号链接本身与链接目标。\r/J 复制时不使用缓冲的 I/O。推荐复制大文件时使用。\r开关 /Y 可以预先在 COPYCMD 环境变量中设置。\r这可能被命令行上的 /-Y 覆盖。\r 深复制 案例  \rH:\\\u0026gt;XCOPY Java学习相关电子书籍 E:\\temp\\mess\r不加参数只是复制了文件，并没有复制要复制的文件夹里的文件夹\r接下来复制一个包含子文件夹的案例\rH:\\\u0026gt;XCOPY Java学习相关电子书籍 E:\\temp\\aess /s/e\r目标 E:\\temp\\aess 是文件名\r还是目录名\r(F = 文件，D = 目录)? d\rJava学习相关电子书籍\\Algorithms 4th Edition.pdf\rJava学习相关电子书籍\\Core Java. Volume II. Advanced Features, 8th Edition.pdf\rJava学习相关电子书籍\\Core.Java.Volume.I.Fundamentals,8th.Edition.pdf\rJava学习相关电子书籍\\Effective.Enterprise.Java.pdf\rJava学习相关电子书籍\\Flex+白皮书.pdf\rJava学习相关电子书籍\\Flex3高级图表开发指南.pdf\rJava学习相关电子书籍\\Google笔试题.pdf\rJava学习相关电子书籍\\head first javascript中文版.pdf\rJava学习相关电子书籍\\Head First Java中文版(深入浅出Java)[零基础推荐].pdf\rJava学习相关电子书籍\\Head First Servlet JSP(清晰中文版).PDF\rJava学习相关电子书籍\\Head First 设计模式.pdf\rJava学习相关电子书籍\\HttpClient入门.pdf\rJava学习相关电子书籍\\ibatis开发指南.pdf\rJava学习相关电子书籍\\J2EE反模式.pdf\rJava学习相关电子书籍\\Java Collections中的Fail Fast机制.pdf\rJava学习相关电子书籍\\Java Network Programming.pdf\rJava学习相关电子书籍\\Java Web动态图表编程.pdf\rJava学习相关电子书籍\\Java Web开发典型模块大全.pdf\rJava学习相关电子书籍\\Java 编程思想 -- 面向对象逻辑思维.pdf\rJava学习相关电子书籍\\Java.Rules中文版.pdf\rJava学习相关电子书籍\\Java.Web服务开发.pdf\rJava学习相关电子书籍\\JAVA2核心技术第1卷.基础知识7th.pdf\rJava学习相关电子书籍\\Java2网络协议技术内幕.pdf\rJava学习相关电子书籍\\JavaScript王者归来.pdf\rJava学习相关电子书籍\\JavaScript高级程序设计（第3版）中文 高清 完整 (1).pdf\rJava学习相关电子书籍\\JAVA与XML.pdf\rJava学习相关电子书籍\\JAVA优化编程.pdf\rJava学习相关电子书籍\\java入门到详解[推荐].pdf\rJava学习相关电子书籍\\java华为面试题.pdf\rJava学习相关电子书籍\\Java基础与案例开发详解.pdf\rJava学习相关电子书籍\\java基础教程(强烈推荐).pdf\rJava学习相关电子书籍\\Java夜未眠_程序员的心声.pdf\rJava学习相关电子书籍\\java实例详解.pdf\rJava学习相关电子书籍\\Java并发程序设计教程.pdf\rJava学习相关电子书籍\\Java开发利器Myeclipse全面详解.pdf\rJava学习相关电子书籍\\Java开发实战经典.pdf\rJava学习相关电子书籍\\Java数据结构和算法.pdf\rJava学习相关电子书籍\\Java数据结构和算法中文第二版[jb51.net].pdf\rJava学习相关电子书籍\\Java最著名的开源项目.pdf\rJava学习相关电子书籍\\Java核心技术 卷1 基础知识 原书第9版.pdf\rJava学习相关电子书籍\\JAVA核心技术卷2：高级特征.pdf\rJava学习相关电子书籍\\java核心技术，完整中文版.pdf\rJava学习相关电子书籍\\Java线程.pdf\rJava学习相关电子书籍\\Java经典问题答案.pdf\rJava学习相关电子书籍\\Java经典问题答案（带书签）.pdf\rJava学习相关电子书籍\\Java编程及相关书籍.O\u0026amp;#39;Reilly.Creating.Effective.Javahelp.pdf\rJava学习相关电子书籍\\Java编程指南.pdf\rJava学习相关电子书籍\\Java编程规范.pdf\rJava学习相关电子书籍\\Java编辑思想（第四版）..pdf\rJava学习相关电子书籍\\Java网络socket编程详解.pdf\rJava学习相关电子书籍\\Java网络编程技术与实践.pdf\rJava学习相关电子书籍\\Java虚拟机规范（Java SE 7）.pdf\rJava学习相关电子书籍\\Java解惑(中文).pdf\rJava学习相关电子书籍\\Java设计模式之抽象工厂模式.pdf\rJava学习相关电子书籍\\Java语言导学(第3版)CN.pdf\rJava学习相关电子书籍\\Java语言规范中文版(第三版).pdf\rJava学习相关电子书籍\\JAVA面向对象编程(孙卫琴).pdf\rJava学习相关电子书籍\\Java项目开发案例全程实录_第二版_.pdf\rJava学习相关电子书籍\\JDK1.5的泛型实现.pdf\rJava学习相关电子书籍\\jQuery基础教程第四版 (2).pdf\rJava学习相关电子书籍\\jQuery技术内幕：深入解析jQuery架构设计与实现原理.pdf\rJava学习相关电子书籍\\JSTL标签.pdf\rJava学习相关电子书籍\\Oracle与SQLServe..pdf\rJava学习相关电子书籍\\oracle存储过程超详细使用手册..pdf\rJava学习相关电子书籍\\Oracle数据库性能优化.pdf\rJava学习相关电子书籍\\Python Programming With The Java Class Libraries - A Tutorial For Building Web And Enterprise Applications With Jython..pdf\rJava学习相关电子书籍\\Spring.2.0核心技术与最佳实践.廖雪峰.扫描版.pdf\rJava学习相关电子书籍\\Spring基础教程.pdf\rJava学习相关电子书籍\\SPRING开发指南.pdf\rJava学习相关电子书籍\\SSH基础知识 常用命令 配置实例.pdf\rJava学习相关电子书籍\\Struts 2 in Action.pdf\rJava学习相关电子书籍\\Struts中文手册.pdf\rJava学习相关电子书籍\\The Java Virtual Machine Specification, Java SE 7 Edition.pdf\rJava学习相关电子书籍\\Thinking.In.Java(中文版).pdf\rJava学习相关电子书籍\\Windows API开发详解 函数、接口、编程实例.pdf\rJava学习相关电子书籍\\[21天学通Java.6(第5版)].Rogers.Cadenhead\u0026amp;Laura.Lemay.扫描版.pdf\rJava学习相关电子书籍\\[Flex.3实战].（美）艾哈迈德，（美）赫希，（美）阿比德.扫描版.pdf\rJava学习相关电子书籍\\[Java并发编程实践].(Java.Concurrency.in.Practice).Brian.Goetz.文字版(1).pdf\rJava学习相关电子书籍\\[JAVA消息服务].（美）Mark.Richards,.Richard.Monson-Haefel,.David.A.Chappell.文字版.pdf\rJava学习相关电子书籍\\[Java编程及相关书籍].O\u0026amp;#39;Reilly.Creating.Effective.Javahelp.pdf\rJava学习相关电子书籍\\[Java网络编程(第3版,2004)].(Java.Network.Programming).Elliotte.Rusty.Harold.文字版.pdf\rJava学习相关电子书籍\\[Java语言程序设计].(Introduction.to.Java.Programming,.Brief.Version,.8ed),.Liang,.文字版.pdf\rJava学习相关电子书籍\\[代码大全2中文版(完整清晰版)].pdf\rJava学习相关电子书籍\\《Effective JavaScript》扫描版（中文） (3).pdf\rJava学习相关电子书籍\\《SQL查询的艺术》.(张权,郭天娇).[PDF]@jb51.net.pdf\rJava学习相关电子书籍\\《经典JavaEE企业应用实战》 (1).pdf\rJava学习相关电子书籍\\中兴面试题.pdf\rJava学习相关电子书籍\\初学者第1章 对象入门.pdf..pdf\rJava学习相关电子书籍\\北京中软笔试题.pdf\rJava学习相关电子书籍\\华为试题.pdf\rJava学习相关电子书籍\\基于MVC的JavaScript Web富应用开发(完整版).pdf\rJava学习相关电子书籍\\大话数据结构.pdf\rJava学习相关电子书籍\\大话设计模式(1).pdf\rJava学习相关电子书籍\\大话设计模式.pdf\rJava学习相关电子书籍\\实用J2EE设计模式编程指南.pdf\rJava学习相关电子书籍\\实用算法基础教程.pdf\rJava学习相关电子书籍\\广东北电面试题.pdf\rJava学习相关电子书籍\\快速软件开发..pdf\rJava学习相关电子书籍\\排序算法汇总.pdf\rJava学习相关电子书籍\\新手学Java 7编程（第5版）.pdf\rJava学习相关电子书籍\\深入JAVA虚拟机.pdf\rJava学习相关电子书籍\\深入JAVA虚拟机第二版.pdf\rJava学习相关电子书籍\\深入体验Java Web开发内幕——核心基础.pdf\rJava学习相关电子书籍\\深入体验Javaweb开发内幕（高级特性）.pdf\rJava学习相关电子书籍\\深入学习：JFC SWING—JAVA 基础类组件集.pdf\rJava学习相关电子书籍\\王牌1 Java SE 类库查询手册.pdf\rJava学习相关电子书籍\\王牌2 学习成果检测——【练一练】答案.pdf\rJava学习相关电子书籍\\王牌3 Eclipse常用快捷键.pdf\rJava学习相关电子书籍\\王牌4 Eclipse提示与技巧.pdf\rJava学习相关电子书籍\\王牌5 Java程序员职业规划.pdf\rJava学习相关电子书籍\\王牌6 Java程序员面试技巧.pdf\rJava学习相关电子书籍\\王牌7 Java常见面试题.pdf\rJava学习相关电子书籍\\王牌8 扫雷英雄榜——Java常见错误及解决方案.pdf\rJava学习相关电子书籍\\王牌9 优秀程序员之路——Java开发经验及技巧大汇总.pdf\rJava学习相关电子书籍\\百度试题.pdf\rJava学习相关电子书籍\\第10章 Java IO系统.pdf\rJava学习相关电子书籍\\第11章 运行期类型鉴定.pdf\rJava学习相关电子书籍\\第12章 传递和返回对象.pdf\rJava学习相关电子书籍\\第13章 创建窗口和程序片.pdf\rJava学习相关电子书籍\\第14章 多线程.pdf\rJava学习相关电子书籍\\第15章 网络编程(1).pdf\rJava学习相关电子书籍\\第16章 设计范式.pdf\rJava学习相关电子书籍\\第17章 项目.pdf\rJava学习相关电子书籍\\第2章 一切都是对象.pdf\rJava学习相关电子书籍\\第3章 控制程序流程.pdf\rJava学习相关电子书籍\\第4章 初始化和清除.pdf\rJava学习相关电子书籍\\第5章 隐藏实施过程.pdf\rJava学习相关电子书籍\\第6章 类再生.pdf\rJava学习相关电子书籍\\第7章 多形性.pdf\rJava学习相关电子书籍\\第8章 对象的容纳.pdf\rJava学习相关电子书籍\\第9章 异常差错控制.pdf\rJava学习相关电子书籍\\算法与数据结构-实用算法基础教程.pdf\rJava学习相关电子书籍\\算法导论.pdf\rJava学习相关电子书籍\\精通JavaScript动态网页编程(实例版).pdf\rJava学习相关电子书籍\\精通JavaScript（中文清晰优化版）.pdf\rJava学习相关电子书籍\\精通spring - Mastering Spring.pdf\rJava学习相关电子书籍\\精通Struts基于MVC的Java Web设计与开发(1).pdf\rJava学习相关电子书籍\\精通Struts基于MVC的Java Web设计与开发.pdf\rJava学习相关电子书籍\\经典查询练手.pdf\rJava学习相关电子书籍\\编程之美-完整版.pdf\rJava学习相关电子书籍\\网易笔试题.pdf\rJava学习相关电子书籍\\网站开发前台后台技术指南.pdf\rJava学习相关电子书籍\\罗时飞.精通spring.pdf\rJava学习相关电子书籍\\腾讯试题.pdf\rJava学习相关电子书籍\\解析Java虚拟机器开发：权衡优化、高效和安全的最优方案.pdf\rJava学习相关电子书籍\\计算机导论与JavaScript编程(第3版).pdf\rJava学习相关电子书籍\\设计模式：Java语言中的应用.pdf\rJava学习相关电子书籍\\迅雷笔试题.pdf\rJava学习相关电子书籍\\重构-改善既有代码的设计.pdf\rJava学习相关电子书籍\\重构_改善既有代码的设计[高清版]..pdf\rJava学习相关电子书籍\\附录A 使用非JAVA代码.pdf\rJava学习相关电子书籍\\附录B 对比C++和java.pdf\rJava学习相关电子书籍\\附录C Java编程规则.pdf\rJava学习相关电子书籍\\附录D 性能.pdf\rJava学习相关电子书籍\\附录E 关于垃圾收集的一些话.pdf\rJava学习相关电子书籍\\高效程序员的45个习惯：敏捷开发修炼之道.pdf\rJava学习相关电子书籍\\黑客入门(超级详细版).pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\100道趣题.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\15天学会jQuery(0-5).pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\15天学会jQuery(11-15).pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\15天学会jQuery(6-10).pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\15天学会jquery(完整版).pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\css权威指南.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\CSS禅意花园.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\CSS网站布局实录 （第二版）.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\Head First HTML与CSS、XHTML （中文版）.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\HTML5高级程序设计 [西林街 - 千万亿网盘资源 www.xilinjie.com].pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\HTML_5从入门到精通.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\JavaScript DOM编程艺术（中文第二版）.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\JavaScript.DOM高级程序设计.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\JavaScript设计模式.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\JavaScript语言精粹_修订版.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\JavaScript高级程序设计（第3版）中文 高清 完整.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\JQUERY权威指南（完整版）.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\ppk谈JavaScript.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\Secrets of the JavaScript Ninja.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\[HTML5游戏开发].(Jeanine Meyer).徐阳等.扫描版.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\[HTML5资料]Canvas入门基础教程.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\[JavaScript高级程序设计(第2版)].（美）泽卡斯.扫描版.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\[jQuery攻略].(印)哈瓦尼.扫描版.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\[JQuery菜鸟到忍者].Sitepoint.jQuery.Novice.to.Ninja.Feb.2010.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\[ppk谈JavaScript].(荷)科克.扫描版(第一部分).pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\[web开发CSS系列].Apress.Pro.CSS.Techniques.Nov.2006.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\[web开发CSS系列].SitePoint.Everything.You.Know.About.CSS.is.Wrong.Oct.2008.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\[web开发CSS系列].The.Art.and.Science.of.CSS.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\[web开发CSS系列].The.Principles.of.Beautiful.Web.Design.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\[web开发CSS系列].The.Ultimate.CSS.Reference.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\[web开发CSS系列].UIdesignForMereMortals.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\[web开发CSS系列].WebDevelopmentSolutions.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\[大家网]高性能网站建设指南[www.TopSage.com].pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\[深入浅出Javascript].O'reilly.Head.First.Javascript.Jan.2008.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\[精通CSS高级Web标准解决方案].CSS.Mastery.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\[网页重构xhtml.css].Ajax.In.Action.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\[网页重构xhtml.css].Bulletproof_Web_Design.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\[网页重构xhtml.css].css.hack.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\[网页重构xhtml.css].css.mastery.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\[高性能网站建设指南——前端工程师技能精粹(英文原版)].O'Reilly.High.Performance.Web.Sites.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\[高性能网站建设进阶指南].(Even.Faster.Web.Sites).Steve.Souders.文字版.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\[高流量网站的CSS设计].(Pro.CSS.for.High.Traffic.Websites).A.Kennedy\u0026amp;I.d.Leon.文字版.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\大巧不工Web前端设计修炼之道 [西林街 - 千万亿网盘资源 www.xilinjie.com].pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\悟透JavaScript.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\淘宝的HTML5实践.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\用AngularJS开发下一代Web应用.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\瞬间之美 Web界面设计如何让用户心动.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\精彩绝伦的CSS.pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\精通JavaScript(图灵计算机科学丛书).pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\网站重构—应用Web标准进行设计[中文版].pdf\rJava学习相关电子书籍\\JavaWEB(htmi,css）、JavaScript、jQuery等相关书籍\\高性能JavaScript.pdf\r复制了 208 个文件\rJavaWEB(htmi,css）、JavaScript、jQuery等相关书籍 这个就是子文件夹\rxcopy D:\\CS E:\\kk\\ /s/c\r 文件重命名命令 ren sourceFileName targetFileName  E:\\temp\\cc\u0026gt;ren d.txt d2.txt;\rE:\\temp\\cc\u0026gt;type d2.txt\rthis is a text file\r 文件移动命令(剪贴命令) move fileName path+FileName  E:\\temp\\cc\u0026gt;move d2.txt E:\\temp\\kk\r移动了 1 个文件。\r 文件删除操作 del fileName  E:\\temp\\kk\u0026gt;dir\r驱动器 E 中的卷是 新加卷\r卷的序列号是 64E8-4ABF\rE:\\temp\\kk 的目录\r2020/02/14 19:10 \u0026lt;DIR\u0026gt; .\r2020/02/14 19:10 \u0026lt;DIR\u0026gt; ..\r2020/02/14 18:59 19 d2.txt\r1 个文件 19 字节\r2 个目录 264,645,689,344 可用字节\rE:\\temp\\kk\u0026gt;del d2.txt\rE:\\temp\\kk\u0026gt;dir\r驱动器 E 中的卷是 新加卷\r卷的序列号是 64E8-4ABF\rE:\\temp\\kk 的目录\r2020/02/14 19:12 \u0026lt;DIR\u0026gt; .\r2020/02/14 19:12 \u0026lt;DIR\u0026gt; ..\r0 个文件 0 字节\r2 个目录 264,645,689,344 可用字节\r 删除特定文件夹下的文件  E:\\temp\u0026gt;del kk\rE:\\temp\\kk\\*, 是否确认(Y/N)? Y\r删除kk文件夹下所以的文件\r 文件夹删除 rd /s path  E:\\temp\\kk\u0026gt;rd /s dg\rdg, 是否确认(Y/N)? Y\r 文件夹删除 rd path  PS E:\\temp\u0026gt; dir 目录: E:\\temp\rMode LastWriteTime Length Name\r---- ------------- ------ ----\rd----- 2020/2/15 10:40 cc\rd----- 2020/2/15 12:01 kk\r-a---- 2020/2/14 18:59 19 d2.txt\rPS E:\\temp\u0026gt; rd cc  dos命令下正则表达式有效  D:\\ter\u0026gt;del *.txt ;\r","pubDate":"2021-02-15","title":"DOS \u003e file"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_windows_dos_network/","plain":"DOS网络操作命令  netstat -ano (列出所有端口的情况)  PS C:\\Users\\noatn\u0026gt; netstat -ano\r活动连接\r协议 本地地址 外部地址 状态 PID\rTCP 0.0.0.0:135 0.0.0.0:0 LISTENING 1028\rTCP 0.0.0.0:445 0.0.0.0:0 LISTENING 4\rTCP 0.0.0.0:1024 0.0.0.0:0 LISTENING 852\rTCP 0.0.0.0:1025 0.0.0.0:0 LISTENING 2232\rTCP 0.0.0.0:3306 0.0.0.0:0 LISTENING 3672\rTCP 0.0.0.0:5040 0.0.0.0:0 LISTENING 5660\rTCP 0.0.0.0:7680 0.0.0.0:0 LISTENING 6628\rTCP 0.0.0.0:49664 0.0.0.0:0 LISTENING 868\rTCP 0.0.0.0:49665 0.0.0.0:0 LISTENING 784\rTCP 0.0.0.0:49666 0.0.0.0:0 LISTENING 1580\rTCP 0.0.0.0:49667 0.0.0.0:0 LISTENING 1316\rTCP 127.0.0.1:1036 0.0.0.0:0 LISTENING 2536\rTCP 127.0.0.1:1155 127.0.0.1:1156 ESTABLISHED 1204\rTCP 127.0.0.1:1156 127.0.0.1:1155 ESTABLISHED 1204\rTCP 127.0.0.1:1157 127.0.0.1:1158 ESTABLISHED 1204\rTCP 127.0.0.1:1158 127.0.0.1:1157 ESTABLISHED 1204\rTCP 127.0.0.1:6942 0.0.0.0:0 LISTENING 1204\rTCP 127.0.0.1:10000 0.0.0.0:0 LISTENING 3556\rTCP 127.0.0.1:63342 0.0.0.0:0 LISTENING 1204\rTCP 192.168.31.208:139 0.0.0.0:0 LISTENING 4\rTCP 192.168.31.208:3810 104.18.25.243:80 ESTABLISHED 6976\rTCP 192.168.31.208:4258 13.107.3.254:443 ESTABLISHED 6976\rTCP 192.168.31.208:4368 40.90.189.152:443 ESTABLISHED 3700\rTCP 192.168.31.208:4571 111.231.211.246:443 FIN_WAIT_1 9324\rTCP 192.168.31.208:4589 111.12.62.190:443 LAST_ACK 9324\rTCP 192.168.31.208:4593 185.199.108.153:443 FIN_WAIT_1 9324\rTCP 192.168.31.208:4595 112.25.253.5:443 ESTABLISHED 9324\rTCP 192.168.31.208:4596 223.85.58.79:443 CLOSE_WAIT 9324\rTCP 192.168.31.208:4600 223.85.58.79:443 LAST_ACK 9324\rTCP 192.168.31.208:4602 192.144.173.136:7823 ESTABLISHED 9324\rTCP 192.168.31.208:4609 192.30.252.153:80 LAST_ACK 9324\rTCP 192.168.31.208:4610 192.30.252.153:80 LAST_ACK 9324\rTCP 192.168.31.208:4611 192.30.252.153:80 LAST_ACK 9324\rTCP 192.168.31.208:4616 209.197.3.24:443 LAST_ACK 9324\rTCP 192.168.31.208:4617 140.205.33.7:443 TIME_WAIT 0\rTCP [::]:135 [::]:0 LISTENING 1028\rTCP [::]:445 [::]:0 LISTENING 4\rTCP [::]:1024 [::]:0 LISTENING 852\rTCP [::]:1025 [::]:0 LISTENING 2232\rTCP [::]:3306 [::]:0 LISTENING 3672\rTCP [::]:7680 [::]:0 LISTENING 6628\rTCP [::]:49664 [::]:0 LISTENING 868\rTCP [::]:49665 [::]:0 LISTENING 784\rTCP [::]:49666 [::]:0 LISTENING 1580\rTCP [::]:49667 [::]:0 LISTENING 1316\rUDP 0.0.0.0:500 *:* 3540\rUDP 0.0.0.0:4500 *:* 3540\rUDP 0.0.0.0:5050 *:* 5660\rUDP 0.0.0.0:5353 *:* 6324\rUDP 0.0.0.0:5353 *:* 9324\rUDP 0.0.0.0:5353 *:* 6324\rUDP 0.0.0.0:5353 *:* 8372\rUDP 0.0.0.0:5353 *:* 10032\rUDP 0.0.0.0:5353 *:* 10032\rUDP 0.0.0.0:5353 *:* 9324\rUDP 0.0.0.0:5353 *:* 8372\rUDP 0.0.0.0:5353 *:* 2076\rUDP 0.0.0.0:5355 *:* 2076\rUDP 0.0.0.0:49665 *:* 3636\rUDP 0.0.0.0:57076 *:* 2076\rUDP 0.0.0.0:58215 *:* 2076\rUDP 127.0.0.1:1900 *:* 9868\rUDP 127.0.0.1:40000 *:* 3556\rUDP 127.0.0.1:49664 *:* 4008\rUDP 127.0.0.1:51112 *:* 6976\rUDP 127.0.0.1:62732 *:* 9868\rUDP 192.168.31.208:137 *:* 4\rUDP 192.168.31.208:138 *:* 4\rUDP 192.168.31.208:1900 *:* 9868\rUDP 192.168.31.208:2177 *:* 8424\rUDP 192.168.31.208:62731 *:* 9868\rUDP [::]:500 *:* 3540\rUDP [::]:4500 *:* 3540\rUDP [::]:5353 *:* 6324\rUDP [::]:5353 *:* 2076\rUDP [::]:5353 *:* 8372\rUDP [::]:5353 *:* 10032\rUDP [::]:5353 *:* 9324\rUDP [::]:5355 *:* 2076\rUDP [::]:57076 *:* 2076\rUDP [::]:58215 *:* 2076\rUDP [::1]:1900 *:* 9868\rUDP [::1]:62730 *:* 9868\rUDP [fe80::6d6c:6e66:c80:456b%16]:1900 *:* 9868\rUDP [fe80::6d6c:6e66:c80:456b%16]:2177 *:* 8424\rUDP [fe80::6d6c:6e66:c80:456b%16]:62729 *:* 9868\r 查看被占用端口对应的PID，输入命令： netstat -ano|findstr \u0026lsquo;3306\u0026rsquo; ，回车，记下最后一位数字，即PID,这里是3672  PS C:\\Users\\noatn\u0026gt; netstat -ano|findstr '3306' TCP 0.0.0.0:3306 0.0.0.0:0 LISTENING 3672\rTCP [::]:3306 [::]:0 LISTENING 3672\r ipconfig用法  PS C:\\WINDOWS\\system32\u0026gt; ipconfig /?\r用法:\ripconfig [/allcompartments] [/? | /all |\r/renew [adapter] | /release [adapter] |\r/renew6 [adapter] | /release6 [adapter] |\r/flushdns | /displaydns | /registerdns |\r/showclassid adapter |\r/setclassid adapter [classid] |\r/showclassid6 adapter |\r/setclassid6 adapter [classid] ]\r其中\radapter 连接名称\r(允许使用通配符 * 和 ?，参见示例)\r选项:\r/? 显示此帮助消息\r/all 显示完整配置信息。\r/release 释放指定适配器的 IPv4 地址。\r/release6 释放指定适配器的 IPv6 地址。\r/renew 更新指定适配器的 IPv4 地址。\r/renew6 更新指定适配器的 IPv6 地址。\r/flushdns 清除 DNS 解析程序缓存。\r/registerdns 刷新所有 DHCP 租用并重新注册 DNS 名称\r/displaydns 显示 DNS 解析程序缓存的内容。\r/showclassid 显示适配器允许的所有 DHCP 类 ID。\r/setclassid 修改 DHCP 类 ID。\r/showclassid6 显示适配器允许的所有 IPv6 DHCP 类 ID。\r/setclassid6 修改 IPv6 DHCP 类 ID。\r默认情况下，仅显示绑定到 TCP/IP 的每个适配器的 IP 地址、子网掩码和\r默认网关。\r对于 Release 和 Renew，如果未指定适配器名称，则会释放或更新所有绑定\r到 TCP/IP 的适配器的 IP 地址租用。\r对于 Setclassid 和 Setclassid6，如果未指定 ClassId，则会删除 ClassId。\r示例:\r\u0026gt; ipconfig ... 显示信息\r\u0026gt; ipconfig /all ... 显示详细信息\r\u0026gt; ipconfig /renew ... 更新所有适配器\r\u0026gt; ipconfig /renew EL* ... 更新所有名称以 EL 开头\r的连接\r\u0026gt; ipconfig /release *Con* ... 释放所有匹配的连接，\r例如“有线以太网连接 1”或\r“有线以太网连接 2”\r\u0026gt; ipconfig /allcompartments ... 显示有关所有隔离舱的\r信息\r\u0026gt; ipconfig /allcompartments /all ... 显示有关所有隔离舱的\r详细信息\r1.显示网络协议配置 ipconfig 如果要查看跟详细的网络配置信息 /all 包括MAC地址、IP地址、子网掩码、默认网关、DNS\r2.更新IP地址 ipconfig/renew\r3.初始化网络配置 ipconfig/registerdns 将网络状态还原到初始状态\r4.显示本地DNS信息 ipconfig/displaydns\r5.清除本地DNS缓存内容 ipconfig/flushdns\r6.取消IP地址租用 ipconfig/release DHCP服务器：动态获取到IP地址及其他网络设置\r7.备份网络设置 ipconfig/all\u0026gt;c:\\bak.txt 将所有网络配置信息备份到bak.txt中\r ipconfig 举例用法 显示本地DNS信息  PS C:\\WINDOWS\\system32\u0026gt; ipconfig /displaydns\rWindows IP 配置\r1.0.0.127.in-addr.arpa\r----------------------------------------\r记录名称. . . . . . . : 1.0.0.127.in-addr.arpa.\r记录类型. . . . . . . : 12\r生存时间. . . . . . . : 540319\r数据长度. . . . . . . : 8\r部分. . . . . . . . . : 答案\rPTR 记录 . . . . . . : www.xmind.net\rroot-c3-ca2-2009.ocsp.d-trust.net\r----------------------------------------\r记录名称. . . . . . . : root-c3-ca2-2009.ocsp.d-trust.net\r记录类型. . . . . . . : 5\r生存时间. . . . . . . : 9\r数据长度. . . . . . . : 8\r部分. . . . . . . . . : 答案\rCNAME 记录 . . . . . : ocsp.d-trust.net\r记录名称. . . . . . . : ocsp.d-trust.net\r记录类型. . . . . . . : 1\r生存时间. . . . . . . : 9\r数据长度. . . . . . . : 4\r部分. . . . . . . . . : 答案\rA (主机)记录 . . . . : 213.61.227.196\rhm.baidu.com\r----------------------------------------\r记录名称. . . . . . . : hm.baidu.com\r记录类型. . . . . . . : 5\r生存时间. . . . . . . : 194\r数据长度. . . . . . . : 8\r部分. . . . . . . . . : 答案\rCNAME 记录 . . . . . : hm.e.shifen.com\r记录名称. . . . . . . : hm.e.shifen.com\r记录类型. . . . . . . : 1\r生存时间. . . . . . . : 194\r数据长度. . . . . . . : 4\r部分. . . . . . . . . : 答案\rA (主机)记录 . . . . : 39.156.66.179\rwww.xmind.net\r----------------------------------------\r没有 AAAA 类型的记录\rwww.xmind.net\r----------------------------------------\r记录名称. . . . . . . : www.xmind.net\r记录类型. . . . . . . : 1\r生存时间. . . . . . . : 540319\r数据长度. . . . . . . : 4\r部分. . . . . . . . . : 答案\rA (主机)记录 . . . . : 127.0.0.1\rzhidao.baidu.com\r----------------------------------------\r记录名称. . . . . . . : zhidao.baidu.com\r记录类型. . . . . . . : 5\r生存时间. . . . . . . : 20\r数据长度. . . . . . . : 8\r部分. . . . . . . . . : 答案\rCNAME 记录 . . . . . : iknow.baidu.com\r记录名称. . . . . . . : iknow.baidu.com\r记录类型. . . . . . . : 5\r生存时间. . . . . . . : 20\r数据长度. . . . . . . : 8\r部分. . . . . . . . . : 答案\rCNAME 记录 . . . . . : iknow.n.shifen.com\r记录名称. . . . . . . : iknow.n.shifen.com\r记录类型. . . . . . . : 1\r生存时间. . . . . . . : 20\r数据长度. . . . . . . : 4\r部分. . . . . . . . . : 答案\rA (主机)记录 . . . . : 112.34.111.123\rblog.csdn.net\r----------------------------------------\r记录名称. . . . . . . : blog.csdn.net\r记录类型. . . . . . . : 1\r生存时间. . . . . . . : 3\r数据长度. . . . . . . : 4\r部分. . . . . . . . . : 答案\rA (主机)记录 . . . . : 47.95.47.253\radservice.google.com\r----------------------------------------\r记录名称. . . . . . . : adservice.google.com\r记录类型. . . . . . . : 5\r生存时间. . . . . . . : 11\r数据长度. . . . . . . : 8\r部分. . . . . . . . . : 答案\rCNAME 记录 . . . . . : pagead46.l.doubleclick.net\r记录名称. . . . . . . : pagead46.l.doubleclick.net\r记录类型. . . . . . . : 1\r生存时间. . . . . . . : 11\r数据长度. . . . . . . : 4\r部分. . . . . . . . . : 答案\rA (主机)记录 . . . . : 203.208.50.58\r记录名称. . . . . . . : pagead46.l.doubleclick.net\r记录类型. . . . . . . : 1\r生存时间. . . . . . . : 11\r数据长度. . . . . . . : 4\r部分. . . . . . . . . : 答案\rA (主机)记录 . . . . : 203.208.50.57\r记录名称. . . . . . . : pagead46.l.doubleclick.net\r记录类型. . . . . . . : 1\r生存时间. . . . . . . : 11\r数据长度. . . . . . . : 4\r部分. . . . . . . . . : 答案\rA (主机)记录 . . . . : 203.208.50.45\r 检测自己的ip ipconfig  C:\\Users\\noatn\u0026gt;ipconfig\rWindows IP 配置\r以太网适配器 以太网:\r媒体状态 . . . . . . . . . . . . : 媒体已断开连接\r连接特定的 DNS 后缀 . . . . . . . :\r无线局域网适配器 本地连接* 1:\r媒体状态 . . . . . . . . . . . . : 媒体已断开连接\r连接特定的 DNS 后缀 . . . . . . . :\r无线局域网适配器 本地连接* 2:\r媒体状态 . . . . . . . . . . . . : 媒体已断开连接\r连接特定的 DNS 后缀 . . . . . . . :\r以太网适配器 以太网 2:\r媒体状态 . . . . . . . . . . . . : 媒体已断开连接\r连接特定的 DNS 后缀 . . . . . . . :\r无线局域网适配器 WLAN:\r连接特定的 DNS 后缀 . . . . . . . :\r本地链接 IPv6 地址. . . . . . . . : fe80::6d6c:6e66:c80:456b%16\rIPv4 地址 . . . . . . . . . . . . : 192.168.31.208\r子网掩码 . . . . . . . . . . . . : 255.255.255.0\r默认网关. . . . . . . . . . . . . : 192.168.31.1\r   \r 检测是否连上外网 ping url  C:\\Users\\noatn\u0026gt;ping 192.168.31.208\r正在 Ping 192.168.31.208 具有 32 字节的数据:\r来自 192.168.31.208 的回复: 字节=32 时间\u0026lt;1ms TTL=128\r来自 192.168.31.208 的回复: 字节=32 时间\u0026lt;1ms TTL=128\r来自 192.168.31.208 的回复: 字节=32 时间\u0026lt;1ms TTL=128\r来自 192.168.31.208 的回复: 字节=32 时间\u0026lt;1ms TTL=128\r192.168.31.208 的 Ping 统计信息:\r数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，\r往返行程的估计时间(以毫秒为单位):\r最短 = 0ms，最长 = 0ms，平均 = 0ms\rC:\\Users\\noatn\u0026gt;ping www.baidu.com\r正在 Ping www.baidu.com [39.156.66.14] 具有 32 字节的数据:\r来自 39.156.66.14 的回复: 字节=32 时间=152ms TTL=50\r来自 39.156.66.14 的回复: 字节=32 时间=821ms TTL=50\r来自 39.156.66.14 的回复: 字节=32 时间=76ms TTL=50\r来自 39.156.66.14 的回复: 字节=32 时间=157ms TTL=50\r39.156.66.14 的 Ping 统计信息:\r数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，\r往返行程的估计时间(以毫秒为单位):\r最短 = 76ms，最长 = 821ms，平均 = 301ms\r这个网络情况就是不好的样子time\u0026gt;821毫秒了 ==就是延迟821毫秒\r 清屏命令 cls   C:\\Users\\noatn\u0026gt;dir\r驱动器 C 中的卷没有标签。\r卷的序列号是 1CE3-274F\rC:\\Users\\noatn 的目录\r2020/02/14 18:32 \u0026lt;DIR\u0026gt; .\r2020/02/14 18:32 \u0026lt;DIR\u0026gt; ..\r2020/01/24 13:55 \u0026lt;DIR\u0026gt; .android\r2020/01/23 08:12 100 .gitconfig\r2019/12/19 20:15 \u0026lt;DIR\u0026gt; .IntelliJIdea2017.3\r2020/01/26 17:53 \u0026lt;DIR\u0026gt; .m2\r2020/02/14 18:32 \u0026lt;DIR\u0026gt; .oracle_jre_usage\r2020/01/23 08:14 \u0026lt;DIR\u0026gt; .ssh\r2020/01/14 23:17 \u0026lt;DIR\u0026gt; .translation\r2020/01/20 21:52 \u0026lt;DIR\u0026gt; .vscode\r2020/01/11 16:34 \u0026lt;DIR\u0026gt; 3D Objects\r2020/01/11 16:34 \u0026lt;DIR\u0026gt; Contacts\r2020/02/14 18:32 \u0026lt;DIR\u0026gt; Desktop\r2020/02/14 17:57 \u0026lt;DIR\u0026gt; Documents\r2020/02/14 18:47 \u0026lt;DIR\u0026gt; Downloads\r2020/01/11 16:34 \u0026lt;DIR\u0026gt; Favorites\r2020/01/11 16:34 \u0026lt;DIR\u0026gt; Links\r2020/01/11 16:34 \u0026lt;DIR\u0026gt; Music\r2020/02/14 10:57 \u0026lt;DIR\u0026gt; OneDrive\r2020/01/22 21:45 \u0026lt;DIR\u0026gt; Pictures\r2020/01/11 16:34 \u0026lt;DIR\u0026gt; Saved Games\r2020/01/11 16:34 \u0026lt;DIR\u0026gt; Searches\r2020/01/11 16:34 \u0026lt;DIR\u0026gt; Videos\r1 个文件 100 字节\r22 个目录 91,425,759,232 可用字节\rC:\\Users\\noatn\u0026gt;cls;\r然后就没有任何了\r 系统情况查看 systeminfo  //这里切记不要输入;\rC:\\Users\\noatn\u0026gt;systeminfo\r主机名: DESKTOP-GN2SF7M\rOS 名称: Microsoft Windows 10 家庭中文版\rOS 版本: 10.0.18363 暂缺 Build 18363\rOS 制造商: Microsoft Corporation\rOS 配置: 独立工作站\rOS 构件类型: Multiprocessor Free\r注册的所有人: noatnu@163.com\r注册的组织: 暂缺\r产品 ID: 00342-35097-36011-AAOEM\r初始安装日期: 2019/12/18, 21:19:37\r系统启动时间: 2020/2/14, 18:40:59\r系统制造商: LENOVO\r系统型号: 20KSA00FCD\r系统类型: x64-based PC\r处理器: 安装了 1 个处理器。\r[01]: Intel64 Family 6 Model 142 Stepping 10 GenuineIntel ~1801 Mhz\rBIOS 版本: LENOVO R0PET42W (1.19 ), 2018/6/14\rWindows 目录: C:\\WINDOWS\r系统目录: C:\\WINDOWS\\system32\r启动设备: \\Device\\HarddiskVolume5\r系统区域设置: zh-cn;中文(中国)\r输入法区域设置: zh-cn;中文(中国)\r时区: (UTC+08:00) 北京，重庆，香港特别行政区，乌鲁木齐\r物理内存总量: 16,281 MB\r可用的物理内存: 10,187 MB\r虚拟内存: 最大值: 18,713 MB\r虚拟内存: 可用: 11,653 MB\r虚拟内存: 使用中: 7,060 MB\r页面文件位置: C:\\pagefile.sys\r域: WORKGROUP\r登录服务器: \\\\DESKTOP-GN2SF7M\r修补程序: 安装了 9 个修补程序。\r[01]: KB4534132\r[02]: KB4513661\r[03]: KB4516115\r[04]: KB4517245\r[05]: KB4521863\r[06]: KB4524569\r[07]: KB4528759\r[08]: KB4537759\r[09]: KB4528760\r网卡: 安装了 3 个 NIC。\r[01]: Realtek PCIe GbE Family Controller\r连接名: 以太网\r状态: 媒体连接已中断\r[02]: Realtek 8821CE Wireless LAN 802.11ac PCI-E NIC\r连接名: WLAN\r启用 DHCP: 是\rDHCP 服务器: 192.168.31.1\rIP 地址\r[01]: 192.168.31.208\r[02]: fe80::6d6c:6e66:c80:456b\r[03]: Sangfor SSL VPN CS Support System VNIC\r连接名: 以太网 2\r状态: 媒体连接已中断\rHyper-V 要求: 虚拟机监视器模式扩展: 是\r固件中已启用虚拟化: 否\r二级地址转换: 是\r数据执行保护可用: 是\r//具体用法\rC:\\Users\\noatn\u0026gt;SYSTEMINFO /?\rSYSTEMINFO [/S system [/U username [/P [password]]]] [/FO format] [/NH]\r描述:\r该工具显示本地或远程机器(包括服务包级别)的操作系统配置的信息。\r参数列表:\r/S system 指定要连接的远程系统。\r/U [domain\\]user 指定应该在哪个用户上下文执行命令。\r/P [password] 指定给定用户上下文的密码。如果省略则\r提示输入。\r/FO format 指定显示结果的格式。\r有效值: \u0026quot;TABLE\u0026quot;、\u0026quot;LIST\u0026quot;、\u0026quot;CSV\u0026quot;。\r/NH 指定“列标题”不应该在输出中显示。\r只对 \u0026quot;TABLE\u0026quot; 和 \u0026quot;CSV\u0026quot; 格式有效。\r/? 显示帮助消息。\r例如:\rSYSTEMINFO\rSYSTEMINFO /?\rSYSTEMINFO /S system\rSYSTEMINFO /S system /U user\rSYSTEMINFO /S system /U domain\\user /P password /FO TABLE\rSYSTEMINFO /S system /FO LIST\rSYSTEMINFO /S system /FO CSV /NH\r  内存查看 mem (部分windows不支持了或者缺失此条程序)\n  磁盘检测 chkdsk D:\n  PS C:\\WINDOWS\\system32\u0026gt; chkdsk /?\r检查磁盘并显示状态报告。\rCHKDSK [volume[[path]filename]]] [/F] [/V] [/R] [/X] [/I] [/C] [/L[:size]] [/B] [/scan] [/spotfix]\rvolume 指定驱动器号(后面跟一个冒号)、\r装入点或卷名。\rfilename 仅 FAT/FAT32: 指定要检查\r碎片的文件。\r/F 修复磁盘上的错误。\r/V 在 FAT/FAT32 上: 显示磁盘上每个文件的\r完整路径和名称。\r在 NTFS 上: 显示清理消息(如果有)。\r/R 查找坏扇区并恢复可读信息\r(未指定 /scan 时，隐含 /F)。\r/L:size 仅 NTFS: 将日志文件大小更改为指定\r的 KB 数。如果未指定大小，则显示\r当前大小。\r/X 如果必要，则先强制卸除卷。\r该卷的所有打开的句柄都将无效\r(隐含 /F)。\r/I 仅 NTFS: 对索引项进行强度较小的\r检查。\r/C 仅 NTFS: 跳过文件夹结构内的\r循环检查。\r/B 仅 NTFS: 重新评估该卷上的坏簇\r(隐含 /R)\r/scan 仅 NTFS: 在卷上运行联机扫描\r/forceofflinefix 仅 NTFS: (必须与 \u0026quot;/scan\u0026quot; 一起使用)\r跳过所有联机修复；找到的所有故障都\r排队等待脱机修复(即 \u0026quot;chkdsk /spotfix\u0026quot;)。\r/perf 仅 NTFS: (必须与 \u0026quot;/scan\u0026quot; 一起使用)\r使用更多系统资源尽快完成\r扫描。这可能会对系统中运行的其他任务的性能\r造成负面影响。\r/spotfix 仅 NTFS: 在卷上运行点修复\r/sdcleanup 仅 NTFS: 回收不需要的安全描述符\r数据(隐含 /F)。\r/offlinescanandfix 在卷上运行脱机扫描并进行修复。\r/freeorphanedchains 仅 FAT/FAT32/exFAT: 释放所有孤立的簇链\r而不恢复其内容。\r/markclean 仅 FAT/FAT32/exFAT: 如果未检测到损坏，则将卷\r标记为干净，即使未指定 /F 也是如此。\r/I 或 /C 开关通过跳过对卷的某些检查，\r来减少运行 Chkdsk 所需的时间。\rE:\\temp\u0026gt;chkdsk D:\r访问被拒绝，因为你没有足够的权限，或\r该磁盘可能被另一个进程锁定。\r你必须调用这一在提升模式下运行的实用工具\r并确保磁盘处于解锁状态。\r采用管理员登陆\rPS C:\\WINDOWS\\system32\u0026gt; chkdsk d:\r文件系统的类型是 NTFS。\r卷标是 新加卷。\r警告! 未指定 /F 参数。\r将在只读模式下运行 CHKDSK。\r阶段 1: 检查基本文件系统结构...\r已处理 143872 个文件记录。\r文件验证完成。\r已处理 37 个大型文件记录。\r已处理 0 个错误的文件记录。\r阶段 2: 检查文件名链接...\r已处理 92 个重新解析记录。\r已处理 178806 个索引项。\r索引验证完成。\r已扫描到 0 个未索引文件。\r已将 0 个未编制索引的文件恢复到回收箱。\r已处理 92 个重新解析记录。\r阶段 3: 检查安全描述符...\r安全描述符验证完成。\r已处理 17467 个数据文件。\rWindows 已扫描文件系统并且没有发现问题。\r无需采取进一步操作。\r总共有 307199999 KB 磁盘空间。\r79964 个文件中有 26412124 KB。\r17469 个索引 18832 KB。\r坏扇区 0 KB。\r系统正在使用 219231 KB。\r日志文件占用了 65536 KB。\r磁盘上 280549812 KB 可用。\r每个分配单元中有 4096 字节。\r磁盘上共有 76799999 个分配单元。\r磁盘上有 70137453 个可用的分配单元。\r dos 版本  E:\\temp\u0026gt;ver\rMicrosoft Windows [版本 10.0.18363.592]\r 探测对方计算机名  netstat -a 192.168.2.8\rPS C:\\Users\\noatn\u0026gt; netstat -a 192.168.2.8\r活动连接\r协议 本地地址 外部地址 状态\rTCP 0.0.0.0:135 DESKTOP-GN2SF7M:0 LISTENING\rTCP 0.0.0.0:445 DESKTOP-GN2SF7M:0 LISTENING\rTCP 0.0.0.0:1024 DESKTOP-GN2SF7M:0 LISTENING\rTCP 0.0.0.0:1025 DESKTOP-GN2SF7M:0 LISTENING\rTCP 0.0.0.0:3306 DESKTOP-GN2SF7M:0 LISTENING\rTCP 0.0.0.0:5040 DESKTOP-GN2SF7M:0 LISTENING\rTCP 0.0.0.0:7680 DESKTOP-GN2SF7M:0 LISTENING\rTCP 0.0.0.0:49664 DESKTOP-GN2SF7M:0 LISTENING\rTCP 0.0.0.0:49665 DESKTOP-GN2SF7M:0 LISTENING\rTCP 0.0.0.0:49666 DESKTOP-GN2SF7M:0 LISTENING\rTCP 0.0.0.0:49667 DESKTOP-GN2SF7M:0 LISTENING\rTCP 127.0.0.1:1036 DESKTOP-GN2SF7M:0 LISTENING\rTCP 127.0.0.1:1155 www:1156 ESTABLISHED\rTCP 127.0.0.1:1156 www:nfa ESTABLISHED\rTCP 127.0.0.1:1157 www:1158 ESTABLISHED\rTCP 127.0.0.1:1158 www:1157 ESTABLISHED\rTCP 127.0.0.1:6942 DESKTOP-GN2SF7M:0 LISTENING\rTCP 127.0.0.1:10000 DESKTOP-GN2SF7M:0 LISTENING\rTCP 127.0.0.1:63342 DESKTOP-GN2SF7M:0 LISTENING\rTCP 192.168.31.208:139 DESKTOP-GN2SF7M:0 LISTENING\r 快速诊断网卡故障 ping 127.0.0.1  PS C:\\WINDOWS\\system32\u0026gt; ping 127.0.0.1; 正在 Ping 127.0.0.1 具有 32 字节的数据:\r来自 127.0.0.1 的回复: 字节=32 时间\u0026lt;1ms TTL=128\r来自 127.0.0.1 的回复: 字节=32 时间\u0026lt;1ms TTL=128\r来自 127.0.0.1 的回复: 字节=32 时间\u0026lt;1ms TTL=128\r来自 127.0.0.1 的回复: 字节=32 时间\u0026lt;1ms TTL=128\r127.0.0.1 的 Ping 统计信息:\r数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，\r往返行程的估计时间(以毫秒为单位):\r最短 = 0ms，最长 = 0ms，平均 = 0ms\r 网络连接查看  PS C:\\Users\\noatn\u0026gt; netstat /?\r显示协议统计信息和当前 TCP/IP 网络连接。\rNETSTAT [-a] [-b] [-e] [-f] [-n] [-o] [-p proto] [-r] [-s] [-x] [-t] [interval]\r-a 显示所有连接和侦听端口。\r-b 显示在创建每个连接或侦听端口时涉及的\r可执行程序。在某些情况下，已知可执行程序承载\r多个独立的组件，这些情况下，\r显示创建连接或侦听端口时\r涉及的组件序列。在此情况下，可执行程序的\r名称位于底部 [] 中，它调用的组件位于顶部，\r直至达到 TCP/IP。注意，此选项\r可能很耗时，并且在你没有足够\r权限时可能失败。\r-e 显示以太网统计信息。此选项可以与 -s 选项\r结合使用。\r-f 显示外部地址的完全限定\r域名(FQDN)。\r-n 以数字形式显示地址和端口号。\r-o 显示拥有的与每个连接关联的进程 ID。\r-p proto 显示 proto 指定的协议的连接；proto\r可以是下列任何一个: TCP、UDP、TCPv6 或 UDPv6。如果与 -s\r选项一起用来显示每个协议的统计信息，proto 可以是下列任何一个:\rIP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP 或 UDPv6。\r-q 显示所有连接、侦听端口和绑定的\r非侦听 TCP 端口。绑定的非侦听端口\r不一定与活动连接相关联。\r-r 显示路由表。\r-s 显示每个协议的统计信息。默认情况下，\r显示 IP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP 和 UDPv6 的统计信息;\r-p 选项可用于指定默认的子网。\r-t 显示当前连接卸载状态。\r-x 显示 NetworkDirect 连接、侦听器和共享\r终结点。\r-y 显示所有连接的 TCP 连接模板。\r无法与其他选项结合使用。\rinterval 重新显示选定的统计信息，各个显示间暂停的\r间隔秒数。按 CTRL+C 停止重新显示\r统计信息。如果省略，则 netstat 将打印当前的\r配置信息一次。\r 网络连接查看 数字形式显示地址和端口号  PS C:\\Users\\noatn\u0026gt; netstat -n\r活动连接\r协议 本地地址 外部地址 状态\rTCP 127.0.0.1:1155 127.0.0.1:1156 ESTABLISHED\rTCP 127.0.0.1:1156 127.0.0.1:1155 ESTABLISHED\rTCP 127.0.0.1:1157 127.0.0.1:1158 ESTABLISHED\rTCP 127.0.0.1:1158 127.0.0.1:1157 ESTABLISHED\rTCP 192.168.31.208:3032 117.18.237.29:80 CLOSE_WAIT\rTCP 192.168.31.208:3312 117.174.50.69:80 ESTABLISHED\rTCP 192.168.31.208:3810 104.18.25.243:80 ESTABLISHED\rTCP 192.168.31.208:3870 203.119.218.69:443 ESTABLISHED\rTCP 192.168.31.208:3880 40.119.211.203:443 ESTABLISHED\rTCP 192.168.31.208:3931 117.174.50.69:80 ESTABLISHED\rTCP 192.168.31.208:3982 213.61.227.196:80 LAST_ACK\rTCP 192.168.31.208:4021 59.110.73.45:443 LAST_ACK\rTCP 192.168.31.208:4023 112.29.158.132:443 LAST_ACK\rTCP 192.168.31.208:4026 112.29.158.132:443 LAST_ACK\rTCP 192.168.31.208:4027 112.18.249.241:443 TIME_WAIT\rTCP 192.168.31.208:4028 112.18.249.241:443 TIME_WAIT\rTCP 192.168.31.208:4029 47.95.47.253:443 TIME_WAIT\rTCP 192.168.31.208:4030 39.107.189.15:443 LAST_ACK\rTCP 192.168.31.208:4032 112.29.158.132:443 LAST_ACK\rTCP 192.168.31.208:4035 112.29.158.132:443 LAST_ACK\rTCP 192.168.31.208:4036 52.114.128.44:443 TIME_WAIT\rTCP 192.168.31.208:4038 131.253.33.254:443 ESTABLISHED\rTCP 192.168.31.208:4039 204.79.197.222:443 ESTABLISHED\rTCP 192.168.31.208:4040 204.79.197.222:443 ESTABLISHED\rTCP 192.168.31.208:4041 131.253.33.254:443 ESTABLISHED\rTCP 192.168.31.208:4042 131.253.33.254:443 ESTABLISHED\rTCP 192.168.31.208:4044 62.96.224.156:389 ESTABLISHED\rTCP 192.168.31.208:4045 117.18.237.29:80 ESTABLISHED\rTCP 192.168.31.208:4046 47.95.47.253:443 ESTABLISHED\rTCP 192.168.31.208:4047 117.177.133.243:443 ESTABLISHED\rTCP 192.168.31.208:4048 112.18.249.239:443 ESTABLISHED\rTCP 192.168.31.208:4049 204.79.197.222:443 ESTABLISHED\rTCP 192.168.31.208:4050 221.178.73.35:443 ESTABLISHED\rTCP 192.168.31.208:4051 39.107.11.172:443 ESTABLISHED\rTCP 192.168.31.208:4052 112.29.158.132:443 ESTABLISHED\rTCP 192.168.31.208:4053 183.220.151.49:443 ESTABLISHED\rTCP 192.168.31.208:4054 13.107.3.254:443 ESTABLISHED\r","pubDate":"2021-02-15","title":"DOS \u003e network"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_windows_ftp/","plain":"本地设置FTP服务器 步骤1：在计算机上打开“控制面板”，然后单击“程序和功能”。 步骤2：在“程序和功能”窗口中，单击“控制面板”窗口左侧的“打开或关闭Windows功能”。 第3步：现在等待一段时间并向下滚动以找出“Internet信息服务”。 只需展开它，打开“FTP服务器”，“Web管理工具”和“万维网服务”下的所有内容，与下面的屏幕截图相同。 完成所有服务后，单击“确定” 第4步：应用更改需要一些时间，完成后，单击“立即重新启动”以重新启动计算机并应用所做的更改 步骤5：重新启动计算机后，再次打开“控制面板”，然后单击“管理工具”将其打开 步骤7：在IIS管理器窗口的左侧，展开窗口左侧的计算机名称，除非您找到“站点”。 只需右键单击“站点”，然后单击“添加FTP站点\u0026hellip;” 第8步：这里给FTP站点命名。 我将\u0026rsquo;sampleftp\u0026rsquo;赋予FTP站点名称。 现在单击“\u0026hellip;”按钮以找到要通过FTP服务器访问的文件夹或驱动程序。 我为本教程选择了“C：FTP_Path”。 完成所有操作后，单击“下一步” 步骤9：在下一个窗口中，单击与“IP Address：”对应的下拉菜单，然后在本地网络上选择计算机的IP地址。  将端口号保留为“21”，默认情况下是这样。  步骤10：选择“No SSL”并启用“自动启动FTP站点”，然后单击“下一步”。  *由于这是一个教程，我不允许使用SSL。 但是，如果您想通过FTP服务器访问敏感数据，我建议您使用SSL  步骤11：现在选择“基本”的身份验证方法，并向“所有用户”提供“授权”。 用户必须输入您的Windows用户名和密码才能使用此身份验证方法访问FTP服务器上的文件  现在，根据您要如何设置FTP服务器，将权限设置为“读取”和“写入”或仅设置为“读取”。 之后，单击“完成”以完成站点设置并在Windows计算机上启动FTP服务器  配置防火墙  您的FTP服务器已准备就绪并且正在运行 但是，您需要配置Windows防火墙以允许与您的计算机进行FTP通信的事务处理。  步骤12：打开“控制面板”并在Windows 10上单击“Windows Defender Firewall”或在Windows 7上单击“Windows防火墙” 步骤13：单击窗口左侧的“允许通过Windows Defender防火墙的应用程序或功能” 步骤14：在新窗口中，单击“更改设置”并标记“FTP服务器”的“公共”和“私人”对应的复选框，然后单击“确定”。   现在，您可以使用适当的应用程序轻松地从本地网络中的任何其他计算机或移动设备访问FTP服务器，或者只需从浏览器访问即可。\n  步骤15：只需输入\u0026rsquo;ftp：//'，然后输入计算机的IP地址和端口号，即21。对于本教程，我的计算机的IP地址为192.168.1.108。\n  所以完整的地址将是\u0026rsquo;ftp://192.168.1.108:21'\n  步骤16：如果输入的地址正确，将要求您输入Windows计算机的用户名和密码。 最后，点击“确定”或“登录”，以适用于您的方式为准  如果身份验证成功，您将能够看到通过FTP服务器共享的文件夹或驱动器中的内容。    这样，您就可以在本地网络上访问Windows计算机上的文件。\n  通过Internet访问本地FTP服务器\n  通过Internet访问本地或家庭FTP服务器需要在路由器上配置一些设置。因此，该过程可能会根据您使用的路由器的公司和型号而有所不同。不过，我在此基本了解如何配置路由器以通过互联网访问您的FTP服务器。\n  在继续之前，请记下您的Internet服务提供商从以下链接提供给您的外部IP地址。\n  打开路由器配置页面，该页面应为192.168.1.1,192.168.0.1或左右。您可以在配置手册中找到路由器配置页面的地址。\n  对我来说，它是192.168.1.1。只需打开配置页面，然后使用用户名和密码登录即可。\n  然后转到“高级设置”，并在其下选择“NAT”。\n  步骤17：在“Virtual Circuit”中选择“PVC2”，然后单击“Virtual Server”。将“IP数量”设置为“单个”，这应该是默认值。 步骤18：现在点击“应用程序”对应的下拉菜单，然后从菜单中选择“FTP”。 之后将自动应用其他配置。 您甚至会注意到FTP应用程序的端口号也被分配为“21”  现在为我设置本地IP地址，即192.168.1.108。  第19步：完成后，单击“保存”。 第20步：一切准备就绪。 现在输入\u0026rsquo;ftp：//'，后跟前面提到的外部IP地址，以及冒号后的端口号，即21。  所以对我来说地址是\u0026rsquo;ftp://117.194.16.221:21'。 如果您的ISP为您分配动态IP地址，则每次重新启动路由器时外部IP地址都会更改。  ","pubDate":"2021-02-15","title":"FTP"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_git_git/","plain":" Push master to origin/master was rejected by remote  有三种原因\r1:push的这个工程是其他人新建的，找她开通master权限后，再次push\r2:git 工程错误\rgit pull\rgit pull origin master\rgit pull origin master --allow-unrelated-histories\r3:github 设置原因\r勾选了Keep my email addresses private\r解决办法2种\r第一种 通知账户人员取消勾选\r第二种\r重新设置你的全局用户E-mail\rgit config --list 查看这个时候一定不对\r因此重新设置全局email\r重置上次提交的作者信息 git commit --amend --reset-author\rgit config --global user.name \u0026quot;zch\u0026quot;\rgit config --global user.email \u0026quot;sdhshd@163.com\u0026quot;\rok\r对了你如果使用的不是idea而是git\r那么抛出的错误非常明显\r如果抛出\rgit报错--\u0026gt;! [remote rejected] master -\u0026gt; master (push declined due to email privacy restrictions)\r那么一定是这个原因\r git clone时报RPC failed; curl 18 transfer closed with outstanding read data remaining 错误  原因1：缓存区溢出\rgit config http.postBuffer 524288000\r执行上面命令如果依旧clone失败，考虑可能原因2：网络下载速度缓慢\r解决方法：命令行输入\rgit config --global http.lowSpeedLimit 0\rgit config --global http.lowSpeedTime 999999\r如果依旧clone失败，则首先浅层clone，然后更新远程库到本地\rgit clone --depth=1 http://gitlab.xxx.cn/yyy/zzz.git\rgit fetch --unshallow\r","pubDate":"2021-02-15","title":"git"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_problem_githubpages%E7%BB%91%E5%AE%9A%E6%9D%A5%E8%87%AA%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E5%9F%9F%E5%90%8D/","plain":"  原教程但是由于他使用的github的用户名做的域名映射器,这样不好的地方是有可能你使用自定义的方式建立github仓库名比如 English study,还有一个是他使用的阿里云的域名映射解析这些是老版本的\n  GitHub Pages 绑定来自阿里云的域名==原博客教程\n  我的使用 github url ==\u0026gt; https://github.com/noatnu/studyDoc , 买的域名 http://www.zhouchenghua.com/  解析第一个设置   创建A记录，请将您的顶点域指向GitHub Pages的IP地址 https 解析ip,上面的192.30.252.153是http解析方式现在官方已经宣布过时了,选择下面任意一个都可以  185.199.108.153\r185.199.109.153\r185.199.110.153\r185.199.111.153\r 解析第二个设置    github 要做的事\n  创建 CNAME文件,写入www.zhouchenghua.com\n   这个是我设置github project 设置截图   ping 地址  C:\\Users\\noatn\u0026gt;ping www.github.com\r正在 Ping github.com [13.250.177.223] 具有 32 字节的数据:\r请求超时。\r请求超时。\r请求超时。\r请求超时。\r13.250.177.223 的 Ping 统计信息:\r数据包: 已发送 = 4，已接收 = 0，丢失 = 4 (100% 丢失)，\rC:\\Users\\noatn\u0026gt;ping www.github.com.noatnu.studyDoc\r正在 Ping www.github.com.noatnu.studyDoc [223.87.179.156] 具有 32 字节的数据:\r来自 223.87.179.156 的回复: 字节=32 时间=872ms TTL=54\r来自 223.87.179.156 的回复: 字节=32 时间=10ms TTL=54\r来自 223.87.179.156 的回复: 字节=32 时间=7ms TTL=54\r来自 223.87.179.156 的回复: 字节=32 时间=8ms TTL=54\r223.87.179.156 的 Ping 统计信息:\r数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，\r往返行程的估计时间(以毫秒为单位):\r最短 = 7ms，最长 = 872ms，平均 = 224ms\r  223.87.179.156这是我的静态博客地址 223.87.179.156\n  192.30.252.153 还可以改为223.87.179.156 ,不过不建议改 因为我们自己查出的ip不是固定ip 而 92.30.252.153是Github Pages服务器指定的IP地址，访问该IP地址即表示访问Github Pages\n  现在ipv4已经分配完了,虽然北美，日本，欧洲，韩国，香港等地的企业商 还有ipv4申请但是其实是他们以前申请保留下来的\n  按照我上面的截图设置即可 ,然后把我的github project url 下载下来看一下\n  所以设置完毕会等一段时间,大概至少会超过1个小时,因为这里面牵扯到阿里云的解析是否解析了你的域名映射,当然这不包括你的域名购买时间，注册以及实名认证这些时间,虽然官方说的时间是挺短的,当你做这些才会一声叹息啊\n  ","pubDate":"2021-02-15","title":"GitHubPages绑定来自阿里云的域名"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_git_gitintroduction/","plain":"git学习 git 区域概念  git分为工作区(我们自己的file)和版本库这其中版本库又包含暂存区(Stage)和分支区(master)    git add ********** 把文件添加到仓库\n  git reset README.md 取消提交到暂存区域\n  git commmit -m \u0026lsquo;xxxx\u0026rsquo; 提交到仓库\n  git diff 查看提交到仓库文件之后文件又被修改的变化\n  git status 查看状态\n  git rm -f gitS.md 强制删除\n  git log 显示从最近到最远的提交日志\n  git log \u0026ndash;pretty=oneline 只显示版本号\n  关于版本回退问题   git reset \u0026ndash;hard HEAD^ 版本重置为上一个版本\n  git 关于版本处理进行了设置\n  git reset \u0026ndash;hard HEAD^　重置为上一个版本\n   这里解释下HEAD表示当前版本 如最新提交的版本号:3a451d666e6c952e1588117ef18933be489beb18 zch, 上上一个版本就是HEAD^^ 那么假如是重置为上上一个版本那么命令就是git reset \u0026ndash;hard HEAD^^ 那么假如说有100个版本呢?当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100 如:git reset \u0026ndash;hard HEAD~50 往上５０个版本 当然了如果记得具体版本号当然更好了    git reset \u0026ndash;hard 3a451d666e6c952e1588117ef18933be489beb18 这样就可以了,对了这的版本号其实可以不用写全,因为是linux嘛\n  git reflog 记录一天的命令(当天)\n  a249f45 HEAD@{0}: reset: moving to HEAD^\r545bb20 HEAD@{1}: commit: 2018年 03月 12日 星期一 10:17:56\ra249f45 HEAD@{2}: commit: append GPL\r3a451d6 HEAD@{3}: commit (initial): zch\r 你可以发现这里面包含当天所有操作的版本号(因为回退到某个版本之后那个版本号你再用git log就查找不出来了)   git log可以查看提交历史，以便确定要回退到哪个版本 git reflog查看命令历史，以便确定要回到未来的哪个版本。   (假如在工作区的内容已经做了修改与暂存区之间相比有了变化,并且你想要要丢弃这种变化,那么你可以)   git checkout \u0026ndash; gitS.md 抛弃工作区所做的修改　那么工作区就被修改为与暂存区一样了 git checkout \u0026ndash; file命令中的\u0026ndash;很重要，没有\u0026ndash;，就变成了“切换到另一个分支”的命令   关于删除文件\n  假如说你删除了当前工作区的某一个文件比如gitS.md   如进行了这个操作 rm gitS.md(linux 下) 这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了(git status) 现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令(git rm gitS.md) (git commit -m \u0026lsquo;yes delete file\u0026rsquo;) 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本 命令(git checkout \u0026ndash; gitS.md)\n 分支(重点)  git checkout -b dev (创建dev分支，然后切换到dev分支)  git branch dev 创建分支dev\rgit checkout dev 切换到分支dev\r git branch命令查看当前分支   git branch命令会列出所有分支，当前分支前面会标一个*号\n * dev\rmaster\r 可以随便写点内容然后提交 git commit -m \u0026lsquo;branch test\u0026rsquo; 现在，dev分支的工作完成，我们就可以切换回master分支\n  git checkout master 切换到当前分支 (这时查看gitS.md刚刚随便写的内容并没有在file中)   　我们需要与当前分支合并\n  git merge dev (dev与master合并,master表示主分支)   cat gitS.md 就看到我们添加的内容了\n  再次查看当前分支 git branch (可以看到现在的分支已经是主分支了)   dev\r* master\r 删除dev分支(git branch -d dev) 再次查看 git branch (可以看到只是主分支master了)  * master\r分支小结 Git鼓励大量使用分支：\r查看分支：git branch\r创建分支：git branch \u0026lt;name\u0026gt;\r切换分支：git checkout \u0026lt;name\u0026gt;\r创建+切换分支：git checkout -b \u0026lt;name\u0026gt;\r合并某分支到当前分支：git merge \u0026lt;name\u0026gt;\r删除分支：git branch -d \u0026lt;name\u0026gt;\r分支冲突 当新创建了一个分支,并且修改内容提交之后,而后又转回到主分支并且又做了修改并且也提交之后,在这之后又进行了合并分支\r这里我们把新创建分支并且做修改的内容称为a,把转到主分支并且做修改的内容称为b,当且仅当a与b相同的时候,这时会发生冲突\r(因为这样在工作区的物理映射都一致了,ps因为都是由工作区提交到缓存区的嘛)\r这个时候我们需要手动解决冲突问题,只需要在把工作区的内容重新修改(这里是已经合并之后)当然不能和b一致有一点点区别即可\r然后重新提交就好\r分支管理策略 通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。\r如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。\r 新创建一个分支dev (git checkout -b dev)   (git add gitS.md) (git commit -m \u0026lsquo;add merge\u0026rsquo;) 在切换为主分支 (git checkout master)   合并分支 以前的方式(git merge dev),这种方式上面说了会丢失信息,因此不采用此种方式(git merge \u0026ndash;no-ff -m \u0026lsquo;merge with no-ff\u0026rsquo; dev)这样就留下了合并信息   (git log \u0026ndash;graph \u0026ndash;pretty=oneline \u0026ndash;abbrev-commit)合并信息如下:  * c41b6a7 merge with no-ff\r|\\ | * d93a2e5 add merge\r|/ * 8e4aa4c conflict fixed\r分支策略\r在实际开发中，我们应该按照几个基本原则进行分支管理：\r首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；\r那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，\rBug分支 软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，\r所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。\r当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交\r并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？\r幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作\r git stash (暂时保存未提交的状态) (git checkout -b issue-101) 说明:却换到此版本之后实际工作区的内容并没有你还没有提交的内容,因此你做出修改  承接上面,关于是否有冲突问题,冲突的原因是你在主分支(master)开发的同时又去修改了项目内容并且和修复bug的分支所做出的修改有相同的地方\r,这时就会产生冲突,在你把bug分支与主分支合并之后并且恰好产生冲突git是会提示的　git会标识出来 这个时侯bug修改的内容已经被添加到了主分支\r因此主分支中关于冲突的部分被git标识了,这个时候我们自己手动修改即可(重复的删除即可,然后在重新提交,检查无误之后删除bug分支)\r  修复完成之后提交 (git add gitS.md) (git commit -m \u0026lsquo;fix bug 101\u0026rsquo;)\n  切换到master分支 (git checkout master)\n  与bug分支合并(git merge \u0026ndash;no-ff -m \u0026ldquo;merged bug fix 101\u0026rdquo; issue-101) 删除issue-101 (git branch -d issue-101)\n  (检查是否有冲突,一般不会有)\n  回到工作的分支上去写代码,这时需要恢复 (git stash pop)||恢复的同时把stash内容也删了\n  注意:可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令git stash apply stash@{0}或者git stash pop stash@{0}\n  (检查是否有冲突 我自己检查是有冲突的, git给我把恢复的那行(原来的)给标识出来了,然后就删除多余的并且也把标识符也删除然后重新提交即可)\n  强行删除某个分支 (假如某个项目中的某个功能不需要了,并且这个功能还没有提交,那么需要强行删除这个分支)(git branch -D feature-xx)(只需把d改为大写即可) 多人协作   要查看远程库的信息(git remote) origin ,远程仓库的默认名称是origin\n  查看详细信息(git remote -v)\n  origin\tgit@github.com:noatnu/docZCH.git (fetch)\rorigin\tgit@github.com:noatnu/docZCH.git (push)\rpsuh 推送地址,fetch抓取地址(当且仅当你有推送权限才会看到push地址)\r推送分支  推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上   假如推送本地的主分支 (git push origin master),假如不是主分支,例如要推送的分支是dev,那么 (git push origin dev)  抓取分支  多人协作时，大家都会往master和dev分支上推送各自的修改 A小伙伴 git clone git@github.com:noatnu/jkblue.git A小伙伴从远程库clone时，默认情况下，A小伙伴只能看到本地的master分支 现在，A小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支 (git checkout -b dev origin/dev) 相当于把远程仓库与新创建并且已经切换到dev的分支相关联起来 (git checkout -b dev)因为此命令表示创建并且切换,后面origin/dev表示关联起来  标签  在Git中打标签非常简单，首先，切换到需要打标签的分支上 (git checkout dev) 打标签 (git tag v1.1) 查看标签 git tag 还可以对具体的版本打标签,比如某某版本号是123456 (git tag v1.2 123456) 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字 (git tag -a v1.2 -m \u0026lsquo;打标签\u0026rsquo; 123456)  提交并推送 首先进入需要提交的那个项目\r将此项目下所有的文件添加到git版本管理系统下,假如你需要其它操作添加，直接正则表达式过滤添加\rgit add ./* 提交到 git 本地仓库\rgit commit -m '2020-01-20 下午推送一次'\r推送\rgit push -u origin master\r如果报错请检查一下推送的分支是否正确\rgit branch\r会这样显示\r----\r* dev\rmarster\r---\r表示当前分值在dev分支\r改为 git push -u origin dev\r看到推送的数据,以及没有出现error等就表示成功\r你可以git status查看下\r回到linux首页 ","pubDate":"2021-02-15","title":"gitIntroduction"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_git_gitub%E9%85%8D%E7%BD%AE/","plain":"zhou@zhou-Lenovo-Z480:~$ git version\rgit version 2.7.4\rzhou@zhou-Lenovo-Z480:~$ ssh -T git@github.com\rWarning: Permanently added the RSA host key for IP address '192.30.255.112' to the list of known hosts.\rPermission denied (publickey).\rzhou@zhou-Lenovo-Z480:~$ git config --global user.name \u0026quot;zhouchenhua\u0026quot;\rzhou@zhou-Lenovo-Z480:~$ git config --global user.email \u0026quot;noatnu@163.com\u0026quot;\rzhou@zhou-Lenovo-Z480:~$ git config --list\ruser.name=zhouchenhua\ruser.email=noatnu@163.com\rzhou@zhou-Lenovo-Z480:~$ ssh-keygen -C ‘noatnu@163.com’ -t rsa\rGenerating public/private rsa key pair.\rEnter file in which to save the key (/home/zhou/.ssh/id_rsa): america347191\rEnter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in america347191.\rYour public key has been saved in america347191.pub.\rThe key fingerprint is:\rSHA256:7WlMe5QL3eMrdG6b7BB/z66zSpwIOBRM0GTD4hK6BW4 ‘noatnu@163.com’\rThe key's randomart image is:\r+---[RSA 2048]----+\r| .B* |\r|. . ..+o |\r|.o o .. |\r|.Eo .. . . . o |\r|.o . o S + = o |\r|. . = B.*.. |\r| B.Boo .|\r| . o.o+=.|\r| .=O*+|\r+----[SHA256]-----+\rroot@zhou-Lenovo-Z480:/home/zhou# cd ~/.ssh\rroot@zhou-Lenovo-Z480:~/.ssh# ls -a\r. .. id_rsa id_rsa.pub\rroot@zhou-Lenovo-Z480:~/.ssh# gedit id_rsa.pub  回到linux首页 ","pubDate":"2021-02-15","title":"gitub配置"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_tool_guava-common/","plain":"Guava 基于java1.6的类库集合的扩展项目  com.google.common.annotations：普通注解类型。 com.google.common.base：基本工具类库和接口。 com.google.common.cache：缓存工具包，非常简单易用且功能强大的JVM内缓存。 com.google.common.collect：带泛型的集合接口扩展和实现，以及工具类，这里你会发现很多好玩的集合。 com.google.common.eventbus：发布订阅风格的事件总线。 com.google.common.hash： 哈希工具包。 com.google.common.io：I/O工具包。 com.google.common.math：原始算术类型和超大数的运算工具包。 com.google.common.net：网络工具包。 com.google.common.primitives：八种原始类型和无符号类型的静态工具包。 com.google.common.reflect：反射工具包。 com.google.common.util.concurrent：多线程工具包。\r 常见Object方法   hashCode compare/compareTo 实现一个比较器[Comparator]，或者直接实现Comparable接口有时也伤不起\n public class ProjectInfo implements Serializable,Comparable\u0026lt;ProjectInfo\u0026gt; {\rprivate int id;\rprivate String name;\rpublic int getId() {\rreturn id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setId(int id) {\rthis.id = id;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r@Override\rpublic int compareTo(ProjectInfo o) {\rreturn ComparisonChain.start().compare(this.getName(),o.getName()).compare(this.getId(),o.getId()).result();\r}\r@Override\rpublic int hashCode() {\rreturn Objects.hashCode(getId(),getName());\r}\r}\r 当一个对象中的字段可以为null时，实现Object.equals方法会很痛苦，因为不得不分别对它们进行null检查。 使用Objects.equal帮助你执行null敏感的equals判断，从而避免抛出NullPointerException\n public void testA(){\rSystem.out.println(Objects.equal(\u0026quot;a\u0026quot;,\u0026quot;a\u0026quot;));// --\u0026gt;true\rSystem.out.println(Objects.equal(\u0026quot;a\u0026quot;,\u0026quot;\u0026quot;));// --\u0026gt;false\rSystem.out.println(Objects.equal(\u0026quot;\u0026quot;,\u0026quot;\u0026quot;));// --\u0026gt;true\rSystem.out.println(Objects.equal(\u0026quot;\u0026quot;,\u0026quot;w\u0026quot;));// --\u0026gt;false\rSystem.out.println(Objects.equal(null,null));// --\u0026gt;true\rSystem.out.println(Objects.equal(null,\u0026quot;\u0026quot;));// --\u0026gt;false\r}\r toString 好的toString方法在调试时是无价之宝，但是编写toString方法有时候却很痛苦。使用MoreObjects(低版本还是Objects)\n System.out.println(MoreObjects.toStringHelper(this).add(\u0026quot;x\u0026quot;,2).\radd(\u0026quot;y\u0026quot;,Math.round(Math.random()*10)).toString());\r/*console : ObjectsDemo{x=2, y=9}*/\r Preconditions   前置条件Preconditions提供静态方法来检查方法或构造函数，被调用是否给定适当的参数。它检查的先决条件。其方法失败抛出IllegalArgumentException\n public class PreconditionsDemo {\rpublic static void main(String[] args) {\rtry {\rsum(null,2);\r}catch (IllegalArgumentException e){\rSystem.out.println(e.getMessage());\r}\r}\rprivate static int sum(Integer a,Integer b){\ra = Preconditions.checkNotNull(a,\u0026quot;不能为null\u0026quot;);\rb = Preconditions.checkNotNull(a,\u0026quot;不能为null\u0026quot;);\rreturn a+b;\r}\r/**\r* 直接写检查表达式\r* @param input\r* @return\r*/\rprivate static double sqrt(double input){\rPreconditions.checkArgument(input \u0026gt;= 0.0);\rreturn Math.sqrt(input);\r}\r/**\r* 数组索引检查\r* @param index\r* @return\r*/\rprivate static int getValue(int index){\rint[] data = {Integer.parseInt(Math.round(Math.random())+\u0026quot;\u0026quot;),Integer.parseInt(Math.round(Math.random())+\u0026quot;\u0026quot;)} ;\rindex = Preconditions.checkElementIndex(index,data.length,\u0026quot;\u0026quot;);\rreturn data[index];\r}\r/**\r* 直接写检查表达式\r* @param num\r*/\rprivate static void maxTwo(int num){\rPreconditions.checkState(num\u0026gt;2,\u0026quot;抛出异常\u0026quot;);\r}\r}\r Joiner   Joiner 提供了各种方法来处理字符串加入操作，对象等(Joiner的实例不可变的，因此是线程安全的)\n public static void testA() {\r/*\ron:制定拼接符号，如：test1-test2-test3 中的 “-“ 符号\rskipNulls()：忽略NULL,返回一个新的Joiner实例\ruseForNull(“Hello”)：NULL的地方都用字符串”Hello”来代替\r*/\rJoiner joiner = Joiner.on(\u0026quot;,\u0026quot;);\rStringBuilder builder = new StringBuilder(1024);\r// joiner.skipNulls().appendTo(builder, \u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;, null, \u0026quot;d\u0026quot;);\rjoiner.useForNull(\u0026quot;--HH--\u0026quot;).appendTo(builder, \u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;, null, \u0026quot;d\u0026quot;);\rSystem.out.println(builder.toString());\rMap\u0026lt;String, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;();\rmap.put(\u0026quot;key1\u0026quot;, \u0026quot;value1\u0026quot;);\rmap.put(\u0026quot;key2\u0026quot;, \u0026quot;value2\u0026quot;);\rmap.put(\u0026quot;key3\u0026quot;, \u0026quot;value3\u0026quot;);\rSystem.out.println(Joiner.on(\u0026quot;,\u0026quot;).withKeyValueSeparator(\u0026quot;=\u0026quot;).join(map));\r}\rconsole\ra,b,c,--HH--,d\rkey1=value1,key2=value2,key3=value3\r Splitter 能够将一个字符串按照指定的分隔符拆分成可迭代遍历的字符串集合，Iterable   public static void testA() {\r/*\ron():指定分隔符来分割字符串\rlimit():当分割的子字符串达到了limit个时则停止分割\rfixedLength():根据长度来拆分字符串\rtrimResults():去掉子串中的空格\romitEmptyStrings():去掉空的子串\rwithKeyValueSeparator():要分割的字符串中key和value间的分隔符,分割后的子串中key和value间的分隔符默认是=\r*/\rIterable it = null;\rit = Splitter.on(\u0026quot;,\u0026quot;).limit(3).trimResults().split(\u0026quot;a ,b , c, d\u0026quot;);\rSystem.out.println(Splitter.fixedLength(3).split(\u0026quot;1 2 3\u0026quot;));//[1 2, 3]\rSystem.out.println(Splitter.on(\u0026quot; \u0026quot;).omitEmptyStrings().splitToList(\u0026quot;1 2 3\u0026quot;));\rSystem.out.println(Splitter.on(\u0026quot;,\u0026quot;).omitEmptyStrings().split(\u0026quot;1,,,,2,,,3\u0026quot;));//[1, 2, 3]\rSystem.out.println(Splitter.on(\u0026quot; \u0026quot;).trimResults().split(\u0026quot;1 2 3\u0026quot;)); //[1, 2, 3],默认的连接符是,\rSystem.out.println(Splitter.on(\u0026quot;;\u0026quot;).withKeyValueSeparator(\u0026quot;:\u0026quot;).split(\u0026quot;a:1;b:2;c:3\u0026quot;));//{a=1, b=2, c=3}\r}\r//连接器[Joiner]\r@Test\rpublic void testJoiner() {\r//创建连接器\rJoiner joiner = Joiner.on(\u0026quot;; \u0026quot;).skipNulls();//skipNulls 跳过null\rString join = joiner.join(\u0026quot;Harry\u0026quot;, null, \u0026quot;Ron\u0026quot;, \u0026quot;Hermione\u0026quot;);\rSystem.out.println(join);\r//apache 下的连接器\rString join1 = StringUtils.join(Arrays.asList(\u0026quot;Harry\u0026quot;, \u0026quot;Ron\u0026quot;, \u0026quot;Hermione\u0026quot;), \u0026quot;;\u0026quot;);\rSystem.out.println(join1);\r//useForNull 当连接的字符串有null值那么使用yes代替\rString join2 = Joiner.on(\u0026quot;=\u0026quot;).useForNull(\u0026quot;yes\u0026quot;).join(Arrays.asList(\u0026quot;Harry\u0026quot;, null, \u0026quot;Ron\u0026quot;, \u0026quot;Hermione\u0026quot;));\rSystem.out.println(join2);\r//把连接后的字符串放入StringBuilder里面\rStringBuilder builder = new StringBuilder();\rStringBuilder stringBuilder = Joiner.on(\u0026quot;=\u0026quot;).useForNull(\u0026quot;yes2\u0026quot;).appendTo(builder, \u0026quot;Harry\u0026quot;, \u0026quot;Ron\u0026quot;, null,\u0026quot;Hermione\u0026quot;);\rSystem.out.println(builder.toString());\rSystem.out.println(stringBuilder.toString());\r}\r@Test\rpublic void testSplitter() {\rString text = \u0026quot;the ,quick, , brown , fox, jumps, over, the, lazy, little dog\u0026quot; ;\r// \u0026quot;dsdh\u0026quot;.split() ;\rIterable\u0026lt;String\u0026gt; split = Splitter.on(\u0026quot;,\u0026quot;).trimResults().omitEmptyStrings().limit(4).split(text);\rsplit.spliterator().forEachRemaining(s -\u0026gt; System.out.println(s));\r}\romitEmptyStrings()\t从结果中自动忽略空字符串\rtrimResults()\t移除结果字符串的前导空白和尾部空白\rtrimResults(CharMatcher)\t给定匹配器，移除结果字符串的前导匹配字符和尾部匹配字符\rlimit(int)\t限制拆分出的字符串数量\r Collection 不可变集合   不可变对象有很多优点，包括  public class ImmutableDemo {\rpublic static void main(String[] args) {\rImmutableSet\u0026lt;String\u0026gt; set=ImmutableSet.of(\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;c\u0026quot;,\u0026quot;d\u0026quot;);\rImmutableSet\u0026lt;String\u0026gt; set1=ImmutableSet.copyOf(set);\rImmutableSet\u0026lt;String\u0026gt; set2=ImmutableSet.\u0026lt;String\u0026gt;builder().addAll(set).add(\u0026quot;e\u0026quot;).build();\rSystem.out.println(set);\rImmutableList\u0026lt;String\u0026gt; list=set.asList();\r}\r}\r Multiset Multiset可统计一个词在文档中出现了多少次  public class MultiSetDemo {\rpublic static void main(String[] args) {\rMultiset\u0026lt;String\u0026gt; set= LinkedHashMultiset.create();\rset.add(\u0026quot;a\u0026quot;);\rset.add(\u0026quot;a\u0026quot;);\rset.add(\u0026quot;a\u0026quot;);\rset.add(\u0026quot;a\u0026quot;);\rset.setCount(\u0026quot;a\u0026quot;,5); //添加或删除指定元素使其在集合中的数量是count\rSystem.out.println(set.count(\u0026quot;a\u0026quot;)); //给定元素在Multiset中的计数\rSystem.out.println(set);\rSystem.out.println(set.size()); //所有元素计数的总和,包括重复元素\rSystem.out.println(set.elementSet().size()); //所有元素计数的总和,不包括重复元素\rset.clear(); //清空集合\rSystem.out.println(set);\r}\r}\r Multimap可以很容易地把一个键映射到多个值。换句话说，Multimap是把键映射到任意多个值的一般方式。  public class MultiMapDemo {\rpublic static void main(String[] args) {\rMultimap\u0026lt;String, Integer\u0026gt; map = HashMultimap.create(); //Multimap是把键映射到任意多个值的一般方式\rmap.put(\u0026quot;a\u0026quot;, 1); //key相同时不会覆盖原value\rmap.put(\u0026quot;a\u0026quot;, 2);\rmap.put(\u0026quot;a\u0026quot;, 3);\rSystem.out.println(map); //{a=[1, 2, 3]}\rSystem.out.println(map.get(\u0026quot;a\u0026quot;)); //返回的是集合\rSystem.out.println(map.size()); //返回所有”键-单个值映射”的个数,而非不同键的个数\rSystem.out.println(map.keySet().size()); //返回不同key的个数\rMap\u0026lt;String, Collection\u0026lt;Integer\u0026gt;\u0026gt; mapView = map.asMap();\r}\r}\r Table它有两个支持所有类型的键：”行”和”列”。  public class TableDemo {\rpublic static void main(String[] args) {\r//记录学生在某门课上的成绩\rTable\u0026lt;String,String,Integer\u0026gt; table= HashBasedTable.create();\rtable.put(\u0026quot;jack\u0026quot;,\u0026quot;java\u0026quot;,100);\rtable.put(\u0026quot;jack\u0026quot;,\u0026quot;c\u0026quot;,90);\rtable.put(\u0026quot;mike\u0026quot;,\u0026quot;java\u0026quot;,93);\rtable.put(\u0026quot;mike\u0026quot;,\u0026quot;c\u0026quot;,100);\rSet\u0026lt;Table.Cell\u0026lt;String,String,Integer\u0026gt;\u0026gt; cells=table.cellSet();\rfor (Table.Cell\u0026lt;String,String,Integer\u0026gt; cell : cells) {\rSystem.out.println(cell.getRowKey()+\u0026quot; \u0026quot;+cell.getColumnKey()+\u0026quot; \u0026quot;+cell.getValue());\r}\rSystem.out.println(table.row(\u0026quot;jack\u0026quot;));\rSystem.out.println(table);\rSystem.out.println(table.rowKeySet());\rSystem.out.println(table.columnKeySet());\rSystem.out.println(table.values());\r}\r}\r 集合操作：交集、差集、并集  public class CollectionsDemo {\rpublic static void main(String[] args) {\rSet\u0026lt;Integer\u0026gt; set1 = Sets.newHashSet(1, 2, 3, 4, 5);\rSet\u0026lt;Integer\u0026gt; set2 = Sets.newHashSet(3, 4, 5, 6);\rSets.SetView\u0026lt;Integer\u0026gt; inter = Sets.intersection(set1, set2); //交集\rSystem.out.println(inter);\rSets.SetView\u0026lt;Integer\u0026gt; diff = Sets.difference(set1, set2); //差集,在A中不在B中\rSystem.out.println(diff);\rSets.SetView\u0026lt;Integer\u0026gt; union = Sets.union(set1, set2); //并集\rSystem.out.println(union);\r}\r}\r","pubDate":"2021-02-15","title":"Guava-common"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_linux_host%E6%98%A0%E5%B0%84/","plain":"sudo vi hosts\n127.0.0.1\tlocalhost 127.0.1.1\tzhou-Lenovo-Z480\nThe following lines are desirable for IPv6 capable hosts ::1 ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters\n#pmcc dev 127.0.0.1 dev.pmcc.com\n","pubDate":"2021-02-15","title":"host映射"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_hugo_hugo_tutorials1/","plain":"教程1 快速开始  步骤1：安装Hugo  brew install hugo\r# or\rport install hugo\r 要验证新安装  hugo version\r 步骤2：建立新网站  hugo new site quickstart\r# 上面的代码将在名为的文件夹中创建一个新的Hugo网站quickstart。\r 步骤3：添加主题  # 首先，从GitHub下载主题并将其添加到您站点的themes目录中：\rcd quickstart\rgit init\rgit submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke\r 然后，将主题添加到站点配置中：  echo 'theme = \u0026quot;ananke\u0026quot;' \u0026gt;\u0026gt; config.toml\r 步骤4：添加一些内容  hugo new posts/my-first-post.md\r 如果需要，请编辑新创建的内容文件，该文件将从以下内容开始：   ---\rtitle: \u0026quot;My First Post\u0026quot;\rdate: 2019-03-26T08:47:11+01:00\rdraft: true\r---\r 步骤5：启动Hugo服务器  ▶ hugo server -D\r| EN\r+------------------+----+\rPages | 10\rPaginator pages | 0\rNon-page files | 0\rStatic files | 3\rProcessed images | 0\rAliases | 1\rSitemaps | 1\rCleaned | 0\rTotal in 11 ms\rWatching for changes in /Users/bep/quickstart/{content,data,layouts,static,themes}\rWatching for config changes in /Users/bep/quickstart/config.toml\rEnvironment: \u0026quot;development\u0026quot;\rServing pages from memory\rRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\rWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\rPress Ctrl+C to stop\r 步骤7：建立静态页面  hugo -D\r./public/默认情况下，输出将位于目录中（-d/--destination标志进行更改，或publishdir在配置文件中设置）\r","pubDate":"2021-02-15","title":"hugo \u003e tutorials1"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_hugo_hugo_tutorials2/","plain":"教程2  1、\t创建blog  hugo new site myblog_pub\rcd myblog_pub/\rgit submodule add https://github.com/chinanf-boy/gohugo-theme-yinwang.git themes/yinwang\r  2、\t修改配置\n  vi config.toml\n  root@instance-x8rtph4n:/home/go/code/hugo_dir/myblog_pub/public# more ../config.toml baseURL = \u0026quot;http://ypbsyy.github.io/\u0026quot;\rlanguageCode = \u0026quot;en-us\u0026quot;\rtitle = \u0026quot;我是yaopeng\u0026quot;\rtheme = \u0026quot;yinwang\u0026quot;\r#pygmentsCodeFences = true\r#pygmentsCodefencesGuessSyntax = false\r#pygmentsStyle = \u0026quot;dracula\u0026quot;\r#pygmentsOptions = ['linenos']\r# 代码高亮/chroma，hugo默认自带\r[params]\rauthor = \u0026quot;yaopeng\u0026quot;\rgithub = \u0026quot;yaopeng\u0026quot;\r# gitlab = \u0026quot;yobrave\u0026quot;\r#googleAnalytics = \u0026quot;****\u0026quot;\r# 谷歌统计gtag\rhighlight = \u0026quot;dracula\u0026quot; # 默认样式 `github`\rlangs = [\u0026quot;go\u0026quot;]\r# 默认加载 highlight.min.js，但 一些不支持的语言, 你自己添加,\r# 其实也可以使用hugo自带的语法高亮器设置，不过我有点懒\r# single = false\r# 单页面的Home 按钮去除\r# menus = true\r# 我 想加更多目录\r# backgroundColor = \u0026quot;#fbf6ec\u0026quot;\r加点黄黄的背景色   3、\t创建github\n  4、\t部署到github\n  git submodule init\rgit submodule update\rhugo --buildDrafts\rcd public/\rgit init\rgit remote rm origin git remote add origin https://github.com/ypbsyy/ypbsyy.github.io.git\rgit add -A\rgit commit -m \u0026quot;first commit\u0026quot;\rgit push -u origin master\r这里面实际到hugo –buildDrafts 这里就ok 剩余的是把public中的html传入静态网页中\r 注意文章开头必须有这几个   ---\rtitle: \u0026quot;My First Post\u0026quot;\rdate: 2019-03-26T08:47:11+01:00\rdraft: true\r---\r  baseURL = \u0026ldquo;https://swagcode-io.github.io/demo\u0026quot;\n  这里的url是自己对应的\n  git submodule add https://github.com/chinanf-boy/gohugo-theme-yinwang.git themes/yinwang\n  下载主题\n  参考网址\n  https://www.pianshen.com/article/1216214802/\n  https://zhuanlan.zhihu.com/p/105021100?utm_source=weibo\n  https://zhuanlan.zhihu.com/p/105021100?utm_source=weibo\n  ","pubDate":"2021-02-15","title":"hugo \u003e tutorials2"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_idea_idea/","plain":" idea 解决working directory 设置到 target  test ng D:\\IdeaProjects\\java-se-study\rrun config $MODULE_DIR$\r","pubDate":"2021-02-15","title":"idea"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_maven_idea%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE%E5%87%BA%E7%8E%B0unable_to_import_maven_project_see_logs_for_details%E6%8F%90%E7%A4%BA/","plain":" idea导入项目出现Unable to import maven project: See logs for details提示\n 第一种解决办法   删除项目根目录下.idea文件夹\n  关闭idea工具，重新打开选择File-\u0026gt;New-\u0026gt;Project from the existing source ,选择刚才的项目根目，下一步：\n  一直点next，最后点击主工程的pom.xml 完成！\n  第二种   打开idea 的日志文件如果发现【Error】com.google.inject.CreationException: Unable to create injector\n  那么自定义配置Maven3.6.2报错 或者更高版本maven\n  原因：Maven3.6.2的版本兼容问题。\n  解决方法：重新下载较低版本Maven3.6.1及以下版本可以顺利解决。\n  用maven无论是新建项目还是导入没有下载到本地仓库的jar。出现了Unable to import maven project\n  打开cmd，ping localhost，显示一般故障\n  在左边控制栏，关闭防火墙，再开启防火墙 再次ping localhost，成功\n  对了 假如出现文件权限问题 那么更改maven的本地仓库地址\n   title : \u0026lsquo;idea导入项目出现Unable \u0026gt; to \u0026gt; import \u0026gt; maven \u0026gt; project \u0026gt; See \u0026gt; logs \u0026gt; for \u0026gt; details提示\u0026rsquo; date : \u0026lsquo;2021-02-15\u0026rsquo; draft : false tags : [\u0026ldquo;maven\u0026rdquo;] categories : [\u0026ldquo;problem\u0026rdquo;,\u0026ldquo;index\u0026rdquo;] author : \u0026lsquo;zch\u0026rsquo; description : \u0026lsquo;测试博客\u0026rsquo; lastmod : \u0026lsquo;2021-02-15\u0026rsquo;  idea导入项目出现Unable to import maven project: See logs for details提示\n 第一种解决办法   删除项目根目录下.idea文件夹\n  关闭idea工具，重新打开选择File-\u0026gt;New-\u0026gt;Project from the existing source ,选择刚才的项目根目，下一步：\n  一直点next，最后点击主工程的pom.xml 完成！\n  第二种   打开idea 的日志文件如果发现【Error】com.google.inject.CreationException: Unable to create injector\n  那么自定义配置Maven3.6.2报错 或者更高版本maven\n  原因：Maven3.6.2的版本兼容问题。\n  解决方法：重新下载较低版本Maven3.6.1及以下版本可以顺利解决。\n  用maven无论是新建项目还是导入没有下载到本地仓库的jar。出现了Unable to import maven project\n  打开cmd，ping localhost，显示一般故障\n  在左边控制栏，关闭防火墙，再开启防火墙 再次ping localhost，成功\n  对了 假如出现文件权限问题 那么更改maven的本地仓库地址\n  ","pubDate":"2021-02-15","title":"idea导入项目出现Unable \u003e to \u003e import \u003e maven \u003e project \u003e See \u003e logs \u003e for \u003e details提示"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_meditation_info/","plain":"冥想 呼吸冥想法   1:坐好，后背挺直，然后闭上眼睛\n  2:关注你自己呼吸时的感觉,吸气，吸气，选择一个感受突出的地方，通常是你的鼻子或者耳朵、腹部然后集中注意力，关注你自己呼吸时的感觉。吸气，吸气，用嘴呼吸（最好关注腹部，因为我们大部分人都是腹部呼吸法）\n  3:一旦你开始这样做了脑子会乱想,你需要关注你到什么时候走神的，那么走神后重新调整后重新开始集中注意力开始冥想。\n  ","pubDate":"2021-02-15","title":"info"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_tool_io/","plain":"org.apache.commons.io.FilenameUtils 文件名称操作   FilenameUtils.getExtension(fileName) 获取文件后缀 //text\n  FilenameUtils.getName(fileName) 获取文件完整名称 //c.text\n  FilenameUtils.getBaseName(fileName) 获取文件名称 //c\n  FilenameUtils.getFullPath(fileName) 获取文件的完整路径 //D:\\data\\\n  String path = \u0026quot;D:\\\\data\\\\假设开发法土地模板.docx\u0026quot; ;\rString fullPath = FilenameUtils.getFullPath(path);\rSystem.out.println(\u0026quot;fullPath:\u0026quot;+fullPath);//D:\\data\\\rString name = FilenameUtils.getName(path);\rSystem.out.println(\u0026quot;name:\u0026quot;+name); //假设开发法土地模板.docx\rString prefix = FilenameUtils.getPrefix(path);\rSystem.out.println(\u0026quot;prefix:\u0026quot;+prefix); //D:\\\rint prefixLength = FilenameUtils.getPrefixLength(path);\rSystem.out.println(\u0026quot;prefixLength:\u0026quot;+prefixLength); //3\rString path1 = FilenameUtils.getPath(path);\rSystem.out.println(\u0026quot;path:\u0026quot;+path1); //data\\\rString baseName = FilenameUtils.getBaseName(path);\rSystem.out.println(\u0026quot;baseName:\u0026quot;+baseName); //假设开发法土地模板\rString extension = FilenameUtils.getExtension(path);\rSystem.out.println(\u0026quot;extension:\u0026quot;+extension); //docx\rFileUtils：提供文件操作（移动文件，读取文件，检查文件是否存在等等） String path = \u0026quot;D:\\\\data\\\\test\u0026quot;;\rString fileSize = FileUtils.byteCountToDisplaySize(1024 * 1024);\r// 转换文件长度单位\rAssert.assertEquals(\u0026quot;1 MB\u0026quot;, fileSize);\r// 清空某目录下的所有目录,含文件夹和文件,注意是目录下,不包含父目录\rFileUtils.cleanDirectory(new File(path));\r// copy URL中文件到參數2\rFileUtils.copyURLToFile(new URL(\u0026quot;https://v3.bootcss.com/\u0026quot;), new File(\u0026quot;D:\\\\data\\\\test1\\\\a1.txt\u0026quot;));//a1.txt 里面拷贝下来是一个网页\r// 强制删除文件\rFileUtils.forceDelete(new File(\u0026quot;D:\\\\data\\\\test1\\\\a1.txt\u0026quot;));\r// 将文件转为 InputStream\rFileUtils.openInputStream(new File(\u0026quot;D:\\\\data\\\\aac.pptx\u0026quot;));\r//openOutStream\rFileUtils.openOutputStream(new File(\u0026quot;D:\\\\data\\\\aac.pptx\u0026quot;));\r// 读取文件转为字节数组\rbyte[] bytes = FileUtils.readFileToByteArray(new File(\u0026quot;D:\\\\data\\\\aab.pptx\u0026quot;));\r// 读取文件转换为String类型,方便文本读取\rFileUtils.readFileToString(new File(\u0026quot;D:\\\\data\\\\aab.pptx\u0026quot;),\u0026quot;UTF-8\u0026quot;);\r// 返回目录的大小\rlong size = FileUtils.sizeOfDirectory(new File(\u0026quot;D:\\\\data\\\\\u0026quot;));\r// 写字符串到参数1文件中\rFileUtils.writeStringToFile(new File(\u0026quot;D:\\\\data\\\\test1\\\\b2.txt\u0026quot;), \u0026quot;test\u0026quot;, \u0026quot;UTF-8\u0026quot;);\r// 将参数1目录下的全部内容复制到参数2目录\rFileUtils.copyDirectory(new File(\u0026quot;D:\\\\data\\\\test1\u0026quot;), new File(\u0026quot;D:\\\\data\\\\test2\u0026quot;));\r// 将参数1目录整个复制到参数2目录下\rFileUtils.copyDirectoryToDirectory(new File(\u0026quot;D:\\\\data\u0026quot;) , new File(\u0026quot;D:\\\\data\\\\test1\u0026quot;));\r// copy参数1文件到参数2\rFileUtils.copyFile(new File(\u0026quot;D:\\\\data\\\\test1\\\\b2.txt\u0026quot;), new File(\u0026quot;D:\\\\data\\\\b1.txt\u0026quot;));\r// copy参数1文件到参数2目录下\rFileUtils.copyFileToDirectory(new File(\u0026quot;D:\\\\data\\\\b1.txt\u0026quot;) , new File(\u0026quot;D:\\\\data\\\\test2\u0026quot;)) ;\r//读取文件的每一行\rList\u0026lt;String\u0026gt; stringList = FileUtils.readLines(new File(\u0026quot;D:\\\\data\\\\b1.txt\u0026quot;));\rIOCase：提供字符串操作以及比较的方法 FileSystemUtils：提供查看指定目录剩余空间的方法  long spaceKb = FileSystemUtils.freeSpaceKb(\u0026quot;D:\\\\data\\\\\u0026quot;);//247018912 kb\rSystem.out.println(spaceKb);\rIOUtils  Reader reader = new InputStreamReader(new FileInputStream(new File(\u0026quot;D:\\\\data\\\\b1.txt\u0026quot;))) ;\rIOUtils.copy(reader,new FileOutputStream(\u0026quot;D:\\\\data\\\\b3.txt\u0026quot;)) ;\rbyte[] toByteArray = IOUtils.toByteArray(new URL(\u0026quot;https://www.bootcss.com/\u0026quot;));\r","pubDate":"2021-02-15","title":"IO"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_java_java_bitoperation/","plain":"位运算   十进制转二进制\n  正整数十进制转二进制\n   正整数转成二进制。要点一定一定要记住哈：除二取余，然后倒序排列，高位补零。也就是说，将正的十进制数除以二，得到的商再除以二，依次类推直到商为零或一时为止，然后在旁边标出各步的余数，最后倒着写出来，高位补零就OK咧。\n  2 |93 1\r──────\r2 |46 0\r────── 2 |23 1\r──────\r2 |11 1\r────── 2|5 1\r────\r2|2 0\r────\r1 1011101\r不满足8位所以高位补0 计算机内部表示数的字节单位是定长的，如8位，16位，或32位。所以，位数不够时，高位补零\r01011101\r反推回去\r1011101\r6543210 ==\u0026gt; 2(6)*1+2(5)*0+2(4)*1+2(3)*1+2(2)*1+2(1)*0+2(0)*1 ==》Math.pow(2,6) + Math.pow(2,4) + Math.pow(2,3) +Math.pow(2,2)+1=93\r2 |100 0\r───────\r2 |50 0\r────── 2 |25 1\r──────\r2 |12 0\r────── 2|6 0\r────\r2|3 1\r────\r1 01100100\r2 |73 1\r──────\r2 |36 0\r────── 2 |18 0\r──────\r2 |9 1\r────── 2|4 0\r────\r2|2 0\r────\r1 1001001\r 正小数转换二进制   乘二取整，直到小数为零为止，先整为高位，后整为低位 乘二取整，截取整数，如果还没到整数那么取0，截取后剩余的小数继续乘以2然后再截取整数，直到小数为0为止，这里要注意的是每乘以2后必须截取，然后才能往后继续算\n 0.625 ==\u0026gt; 二进制\r第一次\r0.625x2 = 1.25 截取整数 1 剩余的字符串变为0.25 继续往下\r0.25x2 = 0.5 截取整数0 剩余的字符串为0.5 继续往下\r0.5x2 = 1.0 截取整数1 剩余的字符串为0 算法结束\r统计从1.25截取的整数开始1 -\u0026gt; 0 -\u0026gt;1\r所以结果为0.101\r 负整数转换成二进制   先是将对应的正整数转换成二进制后，对二进制取反，然后对结果再加一\n  2 |87 1\r──────\r2 |43 1\r────── 2 |21 1\r──────\r2 |10 0\r────── 2|5 1\r────\r2|2 0\r────\r1 1010111 ==\u0026gt; 补位 01010111 取反\r10101000\r加1\r10101001\rSystem.out.println( Integer.toBinaryString(-87)); ==\u0026gt;11111111111111111111111110101001 (32位) 去除多余的得到 10101001\r 二进制加法   先把两个数对齐，和十进制计算时候的第一步一样，从最右边对齐的上下两个数开始，1+0=1，0+0=0。\n  如果两个数不是都是1，直接相加就可以了，写在下面，1=1=10，把1写上面，把0写下面。\n  1+1+1=11，要注意进位，依此类推，计算完成。(必须近卫实际上可以看作)\n  2 |2034 0 ────────────\r2 |1017 1\r────────────\r2 |0508 0\r────────────\r2 |0254 0\r────────────\r2 |0127 1\r────────────\r2 |0063 1 ────────────\r2 |0031 1\r────────────\r2 |0015 1\r────────────\r2 |0007 1\r────────────\r2 |0003 1\r────────────\r1 2034 二进制011111110010\r128 二进制10000000\r0 1 1 1 1 1 1 1 0 0 1 0\r+ 1 0 0 0 0 0 0 0\r──────────────────────\r0 1 0 0 0 0 1 1 1 0 0 1 0\r==\u0026gt;2162\r 二进制减法    二进制乘法   按照乘法，00=0，01=0，11=1，进行运算，10010101=0101101\n 32x24\n2 |32 0 ────────────\r2 |16 0\r────────────\r2 |8 0\r────────────\r2 |4 0\r────────────\r2 |2 0\r────────────\r1\r32 = 100000\r2 |24 0 ────────────\r2 |12 0\r────────────\r2 |6 0\r────────────\r2 |3 1\r────────────\r1\r24 = 11000\r                     1 0 0 0 0 0   X     1 1 0 0 0   ___ ___ ___ ___ ___ ___ ___ ___ ___ ___       0 0 0 0 0 0      0 0 0 0 0 0      0 0 0 0 0 0      1 0 0 0 0 0      1 0 0 0 0 0       ___ ___ ___ ___ ___ ___ ___ ___ ___ ___   1 1 0 0 0 0 0 0 0 0    32x24 == \u0026gt; 100000 * 11000 = 1100000000 = 768\r 按位与运算符(\u0026amp;)   参加运算的两个数据，按二进制位进行 \u0026ldquo;与\u0026rdquo; 运算。 运算规则： 0\u0026amp;0=0; 0\u0026amp;1=0; 1\u0026amp;0=0; 1\u0026amp;1=1; 即：两位同时为 “1，结果才为 ” “1，否则为 ” 0\n  6 \u0026amp; 8 == 0\r1 0 0 0\r0 1 1 0\r--------\r0 0 0 0\r3\u0026amp;5 即 0000 0011 \u0026amp; 0000 0101 = 0000 0001 因此， 3\u0026amp;5 的值得 1。\r二进制如何转十进制，十进制如何转二进制\n二进制怎样相加\n二进制怎么进行减法相减\n从java toBinaryString() 看计算机数值存储方式（原码、反码、补码）\n","pubDate":"2021-02-15","title":"java \u003e bitOperation"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_java_java_java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E5%A4%A7%E5%85%A8/","plain":"﻿\n一、基础知识： 1、JVM、JRE和JDK的区别：  JVM(Java Virtual Machine):java虚拟机，用于保证java的跨平台的特性。 java语言是跨平台，jvm不是跨平台的。 JRE(Java Runtime Environment):java的运行环境,包括jvm+java的核心类库。\tJDK(Java Development Kit):java的开发工具,包括jre+开发工具\n 2、环境变量path和classpath的作用是什么？  (1)path是配置Windows可执行文件的搜索路径，即扩展名为.exe的程序文件所在的目录， 用于指定DOS窗口命令的路径。 (2)Classpath是配置class文件所在的目录，用于指定类搜索路径，JVM就是通过它来寻找该类的class类文件的。\n 3、变量有什么用？为什么要定义变量？什么时候用？  答：变量的作用：用来存储数据。 为什么要定义变量：用来不断的存放同一类型的常量，并可以重复使用\n 4、\u0026amp;和\u0026amp;\u0026amp;的区别?  答：（1）\u0026amp;\u0026amp;会出现短路，如果可以通过第一个表达式判断出整个表达式的结果，则不继续后面表达式的运算； 只能操作boolean类型数据； （2）\u0026amp;不会出现短路，将整个表达式都运算。既可以操作boolean数据还可以操作数。\n 5、标示符命名规则：  由数字(0-9)，大小写英文字母，以及_和$组成。 不能以数字开头。 不能使用关键字来自定义命名。\n 6、数据类型：  (1)基本数据类型(4类8种)： 整数类型：byte、short、int、long 浮点数类型：float、double 字符类型：char 布尔类型：boolean(ture false) (2)引用数据类型： 类 接口 数组\n 7、类型转换  精度从高到低 double float long int short(char) byte (1)自动类型转换 将一个低精度\u0026mdash;高精度 (2)强制类型转换 将一个高精度\u0026mdash;低精度(精度会下降)\n 8、java语言的三种技术架构  J2EE：企业版 是为开发企业环境下的应用程序提供的一套解决方案。 该技术体系中包含的技术如 Servlet、Jsp等，主要针对于Web应用程序开发。 J2SE：标准版 是为开发普通桌面和商务应用程序提供的解决方案。 该技术体系是其他两者的基础，可以完成一些桌面应用程序的开发。 比如Java版的扫雷。 J2ME：小型版 是为开发电子消费产品和嵌入式设备提供的解决方案。 该技术体系主要应用于小型电子消费类产品，如手机中的应用程序等。\n 9、java的跨平台性：  通过Java语言编写的应用程序在不同的系统平台上都可以运行。 跨平台的原因： 只要在需要运行java应用程序的操作系统上，先安装一个Java虚拟机(JVM Java Virtual Machine)即可。 由JVM来负责Java程序在该系统中的运行。\n 10、有符号数据的表示法(次重点)  原码，反码(原码取反)，补码(反码+1)。\n 11、函数  定义：函数就是定义在类中的具有特定功能的一段独立小程序。\t特点： 定义函数可以将功能代码进行封装 便于对该功能进行复用 函数只有被调用才会被执行 函数的出现提高了代码的复用性 对于函数没有具体返回值的情况，返回值类型用关键字void表示， 那么该函数中的return语句如果在最后一行可以省略不写。 函数的应用两个明确： 明确要定义的功能最后的结果是什么？ 明确在定义该功能的过程中，是否需要未知内容参与运算\n 12、重载：  概念：在同一个类中，允许存在一个以上的同名函数，只要它们的参数个数或者参数类型不同即可。\t特点：与返回值类型无关，只看参数列表(参数类型以及参数个数)。\t好处：方便于阅读，优化了程序设计。\n 13、数组：  概念：同一种数据类型的集合。\t好处：可以自动给数组中的元素从0开始编号，方便操作这些元素。\n 14、内存结构：  栈内存：用于存储局部变量，当数据使用完，所占空间会自动释放。 堆内存：数组和对象，通过new建立的实例都存放在堆内存中。 方法区：静态成员、构造函数、常量池、线程池 本地方法区：window系统占用 寄存器：\n 二、面向对象 1、面向对象思想：  (1)概述：面向对象是相对于面向过程而言的，面向过程强调的是功能，面向对象强调的是将功能封装进对象， 强调具备功能的对象； (2)思想特点： A:是符合人们思考习惯的一种思想； B:将复杂的事情简单化了； C:将程序员从执行者变成了指挥者； 比如我要达到某种结果，我就寻找能帮我达到该结果的功能的对象，如我要洗衣服我就买洗衣机， 至于怎么洗我不管。 (3)特征： 封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式 继承: 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义 这些属性和行为，只要继承那个类即可。 多态: 一个对象在程序不同运行时刻代表的多种状态，父类或者接口的引用指向子类对象\n 2、类和对象：  类：对现实世界中某类事物的描述,是抽象的，概念上的定义。 对象：事物具体存在的个体。\n 3：成员变量和局部变量的区别(重点)  (1)作用域 成员变量：针对整个类有效。 局部变量：只在某个范围内有效。(一般指的就是方法,语句体内) (2)存储位置 成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。 局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。 当方法调用完，或者语句结束后，就自动释放。 (3)初始值 成员变量：有默认初始值。 局部变量：没有默认初始值，使用前必须赋值。\n 4、匿名对象  (1)匿名对象就是没有名字的对象。是对象的一种简写形式。 (2)应用场景 A:只调用一次类中的方法。 B:可以作为实际参数在方法传递中使用\n 5、封装：  指隐藏对象的属性和实现细节，仅对外提供公共访问方式；比如电脑机箱、笔记本等 好处： 将变化隔离； 方便使用； 提高复用性； 提高安全性\n 6、关键字private：封装在代码中的体现  (1)私有的意思，权限修饰符 (2)用来修饰成员变量和成员函数 (3)用private修饰的成员只在本类中有效 (4)私有是封装的一种体现\n 7、构造方法：  (1)特点： 方法名与类名相同 没有返回类型 没有返回值 (2)作用：构造函数是用于创建对象，并对其进行初始化赋值，对象一建立就自动调用相对应的构造函数， (3)构造方法的注意事项: A:如果一个自定义类没有构造方法，系统会默认给出一个无参构造方法。 B:如果一个自定义类提供了构造方法，那么，系统将不再给出无参构造方法。 这个时候，你可以不使用无参构造方法。 如果你想使用，那么，就必须手动给出无参构造方法。 建议：一般情况下，我们的自定义类都要手动给出无参构造方法。 (4)构造方法和成员方法的区别 A:格式区别y 构造方法和类名相同，并且没有返回类型，也没有返回值。 普通成员方法可以任意起名，必须有返回类型，可以没有返回值。 B:作用区别 构造方法用于创建对象，并进行初始化值。 普通成员方法是用于完成特定功能的。 C:调用区别 构造方法是在创建对象时被调用的，一个对象建立，只调用一次相应构造函数 普通成员方法是由创建好的对象调用，可以调用多次\n 8、构造代码块：  (1)作用：给对象进行初始化，对象一建立就执行，而且优先于构造函数执行 (2)构造代码块和构造函数的区别： 构造代码块是给所有不同对象的共性进行统一初始化 构造函数是给对应的对象进行初始化\n 9、this关键字  (1)this关键字代表本类对象的一个引用，谁调用this所在的方法，this就代表谁\n(2)this的使用场景 A:用于区分同名成员变量和局部变量； B:在定义函数时，该函数内部要用到调用该函数的对象时，因为此时对象还没建立，故this代表此对象 B:构造函数间调用 **这个时候，this(参数)必须作为第一条语句存在。\n 10、Person p = new Person();在内存中做了哪些事情。 (1)将Person.class文件加载进内存中。\r(2)如果p定义在主方法中，那么，就会在栈空间开辟一个变量空间p。\r(3)在堆内存给对象分配空间。\r(4)对对象中的成员进行默认初始化。\r(5)对对象中的成员进行显示初始化。\r(6)调用构造代码块对对象进行初始化。(如果没有就不执行)\r(7)调用构造方法对对象进行初始化。对象初始化完毕。\r(8)将对象的内存地址赋值给p变量，让p变量指向该对象。\r 11、static关键字： (1)静态的意思，用来修饰成员变量和成员函数\r(2)静态的特点:\r随着类的加载而加载\r优先于对象存在\r对所有对象共享\r可以被类名直接调用\r(3)静态的注意事项\rA:静态方法只能访问静态成员\r为什么：因为静态的内容是随着类的加载而加载，它是先进内存的。\rB:静态方法中不能使用this,super关键字\rC:主方法是静态的\rpublic static void main(String[] args)\rpublic:公共的意思，是最大权限修饰符。\rstatic:由于jvm调用main方法的时候，没有创建对象。\r只能通过类名调用。所以，main必须用static修饰。\rvoid:由于main方法是被jvm调用，不需要返回值。用void修饰。\rmain:main是主要的意思，所以jvm采用了这个名字。是程序的入口。\rString[]:字符串数组\rargs:数组名\r在运行的时候，通过java命令给args数组赋值。\r格式：java MainTest hello world itcast\r(4)静态变量和成员变量的区别\rA：调用方式\r静态变量也称为类变量，可以直接通过类名调用。也可以通过对象名调用。\r这个变量属于类。\r成员变量也称为实例变量，只能通过对象名调用。这个变量属于对象。\rB：存储位置\r静态变量存储在方法区长中的静态区。\r成员变量存储在堆内存。\rC：生命周期\r静态变量随着类的加载而存在，随着类的消失而消失。生命周期长。\r成员变量随着对象的创建而存在，随着对象的消失而消失。\rD：与对象的相关性\r静态变量是所有对象共享的数据。\r成员变量是每个对象所特有的数据。\r(5)静态的优点和弊端\r优点：\r对对象的共享数据进行单独空间的存储，节省内存，没有必要每个对象都存储一份\r可直接被类名调用\r弊端：\r生命周期过长，随着类的消失而消失\r访问出现权限，即静态虽好但只能访问静态\r(6)什么使用使用静态呢？\rA:当所有对象共享某个数据的时候，就把这个成员变量定义为静态修饰的。\rB:当某个方法没有访问该类中的非静态成员，就可以把这个方法定义为静态修饰。\r静态的生命周期比较长，所以一般不推荐使用。\r(7)静态代码块\rA:它只执行一次，它比main还先执行。\rB:执行顺序\r静态代码块--构造代码块--构造方法\r 12、制作API(次重点) API(全拼):Application Program Interface 应用程序编程接口。\r(1)类中的内容需要用文档注释。\r(2)使用JDK\\bin目录下的javadoc工具。\r格式:javadoc -d 目录 -author -version ArrayTool.java\r 13、单例设计模式： (1)设计模式：\r解决某类问题行之有效的方法，是一种思想，是规律的总结\r(2)用来保证某个类在内存中只有一个对象\r(3)保证唯一性的思想及步骤\r**为了避免其他程序建立该类对象，先禁止其他程序建立该类对象，即将构造函数私有化\r**为了其他程序访问到该类对象，须在本类中创建一个该类私有对象\r**为了方便其他程序访问到该类对象，可对外提供一个公共访问方式\r比如API中的Runtime类就是单例设计模式。\r(4)单例设计模式的两种方式\rA:饿汉式 当类加载的时候，就创建对象。\tclass Student\r{\rprivate Student(){}\rprivate static final Student s = new Student();\rpublic static Student getInstance()\r{\rreturn s;\r}\r}\rB:懒汉式 当使用的使用，才去创建对象。\rclass Student\r{\rprivate Student(){}\rprivate static final Student s = null;\rpublic static Student getInstance()\r{\rif(s==null) {\r//线程1就进来了，线程2就进来了。\rs = new Student();\r}\rreturn s;\r}\r}\r饿汉式和懒汉式的区别：\r**\r饿汉式是类一加载进内存就创建好了对象；\r懒汉式则是类才加载进内存的时候，对象还没有存在，只有调用了getInstance()方法时，\r对象才开始创建。\r**\r懒汉式是延迟加载，如果多个线程同时操作懒汉式时就有可能出现线程安全问题，解决线程安全问题\r可以加同步来解决。但是加了同步之后，每一次都要比较锁，效率就变慢了，\r所以可以加双重判断来提高程序效率。\r注：开发常用饿汉式，因为饿汉式简单安全。懒汉式多线程的时候容易发生问题\r 14、Math类的使用(重点) (1)数学操作类:该类没有构造函数，方法均为静态的\t(2)掌握内容\rA:成员变量\r**E：比任何其他值都更接近e（即自然对数的底数）的double值。\r**PI：比任何其他值都更接近pi（即圆的周长与直径之比）的double值。\rB:成员方法\r**static double abs(double a) 返回 double 值的绝对值。返回绝对值\r**static double ceil(double a) 返回最小的（最接近负无穷大）double 值，该值大于等于参数，并等于某个整数。 **static double floor(double a) 返回最大的（最接近正无穷大）double 值，该值小于等于参数，并等于某个整数。 **max：返回两个值中较大的那个\r**min：返回两个值中较小的那个\r**static long round(double a) 返回最接近参数的 long。\rstatic int round(float a) 返回最接近参数的 int。 **static double random() 返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。 **static double pow(double a, double b) 返回第一个参数的第二个参数次幂的值。 **static double sqrt(double a) 返回正确舍入的 double 值的正平方根。  15、Random类的使用(重点) (1)产生随机数的类\r(2)掌握内容\rA:构造方法\r**Random() 创建一个新的随机数生成器。 **Random(long seed) 使用单个 long 种子创建一个新的随机数生成器。\rB:成员方法\r**int nextInt() 返回下一个伪随机数，它是此随机数生成器的序列中均匀分布的 int 值。 **int nextInt(int n) 返回一个伪随机数，它是取自此随机数生成器序列的、\r在 0（包括）和指定值（不包括）之间均匀分布的 int 值。\r 16、Scanner类的使用 (1)可以获取从键盘的输入数据\r(2)掌握内容\r构造方法：\rScanner(InputStream source) 构造一个新的 Scanner，它生成的值是从指定的输入流扫描的。\r如：Scanner sc = new Scanner(System.in);\r方法摘要\rsc.nextInt();获取整型数据\rsc.nextLine();获取字符串数据\r 17、继承(重点) (1)把很多类的相同特征和行为进行抽取，用一个类来描述。让多个类和这个类产生一个关系。\r这样的话，多个类就可以省略很多代码。这个关系就是继承。java中用extends关键字表示。\r(2)继承的体系结构\rA:多个具体的对象，不断的向上抽取共享的内容，最终形成了一个体系。这个体系叫做继承体系。\rB:继承体系的学习和使用原则\r**学习顶层的内容。因为他是整个体系的共性内容。\r**创建子类使用。也就是使用底层的具体对象。\r(3)继承的特点:\rA:java中只能单继承，没有多继承。\rB:java可以有多重(层)继承。\r(4)继承的好处：\r继承的出现提高了代码的复用性。\r继承的出现让类与类之间产生了关系，提供了多态的前提。\r(5)子父类中的成员关系\rA:成员变量\r在子类方法中使用一个变量时：\r首先，在方法的局部变量中找这个变量，有则使用。\r否则，在本类中找成员变量，有则使用。\r否则，在父类中找成员变量，有则使用。\r否则，报错。\rB:成员方法\r用子类对象使用一个方法时。\r首先，在子类中找这个方法，有则使用。\r否则，在父类中找这个方法，有则使用。\r否则，报错。\r重写和重载的区别？\r重载：在同一类中。方法名相同，参数列表不同。重载可以改变返回类型。\r重写：在不同类中(子父类中)。\r方法声明相同(返回类型，方法名，参数列表均相同)。\r重写需要注意：\r**子类方法的访问权限要大于等于父类方法的访问权限。\r**静态只能重写静态。但是这种情况一般不会出现。\r构造方法\r**子类的实例化过程\r***子类创建对象时，会先去创建父类的对象。\r默认是去调用父类的无参构造方法。\r***子类构造方法中，第一行默认是super()\r***为什么子类中第一行会默认有super()\r因为他继承父类的成员使用，使用前这些成员必须初始化，\r而他们是父类的成员，所以，必须通过父类进行初始化。\r所以，会先创建一个父类的对象。\r**当父类没有无参构造方法时\r必须使用this或者super调用其他的构造方法。\r(6)this和super的区别\rthis:代表本类对象的引用。\rsuper:代表父类的存储空间。\r 18、final关键字(重点) (1)最终的意思，可以用于修饰类，方法，变量。\r(2)final修饰的类不能被继承。\rfinal修饰的方法不能被重写。\rfinal修饰的变量是一个常量。只能被赋值一次。\r内部类只能访问被final修饰的局部变量。\r 19、抽象类(重点) (1)多个类有相同的方法声明，但是方法体不一样。这个时候，我们考虑把方法声明进行抽取。\r让子类继承后，自己去实现方法体。没有方法体的方法，我们需要用抽象标志下。\r抽象的关键字是：abstract。\r(2)抽象类：\r该方法称为抽象方法，包含抽象方法的类就是抽象类。\r(3)抽象类的特点：\rA:抽象类和抽象方法都要用abstract进行修饰\rB:抽象类不能被实例化\rC:抽象类中不一定有抽象方法，但是，有抽象方法的类一定是抽象类。\r(4)抽象类中数据的特点\rA:成员变量\r抽象类中可以有变量，也可以有常量。\rB:成员方法\r抽象类中可以有抽象方法，也可以有非抽象方法。\rC:构造方法\r抽象类是一个类，所以，它有构造方法。\r虽然本身不能实例化。但是可以给子类实例化使用。\r(5)抽象类中的问题\rA:抽象类中是否有构造方法？能不能被实例化？如果不能，为什么有构造方法？\r抽象类有构造方法。\r抽象类不能被实例化。\r抽象类中的构造方法供子类实例化调用。\rB:抽象关键字abstract不可以和哪些关键字共存？\r**private:\r私有内容子类继承不到，所以，不能重写。\r但是abstract修饰的方法，要求被重写。两者冲突。\r**final\rfinal修饰的方法不能被重写。\r而abstract修饰的方法，要求被重写。两者冲突。\t**static\r假如一个抽象方法能通过static修饰，那么这个方法，就可以直接通过类名调用。\r而抽象方法是没有方法体的，这样的调用无意义。所以，不能用static修饰。\rC:抽象类中可不可以没有抽象方法？如果可以，这样的类有什么用吗？\r抽象类可以没有抽象方法。\r抽象类中没有抽象方法的作用，只是为了不让别的类建立该抽象类对象。这个在awt中有体现。\r 20、接口interface (1)当一个类中的方法都是抽象的时候，java提供了另一种表示方式，叫接口。\r用interface关键字表示。类与接口关系用implements表示。\r(2)接口的成员特点\rA:成员变量\r是常量，默认修饰 public static final\tB:成员方法\r都是抽象的，默认修饰 public abstract\t(3)关系\rA:类与类的关系\r是继承关系。类与类只能单继承，可以多重继承。\rB:类和接口的关系\r是实现关系。类可以多实现接口。\r类在继承一个类的同时，可以实现多个接口。\rC:接口和接口的关系\r是继承关系。接口可以多继承接口。\r(4)接口的特点\rA:是对外暴露的规则\rB:是功能的扩展\rC:接口的出现降低耦合性。\r耦合(类与类之间的关系)\r内聚(类完成功能的能力)\r编程规范：低耦合，高内聚。\rD:接口可以多实现。如：CPU和主板、笔记本的USB插口、插座\r(5)接口和抽象类的区别\rA：抽象类只能被单继承\r接口可以多实现,接口的出现避免了多继承的局限性。\rB：抽象类中的数据特点：\r成员变量：可以是变量，也可以是常量\r成员方法：可以是抽象方法，也可以是非抽象方法\r构造方法：有构造方法\r接口中的数据特点：\r成员变量：是常量。默认修饰 public static final\r成员方法：都是抽象方法。都有默认修饰 public abstract\r构造方法：没有构造方法\rC：抽象类中定义的是继承体系中的共性功能。\r接口中定义的是继承体系中的扩展功能。\rD：抽象类被继承是\u0026quot;is a\u0026quot;关系:xx是yy的一种\r接口被实现是\u0026quot;like a\u0026quot;关系:xx像yy的一种\r 21、多态： (1)同一个对象，在程序不同时刻的多种运行状态。举例：动物，狗是狗，狗是动物。水(气态，液态，固态)\r(2)多态前提\rA:存在着继承或者实现关系\rB:有方法的重写\rC:父类(接口)引用指向子类(实现)对象\r(3)多态的好处和弊端：\r好处：多态的存在提高了程序的扩展性和后期可维护性\r弊端：虽然可以预先使用，但是只能访问父类中已有的功能，运行的是后期子类的功能内容。\r不能预先使用子类中定义的特有功能。\r(4)多态中对象调用成员的特点\rFu f = new Zi();\rA:成员变量\r编译看左边，运行看左边\rB:成员方法 编译看左边，运行看右边\rC:静态方法\r编译看左边，运行看左边\r(5)多态的思想\r指挥同一批对象做事情。举例：带兵打仗，下课等。\r 22、instanceof关键字 A:用于判断某个对象是否是某种类型。\rB:格式对象名 instanceof 子类(实现)名\r 23、Object类： (1)是所有类的根类，超类。\rjava中提供的类以及我们自定义的类都直接或者间接的继承自Object类。\r(2)Object类中的方法\rA:void finalize() 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。\rB:Class getClass()\r获取对象的字节码文件的描述类，后面再讲反射的时候还会在说这个类。\rString name = s.getClass().getName();\rC:int hashCode()\r获取对象的哈希值。其实就是对象的内存地址值十进制表示\rD:String toString()\r返回对象的字符串表示。\r表示格式：\rgetClass().getName()+\u0026quot;@\u0026quot;+Integer.toHexString(hashCode());\r一般我们输出对象名的时候，其实底层调用的就是该对象的toString()方法。\r这种返回没有意义，所以，我们会重写这个方法，显示类的成员变量信息。\rE:boolean equals(Object obj)\r用于比较两个对象的地址值是否相同。\r我们获取对象后，比较它的地址值意义不大。所以也会对这个方法进行重写。\r重写要完成什么功能，是根据需求定的。\r(3)==和equals的用法：\rA:==怎么用？\r**可以用于比较基本数据类型，比较的就是基本数据类型的值是否相等。\r**可以用于比较引用数据类型，比较的是对象的地址值是否相等。\rB:equals怎么用？\requals只能用于比较引用数据类型的。\r**Object提供的equals是用于比较对象地址值是否相同。\r**自定义类中，如果重写了equals方法，那么就是按照你自己的需求来比较的。\r 24、package关键字 (1)包：其实就是文件夹。用于区分不同包下相同的类名。\r(2)好处：\rA：对类文件进行分类管理。\rB：给类提供了多层命名空间\raaa.Demo\rbbb.Demo\rC：写在程序文件的第一行。\rD：包也是一种封装形式。\r 25、import关键字 (1)导入包的关键字\r(2)格式：\rimport 包名;\r(3)注意：\rA:一个程序文件中只有一个package，可以有多个import。\rB:用来导包中的类，不导入包中的包。\rC:通常写import mypack.Demo，明确自己使用的类。 (4)关键字的顺序\r类，包，导包这些关键的顺序。\r包 -- \u0026gt; 到包 -- \u0026gt; 类\r 26、不同修饰符可以修饰哪些内容    修饰符名称 本类中 同一个包中 不同包中的子类中 不同包中     private OK      默认 OK Ok     protected OK Ok OK    public OK Ok OK Ok       修饰符名称 类 构造方法 成员变量 成员方法     private OK OK OK    默认 OK Ok OK OK   protected OK Ok OK    public OK Ok OK Ok   static OK Ok     abstract Ok Ok      一般格式： 成员变量： 权限修饰符+static/final+数据类型+成员变量名 public static final int NUM = 10;\n成员方法： 权限修饰符+static/final/abstract+返回类型+方法名\n27、内部类(次重点) (1)把一个类定义在某个类中的，这个类就被称为内部类，内置类，嵌套类。\r(2)访问特点：\rA:内部类可以直接访问外部类中的成员，因为内部类持有外部类的引用，\r格式为：外部类名.this\rB:外部类要想访问内部类的成员，必须创建对象访问。\r(3)内部类的访问格式：\rA:当内部类定义在外部类的成员位置，而且非私有，则可以在其他外部类中直接建立内部类对象\r格式：外部类名.内部类名 变量名 = new 外部类对象.内部类对象\r如：Outer.Inner in = new Outer().new Inner()\rB:当内部类在外部类成员位置，且被static修饰时\r**外部其他类可直接访问静态内部类的非静态成员\r格式：new 外部类名.内部类名().内部类成员\r如：new Outer.Inner().function();\r**外部其他类可直接访问静态内部类的静态成员\r格式：new 外部类名.内部类名.内部类成员\r如：new Outer.Inner.function();\r(4)什么使用时候内部类呢？\r假如有A类和B类，A类想直接访问B类的成员，B类访问A类成员的时候，\r需要创建A类对象进行访问，这个时候，就可以把A类定义为B类的内部类。\r(5)内部类的位置\rA:成员位置\r**可以被private修饰(Body，Heart)\r**可以被static修饰。(它访问的外部类的成员必须是静态的)\tB:局部位置\r**可以直接访问外部类中的成员，因为还持有外部类的持用\r也可以直接访问局部成员，但是局部成员要用final修饰。\t注意：局部内部类不能用private和static修饰\t(6)通过class文件我们就可以区分是否带有内部类，以及内部类的位置\rOuter$Inner:成员内部类\rOuter$1Inner:局部内部类\r 28、匿名内部类(局部内部类的简写) (重点) (1)前提：继承一个类或者实现一个接口\r(注意不要弄混匿名内部类的前提和多态的前提)\r(2)格式：\rnew 父类名或者接口名()\r{\r重写父类方法或者实现接口中的方法。\r也可以自定义其他方法。\r};\r(3)什么时候定义匿名内部类？\r匿名内部类只是为了简化书写，匿名内部类有局限，通常定义匿名内部类时，该类方法不超过3个\r(4)匿名内部类的好处和弊端：\r好处：简化代码书写\r弊端：\r不能直接调用自己的特有方法\r不能执行强转换动作\r如果该类里面方法较多，不允许使用匿名内部类\r 29、模板设计模式： 在定义功能时，功能的一部分是确定的，有一部分是不确定的，而且确定的部分在使用不确定的部分，\r可将不确定的部分暴露出去，由该类的子类去完成。\r如：求一段程序的运行时间例子。\r 30、异常 (1)程序运行过程中的不正常现象就叫异常。\r(2)导致程序运行不正常的现象有很多，所以，就有很多的异常对象。\r而这些异常对象存在着共性的内容，所以，可以不断的进行抽取。最终形成了异常的体系结构。\r异常体系的根类是:Throwable\rThrowable：\r|--Error:重大的问题，我们处理不了。也不需要编写代码处理。比如说内存溢出。\r|--Exception:一般性的错误，是需要我们编写代码进行处理的。\r|--RuntimeException:运行时异常，这个我们也不需要处理。\r其实就是为了让他在运行时出问题，然后我们回来修改代码。\r(3)异常的分类\t异常有两种：\r编译时被检测异常：\r该异常在编译时，如果没有处理(没有抛也没有try)，编译失败。\r该异常被标识，代表这可以被处理。\r运行时异常(编译时不检测)\r在编译时，不需要处理，编译器不检查。\r该异常的发生，建议不处理，让程序停止。需要对代码进行修正。\r(4)异常体系的特点：\r异常体系中的所有类及其子类对象都具备可抛性。也就是说可以被throw和throws关键字所操作。\r(5)main方法是如何处理异常的。\rA:在main里面编写代码进行处理\rB:交给jvm自己进行处理。采用的是jvm的默认处理方式。\r其实就是相当于调用了异常对象的printStackTrace()方法。\r(6)Throwable类的学习\rgetMessage():获取异常信息，返回字符串。\rtoString():获取异常类名和异常信息，返回字符串。\rprintStackTrace():获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。\r(7)异常的处理·\rA:try...catch...finally\r基本格式：\rtry\r{\r可能出现异常的代码\r}\rcatch(异常对象)\r{\t异常处理代码\r}\rfinally\r{\r释放资源\r}\r变形格式：\rtry...catch\rtry...catch...catch...\rtry...catch...catch...finally\r**多个异常同时被捕获的时候，记住一个原则：\r先逮小的，再逮大的。\r**finally:永远被执行，除非退出jvm。System.exit(0);\r面试题2个。\r***：final,finally,finalize区别。\rfinal是最终的意思。它可以用于修饰类，成员变量，成员方法。\r它修饰的类不能被继承，它修饰的变量时常量，它修饰的方法不能被重写。\rfinally:是异常处理里面的关键字。\r它其中的代码永远被执行。特殊情况：在执行它之前jvm退出。System.exit(0);\rfinalize:是Object类中的一个方法。\r它是于垃圾回收器调用的方式。\r***：假如catch中有return语句， finally里中的代码会执行吗？\r是在return前，还是在return后呢？\r会，在return前执行finally里面的代码。\r(8)Exception和RuntimeException的区别\rA:Exception:一般性的错误，是需要我们编写代码进行处理的。\tB:RuntimeException:运行时异常，这个我们也不需要处理。\r其实就是为了让他在运行时出问题，然后我们回来修改代码。\r在用throws抛出一个的时候，如果这个异常是属于RuntimeException的体系的时候，\r我们在调用的地方可以不用处理。(RuntimeException和RuntimeException的子类)\r在用throws抛出一个的时候，如果这个异常是属于Exception的体系的时候，\r我们在调用的地方必须进行处理或者继续抛出。\r(9)自定义异常\r定义类继承Exception或者RuntimeException\r1,为了让该自定义类具备可抛性。\r2，让该类具备操作异常的共性方法。\rclass MyExcepiton extends Exception\r{\rMyExcepiton(){}\rMyExcepiton(String message)\r{\rsuper(message);\r}\r}\rclass MyException extends RuntimeException\r{\rMyExcepiton(){}\rMyExcepiton(String message)\r{\rsuper(message);\r}\r}\r(10)throws和throw的区别\rA：有throws的时候可以没有throw。\r有throw的时候，如果throw抛的异常是Exception体系，那么必须有throws在方法上声明。\rB：throws用于方法的声明上，其后跟的是异常类名，后面可以跟多个异常类，之间用逗号隔开\rthrow用于方法体中，其后跟的是一个异常对象名\r 三、多线程： 1、进程和线程： 进程：正在进行的程序。每一个进程执行都有一个执行顺序，该顺序是一个执行路径，或者叫一个控制单元。\r线程：进程内部的一条执行路径或者一个控制单元。\r两者的区别：\r一个进程至少有一个线程\r进程在执行过程中拥有独立的内存单元，而多个线程共享内存；\r 2、jvm多线程的启动是多线程吗？ java的虚拟机jvm启动的是单线程，就有发生内存泄露的可能，而我们使用java程序没出现这样的问题，\r也就是jvm启动至少有两个线程，一个执行java程序，一个执行垃圾回收。所以是多线程。\t 2、多线程的优势： 解决了多部分同时运行的问题，提高效率\r 3、线程的弊端： 线程太多会导致效率的降低，因为线程的执行依靠的是CPU的来回切换。\r 4、什么叫多线程： 一个进程中有多个线程，称为多线程。\r 5、实现多线程的方法： 实现多线程可以通过继承Thread类和实现Runnable接口。\r(1)继承Thread\r定义一个类继承Thread类\r复写Thread类中的public void run()方法，将线程的任务代码封装到run方法中\r直接创建Thread的子类对象，创建线程\r调用start()方法，开启线程(调用线程的任务run方法)\r//另外可以通过Thread的getName()获取线程的名称。\r(2)实现Runnable接口；\r定义一个类，实现Runnable接口；\r覆盖接口的public void run()的方法，将线程的任务代码封装到run方法中；\r创建Runnable接口的子类对象\r将Runnabl接口的子类对象作为参数传递给Thread类的构造函数，创建Thread类对象\r（原因：线程的任务都封装在Runnable接口子类对象的run方法中。\r所以要在线程对象创建时就必须明确要运行的任务）。\r调用start()方法，启动线程。\r两种方法区别：\r(1)实现Runnable接口避免了单继承的局限性\r(2)继承Thread类线程代码存放在Thread子类的run方法中\r实现Runnable接口线程代码存放在接口的子类的run方法中；\r在定义线程时，建议使用实现Runnable接口，因为几乎所有多线程都可以使用这种方式实现\r 6、创建线程是为什么要复写run方法？ Thread类用于描述线程。Thread类定义了一个功能，用于存储线程要运行的代码，该存储功能就是run方法。\r 7、start()和run方法有什么区别？ 调用start方法方可启动线程，而run方法只是thread的一个普通方法，调用run方法不能实现多线程；\rStart()方法:\rstart方法用来启动线程,实现了多线程运行,这时无需等待run方法体代码执行完毕而直接继续执行下面的\r代码。通过调用Thread类的start()方法来启动一个线程,这时此线程处于就绪(可运行)状态，并没有运行，\r一旦得到cpu时间片(执行权),就开始执行run()方法,这里方法run()称为线程体，\r它包含了要执行的这个线程的内容，Run方法运行结束,此线程随即终止。\tRun()方法:\rrun()方法只是Thread类的一个普通方法,如果直接调用Run方法,程序中依然只有主线程这一个线程,\r其程序执行路径还是只有一条，还是要等待run方法体执行完毕后才可继续执行下面的代码，\r这样就没有达到多线程的目的。\r 8、线程的几种状态： 新建：new一个Thread对象或者其子类对象就是创建一个线程，当一个线程对象被创建，但是没有开启，这个时候，\r只是对象线程对象开辟了内存空间和初始化数据。\t就绪：新建的对象调用start方法，就开启了线程，线程就到了就绪状态。\r在这个状态的线程对象，具有执行资格，没有执行权。\r运行：当线程对象获取到了CPU的资源。\r在这个状态的线程对象，既有执行资格，也有执行权。\r冻结：运行过程中的线程由于某些原因(比如wait,sleep)，释放了执行资格和执行权。\r当然，他们可以回到运行状态。只不过，不是直接回到。\r而是先回到就绪状态。\r死亡：当线程对象调用的run方法结束，或者直接调用stop方法，就让线程对象死亡，在内存中变成了垃圾。\t 9、sleep()和wait()的区别：  (1)这两个方法来自不同的类，sleep()来自Thread类，和wait()来自Object类。\r(2)sleep是Thread的静态类方法，谁调用的谁去睡觉，即使在a线程里调用了b的sleep方法，实际上还是a去睡觉，\r要让b线程睡觉要在b的代码中调用sleep。而wait()是Object类的非静态方法\r(3)sleep()释放资源不释放锁，而wait()释放资源释放锁；\r(4)使用范围：wait,notify和notifyAll只能在同步控制方法或者同步控制块里面使用,而sleep可以在任何地方使用\r 10、多线程安全问题： (1)原因:当程序的多条语句在操作线程共享数据时(如买票例子中的票就是共享资源)，由于线程的随机性导致\r一个线程对多条语句，执行了一部分还没执行完，另一个线程抢夺到cpu执行权参与进来执行，\r此时就导致共享数据发生错误。比如买票例子中打印重票和错票的情况。\t(2)解决方法:对多条操作共享数据的语句进行同步，一个线程在执行过程中其他线程不可以参与进来\r 11、Java中多线程同步是什么？  同步是用来解决多线程的安全问题的，在多线程中，同步能控制对共享数据的访问。如果没有同步，当一个线程在\r修改一个共享数据时，而另外一个线程正在使用或者更新同一个共享数据，这样容易导致程序出现错误的结果。  12、什么是锁?锁的作用是什么? 锁就是对象\r锁的作用是保证线程同步，解决线程安全问题。\r持有锁的线程可以在同步中执行，没有锁的线程即使获得cpu执行权，也进不去。\r 13、同步的前提: (1)必须保证有两个以上线程\r(2)必须是多个线程使用同一个锁，即多条语句在操作线程共享数据\r(3)必须保证同步中只有一个线程在运行\r 14、同步的好处和弊端 好处：同步解决了多线程的安全问题\r弊端：多线程都需要判断锁，比较消耗资源\r 15、同步的两种表现形式： (1)同步代码块:\r可以指定需要获取哪个对象的同步锁,使用synchronized的代码块同样需要锁,但他的锁可以是任意对象\r考虑到安全问题，一般还是使用同一个对象，相对来说效率较高。\r注意：\r**虽然同步代码快的锁可以使任何对象，但是在进行多线程通信使用同步代码快时，\r必须保证同步代码快的锁的对象和，否则会报错。\r**同步函数的锁是this，也要保证同步函数的锁的对象和调用wait、notify和notifyAll的对象是\r同一个对象，也就是都是this锁代表的对象。\r格式：\rsynchronized(对象)\r{\r需同步的代码;\r}\r(2)同步函数\r同步方法是指进入该方法时需要获取this对象的同步锁，在方法上使用synchronized关键字，\r使用this对象作为锁，也就是使用了当前对象，因为锁住了方法，所以相对于代码块来说效率相对较低。\r注:静态同步函数的锁是该方法所在的类的字节码文件对象，即类名.class文件\r格式：\r修饰词 synchronized 返回值类型 函数名(参数列表)\r{\r需同步的代码;\r}\r在jdk1.5后，用lock锁取代了synchronized，个人理解也就是对同步代码块做了修改，\r并没有提供对同步方法的修改，主要还是效率问题吧。\r 16、多线程的单例设计模式：保证某个类中内存中只有一个对象 (1)饿汉式:\rclass Single\r{\rprivate Single(){}//将构造函数私有化，不让别的类建立该类对象\rprivate static final Single s=new Single();//自己建立一个对象\rpublic static Single getInstance()//提供一个公共访问方式\r{\rreturn s;\r}\r}\r(2)懒汉式：\rclass Single\r{\rprivate Single(){} private static Single s;\rpublic static Single getInstance()\r{\rif(s==null)\rs=new Single();\rreturn s;\r}\r}\r饿汉式和懒汉式的区别：\r**\r饿汉式是类一加载进内存就创建好了对象；\r懒汉式则是类加载进内存的时候，对象还没有存在，只有调用了getInstance()方法时，对象才开始创建。\t**\r懒汉式是延迟加载，如果多个线程同时操作懒汉式时就有可能出现线程安全问题，解决线程安全问题\r可以加同步来解决。但是加了同步之后，每一次都要比较锁，效率就变慢了，\r所以可以加双重判断来提高程序效率。\r如将上述懒汉式的Instance函数改成同步：\rpublic static Single getInstance()\r{\rif(s==null)\r{\rsynchronized(Single.class)\r{\rif(s==null) s=new Single();\r}\r}\rreturn s;\r}\r 17、死锁 两个线程对两个同步对象具有循环依赖时，就会发生死锁。即同步嵌套同步，而锁却不同。\r 18、wait()、sleep()、notify()、notifyAll() wait():使一个线程处于等待状态，并且释放所持有的对象的lock。 sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。 notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，\r而是由JVM确定唤醒哪个线程(一般是最先开始等待的线程)，而且不是按优先级。 Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。\r 18、为什么wait()、notify()、notifyAll()这些用来操作线程的方法定义在Object类中？ (1)这些方法只存在于同步中；\r(2)使用这些方法时必须要指定所属的锁，即被哪个锁调用这些方法；\r(3)而锁可以是任意对象，所以任意对象调用的方法就定义在Object中。\r 19、多线程间通讯： 多线程间通讯就是多个线程在操作同一资源,但是操作的动作不同.\r(1)为什么要通信\r多线程并发执行的时候, 如果需要指定线程等待或者唤醒指定线程, 那么就需要通信.比如生产者消费者的问题，\r生产一个消费一个,生产的时候需要负责消费的进程等待,生产一个后完成后需要唤醒负责消费的线程,\r同时让自己处于等待，消费的时候负责消费的线程被唤醒，消费完生产的产品后又将等待的生产线程唤醒，\r然后使自己线程处于等待。这样来回通信，以达到生产一个消费一个的目的。\t(2)怎么通信\r在同步代码块中, 使用锁对象的wait()方法可以让当前线程等待, 直到有其他线程唤醒为止.\r使用锁对象的notify()方法可以唤醒一个等待的线程，或者notifyAll唤醒所有等待的线程.\r多线程间通信用sleep很难实现，睡眠时间很难把握。\r 20、Lock和Condition 实现提供比synchronized方法和语句可获得的更广泛的锁的操作，可支持多个相关的Condition对象\rLock是个接口\r锁是控制多个线程对共享数据进行访问的工具。\rJDK1.5中提供了多线程升级的解决方案：\r将同步synchonized替换成了显示的Lock操作，将Object中的wait、notify、notifyAll替换成了Condition对象。\r该对象可以Lock锁进行获取\rLock的方法摘要：\rvoid lock() 获取锁。 Condition newCondition() 返回绑定到此 Lock 实例的新 Condition 实例。 void unlock() 释放锁。\rCondition方法摘要：\rvoid await() 造成当前线程在接到信号或被中断之前一直处于等待状态。\rvoid signal() 唤醒一个等待线程。 void signalAll() 唤醒所有等待线程。\r 21、停止线程： stop方法已经过时，如何停止线程？\r停止线程的方法只有一种，就是run方法结束。如何让run方法结束呢？\r开启多线程运行，运行代码通常是循环体，只要控制住循环，就可以让run方法结束，也就是结束线程。\r特殊情况：当线程属于冻结状态，就不会读取循环控制标记，则线程就不会结束。\r为解决该特殊情况，可引入Thread类中的Interrupt方法结束线程的冻结状态；\r当没有指定的方式让冻结线程恢复到运行状态时，需要对冻结进行清除，强制让线程恢复到运行状态\r 22、interrupt: void interrupt() 中断线程: 中断状态将被清除，它还将收到一个 InterruptedException\r 22、守护线程(后台线程) setDaemon(boolean on):将该线程标记为守护线程或者用户线程。\r当主线程结束，守护线程自动结束，比如圣斗士星矢里面的守护雅典娜，\r在多线程里面主线程就是雅典娜，守护线程就是圣斗士，主线程结束了，\r守护线程则自动结束。\r当正在运行的线程都是守护线程时，java虚拟机jvm退出；所以该方法必须在启动线程前调用；\r守护线程的特点：\r守护线程开启后和前台线程共同抢夺cpu的执行权，开启、运行两者都没区别，\r但结束时有区别，当所有前台线程都结束后，守护线程会自动结束。\t 23、多线程join方法： void join() 等待该线程终止。\rvoid join(long millis) 等待该线程终止的时间最长为 millis 毫秒。\rthrows InterruptedException 特点：当A线程执行到B线程的join方法时，A就会等待B线程都执行完，A才会执行\r作用: join可以用来临时加入线程执行；\r 24、多线程优先级：yield()方法 yield():暂停当前正在执行的线程对象，并执行其他线程\rsetPriority(int newPriority):更改线程优先级\rint getPriority() 返回线程的优先级。\rString toString() 返回该线程的字符串表示形式，包括线程名称、优先级和线程组\r(1)MAX_PRIORITY:最高优先级(10级)\r(1)Min_PRIORITY:最低优先级(1级)\r(1)Morm_PRIORITY:默认优先级(5级)\r 25、什么是ThreadLocal类,怎么使用它？ ThreadLocal类提供了线程局部 (thread-local) 变量。是一个线程级别的局部变量，并非“本地线程”。\rThreadLocal 为每个使用该变量的线程,提供了一个独立的变量副本，每个线程修改副本时不影响其它线程对象的副本\r下面是线程局部变量(ThreadLocal variables)的关键点：\r一个线程局部变量(ThreadLocal variables)为每个线程方便地提供了一个单独的变量。\rThreadLocal 实例通常作为静态的私有的(private static)字段出现在一个类中，这个类用来关联一个线程。 当多个线程访问 ThreadLocal 实例时，每个线程维护 ThreadLocal 提供的独立的变量副本。\r常用的使用可在 DAO 模式中见到，当 DAO 类作为一个单例类时，\r数据库链接(connection)被每一个线程独立的维护，互不影响。(基于线程的单例)\r 26、什么时候抛出InvalidMonitorStateException异常?为什么？ 调用 wait ()/notify ()/notifyAll ()中的任何一个方法时，如果当前线程没有获得该对象的锁，\r那么就会抛出 IllegalMonitorStateException 的异常\r也就是说程序在没有执行对象的任何同步块或者同步方法时，\r仍然尝试调用 wait ()/notify ()/notifyAll ()时。由于该异常是 RuntimeExcpetion 的子类，\r所以该异常不一定要捕获(尽管你可以捕获只要你愿意\r作为 RuntimeException，此类异常不会在 wait (),notify (),notifyAll ()的方法签名提及。  27、在静态方法上使用同步时会发生什么事？ 同步静态方法时会获取该类的“Class”对象，所以当一个线程进入同步的静态方法中时，\r线程监视器获取类本身的对象锁，其它线程不能进入这个类的任何静态同步方法。\r它不像实例方法，因为多个线程可以同时访问不同实例同步实例方法。\r 28、当一个同步方法已经执行，线程能够调用对象上的非同步实例方法吗？ 可以，一个非同步方法总是可以被调用而不会有任何问题。\r实际上，Java 没有为非同步方法做任何检查，锁对象仅仅在同步方法或者同步代码块中检查。\r如果一个方法没有声明为同步，即使你在使用共享数据Java照样会调用，而不会做检查是否安全，\r所以在这种情况下要特别小心。一个方法是否声明为同步取决于临界区访问(critial section access)，\r如果方法不访问临界区(共享资源或者数据结构)就没必要声明为同步的。\r 29、在一个对象上两个线程可以调用两个不同的同步实例方法吗？ 不能，因为一个对象已经同步了实例方法，线程获取了对象的对象锁。\r所以只有执行完该方法释放对象锁后才能执行其它同步方法。\r 30、什么是线程饿死，什么是活锁？ 线程饿死和活锁虽然不像死锁一样是常见的问题，但是对于并发编程的设计者来说就像一次邂逅一样。\r当所有线程阻塞，或者由于需要的资源无效而不能处理，不存在非阻塞线程使资源可用。\rJavaAPI 中线程活锁可能发生在以下情形：\r当所有线程在程序中执行 Object.wait (0)，参数为 0 的 wait 方法。\r程序将发生活锁直到在相应的对象上有线程调用 Object.notify ()或者 Object.notifyAll ()。\r当所有线程卡在无限循环中。\r 四、集合框架 1：String类：字符串(重点) (1)多个字符组成的一个序列，叫字符串。\r生活中很多数据的描述都采用的是字符串的。而且我们还会对其进行操作。\r所以，java就提供了这样的一个类供我们使用。\r(2)创建字符串对象\rA:String():无参构造\r**举例：\rString s = new String();\rs = \u0026quot;hello\u0026quot;;\rsop(s);\rB:String(byte[] bys):传一个字节数组作为参数 *****\r**举例\rbyte[] bys = {97,98,99,100,101};\rString s = new String(bys);\rsop(s);\rC:String(byte[] bys,int index,int length):把字节数组的一部分转换成一个字符串 *****\r**举例\rbyte[] bys = {97,98,99,100,101};\rString s = new String(bys,1,2);\rsop(s);\rD:String(char[] chs):传一个字符数组作为参数 *****\r**举例\rchar[] chs = {'a','b','c','d','e'};\rString s = new String(chs);\rsop(s);\rE:String(char[] chs,int index,int length):把字符数组的一部分转换成一个字符串 *****\r**举例\rchar[] chs = {'a','b','c','d','e'};\rString s = new String(chs,1,2);\rsop(s);\tF:String(String str):把一个字符串传递过来作为参数\rchar[] chs = {'a','b','c','d','e'};\rString ss = new String(s);\rsop(ss);\rG:直接把字符串常量赋值给字符串引用对象(最常用) *****\r**举例\rString s = \u0026quot;hello\u0026quot;;\rsop(s);\r(3)面试题\rA:请问String s = new String(\u0026quot;hello\u0026quot;);创建了几个对象。\r两个。一个\u0026quot;hello\u0026quot;字符串对象，在方法区的常量池；一个s对象，在栈内存。\rB:请写出下面的结果\rString s1 = new String(\u0026quot;abc\u0026quot;);\rStrign s2 = new String(\u0026quot;abc\u0026quot;);\rString s3 = \u0026quot;abc\u0026quot;;\rString s4 = \u0026quot;abc\u0026quot;;\rsop(s1==s2); //false\rsop(s1==s3); //false\rsop(s3==s4); //true\rC:字符串对象一旦被创建就不能被改变。\r指的是字符串常量值不改变。\r(4)字符串中各种功能的方法\rA:判断\r****\tboolean equals(Object anObject):判断两个字符串的内容是否相同，复写了Object的方法\r****\tboolean equalsIgnoreCase(String anotherString):判断两个字符串的内容是否相同，\r不区分大小写\r****\tboolean contains(String s):判断一个字符串中是否包含另一个字符串\r注意：判断字符串是否包含特殊字符.直接表示为str.contains(\u0026quot;.\u0026quot;)\rboolean endsWith(String suffix):测试此字符串是否以指定的后缀结束\rboolean startsWith(String suffix):测试此字符串是否以指定的前缀开始\rboolean isEmpty():测试字符串是否为空\rB:获取\r*****\tint length():返回此字符串的长度\r*****\tchar charAt(int index):返回指定索引处的 char值\r*****\tint indexOf(int ch):返回指定字符在此字符串中第一次出现处的索引。 int indexOf(int ch, int fromIndex):返回在此字符串中第一次出现指定字符处的索引，\r从指定的索引开始搜索。 int indexOf(String str):返回指定子字符串在此字符串中第一次出现处的索引。 int indexOf(String str, int fromIndex):返回指定子字符串在此字符串中第一次\r出现处的索引，从指定的索引开始。 ***\tint lastIndexOf(int ch)：返回指定字符在此字符串中最后一次出现处的索引。 int lastIndexOf(int ch, int fromIndex) 返回指定字符在此字符串中最后一次出现处的索引,从指定的索引处开始进行反向搜索。 int lastIndexOf(String str) 返回指定子字符串在此字符串中最右边出现处的索引。 int lastIndexOf(String str, int fromIndex) 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。 *****\tString substring(int beginIndex) (注意：该方法substring的String是小写！！！)\r返回一个新的字符串，它是此字符串的一个子字符串。 String substring(int beginIndex, int endIndex) (注意该方法的String是小写！！！)\r返回一个新字符串，它是此字符串的一个子字符串,包含头不包含尾。 C:转换\r*****\tbyte[] getBytes()：(很常用！)从字符串到字节数组的方法\rvoid getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此字符串复制到目标字符数组。 *****\tchar[] toCharArray()：(很常用！)从字符串到字符数组的方法\r****\tstatic String copyValueOf(char[] data) 返回指定数组中表示该字符序列的 String。 static String copyValueOf(char[] data, int offset, int count) 返回指定数组中表示该字符序列的 String。 *****\tstatic String valueOf(数据类型):把该数据类型的数据转换成字符串。\r***\tString toLowerCase()：把字符串转换成小写\rString toUpperCase()：把字符串转换成大写\r***\t字符串的连接\rString concat(String str):将指定字符串连接到此字符串的结尾。\rD:替换\rString replace(char oldChar, char newChar):用新字符替换旧字符(替换所有)\rString replace(String target, String replacement):用新的子串换旧串\rE:分割\rString[] split(String regex)：根据指定的字符串把一个字符串分割成一个字符串数组\rF:\tString trim():去除字符串的前后空格\rG:\tint compareTo(String anotherString) 按字典顺序比较两个字符串。 int compareToIgnoreCase(String str) 按字典顺序比较两个字符串，不考虑大小写。 (5)练习\r1:模拟登录,给三次机会,并提示还有几次.\r默认的用户名和密码为admin。 区分大小写。\r自己从键盘输入用户名和密码。\r2:给定一个字符串统计,统计大写字母,小写字母,数字出现的个数.\r***注意:不包括特殊字符\r从键盘输入一个不包含特殊字符的字符串(只有26个字母和0-9组成)。\r3:给定一个字符串,把它变成首字母大写,其他字母小写的字符串.\r从键盘输入一个字符串，全部26个字母组成的。\r4:子串在整串中出现的次数。\r也就是说:获取一个字符串中,指定的字串在该字符串中出现的次数.\r例如:\r\u0026quot;nbasdnbafllgnbahjnbakqqqqlnba\u0026quot; 在这个字符串中，多有个nba.\r5:对字符串中字符进行自然顺序排序。\r\u0026quot;basckd\u0026quot;--\u0026gt;\u0026quot;abcdks\u0026quot;\r先留做思考内容：\r6:两个字符串的最大相同子串。\r两个字符串的最大相同子串。\r比如:\r\u0026quot;sadabcdfghjkl\u0026quot;\rwerabcdtyu\u0026quot;\r 2：StringBuffer (1)字符串的缓冲区，是一个容器。\r(2)它和String的区别\r它是缓冲区可变长度的。\r(3)构造方法\rStringBuffer() 构造一个其中不带字符的字符串缓冲区，初始容量为 16 个字符。\rStringBuffer(int num) 构造一个不带字符，但具有指定初始容量的字符串缓冲区。\rStringBuffer(String str) 构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容。\r(4)常用方法\rA:增加数据\r**append ：添加各种类型的数据\r**insert : 在容器指定位置插入各种类型的数据。\rB:删除数据\r**deleteCharAt : 删除指定位置的字符\r**delete 还可以用于清空StringBuffer的缓冲区\rC:替换\r**replace\rD:获取 **charAt E:长度和容量\r**length() 元素的个数\r**capacity 元素的理论值\rF:获取元素的位置\r**indexOf\r**lastIndexOf\rG:截取\r**substring(int start)\r**substring(int start,int end)\rH:反转\r**reverse\r(5)字符串和StringBuffer的转换\rString--\u0026gt;StringBuffer通过构造:\r如:StringBuffer sb = new StringBuffer(String str)\rStringBuffer--String通过toString方法 如:StringBuffer sb = new StringBuffer();\rsb.toString();\r 3：StringBuilder 和StringBuffer的功能是一样的，但是有区别：\rStringBuffer(JDK1.0)是线程安全的。\rStringBuilder(JDK1.5)不保证线程安全。\r一般来说，我们写的程序都是单线程的，所以，用StringBuilder，效率高。\rJDK版本的升级原则：\rA:提高效率\rB:提高安全性\rC:简化书写\r 4：基本数据类型的对象包装类 (1)为了更方便的操作每个基本数据类型，java对其提供了很多的属性和方法供我们使用。\r(2)用途：\r**将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能操作该数据。\r**常用的操作之一：用于基本数据类型与字符串之间的转换。\rA:方便操作\rB:用于和字符串进行相互转换\r(3)基本数据类型和对象类型的对应\rbyte\tByte\rshort\tShort int\tInteger\rlong\tLong\rfloat\tFloat\rdouble\tDouble\rboolean\tBoolean\rchar\tCharacter\r(4)构造方法\r字段摘要：\rstatic int MAX_VALUE 值为 2^31-1 的常量，它表示 int 类型能够表示的最大值 static int MIN_VALUE 值为 -2^31 的常量，它表示 int 类型能够表示的最小值\rstatic Class\u0026lt;Integer\u0026gt; TYPE 表示基本类型int的Class 实例\rInteger(int value) 构造一个新分配的Integer对象，它表示指定的int值。\rInreger(String s) 注意：s必须是纯数字的字符串。否则会有异常NumberFormatException\r(5)几个常用的方法\rInteger.toBinaryString();\r以二进制（基数 2）无符号整数形式返回一个整数参数的字符串表示形式。\rInteger.toOctalString();\r以八进制（基数 8）无符号整数形式返回一个整数参数的字符串表示形式。\rInteger.toHexString();\r以十六进制（基数 16）无符号整数形式返回一个整数参数的字符串表示形式。\rstatic int Integer.parseInt(String s) 将字符串参数作为有符号的十进制整数进行解析,\r字符串必须是int型范围内的数字字符串\rstatic int Integer.parseInt(String s,int basic) 使用第二个参数指定的基数,将字符串参数解析为有符号的整数.\r字符串必须是int型范围内的数字字符串\rshort shortValue() 以short类型返回该Integer的值。 int intValue() 以int类型返回该Integer的值。 static Integer valueOf(int num) 返回一个表示指定的 int 值的 Integer 实例。\rstatic Integer valueOf(String s) 返回保存指定的String的值的Integer对象。 static Integer valueOf(String s, int radix) 返回一个Integer对象，该对象中保存了用第二个参数提供的基数进行\r解析时从指定的String中提取的值。 (6)类型转换\rint -- Integer\rint num = 20;\rA:Integer i = new Integer(num);\rB:Integer i = Integer.valueOf(num);\rInteger -- int\rInteger i = new Integer(20);\rA:int num = i.intValue();\rint -- String\rint num = 20;\rA:String s = String.valueOf(num);\rB:String s = \u0026quot;\u0026quot;+num;\rC:String s = Integer.toString(num);\rString -- int\rString s = \u0026quot;20\u0026quot;;\rA:int num = Integer.parseInt(s);\rB:Integer i = new Integer(s);或者Integer i = Integer.valueOf(s);\rint num = i.intValue();\t 6、集合框架： (1)为什么出现集合类？\r面向对象对事物的体现都是以对象的形式，为了方便对多个对象的操作，就对对象进行存储。\r集合就是存储对象最常用的一种方式.\r(2)数组和集合都是容器，两者有何不同？\r**数组长度固定，而集合长度是可变的\t**数组值可以存储对象，还可以存储基本数据类型;而集合只能存储对象\t**数组存储数据类型是固定的，而集合存储的数据类型不固定\t(3)集合类的特点：\r集合只能存储对象\r集合的长度是可变的\r集合可以存储不同类型的对象\r(4)集合类框架(重要！！！要分清几种容器间的区别)：\r**Collection:顶层接口\r|---\u0026gt;List:列表，元素是有序的(元素带角标索引)，可以有重复元素,可以有null元素。\r|---\u0026gt;ArrayList(JDK1.2):底层的数据结构是数组数据结构，特点是查询速度快(因为带角标)，\r但是增删速度稍慢,因为当元素多时，增删一个元素则所有元素的角标都得改变\r线程不同步。默认长度是10，当超过长度时，按50%延长集合长度。\t|---\u0026gt;LinkedList(JDK1.2):底层数据结构式链表数据结构(即后面一个元素记录前一个)，\r特点：查询速度慢，因为每个元素只知道前面一个元素，但增删速度快\r因为元素再多，增删一个，只要让其前后的元素重新相连即可\r线程是不同步的。\t|---\u0026gt;Vector(JDK1.0):底层数据结构是数组数据结构.特点是查询和增删速度都很慢。\r默认长度是10，当超过长度时,按100%延长集合长度。\r线程同步。\r(Vector功能跟ArrayList功能一模一样，已被ArrayList替代)\r**List使用注意！\r|---\u0026gt;ArrayList:\r(1)当往ArrayList里面存入元素没什么要求时，即只要求有序就行时；\r(2)当往ArrayList里面存入元素要求不重复时，比如存入学生对象，当同名同姓时\r视为同一个人，则不往里面存储。则定义学生对象时，需复写equals方法\rpublic boolean equals(Object obj)\r{\rif(!(obj instanceof Student))\rreturn false;\rStudent stu = (Student)obj;\rreturn this.name.equals(stu.name)\u0026amp;\u0026amp;this.age==stu.age;\r}\r则往ArrayList集合通过add存入学生对象时，集合底层自己会调用学生类的equals方法，\r判断重复学生则不存入。\r注：对于List集合，无论是add、contains、还是remove方法，判断元素是否相同，\r都是通过复写equals方法来判断！\r|---\u0026gt;LinkedList\r(1)LinkLedist的特有方法：\rboolean offerFirst(E e) 在此列表的开头插入指定的元素。\rboolean offerLast(E e) 在此列表末尾插入指定的元素。\rE peekFirst() 获取但不移除此列表的第一个元素；如果此列表为空，则返回 null。\rE peekLast() 获取但不移除此列表的最后一个元素；如果此列表为空，则返回 null。\rE pollFirst() 获取并移除此列表的第一个元素；如果此列表为空，则返回 null。\rE pollLast() 获取并移除此列表的最后一个元素；如果此列表为空，则返回 null。\r(2)通过LinkLedist的特有方法，可以实现某些数据特殊方式的存取，比如堆栈和队列。\r一般情况下，使用哪种List接口下的实现类呢？\r如果要求增删快，考虑使用LinkedList\r如果要求查询快，考虑使用ArrayList\r如果要求线程安全，考虑使用Vector。\r|---\u0026gt;Set:集合，元素是无序的(因为没有索引)，元素不可以重复。可以有null元素。\r|---\u0026gt;HashSet(JDK1.2):底层数据结构是哈希表、存取速度快、元素唯一、线程不同步。\r保证性元素唯一的原理:\r先判断元素的hashCode值是否相同，再判断两元素的equals方法是否为true\r(往HashSet里面存的自定义元素要复写hashCode和equals方法，\r以保证元素的唯一性！)\r|---\u0026gt;TreeSet:底层数据结构式二叉树。可以对Set集合中的元素进行排序。元素有序、线程不同步。\r保证元素唯一性的依据：compareTo方法return 0\rTreeSet排序的第一种方式:让元素自身具备比较性，比如八种基本数据类型或则字符串，\r实现Compareble接口,覆盖compareTo方法，\r此方式是元素的自然顺序\tTreeSet排序的第一种方式:当元素自身不具备比较性(比如存储学生对象时)或者具备的\r比较性不是我们所需要的比较性时(比如想字符串的长度排序),\r此时就需要让集合自身具备自定义的比较性。 那如何让集合自身具备比较性呢？可在集合初始化时，\r就让集合具备比较方式。即定义一个类，\r实现Comparator接口，覆盖compare方法。\r**Set集合使用注意事项：\r(1)HashSet:\r通过new的方式往HashSet里面存的元素的hashCode都不同，但通常我们定义对象，\r比如学生对象时，虽然是new的两个学生对象，但是当他们name和age一样时，我们认为是\r同一个对象，所以为了保证元素的唯一性，我们通常在往HashSet集合里面存储元素时，\r在定义对象的类中通常复写hashCode和equals方法。\rpublic int hashCode()\r{\rreturn name.hashCode()+age*39;\r}\rpublic boolean equals(Object obj)\r{\rif(!(obj instanceof Student))\rreturn false;\rStudent stu = (Student)obj;\rreturn this.name.equals(stu.name)\u0026amp;\u0026amp;this.age==stu.age;\r}\rHashSet是如何保证元素唯一性的呢？\r**如果两元素的hashCode值不同，则不会调用equals方法\r**如果两元素的hashCode值相同，则继续判断equals是否返回true；\r**hashCode和equals方法虽然定义在自定义对象类里面，但不是我们手动调用\r而是往HashSet集合里面存储元素的时候，集合底层自己调用hashCode和equals\r它自己拿对象去判断，自己判断两元素是否是同一个元素。\r(2)TreeSet:\rTreeSet要求往里面存的元素具备比较性，否则会报错。\rTreeSet排序的第一种方式:让元素自身具备比较性\r定义对象类，实现Compareble接口,复写compareTo方法，此方式是元素的自然顺序\rclass Student implements Comparable\r{\rprivate String name;\rprivate int age;\rpublic Student(String name,int age)\r{\rthis.name=name;\rthis.age=age;\r}\rpublic String getName()\r{\rreturn name;\r}\rpublic int getAge()\r{\rreturn age;\r}\rpublic int compareTo(Object obj)\r{\rif(!(obj instanceof Student))\rthrow new RuntimeException(\u0026quot;不是学生对象！\u0026quot;);\rStudent stu = (Student)obj;\rint num = this.age-stu.age;\rif(num==0)\rreturn this.name.compareTo(stu.name);\rreturn num;\r}\r}\rTreeSet排序的第一种方式:让集合具备比较性\r当元素自身不具备比较性(比如存储学生对象时)或者具备的\r比较性不是我们所需要的比较性时(比如想字符串的长度排序),\r此时就需要让集合自身具备自定义的比较性。 那如何让集合自身具备比较性呢？可在集合初始化时，\r就让集合具备比较方式。即定义一个类，\r实现Comparator接口，覆盖compare方法。\rclass StringLengthComparator implements Comparator\r{\rpublic int compare(Object obj1,Object obj2)\r{\rString s1 = (String)obj1;\rString s2 = (String)obj2;\rint num = new Integer(s1.length()).compareTo(new Integer(s2.length()));\rif(num==0)\rreturn s1.compareTo(s2);\rreturn num;\r}\r}\rclass TreeSetTest\r{\rpublic static void main(String[] args)\r{\rTreeSet ts = new TreeSet(new StringLengthComparator());\rts.add(\u0026quot;addfg\u0026quot;);\rts.add(\u0026quot;dfg\u0026quot;);\rts.add(\u0026quot;agtuug\u0026quot;);\rts.add(\u0026quot;vgjkg\u0026quot;);\rsop(ts);\r}\r}\r基本数据类型或字符串对象均实现了Comparable接口，故同种类型基本数据间具备比较性，即自然顺序。\r**Map:顶层接口,该集合存储的是键值对,而且键是唯一的,Map和Set很像,Set集合底层就是使用了Map集合。\rMap集合没有迭代器，要取出元素必须先将Map集合转换成Set集合才能遍历元素\r|---\u0026gt;HashTable(JDK1.0): 底层是哈希表数据结构；\r不可以使用null键和null值；\r用作键的对象必须实现hashCode和equals方法来保证键的唯一性\r线程同步，效率低\r|---\u0026gt;HashMap(JDK1.2):\r底层是哈希表数据结构；\r允许使用null键和null值；\r线程不同步，效率高；\r保证元素唯一性的:\r原理：先判断元素的hashCode值是否相同，再判断两元素的equals方法是否为true\r(往HashSet里面存的自定义元素要复写hashCode和equals方法，\r以保证元素的唯一性！)\rclass Student {\rprivate String name;\rprivate int age;\rpublic Student(String name, int age) {\rsuper();\rthis.name = name;\rthis.age = age;\r}\rpublic int getAge() {\rreturn age;\r}\rpublic void setAge(int age) {\rthis.age = age;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r@Override\rpublic int hashCode(){\rreturn name.hashCode()+age*34;\r}\r@Override\rpublic boolean equals(Object obj){\rif(!(obj instanceof Student))\rreturn false;\rStudent stu = (Student)obj;\rreturn this.name.equals(stu.name)\u0026amp;\u0026amp;this.age==stu.age;\r}\rpublic class HashMapDemo1 {\rpublic static void main(String[] args) {\rMap\u0026lt;Student , String\u0026gt; hmap = new HashMap\u0026lt;Student , String\u0026gt;();\rhmap.put(new Student(\u0026quot;001\u0026quot;,20), \u0026quot;beijing\u0026quot;);\rhmap.put(new Student(\u0026quot;002\u0026quot;,25), \u0026quot;hebei\u0026quot;);\rhmap.put(new Student(\u0026quot;003\u0026quot;,50), \u0026quot;hainan\u0026quot;);\rhmap.put(new Student(\u0026quot;001\u0026quot;,20), \u0026quot;beijing\u0026quot;);\rSystem.out.println(hmap.size());\rSet\u0026lt;Student\u0026gt; keySet = hmap.keySet();\rIterator\u0026lt;Student\u0026gt; it = keySet.iterator();\rwhile(it.hasNext()){\rStudent stu = it.next();\rString addr = hmap.get(stu);\rSystem.out.println(stu.getName()+\u0026quot;..\u0026quot;+stu.getAge()+\u0026quot;::\u0026quot;+addr);\r}\t}\t}\t|---\u0026gt;TreeMap(JDK1.0):\r底层是二叉树结构；\r允许使用null键和null值；\r线程不同步；\r可以给Map集合中的键进行排序.\rTreeMap排序的第一种方式:让元素自身具备比较性，比如八种基本数据类型或则字符串，\r实现Compareble接口,覆盖compareTo方法，\r此方式是元素的自然顺序\tTreeMap排序的第一种方式:当元素自身不具备比较性(比如存储学生对象时)或者具备的\r比较性不是我们所需要的比较性时(比如想字符串的长度排序),\r此时就需要让集合自身具备自定义的比较性。 那如何让集合自身具备比较性呢？可在集合初始化时，\r就让集合具备比较方式。即定义一个类，\r实现Comparator接口，覆盖compare方法。\rclass Student implements Comparable\u0026lt;Student\u0026gt;{\rprivate String name;\rprivate int age;\rpublic Student(String name, int age) {\rsuper();\rthis.name = name;\rthis.age = age;\r}\rpublic int getAge() {\rreturn age;\r}\rpublic void setAge(int age) {\rthis.age = age;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r@Override\rpublic int compareTo(Student stu) {\rint num = new Integer(this.age).compareTo(new Integer(stu.age));\rif(num==0)\rreturn this.name.compareTo(stu.name);\rreturn num;\r}\t}\rpublic class HashMapDemo1 {\rpublic static void main(String[] args) {\rMap\u0026lt;Student , String\u0026gt; tmap = new TreeMap\u0026lt;Student , String\u0026gt;();\rtmap.put(new Student(\u0026quot;001\u0026quot;,20), \u0026quot;beijing\u0026quot;);\rtmap.put(new Student(\u0026quot;002\u0026quot;,25), \u0026quot;hebei\u0026quot;);\rtmap.put(new Student(\u0026quot;003\u0026quot;,50), \u0026quot;hainan\u0026quot;);\rtmap.put(new Student(\u0026quot;001\u0026quot;,20), \u0026quot;beijing\u0026quot;);\rSystem.out.println(tmap.size());\rSet\u0026lt;Student\u0026gt; keySet1 = tmap.keySet();\rIterator\u0026lt;Student\u0026gt; it1 = keySet1.iterator();\rwhile(it1.hasNext()){\rStudent stu = it1.next();\rString addr = tmap.get(stu);\rSystem.out.println(stu.getName()+\u0026quot;..\u0026quot;+stu.getAge()+\u0026quot;::\u0026quot;+addr);\t}\r}\r}\r**Iterator：对collection进行迭代的迭代器.迭代器取代了Enumeration。\r迭代器和枚举的区别：\r迭代器允许调用者利用定义良好的语义在迭代期间从迭代器所指向的collection移除元素\r方法名称得到了改进，简化书写 **LisIterator：系列表迭代器，允许程序员按任一方向遍历列表、迭代期间修改列表\t**Comparable：此接口强行对实现它的每个类的对象进行整体自然排序。使元素具备比较性\r**Comparator：强行对某个对象collection进行整体排序的比较函数，使集合具备比较性\r**Collections：此类完全由在 collection 上进行操作或返回 collection 的静态方法组成。\r**Arrays：此类包含用来操作数组(比如排序和搜索)的各种静态方法\r 7、集合类各容器方法： 接口Collection方法摘要(没有构造方法) a)添加：\ti. boolean add(E e)\tj. boolean addAll(Collection c)\rb)删除：\ri. void clear():清空容器\rj. boolean remove(Objec object):\rk. boolean removeAll(Collection c):\rc)判断：\ri. boolean contains(Object object):判断是否包含此元素\rj. boolean containsAll(Collection c):判断是否包含一堆元素\rk. boolean equals(Object object):比较此collection与指定对象是否相等\rm. boolean isEmpty():判断是否集合为空\rd)获取：\rh. Iterator iterator():取出\ri. int hashCode():返回此collection的哈希值\rj. int size():返回此collection中元素的个数\rk. boolean retainAll(Collection c):取交集\rm. Object toArray():返回此collection中所有元素的数组\rn. T[] toArray(T[] a):返回包含此collection中所有元素的数值。\r List集合子类及其方法 (1)List接口是Collection接口的一个子接口。\r(2)List接口中的元素有如下特点(对角标的操作都是特有方法，因为有序)：\rA:元素有序(存储顺序和取出顺序一致)\rB:元素可以重复\r(3)List接口中的特有方法\rA:add(int index,Object obj):在指定位置加入元素\rB:remove(int index):移除指定位置的元素\rC:set(int index,Object obj):修改指定位置的元素\rD:get(int index):获取指定位置的元素\rE:indexOf(Object obj):获取指定元素的位置\rF:subList(int start,int end):从一个大的List中截取一个小的List\rG:listIterator():返回一个List接口特有的迭代器\r (1)、ArrayList： |---\u0026gt;构造方法摘要：(少用，不是重点)\rArrayList()：构造一个初始容量为 10 的空列表。\rArrayList(Collection\u0026lt;? extends E\u0026gt; c)： 构造一个包含指定 collection 的元素的列表，\tArrayList(int initialCapacity)： 构造一个具有指定初始容量的空列表。\r|---\u0026gt;方法摘要：\r|---\u0026gt;添加：\rboolean add(E e)： 将指定的元素添加到此列表的尾部。\rvoid add(int index, E element)： 将指定的元素插入此列表中的指定位置。\rboolean addAll(Collection\u0026lt;? extends E\u0026gt; c):按照指定 collection 的迭代器所返回的元素顺序，\r将该 collection 中的所有元素添加到此列表的尾部 boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c)： 从指定的位置开始，将指定 collection\r中的所有元素插入到此列表中。 |---\u0026gt;删除：\rvoid clear(): 移除此列表中的所有元素。\rE remove(int index): 移除此列表中指定位置上的元素。 boolean remove(Object o): 移除此列表中首次出现的指定元素（如果存在）。\rprotected void removeRange(int fromIndex, int toIndex): 移除列表中索引在 fromIndex（包括）和 toIndex（不包括）之间的所有元素。\rboolean removeAll(Collection\u0026lt;?\u0026gt; c): 从列表中移除指定 collection 中包含的其所有元素 |---\u0026gt;获取：\rE get(int index): 返回此列表中指定位置上的元素。\rint indexOf(Object o): 返回此列表中首次出现的指定元素的索引，或如果此列表不包含元素，则返回 -1。\rint lastIndexOf(Object o) 返回此列表中最后一次出现的指定元素的索引，或如果此列表不包含索引，则返回 -1。 public List\u0026lt;E\u0026gt; subList(int fromIndex,int toIndex): 返回列表中指定的 fromIndex（包括 ）\t和 toIndex（不包括）之间的部分视图。\rIterator\u0026lt;E\u0026gt; iterator(): 返回按适当顺序在列表的元素上进行迭代的迭代器。\rListIterator\u0026lt;E\u0026gt; listIterator(int index):返回列表中元素的列表迭代器(按适当顺序),从列表的指定位置开始。\r|---\u0026gt;修改：(特有方法！！)\rE set(int index, E element): 用指定的元素替代此列表中指定位置上的元素。  (2)LinkedList: |---\u0026gt;构造方法摘要：\rLinkedList(): 构造一个空列表。 LinkedList(Collection\u0026lt;? extends E\u0026gt; c): 构造一个包含指定 collection 中的元素的列表，\r这些元素按其 collection 的迭代器返回的顺序排列。\r|---\u0026gt;方法摘要:(特有的)\r|---\u0026gt;添加\rvoid addFirst(E e): 将指定元素插入此列表的开头。 void addLast(E e): 将指定元素添加到此列表的结尾。 |---\u0026gt;获取元素，但不删除元素\rE get(int index): 返回此列表中指定位置处的元素。 E getFirst(): 返回此列表的第一个元素。 E getLast(): 返回此列表的最后一个元素。\r|---\u0026gt;获取元素且删除元素\rE remove()： 获取并移除此列表的头（第一个元素）。 E remove(int index)： 移除此列表中指定位置处的元素。 boolean remove(Object o)： 从此列表中移除首次出现的指定元素（如果存在）。 E removeFirst()： 移除并返回此列表的第一个元素。 E removeLast(): 移除并返回此列表的最后一个元素。\r|---\u0026gt;修改\rE set(int index, E element) 将此列表中指定位置的元素替换为指定的元素。  (3)Vector |---\u0026gt;构造方法摘要：\rVector(): 构造一个空向量，使其内部数据数组的大小为 10，其标准容量增量为零。 Vector(Collection\u0026lt;? extends E\u0026gt; c): 构造一个包含指定 collection 中的元素的向量，\r这些元素按其 collection 的迭代器返回元素的顺序排列。\r|---\u0026gt;方法摘要：\r|---\u0026gt;添加：\rboolean add(E e): 将指定元素添加到此向量的末尾。\rvoid add(int index, E element): 在此向量的指定位置插入指定的元素。 boolean addAll(Collection\u0026lt;? extends E\u0026gt; c):\r将指定 Collection 中的所有元素添加到此向量的末尾， 按照指定 collection 的迭代器所返回的顺序添加这些元素。 boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c): 在指定位置将指定 Collection 中的所有元素插入到此向量中。\r|---\u0026gt;获取:\rEnumeration\u0026lt;E\u0026gt; elements(): 返回此向量的组件的枚举。\rVector特有的取出方式:\r枚举和迭代器很像，其实枚举和迭代器是一样的，只是因为枚举的名称和方法的名称\r名字都过长，所以枚举被迭代器取代了。\r|---\u0026gt;枚举Enumeration的方法摘要：\rboolean hasMoreElements(): 测试此枚举是否包含更多的元素。 E nextElement(): 如果此枚举对象至少还有一个可提供的元素，\r则返回此枚举的下一个元素。  #####Set集合子类及其方法\n(1)HashSet:它不保证set的迭代顺序;特别是它不保证该顺序恒久不变.此类允许使用null元素。 |---\u0026gt;构造方法：\rHashSet() 构造一个新的空 set，其底层 HashMap 实例的默认初始容量是 16，加载因子是 0.75。\rHashSet(Collection\u0026lt;? extends E\u0026gt; c) 构造一个包含指定 collection 中的元素的新 set。\r|---\u0026gt;方法摘要：\rboolean add(E e) 如果此 set 中尚未包含指定元素，则添加指定元素。 void clear() 从此 set 中移除所有元素。\tObject clone() 返回此 HashSet 实例的浅表副本：并没有复制这些元素本身。 boolean contains(Object o) 如果此 set 包含指定元素，则返回 true。 boolean isEmpty() 如果此 set 不包含任何元素，则返回 true。 Iterator\u0026lt;E\u0026gt; iterator() 返回对此 set 中元素进行迭代的迭代器。 boolean remove(Object o) 如果指定元素存在于此 set 中，则将其移除。\tint size() 返回此 set 中的元素的数量（set 的容量）。  (2)TreeSet:使用元素的自然顺序对元素进行排序，或者根据创建 set 时提供的 Comparator 进行排序. |---\u0026gt;构造方法：\rTreeSet() 构造一个新的空 set，该set根据其元素的自然顺序进行排序。 TreeSet(Collection\u0026lt;? extends E\u0026gt; c) 构造一个包含指定 collection 元素的新 TreeSet，它按照其元素的自然顺序进行排序。 TreeSet(Comparator\u0026lt;? super E\u0026gt; comparator) 构造一个新的空 TreeSet，它根据指定比较器进行排序。\r|---\u0026gt;方法摘要：\r添加：\rboolean add(E e) 将指定的元素添加到此 set（如果该元素尚未存在于 set 中）。\rboolean addAll(Collection\u0026lt;? extends E\u0026gt; c) 将指定 collection 中的所有元素添加到此 set 中。\r删除：\rvoid clear() 移除此 set 中的所有元素。 boolean remove(Object o) 将指定的元素从 set 中移除（如果该元素存在于此 set 中）。 E pollFirst() 获取并移除第一个（最低）元素；如果此 set 为空，则返回 null。 E pollLast() 获取并移除最后一个（最高）元素；如果此 set 为空，则返回 null。 获取：\rIterator\u0026lt;E\u0026gt; iterator() 返回在此 set 中的元素上按升序进行迭代的迭代器。\rE first() 返回此 set 中当前第一个（最低）元素。\rE last() 返回此 set 中当前最后一个（最高）元素。\rint size() 返回 set 中的元素数（set 的容量）。\r判断：\rboolean isEmpty() 如果此 set 不包含任何元素，则返回 true。 boolean contains(Object o) 如果此 set 包含指定的元素，则返回 true。  Map:将键映射到值的对象。Map集合没有迭代器！Map集合特点：该集合存储键值对。而且键是唯一的。 |---\u0026gt;方法摘要：\r|---\u0026gt;添加：\rV put(K key, V value) 将指定的值与此映射中的指定键关联（可选操作）。 void putAll(Map\u0026lt;? extends K,? extends V\u0026gt; m) 从指定映射中将所有映射关系复制到此映射中\r|---\u0026gt;删除：\rvoid clear() 从此映射中移除所有映射关系（可选操作）。 V remove(Object key) 如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。\r|---\u0026gt;判断\rboolean containsKey(Object key) 如果此映射包含指定键的映射关系，则返回 true。 boolean containsValue(Object value) 如果此映射将一个或多个键映射到指定值，则返回 true。\rboolean isEmpty() 如果此映射未包含键-值映射关系，则返回 true。 |---\u0026gt;获取\rint size() 返回此映射中的键-值映射关系数。 Collection\u0026lt;V\u0026gt; values() 返回此映射中包含的值的 Collection 视图。\r重点：Map集合没有迭代器，以下是Map的两种取出方式：\r第一种：Set\u0026lt;K\u0026gt; keySet()\r返回此映射中包含的键的Set视图，将Map集合中所有的键存入Set集合，然后再通过Set集合的\r迭代器取出所有的键，再根据get方法获取每个键的值；\r第二种：Set\u0026lt;Map.Entry\u0026lt;K,V\u0026gt;\u0026gt; entrySet() 返回此映射中包含的映射关系的Set视图，将Map集合中的映射关系存入到Set集合中，\r这个映射关系的数据类型是Map.entry,再通过Map.Entry类的方法再要取出关系里面的键和值\rMap.Entry的方法摘要：\rboolean equals(Object o) 比较指定对象与此项的相等性。\tK getKey() 返回与此项对应的键。\tV getValue() 返回与此项对应的值。\tint hashCode() 返回此映射项的哈希码值。\rV setValue(V value) 用指定的值替换与此项对应的值(特有！！！)。\r 8、Map集合和Collection集合的区别？ 1，\rMap中一次存储是键值对。\rCollection中一次存储是单个元素。\r2，\rMap的存储使用的put方法。\rCollection存储使用的是add方法。 3，\rMap集合没有迭代器，Map的取出，是将Map转成Set，在使用迭代器取出。\rCollection取出，使用就是迭代器。\r4，\r如果对象很多，必须使用集合存储。\r如果元素存在着映射关系，可以优先考虑使用Map存储或者用数组，\r如果没有映射关系，可以使用Collection存储。\r 8、迭代器：Iterator(Map集合没有迭代器) (1)迭代器就是取出集合元素的方式\r(2)迭代器的作用\r因为每个集合中元素的取出方式都不一样，于是就把元素的取出方式进行抽取，并定义在集合内部，\r这样取出方式就可以直接访问集合内部的元素；\r而每个容器的数据结构不同，所以取出动作的细节也不一样，但是有共性内容：判断和取出。\r那么就将共性内容进行抽取，从而形成了接口Iterater\r(3)获取迭代器的方法：\rIterator\u0026lt;E\u0026gt; iterator() 返回在此 collection 的元素上进行迭代的迭代器。 Iterator\u0026lt;E\u0026gt; iterator() 返回在此 set 中的元素上进行迭代的迭代器。 (3)迭代器方法：\rboolean hasNext() 如果仍有元素可以迭代,则返回 true。\rE next() 返回迭代的下一个元素。 void remove() 从迭代器指向的collection中移除迭代器返回的最后一个元素（可选操作）。\r 9、列表迭代器：ListIterator (1)List集合特有的迭代器ListIterator是Iterator的子接口，在迭代时，不可以通过集合对象的\r方法操作集合中的元素，因为会发生ConcurrentModificationException(当方法检测到对象的并发修改，\r但不允许这种修改时，抛出此异常)\r(2)Iterator方法有限，只能对元素进行判断、取出和删除的操作\rListIterator可以对元素进行添加和修改动作等。\r(3)获取列表迭代器方法：\rListIterator\u0026lt;E\u0026gt; listIterator() 返回此列表元素的列表迭代器（按适当顺序）。 ListIterator\u0026lt;E\u0026gt; listIterator(int index) 返回此列表中的元素的列表迭代器（按适当顺序），从列表中指定位置开始。 (4)列表迭代器方法：\rvoid add(E e) 将指定的元素插入列表（可选操作）。\rboolean hasPrevious() 如果以逆向遍历列表，列表迭代器有多个元素，则返回 true。 int nextIndex() 返回对 next 的后续调用所返回元素的索引。 E previous() 返回列表中的前一个元素。 int previousIndex() 返回对 previous 的后续调用所返回元素的索引。 void set(E e) 用指定元素替换 next 或 previous 返回的最后一个元素（可选操作）。  10、堆栈和队列 堆栈：先进后出，比如杯子里的水\r队列：先进先出，比如水管的水\r 11、集合类各种容器的使用注意细节： (1)迭代器：\r**迭代器的next方法是自动向下取元素，要避免出现NoSuchElementException。\r也就是在迭代循环中调用一次next方法一次就要hasNext判断一次，比如语句\rsop(it.next()+\u0026quot;...\u0026quot;+it.next())会发生上述异常。\r**迭代器的next方法返回值类型是Object，所以要记得类型转换,应用泛型后就不用强转\r(2)List集合：\r**List集合里面的元素因为是带角标，所以List集合里面的元素都是有序的，\r另外List集合可以包含重复元素，也可以包含null。 **List集合有迭代器Iterator，还有一个特有迭代器列表ListIterator\r**List集合中判断元素是否相同都是用equals方法，无论contains、remove都依赖equals方法\r比如往ArrayList集合里面存放学生，同名同年龄视为同一个人，此时就需要在学生类复写Object类\r里面的equals方法(非常重要！！！要注意！！)\r(3)Set集合：\r**Set接口里面存放的是元素是无序的，不可以有重复元素，可以包含null\r**Set集合只有一种取出方式，就是迭代器Iterator\r**Set集合功能和Collection是一致的，没有特殊方法\r|---\u0026gt;HashSet:\r**集合里面存放的元素是无序的，唯一的\r**底层数据结构是哈希表，哈希表结构的数据都是无序的，哈希表结构的操作效率都高效\r**线程不同步\r**保证元素唯一性的原理是：通过复写hashCode和equals方法\r****如果两元素的hashCode值相同，则继续判断两元素equals是否为真\r****如果两元素的hashCode值不同，则不会调用equals方法。\r**当我们往HashSet集合存放自定义的元素时(比如学生对象)，通常都要复写hashCode和equals方法，\r而且hashCode和equals方法不通过我们调用，HashSet集合底层内部自己调用，自己拿元素去比较\r|---\u0026gt;TreeSet\r**TreeSet集合可以对存放的元素进行排序，弥补了Set集合元素无序的缺点，且元素是唯一的\r**底层数据结构是二叉树，二叉树结构都是有序的\r**线程不同步\r**TreeSet集合要求往集合里存放的元素自身具备比较性，否则会报错\r**TreeSet集合保证元素唯一性的依据是：通过compareTo或者compare方法中的来保证元素的唯一性。\rTreeSet排序的第一种方式:让元素自身具备比较性，\r定义元素类实现Compareble接口，覆盖compare方法，\r此方式是元素的自然顺序。\rTreeSet排序的第二种方式:让集合具备比较性\r当元素自身不具备比较性或者具备的比较性不是\r我们所需要的比较性时，此时就需要让集合具备自定义的比较性。\r那如何让集合自身具备比较性呢？\r可在集合初始化时，就让集合具备比较方式。\r即定义一个类，实现Comparator接口，覆盖compare方法。\r注：\r**判断元素唯一时，当主要条件一样时，判断次要条件\r**两种排序方式都在时，以比较器为主！！！\r(4)Map集合：\r|--Hashtable\r底层是哈希表结构\r线程安全的，并且键和值不能为null。\r|--HashMap\r底层是哈希表结构\r线程不安全的，键和值可以为null。\r|--LinkedHashMap\r底层是链表和哈希表\r线程不安全\r|--TreeMap\r底层是二叉树\r线程不安全的\r 12、如果你想将一组对象按一定顺序存取，在不考虑并发访问的情况下会使用____C_____ , 反之则会使用____A_____；如果你想存储一组无序但唯一的对象，你会使用___B______ ; 如果你想按关键字对对象进行存取，在不考虑并发访问的情况下会使用___D______ ,反之则会使用_____E____。\rA. Vector\rB. HashSet\rC. ArrayList\rD. HashMap\rE. Hashtable\r 13、泛型： (1)为什么会出现泛型？\r因为集合存放的数据类型不固定，故往集合里面存放元素时，存在安全隐患，\r如果在定义集合时，可以想定义数组一样指定数据类型，那么就可以解决该类安全问题。\rJDK1.5后出现了泛型，用于解决集合框架的安全问题。\r泛型是一个类型安全机制。\r(2)泛型定义格式：通过\u0026lt;\u0026gt;来定义要操作的引用数据类型\rArrayList\u0026lt;String\u0026gt; al = new ArrayList\u0026lt;String\u0026gt;;\r(3)泛型的好处：\r**将运行时期出现的ClassCastException(类型转换异常)问题转移到编译时期；\r**避免了强制转换的麻烦\r(4)什么时候定义泛型？\r泛型在集合框架中很常见，只要见到\u0026lt;\u0026gt;就要定义泛型。其实\u0026lt;\u0026gt;就是用来接收类型的。\r当使用集合时，将集合中要存储的数据类型作为参数传递到\u0026lt;\u0026gt;中即可\r(5)泛型的形式\r**泛型类：即自定义泛型类\rA：当类中要操作的引用数据类型不确定时，早起定义Object来完成扩展，现在定义泛型来完成\rB：局限性：泛型类定义的泛型，在整个类中有效，如果该泛型类的方法被调用，\r当泛型类的对象明确要操作的类型后，所有要操作的类型就被固定。\r**泛型方法：泛型放在返回值前面，修饰符的后面\rA:为了避免泛型类的局限性，让不同方法可以操作不同的类型，而且类型还不确定，\r则可以将泛型定义在方法上\rB:特殊之处：静态方法不可以反问类上定义的泛型\r如果静态方法操作的应用数据类型不确定，可以讲泛型定义在静态方法上\r**泛型接口：\r当泛型定义在接口上时，则子类中要指定实现接口类型，同时还可以子类也可以定义为泛型类\r(6)泛型的高级应用：？通配符\r**当指定两种泛型的集合，则迭代时也要定义两种泛型的迭代器，麻烦，此时可通过将迭代器的泛型\r改为？，如Iterator\u0026lt;?\u0026gt; it=al.iterator();\r**两种泛型限定\r向上限定： ? extends E ;E可以接收E类型或者E的子类\r向下限定： ? super E ;E可以接收E类型或者E的父类\r 14、高级for循环 (1)JDK1.5新特性，代替迭代器使用时的不爽，简化书写，底层原理是迭代器凡是支持迭代器的都支持高级for循环\r高级for循环，只用于集合和数组的遍历，集合只能用Collection不能用Map集合\r只能把Map集合转化成Set集合，才能用for循环。\r(2)格式\rfor(数据类型 变量名:被遍历的集合(Collection)或者数组)\r{\r}\r(3)局限性：\r必须要有遍历的目标\r对集合或者数组进行遍历时，只能获取集合元素，不能对集合元素进行操作\r迭代器除了遍历，还可以进行remove操作集合中的元素\r列表迭代器还可以在遍历过程中进行增删改查的操作\r(4)传统for循环和高级for循环的区别\r高级for循环有一个局限性，就是必须要有遍历的目标(集合或者数组)\r遍历数组时建议使用传统for循环，因为可以定义角标，比如打印100次helloworld时用传统for循环方便\r 15、可变参数 (1)数组的可变参数\r格式：\rint... arr\r(3)方法的可变参数\r格式：\rpublic static void show(String str，int... arr)\r{\r}\r注意：可变参数一定要放在参数列表的最后面\r 16、静态导入： **import static java.util.Arrays.* 导入的是Arrays这个类中所有的静态方法\r**当类名重名时，需要制定具体的报名\r**当方法重名时，需要制定具体所属的对象或者类\r 17、Collections类： (1)此类完全由在 collection 上进行操作或返回 collection 的静态方法组成。\r(2)静态方法摘要：\rstatic \u0026lt;T\u0026gt; boolean addAll(Collection\u0026lt;? super T\u0026gt; c, T... elements) 将所有指定元素添加到指定 collection 中。\rstatic \u0026lt;T\u0026gt; void fill(List\u0026lt;? super T\u0026gt; list, T obj) 使用指定元素替换指定列表中的所有元素。\rstatic \u0026lt;T\u0026gt; boolean replaceAll(List\u0026lt;T\u0026gt; list, T oldVal, T newVal) 使用另一个值替换列表中出现的所有某一指定值。 static void reverse(List\u0026lt;?\u0026gt; list) 反转指定列表中元素的顺序。 static \u0026lt;T\u0026gt; Comparator\u0026lt;T\u0026gt; reverseOrder() 返回一个比较器，它强行逆转实现了 Comparable 接口的对象 collection 的自然顺序\rstatic \u0026lt;T\u0026gt; Comparator\u0026lt;T\u0026gt; reverseOrder(Comparator\u0026lt;T\u0026gt; cmp) 返回一个比较器，它强行逆转指定比较器的顺序。 (3)Collections类特牛的方法：\r集合有一个共同的缺点，那就是线程不安全，被多线程操作时，容易出现问题，虽然可以自己加锁\r但是麻烦。Collections提供特牛的方法，就是给它一个不同步的集合，它返回一个同步的安全的集合\rstatic \u0026lt;T\u0026gt; Collection\u0026lt;T\u0026gt; synchronizedCollection(Collection\u0026lt;T\u0026gt; c) 返回指定 collection 支持的同步（线程安全的）collection。 static \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; synchronizedList(List\u0026lt;T\u0026gt; list) 返回指定列表支持的同步（线程安全的）列表。 static \u0026lt;K,V\u0026gt; Map\u0026lt;K,V\u0026gt; synchronizedMap(Map\u0026lt;K,V\u0026gt; m) 返回由指定映射支持的同步（线程安全的）映射。 static \u0026lt;T\u0026gt; Set\u0026lt;T\u0026gt; synchronizedSet(Set\u0026lt;T\u0026gt; s) 返回指定 set 支持的同步（线程安全的）set。 static \u0026lt;K,V\u0026gt; SortedMap\u0026lt;K,V\u0026gt; synchronizedSortedMap(SortedMap\u0026lt;K,V\u0026gt; m)\r返回指定有序映射支持的同步（线程安全的）有序映射。 static \u0026lt;T\u0026gt; SortedSet\u0026lt;T\u0026gt; synchronizedSortedSet(SortedSet\u0026lt;T\u0026gt; s)\r返回指定有序 set 支持的同步（线程安全的）有序 set。  18、Arrays类： 此类包含用来操作数组（比如排序和搜索）的各种方法。里面都是静态方法。\r如果指定数组引用为 null，则此类中的方法都会抛出 NullPointerException。\r(1)静态方法摘要：\rstatic \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; asList(T... a)\r返回一个受指定数组支持的固定大小的列表。\r注意：\rA:该方法将一个数组变成集合后，不可以使用集合的增删方法，因为数组的长度是固定的！\r如果增删，则发生UnsupportedOprationException(不支持操作异常)\rB:如果数组中的元素都是基本数据类型，则该数组变成集合时，会将该数组作为集合的一个\r元素出入集合\rC:如果数组中的元素都是对象，如String，那么数组变成集合后，数组中的元素就直接转成\r集合中的元素\r 19、数组变集合以及集合变数组的对比： (1)数组变集合：\r方法：static \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; asList(T... a) 返回一个受指定数组支持的固定大小的列表。\r好处：可以使用集合的思想和方法操作数组中的元素，数组是一个对象，但是数组中的功能很少\r(2)集合变数组：\r方法：Collction中的toArray方法\r好处：可以限定对集合元素的操作，防止对集合的元素进行增删，因为数组长度是固定的。\r 20、Collections类和Arrays类的使用。(重点) A:Collections\r排序\r二分查找\r发转\rB:Arrays\r把数组变成字符串输出\r排序\r二分查找\r 21、System： (1)描述系统信息的类\r(2)该类没有构造方法，该类的方法和属性都是静态的\r(3)字段摘要：\rstatic InputStream in “标准”输入流。 static PrintStream out “标准”输出流。 (4)方法摘要：\rstatic void exit(int status) 终止当前正在运行的 Java 虚拟机。 static void gc() 运行垃圾回收器。\rstatic Properties getProperties() 确定当前的系统属性 static String getProperty(String key) 获取指定键指示的系统属性。 static String getProperty(String key, String def) 获取用指定键描述的系统属性。 static void setIn(InputStream in) 重新分配“标准”输入流。 static void setOut(PrintStream out) 重新分配“标准”输出流。 static void setProperties(Properties props) 将系统属性设置为 Properties 参数。 static String setProperty(String key, String value) 设置指定键指示的系统属性。\r 22、Runtime: (1)每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。\r可以通过 getRuntime 方法获取当前运行时。 应用程序不能创建自己的 Runtime 类实例。\r(2)该类没有构造函数，也就是它不能直接创建对象，但是它里里面的方法又不是静态的\r，故它一定有一个方法返回本类对象\r(3)故该类是单例设计模式，保证在内存中只有一个对象\r(4)方法摘要：\rProcess exec(String command) 在单独的进程中执行指定的字符串命令\rvoid gc() 运行垃圾回收器。\rstatic Runtime getRuntime() 返回与当前 Java 应用程序相关的运行时对象\rvoid exit(int status) 通过启动虚拟机的关闭序列，终止当前正在运行的 Java 虚拟机\r 23、Date: (1)Date接口表示特定的瞬间，精确到毫秒\r(2)构造方法\rDate() 分配 Date 对象并初始化此对象，以表示分配它的时间（精确到毫秒）。\rDate(long date) 分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，\r即1970年1月1日00:00:00GMT）以来的指定毫秒数。\r(3)方法摘要：\rint compareTo(Date anotherDate) 比较两个日期的顺序。 boolean equals(Object obj) 比较两个日期的相等性。\r 24、Calendar： (1)直接已知子类： GregorianCalendar (2)构造方法：\rprotected Calendar() 构造一个带有默认时区和语言环境的 Calendar。 protected Calendar(TimeZone zone, Locale aLocale) 构造一个带有指定时区和语言环境的 Calendar。 (3)方法摘要：\rstatic Calendar getInstance() 使用默认时区和语言环境获得一个日历。\r 四、jdk1.5的新特性 (1)静态导入：\r**import语句可以导入一个类或某个包中的所有类\r**import static语句导入一个类中的某个静态方法或所有静态方法\r静态导入后，静态方法前面就不用写类名.方法的方式类调用\r**语法举例： import static java.lang.Math.sin;//导入一个静态方法\rimport static java.lang.Math.*; //导入一个类中的所有静态方法\r**静态导入使用注意：\r当类名重复时，需要制定具体的包名；\r当方法重名时，需要制定具体所属的对象或者类\r(2)可变参数：\r**可变参数的特点：\r*可变参数只能出现在参数列表的最后；\r*...位于变量类型和变量名之间，前后有无空格都可以;\r*调用可变参数的方法时，编译器为该可变参数隐含创建一个数组，\r在方法体中以数组的形式访问可变参数。\r**可变参数举例：\r*变量类型... 变量名 如 int... arr 表示可变参数数组\r*public static void show(String str , int... arr){}\r(3)增强for循环：\r**语法：\rfor ( type 变量名：集合变量名 ) { … } **注意事项：\r迭代变量必须在( )中定义！\r集合变量可以是数组或实现了Iterable接口的集合类\r**举例： public static int add(int x,int ...args) {\rint sum = x;\rfor(int arg:args) {\rsum += arg;\r}\rreturn sum;\r}\r**增强for循环代替了迭代器使用的不爽，简化书写\r**增强for循环局限性：\r对集合或者数组进行遍历时，只能取元素，不能对集合进行操作\r(4)基本数据类型的自动装箱和拆箱\r**基本数据类型\rbyte\t---\u0026gt;\tByte\rshort\t---\u0026gt;\tShort\rint\t---\u0026gt;\tInteger\rlong\t---\u0026gt;\tLong\rfloat\t---\u0026gt;\tFloat\rdouble\t---\u0026gt;\tDouble\rchar\t---\u0026gt;\tCharacter\rboolean\t---\u0026gt;\tBoolean\r**例子：\r**装箱：自动把一个基本数据类型的数据装箱成一个该类型数据的对象引用\rInteger i = 3;(jdk1.5之前这样写是不行的，编译报错)\r**拆箱：自动把一个基本数据类型的对象引用拆箱成一个基本数据类型的数据，再参与运算\rInteger i = 12;\rsop(i+4);\r**享元模式：\rInteger num1 = 12;\rInteger num2 = 12;\rSystem.out.println(num1 == num2);//打印true\rInteger num5 = Integer.valueOf(12);\rInteger num6 = Integer.valueOf(12);\rSystem.out.println(num5 == num6);//打印true\rInteger num3 = 129;\rInteger num4 = 129;\rSystem.out.println(num3 == num4);//打印false\r为什么前面的返回true而后面的运算返回false呢？\r对于基本数据类型的整数，装箱成Integer对象时，如果该数值在一个字节内,(-128~127)，\r一旦装箱成Integer对象后，就把它缓存到磁里面，当下次，又把该数值封装成Integer对象时\r会先看磁里面有没有该对象，有就直接拿出来用，这样就节省了内存空间。因为比较小的整数，\r用的频率比较高，就没必要每个对象都分配一个内存空间。\r这就是享元模式！比如26个英文字母，10个阿拉伯数字\r(5)枚举\r**为什么要有枚举？\r问题：要定义星期几或性别的变量，该怎么定义？假设用1-7分别表示星期一到星期日，\r但有人可能会写成int weekday = 0;或即使使用常量方式也无法阻止意外。\r枚举就是要让某个类型的变量的取值只能为若干个固定值中的一个，否则，编译器就会报错。\r枚举可以让编译器在编译时就可以控制源程序中填写的非法值，\r普通变量的方式在开发阶段无法实现这一目标。\r**用普通类如何实现枚举的功能？定义一个Weekday类来模拟实现：\r步骤：\r*私有化构造方法\r*每个元素分别用一个公有的静态成员变量表示(public static final)\r*可以有若干公有方法或抽象方法。采用抽象方法定义nextDay就将大量的if.else语句\r转移成了一个个独立的类。\r**枚举的应用：\r举例：定义一个Weekday的枚举。\r扩展：枚举类的values,valueOf,name,toString,ordinal等方法\r（记住，讲课时要先于自定义方法前介绍，讲课更流畅）\r总结：枚举是一种特殊的类，其中的每个元素都是该类的一个实例对象。 例如可以调用WeekDay.SUN.getClass().getName和WeekDay.class.getName()。\r**枚举的高级应用：\r**枚举就相当于一个类，其中也可以定义构造方法、成员变量、普通方法和抽象方法。\r**枚举元素必须位于枚举体中的最开始部分，枚举元素列表的后要有分号与其他成员分隔。\r把枚举中的成员方法或变量等放在枚举元素的前面，编译器报告错误。\r**带构造方法的枚举\r构造方法必须定义成私有的\r如果有多个构造方法，该如何选择哪个构造方法？\r枚举元素MON和MON()的效果一样，都是调用默认的构造方法。\r**带方法的枚举\r定义枚举TrafficLamp\r实现普通的next方法\r实现抽象的next方法：每个元素分别是由枚举类的子类来生成的实例对象，\r这些子类采用类似内部类的方式进行定义。增加上表示时间的构造方法\t**枚举只有一个成员时，就可以作为一种单例的实现方式。\t(6)泛型：\r**泛型是提供给javac编译器使用的，可以限定集合中的输入类型，让编译器挡住源程序中的非法输入，\r编译器编译带类型说明的集合时会去除掉“类型”信息，使程序运行效率不受影响，\r对于参数化的泛型类型，getClass()方法的返回值和原始类型完全一样。\r由于编译生成的字节码会去掉泛型的类型信息，只要能跳过编译器，\r就可以往某个泛型集合中加入其它类型的数据，例如，用反射得到集合，再调用其add方法即可。\r**ArrayList\u0026lt;E\u0026gt;类定义和ArrayList\u0026lt;Integer\u0026gt;类引用中涉及如下术语：\r整个称为ArrayList\u0026lt;E\u0026gt;泛型类型\rArrayList\u0026lt;E\u0026gt;中的E称为类型变量或类型参数\r整个ArrayList\u0026lt;Integer\u0026gt;称为参数化的类型\rArrayList\u0026lt;Integer\u0026gt;中的Integer称为类型参数的实例或实际类型参数\rArrayList\u0026lt;Integer\u0026gt;中的\u0026lt;\u0026gt;念着typeof\rArrayList称为原始类型\r**参数化类型与原始类型的兼容性：\r参数化类型可以引用一个原始类型的对象，编译报告警告，\r例如，\u000bCollection\u0026lt;String\u0026gt; c = new Vector();//可不可以，不就是编译器一句话的事吗？\r原始类型可以引用一个参数化类型的对象，编译报告警告，\r例如，\u000bCollection c = new Vector\u0026lt;String\u0026gt;();//原来的方法接受一个集合参数，新的类型也要能传进去\r**参数化类型不考虑类型参数的继承关系：\rVector\u0026lt;String\u0026gt; v = new Vector\u0026lt;Object\u0026gt;(); //错误!///不写\u0026lt;Object\u0026gt;没错，写了就是明知故犯\rVector\u0026lt;Object\u0026gt; v = new Vector\u0026lt;String\u0026gt;(); //也错误!\r编译器不允许创建泛型变量的数组。即在创建数组实例时，\r数组的元素不能使用参数化的类型，\r例如，下面语句有错误：\rVector\u0026lt;Integer\u0026gt; vectorList[] = new Vector\u0026lt;Integer\u0026gt;[10];\r**泛型限定：\r**限定通配符的上边界：\r正确：Vector\u0026lt;? extends Number\u0026gt; x = new Vector\u0026lt;Integer\u0026gt;();\r错误：Vector\u0026lt;? extends Number\u0026gt; x = new Vector\u0026lt;String\u0026gt;();\r**限定通配符的下边界：\r正确：Vector\u0026lt;? super Integer\u0026gt; x = new Vector\u0026lt;Number\u0026gt;();\r错误：Vector\u0026lt;? super Integer\u0026gt; x = new Vector\u0026lt;Byte\u0026gt;();\r**提示：\r限定通配符总是包括自己。\r?只能用作引用，不能用它去给其他变量赋值\rVector\u0026lt;? extends Number\u0026gt; y = new Vector\u0026lt;Integer\u0026gt;();\rVector\u0026lt;Number\u0026gt; x = y;\r上面的代码错误，原理与Vector\u0026lt;Object \u0026gt; x11 = new Vector\u0026lt;String\u0026gt;();相似，\r只能通过强制类型转换方式来赋值。\r 五、IO流 1、IO流概述 (1)用来处理设备(硬盘，控制台，内存)间的数据。\r(2)java中对数据的操作都是通过流的方式。\r(3)java用于操作流的类都在io包中。\r(4)按照流操作的数据的类型不同：分为字节流和字符流。字符流是为了方便中文的操作而来的。\t(5)按照流的流向不同分为：输入流，输出流\r 2、IO流常用基类： (1)字节流\r输出字节流：OutputStream：字节写入流抽象类\r|---\u0026gt;FileOutputStream：\r字节写入流\r|---\u0026gt;BufferedOutputStream：\r字节写入流缓冲区\r|---\u0026gt;PrintStream：\r打印流\r输入字节流：InputStream：字节读取流抽象类\r|---\u0026gt;FileInputStream：\r字节读取流\r|---\u0026gt;BufferedInputStream：\r字节读取流缓冲区\r(2)字符流\t输出字符流：Writer：字符写入流的抽象\r|---\u0026gt;FileWriter：\r字符写入流\r|---\u0026gt;BufferedWriter：\r字符写入流缓冲区\r|---\u0026gt;OutputStreamWriter：\r字符通向字节的转换流(涉及键盘录入时用)\r|---\u0026gt;OutputStreamWriter：\t打印流，可处理各种类型的数据\r输入字符流：Reader: 字符读取流的抽象类\r|---\u0026gt;FileReader：\r字符读取流\r|---\u0026gt;LineNumberReader：\r跟踪行号的缓冲字符读取流\r|---\u0026gt;BufferedReader：\r字符读取流缓冲区\r|---\u0026gt;InputStreamReader：\r字节通向字符的转换流(涉及键盘录入时用)\r(3)IO流常用基类方法摘要：\r**字节写入流：OutputStream：\rvoid close() 关闭此输出流并释放与此流有关的所有系统资源。\rvoid flush()刷新此输出流并强制写出所有缓冲的输出字节。\rabstract void write(int b) 将指定的字节写入此输出流。\rvoid write(byte[] b) 将 b.length 个字节从指定的 byte 数组写入此输出流。 void write(byte[] b, int off, int len) 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。 **字节读取流：InputStream：\rvoid close() 关闭此输入流并释放与该流关联的所有系统资源。\rint available() (特有方法！！)\r返回此输入流下一个方法调用可以不受阻塞地从此输入流读取（或跳过）的估计字节数。 abstract int read() 从输入流中读取数据的下一个字节。 int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。\rint read(byte[] b, int off, int len) 将输入流中最多 len 个数据字节读入 byte 数组。\rlong skip(long n) 跳过和丢弃此输入流中数据的 n 个字节。\r**字符写入流：Writer：\rabstract void close() 关闭此流，但要先刷新它。\rabstract void flush() 刷新该流的缓冲。\rvoid write(int c) 写入单个字符。\rvoid write(char[] cbuf) 写入字符数组。 abstract void write(char[] cbuf, int off, int len) 写入字符数组的某一部分。 void write(String str) 写入字符串。 void write(String str, int off, int len) 写入字符串的某一部分。 **字符读取流：Reader：\rabstract void close() 关闭该流并释放与之关联的所有资源。\rint read() 读取单个字符。\rint read(char[] cbuf) 将字符读入数组\rabstract int read(char[] cbuf, int off, int len) 将字符读入数组的某一部分。\rlong skip(long n) 跳过字符。  3、IO流常用字节流基类的子类： **写入流：\r(1)FileOutputStream：\r**构造方法：\rFileOutputStream(String name) 创建一个向具有指定名称的文件中写入数据的输出文件流。\rFileOutputStream(String name, boolean append) 创建一个向具有指定 name 的文件中写入数据的输出文件流。\rFileOutputStream(File file) 创建一个向指定 File 对象表示的文件中写入数据的文件输出流。 FileOutputStream(File file, boolean append) 创建一个向指定 File 对象表示的文件中写入数据的文件输出流。\r**方法摘要：\rpublic void flush()\rvoid close() 关闭此文件输出流并释放与此流有关的所有系统资源。\rvoid write(int b) 将指定字节写入此文件输出流。\rvoid write(byte[] b, int off, int len) 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此文件输出流。 void write(int b) 将指定字节写入此文件输出流。\r(2)BufferedOutputStream：\r**构造方法：\rBufferedOutputStream(OutputStream out) 创建一个新的缓冲输出流，以将数据写入指定的底层输出流。 BufferedOutputStream(OutputStream out, int size) 创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。 **方法摘要：\rvoid flush() 刷新此缓冲的输出流。 void write(byte[] b, int off, int len) 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此缓冲的输出流。 void write(int b) 将指定的字节写入此缓冲的输出流。\r(3)PrintStream：打印流，可将各种类型的数据原样打印，有自动刷新功能\r**构造方法：\rPrintStream(String fileName) 创建具有指定文件名称且不带自动行刷新的新打印流。\rPrintStream(File file) 创建具有指定文件且不带自动行刷新的新打印流。\rPrintStream(OutputStream out) 创建新的打印流。\rPrintStream(OutputStream out, boolean autoFlush) (当autoFlush为true时具有自动刷新功能)\r创建新的打印流。\r**方法摘要：\rPrintStream append(char c) 将指定字符添加到此输出流。\rvoid close() 关闭流。 void flush() 刷新该流的缓冲。\rvoid print(各种类型的数据：) 打印各种类型的数据 void println(各种类型的数据：)：自动换行\r打印各种类型的数据 void write(byte[] buf, int off, int len) 将 len 字节从指定的初始偏移量为 off 的 byte 数组写入此流。 void write(int b) 将指定的字节写入此流。 **读取流：\r(1)FileInputStream：\r**构造方法：\rFileInputStream(String name) 通过打开一个到实际文件的连接来创建一个 FileInputStream，\r该文件通过文件系统中的路径名 name 指定。\rFileInputStream(File file) 通过打开一个到实际文件的连接来创建一个 FileInputStream，\r该文件通过文件系统中的 File 对象 file 指定。\r**方法摘要：\rint available() (字节读取流特有方法！！！)\r返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取（或跳过）的估计剩余字节数。\rint read() 从此输入流中读取一个数据字节。 int read(byte[] b) 从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。 int read(byte[] b, int off, int len) 从此输入流中将最多 len 个字节的数据读入一个 byte 数组中。 long skip(long n) 从输入流中跳过并丢弃 n 个字节的数据。 (2)BufferedInputStream:\r**构造方法：\rBufferedInputStream(InputStream in) 创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。 BufferedInputStream(InputStream in, int size) 创建具有指定缓冲区大小的 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。 **方法摘要：\rint available() (字节读取流特有方法！！！)\r返回可以从此输入流读取（或跳过）、且不受此输入流接下来的方法调用阻塞的估计字节数。 int read() 参见 InputStream 的 read 方法的常规协定。 int read(byte[] b, int off, int len) 从此字节输入流中给定偏移量处开始将各字节读取到指定的 byte 数组中。 long skip(long n) 参见 InputStream 的 skip 方法的常规协定。\r 4、字符流常用基类的子类 **写入流：\r(1)FileWriter:\r**构造方法：\rFileWriter(String fileName) 根据给定的文件名构造一个 FileWriter 对象。 FileWriter(String fileName, boolean append) 根据给定的文件名以及指示是否附加写入数据的 boolean 值来构造 FileWriter 对象。 FileWriter(File file) 根据给定的 File 对象构造一个 FileWriter 对象。 FileWriter(File file, boolean append) 根据给定的 File 对象构造一个 FileWriter 对象。 FileWriter(FileDescriptor fd) 构造与某个文件描述符相关联的 FileWriter 对象。\r**方法摘要：跟Writer一样\rabstract void close() 关闭此流，但要先刷新它。\rabstract void flush() 刷新该流的缓冲。\rvoid write(int c) 写入单个字符。\rvoid write(char[] cbuf) 写入字符数组。 abstract void write(char[] cbuf, int off, int len) 写入字符数组的某一部分。 void write(String str) 写入字符串。 void write(String str, int off, int len) 写入字符串的某一部分。 (2)BufferedWriter:\r**构造方法：\rBufferedWriter(Writer out) 创建一个使用默认大小输出缓冲区的缓冲字符输出流。 BufferedWriter(Writer out, int sz) 创建一个使用给定大小输出缓冲区的新缓冲字符输出流。 **方法摘要：\rvoid close() 关闭此流，但要先刷新它。 void flush() 刷新该流的缓冲。 void newLine() 写入一个行分隔符。 void write(char[] cbuf, int off, int len) 写入字符数组的某一部分。 void write(int c) 写入单个字符。 void write(String s, int off, int len) 写入字符串的某一部分。 (3)OutputStreamWriter：字节通向字符的转换流\r**构造方法：\rOutputStreamWriter(OutputStream out) 创建使用默认字符编码的 OutputStreamWriter。\r**方法摘要：\rvoid write(char[] cbuf, int off, int len) 写入字符数组的某一部分。 void write(int c) 写入单个字符。 void write(String str, int off, int len) 写入字符串的某一部分。\r(4)PrintWriter:\r**构造方法：\rPrintWriter(String fileName) 创建具有指定文件名称且不带自动行刷新的新 PrintWriter。\rPrintWriter(File file) 使用指定文件创建不具有自动行刷新的新 PrintWriter。\rPrintWriter(Writer out) 创建不带自动行刷新的新 PrintWriter。 PrintWriter(Writer out, boolean autoFlush) 创建新 PrintWriter。 PrintWriter(OutputStream out) 根据现有的 OutputStream 创建不带自动行刷新的新 PrintWriter。 PrintWriter(OutputStream out, boolean autoFlush) 通过现有的 OutputStream 创建新的 PrintWriter。\r**方法摘要：\rPrintWriter append(char c) 将指定字符添加到此 writer。 void print(各种类型的数据：) 打印各种类型的数据 void println(各种类型的数据：)：自动换行\r打印各种类型的数据\rvoid write(char[] buf) 写入字符数组。 void write(char[] buf, int off, int len) 写入字符数组的某一部分。 void write(int c) 写入单个字符。 void write(String s) 写入字符串。 void write(String s, int off, int len) 写入字符串的某一部分。 **读取流：\r(1)FileReader:\r**构造方法：\rFileReader(String fileName) 在给定从中读取数据的文件名的情况下创建一个新 FileReader。\rFileReader(File file) 在给定从中读取数据的 File 的情况下创建一个新 FileReader。 FileReader(FileDescriptor fd) 在给定从中读取数据的 FileDescriptor 的情况下创建一个新 FileReader。 **方法摘要：和Reader基类方法一致：\rabstract void close() 关闭该流并释放与之关联的所有资源。\rint read() 读取单个字符。\rint read(char[] cbuf) 将字符读入数组\rabstract int read(char[] cbuf, int off, int len) 将字符读入数组的某一部分。\rlong skip(long n) 跳过字符。 (2)BufferedReader:\r**构造方法：\rBufferedReader(Reader in) 创建一个使用默认大小输入缓冲区的缓冲字符输入流。\r**方法摘要：\rint read() 读取单个字符。 int read(char[] cbuf, int off, int len) 将字符读入数组的某一部分。 String readLine() 读取一个文本行。 (3)InputStreamReader：字符通向字节的桥梁：\r**构造方法：\rInputStreamReader(InputStream in) 创建一个使用默认字符集的 InputStreamReader。\r**方法摘要:\rint read() 读取单个字符。\rint read(char[] cbuf) 将字符读入数组\rabstract int read(char[] cbuf, int off, int len) 将字符读入数组的某一部分。\rlong skip(long n) 跳过字符。\r(4)LineNumberReader：\r**构造方法：\rLineNumberReader(Reader in) 使用默认输入缓冲区的大小创建新的行编号 reader。\r**方法摘要：\rint read() 读取单个字符。 int read(char[] cbuf, int off, int len) 将字符读入数组中的某一部分。 String readLine() 读取文本行。\rlong skip(long n) 跳过字符。 int getLineNumber() 获得当前行号。 void setLineNumber(int lineNumber) 设置当前行号。  6、IO流常见需求： 字符流： (1)需求1：在硬盘上创建一个文件并写入信息\r用字符写入流：FileWriter\rFileWriter fw = new FileWriter(\u0026quot;g:\\\\filewriter.txt\u0026quot;);\rfw.write(\u0026quot;输入信息\u0026quot;);\rfw.write(\u0026quot;也可以写入字符数组\u0026quot;.toCharArray());\rfw.flush();\rfw.close();\r(2)需求2：在原有文件上续写数据\rFileWriter fw = new FileWriter(\u0026quot;g:\\\\filewriter.txt\u0026quot;,true);\rfw.write(\u0026quot;还可以续写信息\u0026quot;);\rfw.write(\u0026quot;也可以写入字符数组\u0026quot;.toCharArray());\rfw.flush();\rfw.close();\r(3)需求3：读取硬盘上的文本文件，并将数据打印在控制台\rFileReader fr = new FileReader(\u0026quot;g:\\\\filewriter.txt\u0026quot;);\r**第一种读取方法：一个一个字节的读\rint ch = 0;\rch = fr.read();\rsop((char)ch);\rfr.close();\r**第二种读取方法：利用数组来提高效率\rchar[] buf = new char[1024];\rint len = 0;\rwhile((len = fr.read(buf))!=-1)\r{\rsop(new String(buf,0,len));\r}\rfr.close();\r(4)需求4:拷贝文本文件\r利用缓冲区提高数据读写效率\r(无缓冲区就相当于一滴一滴的喝水，有缓冲区就相当于一杯一杯的喝水)\rBufferedReader bufr = new BufferedReader(new FileReader(\u0026quot;g:\\\\filewriter.txt\u0026quot;));\rBufferedWriter bufw = new BufferedWriter(new FileWriter(\u0026quot;d:\\\\copyfilewriter.txt\u0026quot;));\rString line = null;\rwhile((line = bufr.readLine())!=null)\r{\rburw.write(line);\rbufw.newLine();\rbufw.flush();\r}\rbufr.close();\rbufw.close();\r 字节流：字节流写入时没有刷新 (1)需求1：在硬盘上创建一个文件并写入信息(字节流写入时没有刷新)\rFileOutputStream fos = new FileOutputStream(\u0026quot;g:\\\\filestream.txt\u0026quot;);\rfos.write(97);//写入一个字节,int：97代表写入char：a\rfos.write(\u0026quot;也可以写入字节数组\u0026quot;.getBytes());//通常使用此种方式写入，直观！\rfos.close();\r(2)需求2：在硬盘已有文件上续写数据(字节流写入时没有刷新)\rFileOutputStream fos = new FileOutputStream(\u0026quot;g:\\\\filestream.txt\u0026quot;,true);\rfos.write(\u0026quot;创建字节写入流时，传进去一个true参数就可以继续写入信息\u0026quot;.getBytes());\rfos.close();\t(3)需求3：读取硬盘上的文件\rFileInputStream fis = new FileInputStream(\u0026quot;g:\\\\filestream.txt\u0026quot;);\r**第一种读法：一个字节一个字节的读(此种读法慢)\rint ch = 0;\rwhile((ch = fis.read())!=-1)\r{\rsop((char)ch);\r}\r**第一种读法：利用字节数组读(此种读法效率有一定提高)\rbyte[] buf = new byte[1024];\rint len = 0;\rwhile((len = fis.read())!=-1)\r{\rsop(new String(buf,0,len));\r}\r(4)需求4:拷贝字节文件，如图片或者MP3或者电影\r**第一种拷贝：不带缓冲区(慢，还是效率问题)\rFileInputStream fis = new FileInputStream(\u0026quot;g:\\\\1.mp3\u0026quot;);\rFileOutputStream fos = new FileOutputStream(\u0026quot;g:\\\\copy1.mp3\u0026quot;);\rbyte[] buf = new byte[1024];\rint len = 0;\rwhile((len = fis.read(buf))!=-1)\r{\rfos.(buf,0,len);//字节流写入无需刷新\r}\rfis.close();\rfos.close();\r**第二种拷贝：带缓冲区，高效\rBufferedInputStream bufi = new BufferedInputStream(new FileInputStream(\u0026quot;g:\\\\1.mp3\u0026quot;));\rBufferedOutputStream bufo = new BufferedOutputStream(new FileOutputStream(\u0026quot;g:\\\\copy1.mp3\u0026quot;));\rint ch = 0;\rwhile((ch = bufi.read())!=-1)\r{\rbufo.write(ch);\r}\rbufi.close();\rbufo.close();\r 转换流： (1)需求1：读取一个键盘录入\rInputStream in = System.in;//创建一个键盘录入流，流不关则可以一直录入\rint by1 = in.read();//一次读一个字节\rint by2 = in.read();//一次读一个字节\rsop(by1);//假设键盘录入的是abcd,则打印a\rsop(by2);//假设键盘录入的是abcd,则打印b\rin.close();\t(2)需求2：键盘录入一行数据打印一行数据，如果录入的是over则结束录入\rInputStream in = System.in;\rStringBuilder sb = new StringBuilder();\rwhile(true)\r{\rint ch = in.read();\rif(ch=='\\r')\rcontinue;\rif(ch=='\\n')\r{\rString line = sb.toString();\rif(\u0026quot;over\u0026quot;.equals(line))\rbreak;\rsop(line.toUpperCase());//输出大写\rsb.delete(0.sb.length());//清除上一行录入的数据\r}\relse\rsb.append((char)ch);\r}\rin.close();\r(3)需求3：发现需求2中其实就是读一行的原理，故引入字节通向字符的桥梁：InputStreamReader\r为提高效率加入缓冲区：\rBufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));\rString line = null;\rwhile((line = bufr.readLine())!=null)\r{\rif(\u0026quot;over\u0026quot;.equals(line))\rbreak;\rsop(line.toUpperCase());//输出大写\r}\rbufr.close();\r(4)需求4：键盘录入数据并打印到控制台\rBufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));\rBufferedWriter bufw = new BufferedWriter(new OntputStreamWriter(System.out));\rString line = null;\rwhile((line = bufr.readLine())!=null)\r{\tif(\u0026quot;over\u0026quot;.equals(line))\rbreak;\rbufw.write(line.toUpperCase());\rbufw.newLine();\rbufw.flush();\t}\rbufr.close();\rbufw.close();\r(5)需求5:将键盘录入的数据存储到硬盘文件\r则只需将(4)中的\rBufferedWriter bufw = new BufferedWriter(new OntputStreamWriter(System.out));\r改为：\rBufferedWriter bufw = new BufferedWriter(new OntputStreamWriter(new FileWriter(\u0026quot;g:\\\\demo.txt\u0026quot;)));\r即：\rBufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));\rBufferedWriter bufw = new BufferedWriter(new OntputStreamWriter(new FileWriter(\u0026quot;g:\\\\demo.txt\u0026quot;)));\rString line = null;\rwhile((line = bufr.readLine())!=null)\r{\tif(\u0026quot;over\u0026quot;.equals(line))\rbreak;\rbufw.write(line.toUpperCase());\rbufw.newLine();\rbufw.flush();\t}\rbufr.close();\rbufw.close();\r(6)需求6：将硬盘文件的数据打印到控制台\r则只需将(4)中的\rBufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));\r改为：\rBufferedReader bufr = new BufferedReader(new InputStreamReader(new FileReader(\u0026quot;g:\\\\demo.txt\u0026quot;)));\r即：\rBufferedReader bufr = new BufferedReader(new InputStreamReader(new FileReader(\u0026quot;g:\\\\demo.txt\u0026quot;)));\rBufferedWriter bufw = new BufferedWriter(new OntputStreamWriter(System.out));\rString line = null;\rwhile((line = bufr.readLine())!=null)\r{\tif(\u0026quot;over\u0026quot;.equals(line))\rbreak;\rbufw.write(line.toUpperCase());\rbufw.newLine();\rbufw.flush();\t}\rbufr.close();\rbufw.close();\r 7、流操作的规律： ****流操作的难点：流对象很多，不知道具体用哪个\r****规律：\r(1)第一步：先明确源和目的\r源：\r文本：用Reader\r字节：用InputStream\r目的：\r文本：用Writer\r字节：用OutputStream\r(2)第二步：明确是不是纯文本\r是：用字符流；\r不是：用字节流\r(3)第三步：明确流体系后，通过设备来明确具体使用哪个流对象\r源设备：\r键盘：System.in\r硬盘：文件流File\r内存：数组流ArrayStream\r目的设备：\r键盘：System.out\r硬盘：文件流File\r内存：数组流ArrayStream\r 8、File类 构造方法：\rFile(String pathname) 通过将给定路径名字符串转换为抽象路径名来创建一个新 File 实例。 File(String parent, String child) 根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例。\rFile(File parent, String child) 根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。\r方法摘要：\r(1)创建：\rboolean createNewFile() 当且仅当不存在具有此抽象路径名指定名称的文件时，不可分地创建一个新的空文件。 boolean mkdir() 创建一级文件夹\rboolean mkdirs() 创建多级文件夹\r(判断)：\rboolean canExecute() 测试应用程序是否可以执行此抽象路径名表示的文件。 boolean canRead() 测试应用程序是否可以读取此抽象路径名表示的文件。 boolean canWrite() 测试应用程序是否可以修改此抽象路径名表示的文件。\rint compareTo(File pathname) 按字母顺序比较两个抽象路径名。 boolean isAbsolute() 测试此抽象路径名是否为绝对路径名。 boolean isDirectory() 测试此抽象路径名表示的文件是否是一个目录。 boolean isFile() 测试此抽象路径名表示的文件是否是一个标准文件。 boolean isHidden() 测试此抽象路径名指定的文件是否是一个隐藏文件。\rboolean exists() 测试此抽象路径名表示的文件或目录是否存在。 (3)获取：\rString getParent() 返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回 null。 File getParentFile() 返回此抽象路径名父目录的抽象路径名；如果此路径名没有指定父目录，则返回 null。 String getName() 返回由此抽象路径名表示的文件或目录的名称。\rString getPath() 将此抽象路径名转换为一个路径名字符串。 String getAbsolutePath() 返回此抽象路径名的绝对路径名字符串。\rFile getAbsoluteFile() 返回此抽象路径名的绝对路径名形式。\r(4)删除：\rboolean delete() 删除此抽象路径名表示的文件或目录。 oid deleteOnExit() 在虚拟机终止时，请求删除此抽象路径名表示的文件或目录。 (5)获取全部：(非常重要！！！)\rString[] list() 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录。 String[] list(FilenameFilter filter) 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中满足指定过滤器的文件和目录。 File[] listFiles() 返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。 File[] listFiles(FileFilter filter) 返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。\r****FilenameFilter接口只有一个方法：\rboolean accept(File dir, String name) 测试指定文件是否应该包含在某一文件列表中。 ****FileFilter接口只有一个方法：\rboolean accept(File dir, String name) 测试指定文件是否应该包含在某一文件列表中。\r 8、File类常见需求： (1)文件名过滤:列出给定目录的所有.java文件\rpublic void showFileName(File file)\r{\rString[] filenames = file.list(new FilenameFilter()//匿名内部类\r{\rpublic boolean accept(File dir,String name)//复写唯一方法\r{\rreturn name.endsWith(\u0026quot;.java\u0026quot;);//列出所有.java文件\r}\r});\r}\r(2)列出指定目录下的所有文件和文件夹(递归)\r**示例1：不带层次递归：\rpublic static void showDir(File dir)\r{\rFile[] files = dir.listFile();\rfor(int i = 0;i\u0026lt;files.length;i++)\r{\rif(files[i].isDirectory\u0026amp;\u0026amp;!files[i].isHidden())\rshowDir(files[i]);\relse\rsop(files[i]);\r}\r}\r**示例2：带层次递归：\rpublic static void showDir(File dir,int level)\r{\rsop(getLevel(level)+C);//进来先打印层次和目录\rlevel++;\rFile[] files = dir.listFile();\rfor(int i = 0;i\u0026lt;files.length;i++)\r{\rif(files[i].isDirectory\u0026amp;\u0026amp;!files[i].isHidden())\rshowDir(files[i]);\relse\rsop(getLevel(level)+files[i]);//是文件就打印层次和目录\r}\r}\rpublic static String getLevel(int level)\r{\rsop(\u0026quot;|--\u0026quot;);\rStringBuilder sb = new StringBuilder();\rfor(int i=0;i\u0026lt;level;i++)\r{\rsb.inset(0.\u0026quot;| \u0026quot;)\r}\rreturn sb.toString();\r}\r(3)需求：删除带内容的目录：\rpublic static void removeDir(File dir)\r{\rFile[] files = file.listFile();\rfor(int i = 0;i\u0026lt;files.length;i++)\r{\rif(files[i].isDirectory\u0026amp;\u0026amp;!files[i].isHidden())\rremoveDir(files[i]);//如果是文件夹则继续调用函数\relse//如果是文件则删除。注意删除的时候打印删除的结果，防止误删或者重删的情况\rsop(files[i].toString()+\u0026quot;::\u0026quot;+files[i].delete());\r}\rsop(dir+\u0026quot;::\u0026quot;+dir.delete());\r}\r(4)需求：将制定目录下的java文件的绝对路径存储到文本文件中。\r思路：\r**对指定目录进行递归\r**获取递归过程中所有java文件的路径\r**将这些路径存储到集合中\r**将集合中的数据写入文件中\r//对指定目录进行递归并将所以Java文件存储到集合中\rpublic static void getFileName(File file,ArrayList\u0026lt;File\u0026gt; arraylist){\rFile[] files = file.listFiles();\rfor (int i = 0; i \u0026lt; files.length; i++) {\rif(files[i].isDirectory()\u0026amp;\u0026amp;!files[i].isHidden()){\rgetFileName(files[i],arraylist);\r}else{\rif(files[i].getName().endsWith(\u0026quot;.java\u0026quot;)){\rarraylist.add(files[i]);\r}\r}\r}\r}\r//将集合中所有数据存储到新文件中\rpublic static void saveFileToNewDir(ArrayList\u0026lt;File\u0026gt; arraylist,File newDir){\rBufferedWriter bufw = null;\rtry {\rbufw = new BufferedWriter(new FileWriter(newDir));\rfor (File file : arraylist) {\rString fileAbsolutePath = file.getAbsolutePath();\rbufw.write(fileAbsolutePath);\rbufw.newLine();\rbufw.flush();\t}\r} catch (Exception e) {\rSystem.out.println(\u0026quot;文件写入失败\u0026quot;);\r}finally{\rtry {\rif(bufw!=null)\rbufw.close();\r} catch (Exception e2) {\rSystem.out.println(\u0026quot;文件写入流关闭失败\u0026quot;);\r}\r}\r}\r 9、Properties (1)Properties是HashTable的子类，具备Map集合的特点，里面存储的是键值对\r(2)Properties是IO流合集合相结合的集合容器\r(3)Properties的特点是可以用于存储键值对形式的配置文件\r(4)构造方法：\rProperties() 创建一个无默认值的空属性列表。 Properties(Properties defaults) 创建一个带有指定默认值的空属性列表。 (5)方法摘要：\rObject setProperty(String key, String value) 调用 Hashtable 的方法 put。\rString getProperty(String key) 用指定的键在此属性列表中搜索属性。 void load(InputStream inStream) 从输入流中读取属性列表（键和元素对）。 void load(Reader reader) 按简单的面向行的格式从输入字符流中读取属性列表（键和元素对）。 void list(PrintStream out) 将属性列表输出到指定的输出流。 void list(PrintWriter out) 将属性列表输出到指定的输出流。\rvoid store(OutputStream out, String comments) 以适合使用 load(InputStream) 方法加载到 Properties 表中的格式，\r将此 Properties 表中的属性列表（键和元素对）写入输出流。 void store(Writer writer, String comments) 以适合使用 load(Reader) 方法的格式，将此 Properties 表中的\r属性列表（键和元素对）写入输出字符。 Set\u0026lt;String\u0026gt; stringPropertyNames() 返回此属性列表中的键集，其中该键及其对应值是字符串，如果在主属性列表中\r未找到同名的键，则还包括默认属性列表中不同的键 (6)Properties代码示例：\rpublic static void show()\r{\rProperties prop = new Properties();\rprop.setProperty(\u0026quot;张三\u0026quot;,\u0026quot;26\u0026quot;);\rprop.setProperty(\u0026quot;李四\u0026quot;,\u0026quot;30\u0026quot;);\rprop.setProperty(\u0026quot;王五\u0026quot;,\u0026quot;35\u0026quot;);\rsop(prop);\rString value = prop.getProperty(\u0026quot;张三\u0026quot;);\rSet\u0026lt;String\u0026gt; keys = prop.stringPropertyName();\rfor(String key : values)\r{\rsop(key+\u0026quot;:\u0026quot;+prop.getPropety(key));\r}\r}\r(7)需求：记录应用程序的使用次数，如果使用次数已到，则提示用户注册。\r思路：\r**第一次使用时建立一个配置文件用于记录使用次数\r**每次使用都加载该配置文件，并先判断已使用次数\r**每次使用完使用次数加1，写入配置文件\rpublic static void main(String[] args) throws IOException{\rProperties prop = new Properties();//定义Properties，用来和IO流结合\rFile file = new File(\u0026quot;library\\\\time.ini\u0026quot;);//配置文件\rif(!file.exists())\rfile.createNewFile();//如果文件不存在则创建文件(用于第一次使用时创建文件)\rFileInputStream fis = new FileInputStream(file);//定义字节读取流，读取配置文件中记录的使用次数\rprop.load(fis);//载入流，以获取文件中配置的键值对\rint count = 0;//定义使用次数\rString countValue = prop.getProperty(\u0026quot;time\u0026quot;);//通过键获取值\rif(countValue!=null){//第一次时countValue为null\rcount = Integer.parseInt(countValue);//将字符串次数变成数字次数\rif(count\u0026gt;3){\rSystem.out.println(\u0026quot;您使用次数已到，继续使用请注册！\u0026quot;);\rreturn;\r}\r}\rcount++;//如果使用次数未到则次数加1\rprop.setProperty(\u0026quot;time\u0026quot;, count+\u0026quot;\u0026quot;);//配置新的键值对\rFileWriter fos = new FileWriter(file);\rprop.store(fos, \u0026quot;这是应用程序使用次数的配置文件\u0026quot;);//将新的键值对写入文件\rfis.close();\rfos.close();\t}\r 10、IO中的其他流： (1)打印流：\r**PrintWriter:字符打印流\r****构造方法：\rPrintWriter(String fileName) 创建具有指定文件名称且不带自动行刷新的新 PrintWriter。\rPrintWriter(File file) 使用指定文件创建不具有自动行刷新的新 PrintWriter。\rPrintWriter(Writer out) 创建不带自动行刷新的新 PrintWriter。 PrintWriter(Writer out, boolean autoFlush) 自动刷新\rPrintWriter(OutputStream out) 根据现有的 OutputStream 创建不带自动行刷新的新 PrintWriter。 PrintWriter(OutputStream out, boolean autoFlush) 自动刷新\r****方法摘要：\rPrintWriter append(char c) 将指定字符添加到此 writer。 void close() 关闭该流并释放与之关联的所有系统资源。 void flush() 刷新该流的缓冲。 void print(Object obj) 打印对象。 void print(String s) 打印字符串。\rvoid println() 通过写入行分隔符字符串终止当前行。 **PrintStream:字节打印流\r****构造方法：\rPrintStream(String fileName) 创建具有指定文件名称且不带自动行刷新的新打印流。\rPrintStream(File file) 创建具有指定文件且不带自动行刷新的新打印流。\rPrintStream(OutputStream out) 创建新的打印流。 PrintStream(OutputStream out, boolean autoFlush) 创建新的打印流。 ****方法摘要：\rPrintWriter append(char c) 将指定字符添加到此 writer。 void close() 关闭该流并释放与之关联的所有系统资源。 void flush() 刷新该流的缓冲。 void print(Object obj) 打印对象。 void print(String s) 打印字符串。\rvoid println() 通过写入行分隔符字符串终止当前行。\r(2)对象系列化：\r**对象实体化：找一个介质，能长期的存储对象。\r**对象的属性在Java程序中，都是存在于对内存中，随着对象的消失而消失，\r而ObjectOutputStream可以将对象实体化\r**Serializable接口没有一个方法，也就是说其是一个标记接口。比如盖章的猪肉才是安全的。\r**只有实现Serializable接口的子类才能被ObjectOutputStream系列化写入流，当某个\r类实现该接口后，会被Java自动分配UID号，以便编译器识别，区分不同对象。\r**用ObjectOutputStream系列化的对象存储到文件后，该文件是乱码，也就是不可读的\r的用ObjectInputStream读取该类对象的属性。\r**由于对象是有Java给对象分配相应的UID号，而UID号是根据对象的属性不同而分配的。\r当一个类对象被系列化到文件后，如果该类改动了对象的属性，比如将某个成员变量变成私有\r则该对象再用ObjectInputStream读取时会报异常，也就是说该系列化到文件的对象不能再被使用了\r那么，要想继续使用属性被改动后的对象，我们可以自定义给对象分配UID号，让UID号不随对象的属性\r变化而变化。\r自定义对象分配UID方法如下：\rpublic static final long serialVersion UID = 43L;\r**注意：\r静态不能被系列化，因为静态成员变量实在内存的方法区，而ObjectOutputStream只能\r对对内存里面的数据进行系列化\r被transient修饰的非静态成员变量也不能被系列化\r被系列化的对象存储到文件中，该文件是不可读的，所以该文件的扩展名一般\r不写成.txt，通常后缀名写.object\r**ObjectOutputStream\r**ObjectInputStream\r(3)管道流：\rPipedInputStream\rPipedOutputStream\r(4)随机访问文件：RandomAccess(重要！！！)\r**自身具备读写方法(很牛逼！又可以读又可以写)\r**通过skipByte(int x)和seek(int x)来达到随机访问文件\r**该类不是IO体系子类，而是直接继承Object，但它是IO包中的成员，因为它具备读写方法\r**该类内部封装了数组，而且通过指针对数组的元素进行操作，可以通过getFilePoint获取指针位置\r同时可以通过seek改变指针位置\r**该类完成读写的原理是内部封装了字节输入输出流\r**通过该类的构造看出，该类只能操作文件，而且操作的文件只能有固定模式：\r\u0026quot;r\u0026quot;:只读\r\u0026quot;rw\u0026quot;:读写\r\u0026quot;rws\u0026quot;:\r\u0026quot;red\u0026quot;:\r**构造方法：\rRandomAccessFile(File file, String mode) 创建从中读取和向其中写入（可选）的随机访问文件流，该文件由 File 参数指定。 RandomAccessFile(String name, String mode) 创建从中读取和向其中写入（可选）的随机访问文件流，该文件具有指定名称。 **方法摘要：\rvoid write(byte[] b) 将 b.length 个字节从指定 byte 数组写入到此文件，并从当前文件指针开始。 void write(byte[] b, int off, int len) 将 len 个字节从指定 byte 数组写入到此文件，并从偏移量 off 处开始。 void write(int b) 向此文件写入指定的字节。 int read() 从此文件中读取一个数据字节。 int read(byte[] b) 将最多 b.length 个数据字节从此文件读入 byte 数组。 int read(byte[] b, int off, int len) 将最多 len 个数据字节从此文件读入 byte 数组。\rString readLine() 从此文件读取文本的下一行。 long getFilePointer() 返回此文件中的当前偏移量。 long length() 返回此文件的长度。 void seek(long pos) 设置到此文件开头测量到的文件指针偏移量，在该位置发生下一个读取或写入操作。\r(4)操作基本数据类型的流对象：DateStream\r(5)操作字节数组流：\rByteArrayInputStream\rByteArrayOutputStream\r 11、IO流转换流的字符编码 (1)字符流的出现为了方便操作字符，更重要的是加入了编码转换\r(2)通过子类转换流来完成\rInputStreamReander\rOutputStreamWriter\r(3)在两个子类对象进行构造的时候可以加入编码表\r(4)编码表：\r将各个国家的文字用二进制数字表示并一一对应，形成一张表，这就是编码表\r(5)常见的编码表：\r**ASCII：美国标准信息交换码，用一个字节的七位表示\r**ISO8859-1：拉丁码表，欧洲码表，用一个字节的八位表示\r**GB2312：中文编码表，用两个字节表示\r**GBK：中文编码表升级，融合录入更多的中文字符，用两个字节表示，为避免和老美重复\r两字节的最高位都是1，即汉字都是用负数表示\r**Unicode：国际标准码，融合了多种文字，所有文字都用两个字节表示\r**UTF-8：用一个字节到三个字节表示。\r注：Unicode能识别中文，UTF-8也能识别中文，但两种编码表示一个汉字所用的字节数不同\rUnicode用两个字节，UTF-8用三个字节，故涉及到编码转换。\r(6)在流中涉及编码表的转换只有转换流：\rInputStreamReander\rOutputStreamWriter\r(7)代码示例：\rpublic static void write() throws IOException\r{\rOutputStreamWriter osw1 = new OutputStreamWriter(new FileOutputStream(\u0026quot;gbk.txt\u0026quot;),\u0026quot;GBK\u0026quot;);\rosw1.write(\u0026quot;你好\u0026quot;);\rosw1.close();\rOutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(\u0026quot;utf-8.txt\u0026quot;),\u0026quot;UTF-8\u0026quot;);\rosw2.write(\u0026quot;你好\u0026quot;);\rosw2.close();\r}\rpublic static void read() throws IOException\r{\rInputStreamReader isr = new InputStreamReader(new FileInputStream(\u0026quot;gbk.txt\u0026quot;),\u0026quot;GBK\u0026quot;);\rbyte[] buf = new byte[1024];\rint len = isr.read(buf);\rsop(new String(buf,0,len));\r}\r(8)编码解码\r编码：字符串变成字节数组：String--\u0026gt;getBytes()--\u0026gt;byte[]()\r解码：字节数组变成字符串：byte[]--\u0026gt;new String(byte[],0,len)--\u0026gt;String\r(9)代码示例：\rpublic static void main(String[] args)\r{\r//编码解码1：默认编码\rString str1 = \u0026quot;你好\u0026quot;;\rbyte[] buf1 = str1.getBytes();//默认解码：Unicode，四个字节\r//编码解码2：指定编码\rString str2 = \u0026quot;你好\u0026quot;;\rbyte[] buf2 = str2.getBytes(\u0026quot;UTF-8\u0026quot;);//指定解码：UTF-8,六个字节\r//编码解码3：编码正确解码错误\rString str3 = \u0026quot;你好\u0026quot;;\rbyte[] buf3 = str3.getBytes(\u0026quot;GBK\u0026quot;);//指定编码：GBK,四个字节\rString str3 = new String(buf3,\u0026quot;ISO8859-1\u0026quot;);//错误解码\r//编码解码4：错误编码正确解码\rString str4 = \u0026quot;你好\u0026quot;;\rbyte[] buf4 = str4.getBytes(\u0026quot;ISO8859-1\u0026quot;);//错误编码\rString str4 = new String(buf4,\u0026quot;GBK\u0026quot;);//正确解码，读不出来\r//编码解码5：编码对了，但是解码错误了，怎么办呢？\r//此时可以将错误的解码再错编回去，载用正确编码解码\rString str5 = \u0026quot;你好\u0026quot;;\rbyte[] buf5 = str5.getBytes(\u0026quot;GBK\u0026quot;);//正确编码\rString str6 = new String(buf5,\u0026quot;ISO8859-1\u0026quot;);//错误解码，读不出来\rbyte[] buf6 = str6.getBytes(\u0026quot;ISO8859-1\u0026quot;);//再错误编码\rString str7 = new String(buf6,\u0026quot;GBK\u0026quot;);//再正确解码，这样就可以读出来了\r}\r ###六、网络编程：\n1、网络编程概述 (1)网络模型\rOSI参考模型\rTCP/IP参考模型\r(2)网络通讯要素\rIP地址\r端口号\r传输协议\r(3)网络通讯前提：\r**找到对方IP\r**数据要发送到指定端口。为了标示不同的应用程序，所以给这些网络应用程序都用数字进行标示\r。这个表示就叫端口。\r**定义通信规则。这个规则称为通信协议，国际组织定义了通用协议TCP/IP\r(4)计算机网络：\r是指将地理位置不同的具有独立功能的多台计算机及其外部设备，\r通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，\r实现资源共享和信息传递的计算机系统。\r(5)IP地址：\rIP地址 = 网络号码+主机地址\rA类IP地址:第一段号码为网络号码，剩下的三段号码为本地计算机的号码\rB类IP地址:前二段号码为网络号码，剩下的二段号码为本地计算机的号码\rC类IP地址:前三段号码为网络号码，剩下的一段号码为本地计算机的号码\r特殊地址:\r127.0.0.1 回环地址,可用于测试本机的网络是否有问题. ping 127.0.0.1 ipconfig:查看本机IP地址\rxxx.xxx.xxx.0 网络地址\rxxx.xxx.xxx.255 广播地址\rA类\t1.0.0.1---127.255.255.254\t10.X.X.X是私有地址(私有地址就是在互联网上不使用，而被用在局域网络中的地址)\t(2)127.X.X.X是保留地址，用做循环测试用的。\rB类\t128.0.0.1---191.255.255.254\t172.16.0.0---172.31.255.255是私有地址。169.254.X.X是保留地址。\rC类\t192.0.0.1---223.255.255.254\t192.168.X.X是私有地址\rD类\t224.0.0.1---239.255.255.254 E类\t240.0.0.1---247.255.255.254\r(6)各种网络分类方式\rA:按网络覆盖范围划分\r局域网(几米至10公里以内) 城域网(10~100公里) 广域网(几百公里到几千公里) 国际互联网\rB:按网络拓扑结构划分\r总线型网络 星形网络 环型网络 树状网络 混合型网络\rC:按传输介质划分\r有线网 无线网\rD:按网络使用性质划分\r公用网 专用网\r(7)虚拟专用网络（Virtual Private Network ，简称VPN)指的是在公用网络上建立专用网络的技术。\r其之所以称为虚拟网，主要是因为整个VPN网络的任意两个节点之间的连接并没有传统专网\r所需的端到端的物理链路，而是架构在公用网络服务商所提供的网络平台，如Internet、\rATM(异步传输模式〉、Frame Relay （帧中继）等之上的逻辑网络，\r用户数据在逻辑链路中传输。它涵盖了跨共享网络或公共网络的封装、\r加密和身份验证链接的专用网络的扩展。VPN主要采用了隧道技术、加解密技术、\r密钥管理技术和使用者与设备身份认证技术。\r(8)网络模型：\r****OSI模型\r应用层\r表示层\r会话层\r传输层\r网络层\r数据连接层\r物理层\r****TCP/IP模型\r应用层\r传输层\r网际层\r主机至网络层\r 2、TCP和UDP (1)UDP和TCP的区别：\rUDP\r将数据及源和目的封装成数据包中，不需要建立连接\r每个数据报的大小在限制在64k内\r因无连接，是不可靠协议\r不需要建立连接，速度快\rTCP\r建立连接，形成传输数据的通道。\r在连接中进行大数据量传输\r通过三次握手完成连接，是可靠协议\r必须建立连接，效率会稍低\r注：三次握手：\r第一次：我问你在么？\r第二次：你回答在。\r第三次：我反馈哦我知道你在。\r 3、Socket(UDP传输) **Socket就是为网络服务提供的一种机制。\r**通信的两端都有Socket。\r**网络通信其实就是Socket间的通信。\r**数据在两个Socket间通过IO传输。\r**玩Socket主要就是记住流程，代码查文档就行\r(1)UDP传输：DatagramSocket与DatagramPacket\r**发送端：\r建立DatagramSocket服务；\r提供数据，并将数据封装到字节数组中；\r创建DatagramPacket数据包，并把数据封装到包中，同时指定IP和接收端口\r通过Socket服务，利用send方法将数据包发送出去；\r关闭DatagramSocket和DatagramPacket服务。\r**接收端：\r建立DatagramSocket服务，并监听一个端口；\r定义一个字节数组和一个数据包，同时将数组封装进数据包；\r通过DatagramPacket的receive方法，将接收的数据存入定义好的数据包；\r通过DatagramPacke关闭t的方法，获取发送数据包中的信息；\r关闭DatagramSocket和DatagramPacket服务。\rDatagramSocket与DatagramPacket方法摘要：\r*****DatagramSocket\r构造方法：\rDatagramSocket() 构造数据报套接字并将其绑定到本地主机上任何可用的端口。\rDatagramSocket(int port) 创建数据报套接字并将其绑定到本地主机上的指定端口。 DatagramSocket(int port, InetAddress laddr) 创建数据报套接字，将其绑定到指定的本地地址。 方法摘要:\rvoid close() 关闭此数据报套接字。\rInetAddress getInetAddress() 返回此套接字连接的地址。 InetAddress getLocalAddress() 获取套接字绑定的本地地址。\rint getPort() 返回此套接字的端口。 void receive(DatagramPacket p) 从此套接字接收数据报包。 void send(DatagramPacket p) 从此套接字发送数据报包。\r****DatagramPacket\r构造方法：\rDatagramPacket(byte[] buf, int length) 构造 DatagramPacket，用来接收长度为 length 的数据包。\rDatagramPacket(byte[] buf, int length, InetAddress address, int port) 构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。\rInetAddress getAddress() 返回某台机器的 IP 地址，此数据报将要发往该机器或者是从该机器接收到的。 byte[] getData() 返回数据缓冲区。 int getLength() 返回将要发送或接收到的数据的长度。\rint getPort() 返回某台远程主机的端口号，此数据报将要发往该主机或者是从该主机接收到的。\t代码示例：\r****发送端：\rclass UDPSend\r{\rpublic static void main(String[] args) throws Exception\r{\rDatagramSocket ds = new DatagramSocket();\rbyte[] buf = \u0026quot;这是UDP发送端\u0026quot;.getBytes();\rDatagramPacket dp = new DatagramPacket(\rbuf,buf.length,InetAddress.getByName(\u0026quot;192.168.1.253\u0026quot;),10000);\rds.send(dp);\rds.close();\r}\r}\r****接收端\rclass UDPRece\r{\rpublic static void main(String[] args) throws Exception\r{\rDatagramSocket ds = new DatagramSocket(10000);\rbyte[] buf = new byte[1024];\rDatagramPacket dp = new DatagramPacket(buf,buf.length);\rds.receive(dp);//将发送端发送的数据包接收到接收端的数据包中\rString ip = dp.getAddress().getHosyAddress();//获取发送端的ip\rString data = new String(dp.getData(),0,dp.getLength());//获取数据\rint port = dp.getPort();//获取发送端的端口号\rsop(ip+\u0026quot;:\u0026quot;+data+\u0026quot;:\u0026quot;+port);\rds.close();\r}\r}\r需求1：UDP键盘录入数据，并发送给接收端\r发送端：\rclass UDPSend\r{\rpublic static void main(String[] args) throws Exception\r{\rDatagramSocket ds = new DatagramSocket();\rBufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));\rString line = null;\rwhile((line = bufr.readLine())!=null)\r{\rif(\u0026quot;886\u0026quot;.equals(line))\rbreak;\rbyte[] buf = line.getBytes();\rDatagramPacket dp = new DatagramPacket(\rbuf,buf.length,InetAddress.getByName(\u0026quot;192.168.1.253\u0026quot;),10000);\rds.send(dp);\r}\rds.close();\r}\r}\r接收端：\rclass UDPRece\r{\rpublic static void main(String[] args) throws Exception\r{\rDatagramSocket ds = new DatagramSocket(10000);\rwhile(true)\r{\rbyte[] buf = new byte[1024];\rDatagramPacket dp = new DatagramPacket(buf,buf.length);\rds.receive(dp);//将发送端发送的数据包接收到接收端的数据包中\rString ip = dp.getAddress().getHosyAddress();//获取发送端的ip\rString data = new String(dp.getData(),0,dp.getLength());//获取数据\rint port = dp.getPort();//获取发送端的端口号\rsop(ip+\u0026quot;:\u0026quot;+data+\u0026quot;:\u0026quot;+port);\rds.close();\r}\r}\r}\r需求2：编写简单的聊天工具\r思路：\r使用多线程技术\r发送端：\rclass UDPSend implements Runnable\r{\rprivate DatagramSocket ds;\rpublic UDPSend(){}\rpublic UDPSend(DatagramSocket ds)\r{\rthis.ds=ds;\r}\rpublic void run()\r{\rtry\r{\rBufferedReader bufr = new BufferedReader(\rnew InputStreamReader(System.in));\rString line = null;\rwhile((line = bufr.readLine())!=null)\r{\rif(\u0026quot;886\u0026quot;.equals(line))\rbreak;\rbyte[] buff = line.getBytes();\rDatagramPacket dp = new DatagramPacket(\rbuf,buf.length,InetAddress.getByName(\u0026quot;192.168.1.253\u0026quot;),10000);\rds.send(dp);\r}\r}\rcatch(Exception e)\r{\rthrow new RuntimeException(\u0026quot;发送失败\u0026quot;);\r}\r}\r}\r接收端：\rclass UDPRece implements Runnable\r{\rprivate DatagramSocket ds;\rpublic UDPSend(){}\rpublic UDPSend(DatagramSocket ds)\r{\rthis.ds=ds;\r}\rpublic void run()\r{\rtry\r{\rwhile(true)\r{\tbyte[] buf = new byte[1024];\rDatagramPacket dp = new DatagramPacket(buf,buf.length);\rds.receive(dp);//将发送端发送的数据包接收到接收端的数据包中\rString ip = dp.getAddress().getHosyAddress();//获取发送端的ip\rString data = new String(dp.getData(),0,dp.getLength());//获取数据\rint port = dp.getPort();//获取发送端的端口号\rsop(ip+\u0026quot;:\u0026quot;+data+\u0026quot;:\u0026quot;+port);\t}\r}\rcatch(Exception e)\r{\rthrow new RuntimeException(\u0026quot;接收失败\u0026quot;);\r}\r}\r}\r测试类：\rclass UDPTest\r{\rpublic static void main(String[] args)\r{\rDatagramSocket sendSocket = new DatagramSocket();\rDatagramSocket receSocket = new DatagramSocket(10000);\rnew Thread(new UDPSend(sendSocket)).start();\rnew Thread(new UDPRece(receSocket)).start();\r}\r}\r(2)TCP传输\rSocket和ServerSocket\r建立客户端和服务器端\r建立连接后，通过Socket中的IO流进行数据的传输\r关闭socket\r同样，客户端与服务器端是两个独立的应用程序。\r****Socket\r**构造方法：\rSocket() 通过系统默认类型的 SocketImpl 创建未连接套接字\rSocket(InetAddress address, int port) 创建一个流套接字并将其连接到指定 IP 地址的指定端口号。\rSocket(String host, int port) 创建一个流套接字并将其连接到指定主机上的指定端口号。\r**方法摘要：\rvoid close() 关闭此套接字。\rInetAddress getInetAddress() 返回套接字连接的地址。\rInputStream getInputStream() 返回此套接字的输入流。\rOutputStream getOutputStream() 返回此套接字的输出流。 int getPort() 返回此套接字连接到的远程端口。\rvoid shutdownInput() 此套接字的输入流置于“流的末尾”。 void shutdownOutput() 禁用此套接字的输出流。 String toString() 将此套接字转换为 String。\r****ServerSocket\r**构造方法：\rServerSocket() 创建非绑定服务器套接字。 ServerSocket(int port) 创建绑定到特定端口的服务器套接字。\r方法摘要：\rSocket accept() 侦听并接受到此套接字的连接。\rvoid close() 关闭此套接字。 InetAddress getInetAddress() 返回此服务器套接字的本地地址。\r****TCP传输流程：\r**客户端：\r建立Socket服务，并制定要连接的主机和端口；\r获取Socket流中的输出流OutputStream，将数据写入流中，通过网络发送给服务端；\r获取Socket流中的输出流InputStream，获取服务端的反馈信息；\r关闭资源。\r**服务端：\r建立ServerSocket服务，并监听一个端口；\r通过ServerSocket服务的accept方法，获取Socket服务对象；\r使用客户端对象的读取流获取客户端发送过来的数据；\r通过客户端对象的写入流反馈信息给客户端；\r关闭资源；\r****代码示例：\r客户端：\rclass TCPClient\r{\rpublic static void main(String[] args)\r{\rSocket s = new Socket(\u0026quot;192.168.1.253\u0026quot;,10000);\rOutputStream os = s.getOutputStream();\rout.write(\u0026quot;这是TCP发送的数据\u0026quot;.getBytes());\rs.close();\r}\r}\r服务端：\rclass TCPServer\r{\rpublic static void main(String[] args)\r{\rServerSocket ss = new ServerSocket(10000);\rSocket s = ss.accept();\rString ip = s.getInetAddress().getHostAddress();\rsop(ip);\rInputStream is = s.getInputStream();\rbyte[] buf = new byte[1024];\rint len = is.read(buf);\rsop(new String(buf,0,len));\rs.close();\rss.close();\r}\r}\rTCP需求1：客户端给服务端发送数据，服务端接收到后反馈信息给客户端\r客户端：\rclass TCPClient\r{\rpublic static void main(String[] args)\r{\rSocket s = new Socket(\u0026quot;192.168.1.253\u0026quot;,10000);\rOutputStream os = s.getOutputStream();\rout.write(\u0026quot;这是TCP发送的数据\u0026quot;.getBytes());\rInputStream is = s.getInputStream();\rbyte[] buf = new byte[1024];\rint len = is.read(buf);\rsop(new String(buf,0,len));\rs.close();\r}\r}\r服务端：\rclass TCPServer\r{\rpublic static void main(String[] args)\r{\rServerSocket ss = new ServerSocket(10000);\rSocket s = ss.accept();\rString ip = s.getInetAddress().getHostAddress();\rsop(ip);\rInputStream is = s.getInputStream();\rbyte[] buf = new byte[1024];\rint len = is.read(buf);\rsop(new String(buf,0,len));\rOutputStream os = s.getOutputStream();\rout.write(\u0026quot;这是TCP发送的数据\u0026quot;.getBytes());\rs.close();\rss.close();\r}\r}\rTCP需求2：建立一个文本转换服务端，客户给服务端发送文本，服务端将数据转换成大写后返回给客户端\r当客户端输入over时，转换结束\r客户端：\rclass TCPClient\r{\rpublic static void main(String[] args)\r{\rSocket s = new Socket(\u0026quot;192.168.1.253\u0026quot;,10000);\rBufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));\rBufferedWriter bufOut = new BufferedWriter(new OutputStreamWriter(\rs.getOutputStream()));\rBufferedReader bufIn = new BufferedReader(new InputStreamReader(\rs.getInputStream()));\rString line = null;\rwhile((line = bufr.readLine())!=null)\r{\rif(\u0026quot;over\u0026quot;.equals(line))\rbreak;\rbufOut.write(line);\rbufOut.newLine();\rbufOut.flush();\rString retVal = bufIn.readLine();\rsop(\u0026quot;server:\u0026quot;+retVal);\r}\rbufr.close();\rs.close();\r}\r}\r服务端：\rclass TCPServer\r{\rpublic static void main(String[] args)\r{\rServerSocket ss = new ServerSocket(10000);\rSocket s = ss.accept();\rString ip = s.getInetAddress().getHostAddress();\rsop(ip);\rBufferedReader bufIn = new BufferedReader(new InputStreamReader(\rs.getInputStream()));\rBufferedWriter bufOut = new BufferedWriter(new OutputStreamWriter(\rs.getOutputStream()));\rwhile((line = bufIn.readLine())!=null)\r{\rbufOut.write(line.toUpperCase());\rbufOut.newLine();\rbufOut.flush();\r}\rs.close();\rss.close();\r}\r}\r**需求3：拷贝文件\r客户端：\rclass TCPClient\r{\rpublic static void main(String[] args)\r{\rSocket s = new Socket(\u0026quot;192.168.1.253\u0026quot;,10000);\rBufferedReader bufr = new BufferedReader(new FileReader(\u0026quot;g:\\\\demo.txt\u0026quot;));\rPrintWriter pw = new PrintWriter(s.getOutputStream(),true);\rString line = null;\rwhile((line = bufr.readLine())!=null)\r{\rpw.println();\r}\rs.shutDownOutput();\rBufferedReader bufIn = new BufferedReader(new InputStreamReader(\rs.getInputStream()));\rString retVal = bufIn.readLine();\rsop(retVal);\rbufr.close();\rs.close();\r}\r}\r服务端：\rclass TCPServer\r{\rpublic static void main(String[] args)\r{\rServerSocket ss = new ServerSocket(10000);\rSocket s = ss.accept();\rString ip = s.getInetAddress().getHostAddress();\rsop(ip);\rBufferedReader bufIn = new BufferedReader(new InputStreamReader(\rs.getInputStream()));\rPrintWriter out = new PrintWriter(new FileWriter\u0026quot;copy.txt\u0026quot;,true);\rString line =null;\rwhile((line = bufIn.readLine())!=null)\r{\rout.write(line);\r}\rPrintWriter pw = new PrintWriter(s.getOutputStream(),true);\rpw.println(\u0026quot;上传成功\u0026quot;);\rout.close();\rs.close();\rss.close();\r}\r}\r需求4：上传图片\r客户端：\rclass TCPClient\r{\rpublic static void main(String[] args)\r{\rSocket s = new Socket(\u0026quot;192.168.1.253\u0026quot;,10000);\rFileInputStream fis = new FileInputStream(\u0026quot;g:\\\\1.bmp\u0026quot;);\rOutputStream out = s.getOutputStream();\rbyte[] buf = new byte[1024];\rint len = 0;\rwhile((len = bufr.read())!=-1)\r{\rout.write(buf,0,len);\r}\rs.shutDownOutput();\rInputStream in = s.getInputStream();\rbyte[] bufIn = new byte[1024];\rint lenIn = in.read(bufIn);\rsop(new String(bufIn,0,lenIn);\rfis.close();\rs.close();\r}\r}\r服务端：\rclass TCPServer\r{\rpublic static void main(String[] args)\r{\rServerSocket ss = new ServerSocket(10000);\rSocket s = ss.accept();\rString ip = s.getInetAddress().getHostAddress();\rsop(ip);\rFileOutputStream fos = new FileOutputStream(\u0026quot;g:\\\\copy.bmp\u0026quot;);\rInputStream in = s.getInputStream();\rbyte[] bufIn = new byte[1024];\rint lenIn = 0;\rwhile((lenIn=bufIn.read())!=-1)\r{\rfos.write(bufIn,0,lenIn)\r}\rOutputStream outIn = s.getOutputStream();\routIn.write(\u0026quot;上传成功\u0026quot;.getBytes());\rfos.close();\rs.close();\rss.close();\r}\r}\r需求5：客户端并发登陆\r客户端通过键盘录入用户名，服务端对这个用户名进行校验\r如果用户存在，在服务端现实xxx已登录，并在客户端现实欢迎xxx\r如果用户不存在，在服务端现实xxx正在尝试登陆，并在客户端现实xxx用户不存在\r最多登陆三次。\r校验端：\rclass User implements Runnable\r(\rprivate Socket s;\rpublic User(){}\rpublic User(Socket s)\r{\rthis.s=s;\r}\rpublic void run()\r{\rtry\r{\rBufferedReader bufrIn = new BufferedReader(\rnew InputStream(s.getInputStream()))\rString name = bufrIn.readLine();\rif(name==null)\r{\rsop(\u0026quot;用户名为空\u0026quot;);\rbreak;\r}\rBufferedReader bufr = new BufferedReader(\rnew FileReader(\u0026quot;user.txt\u0026quot;));\rPrintWriter pw = new PrintWriter(s.getOutputStream(),true);\rString line = null;\rboolean flag = false;\rwhile((line = bufr.reanLine())!=null)\r{\rif(line.equals(name))\r{\rflag = true;\rbreak;\r}\rif(flag)\r{\rsop(name+\u0026quot;已登陆\u0026quot;);\rpw.println(\u0026quot;欢迎\u0026quot;+name);\rbreak;\r}\relse\r{\rsop(name+\u0026quot;正尝试登陆\u0026quot;);\rpw.println(name+\u0026quot;用户不存在\u0026quot;);\r}\r}\rs.close();\r}\rcatch(Exception e)\r{\rthrow new RuntimeException(\u0026quot;用户校验失败\u0026quot;);\r}\r}\r)\r客户端：\rclass LoginClient\r{\rpublic static void main(String[] args)\r{\rSocket s = new Socket(\u0026quot;192.168.1.253\u0026quot;,10000);\rBufferedReader bufr = new BufferedReader(\rnew InputStreamReader(System.in)));\rPrintWriter out = new PrintWriter(s.getOutputStream(),true);\rBufferedReader bufIn = new BufferedReader(\rnew InputStreamReader(s.getInputStream()));\rfor(int i=0;i\u0026lt;3;i++)\r{\rString line = bufr.readLine();\rif(line == null)\r{\rsop(\u0026quot;用户名不能为空！\u0026quot;);\rbreak;\r}\rout.write(line);\rString retVal = bufIn.readLine();\rsop(retVal);\t}\rbufr.close();\rs.close();\r}\r}\r服务端：\rclass LoginServer\r{\rpublic static void main(String[] args)\r{\rServerSocket ss = new ServerSocket(10000);\rwhile(true)\r{\rSocket s = ss.accept();\rnew Thread(new User()).start();\r}\r}\r}\r ","pubDate":"2021-02-15","title":"java \u003e java基础总结大全"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_java_java_programstructure/","plain":"Java的程序结构 public class HelloWorld {\rpublic static void main(String[] args) {\rSystem.out.println(\u0026quot;Hello World\u0026quot;);\r}\r}\r Java区分大小写 关键字public称为访问修饰符 (这些修饰符用于控制其它程序对这部分代码的访问级别) 关键字class表面Java程序的全部内容都包含在类中 关键字class后面紧跟类名   Java中定义类名的规则很宽松。名字必须以字母开头,后面可以跟字母和数字的任意组合。长度基本没有限制,但是不能使用Java保留字(例如class或public)作为类名\n  标准的命名规范为(FirstSample):类名是以大写字母开头的名词。如果由多个单词组成，每个单词的第一个字母都应该大写(驼峰命名法)\n  源代码的文件名必须与公共类的名字相同,并用.java作为扩展名  数据类型  String s = RandomStringUtils.random(22) ;\rbyte[] bytes = s.getBytes();\rbyte a1 = 35;\rSystem.out.println(a1);\rSystem.out.println(Arrays.toString(bytes));\rbyte[] bytes1 = new byte[35] ;\rint[] ints = new int[35] ;\rfor (int i = 0; i \u0026lt; 35; i++) {\r// bytes1[i] = (byte) RandomUtils.nextInt(-128,127) ;//byte 范围\rbytes1[i] = (byte) RandomUtils.nextInt(28,127) ;\r// ints[i] = RandomUtils.nextInt(-2147483648,2147483647) ;//int的范围\rints[i] = RandomUtils.nextInt(8,2147483647) ;\r}\rSystem.out.println(new String(bytes1));\rchar ch = (char)RandomUtils.nextInt(4347,347437343);//int 转换为char\rch = 3643473473443;//Integer number too large 说明char也有最大值\rch = -63434;//负数不能给char\rSystem.out.println(ch);\r?\rbyte数据类型 8位，我的疑惑是，io流读取文件，是读取这个文件的每个字符对应其编码的2进制？那么所有的二进制大小都不超过8位吗？\r我的理解是，文件传输的时候用的是字符流或者字节流，\r字符与字节\r1、ASCII码：一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。一个二进制数字序列，在计算机中作为一个数字单元，一般为8位二进制数，换算为十进制。最小值-128，最大值127。如一个ASCII码就是一个字节。\r2、UTF-8编码：一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。中文标点占三个字节，英文标点占一个字节\r3、Unicode编码：一个英文等于两个字节，一个中文（含繁体）等于两个字节。中文标点占两个字节，英文标点占两个字节\r传输的最小单位就是字节，一个字节是8位，正好每个byte的大小是8，一个 byte表示一个字节，不浪费空间。\r因为计算机处理数据的单位就是字节。所以，当我们处理磁盘文件和内存数据的时候，就正好选择和计算机处理数据单位等大的数据类型来存储数据。而且，我们调用的类库中的API也都是使用这样类型的参数。所以，我们就必须在编写程序的时候使用byte类型的数组。\rJava语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型 byte 1字节(8位) 最小值是 -128（-2^7）；最大值是 127（2^7-1）；默认值是 0；byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；文件流数组刚好采用byte\rshort 2字节(16位) 最小值是 -32768（-2^15）；最大值是 32767（2^15 - 1）；默认值是 0；\rint 4字节(32位) 最小值是 -2,147,483,648（-2^31）；最大值是 2,147,483,647（2^31 - 1）；一般地整型变量默认为 int 类型；默认值是 0 ；\rfloat 4字节(32位) 最小值：Float.MIN_VALUE=1.4E-45 最大值：Float.MAX_VALUE=3.4028235E38 默认值是 0.0f；\rlang 8字节(64位) 最小值是 -9,223,372,036,854,775,808（-2^63）； 最大值是 9,223,372,036,854,775,807（2^63 -1）； 默认值是 0L；\rdouble 8字节(64位) 最小值：Double.MIN_VALUE=4.9E-324 最大值：Double.MAX_VALUE=1.7976931348623157E308 默认值是 0.0d；\rchar char类型是一个单一的 16 位 Unicode 字符；最小值是 \\u0000（即为0）；最大值是 \\uffff（即为65,535）；\rboolean 4字节 boolean数据类型表示一位的信息；只有两个取值：true 和 false；默认值是 false；\r 变量  在Java中，每一个变量都有一个类型(type)\n 变量初始化  声明一个变量之后，必须用赋值语句对变量进行显示初始化，千万不要使用未初始化的变量 在Java中可以将声明放在代码中的任何地方\n 常量  在Java中利用关键字final指示常量,关键字final只能被赋值一次,一旦被赋值后就不能被更改了\n  \u0026gt;\u0026gt;final类中的成员方法收影响 隐士指定为final方法\rfinal修饰 类 \u0026gt; 此类不能被继承\r\u0026gt;\u0026gt; final类中的成员变量并不受影响\r方法 \u0026gt; 不能被重写\r成员变量 \u0026gt; 必须赋值，初始化一次\r位运算  和c++类似\n 位运算 数学公式 ","pubDate":"2021-02-15","title":"java \u003e programStructure"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF_java_thread_java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF_%E7%AC%AC%E4%B8%80%E7%AB%A0/","plain":"第一章关键技术点   (1) 线程的启动\n  (2) 如何使线程暂停\n  (3) 如何使线程停止\n  (4) 线程的优先级\n  (5) 线程安全相关的问题\n  1 进程和多线程的概念及线程的优点\n 进程:进程是操作系统结构的基础；是一次程序的执行；是一个程序及其数据在处理机上顺序执行时所发生的活动；是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。 进程理解1:正在操作系统中运行的exe程序 线程:线程可以理解成是在进程中独立运行的子任务。(使用多线程技术后，可以在同一时间内运行更多不同种类的任务)  2 使用多线程\n 继承Thread类、或者实现runnable接口,在调用thread对象的start方法,start方法的作用是通知 \u0026ldquo;线程规划器\u0026quot;此线程已经准备就绪，等待调用线程的run方法。这个过程其实就是让系统安排一个时间来调用thread中的run方法  3 实例变量与线程安全\n 自定义线程类中的实例变量针对其他线程可以有共享与不共享之分，这在多个线程之间进行交互时是很重要的一个技术点。 synchronized 可以在任意对象及方法上加锁，而加锁的这段代码称为互斥区或临界区 当一个线程想要执行同步方法里的代码时，线程首先尝试去拿这把锁，如果能拿到这把锁，那么这个线程就可以执行synchronize里面的代码。如果不能拿到这把锁，那么这个线程就会不断地尝试拿这把锁，直到能够拿到为止，而且是有多个线程同时去争抢这把锁。  4 Thread.currentThread()方法\n currentThread 返回代码段正在被哪个线程调用的信息  5 isAlive 判断线程是否处于存活状态\n 线程处于正在运行或准备开始运行的状态，就认为线程是 \u0026ldquo;存活\u0026rdquo; 的  6 sleep\n 方法sleep的作用是在指定的毫秒数内让当前 \u0026ldquo;正在执行的线程\u0026quot;休眠(暂停执行) \u0026ldquo;这个正在执行的线程\u0026quot;是指this.currentThread()返回的线程  7 停止线程\n   使用退出标志，使线程正常退出，也就是当run()方法完成后线程终止    使用stop方法强行终止线程,但是不推荐使用这个方法    使用interrupt方法中断线程    异常法    ","pubDate":"2021-02-15","title":"java \u003e thread \u003e Java多线程编程核心技术 \u003e 第一章"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_thread_java_thread_%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%B9%82%E7%AD%89%E5%A4%84%E7%90%86/","plain":"高并发和分布式中的幂等处理 我们先来谈下幂等的概念 抽象概念   幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。\n  在编程中，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“getUsername()和setTrue()”函数就是一个幂等函数。\n  用通俗的话讲：就是针对一个操作，不管做多少次，产生效果或返回的结果都是一样的\n  举几个例子：\n  1.比如前端对同一表单数据的重复提交，后台应该只会产生一个结果。\n  2.比如我们发起一笔付款请求，应该只扣用户账户一次钱，当遇到网络重发或系统bug重发，也应该只扣一次钱。\n  3.比如发送消息，也应该只发一次，同样的短信如果多次发给用户，用户会崩溃。\n  4.比如创建业务订单，一次业务请求只能创建一个，不能出现创建多个订单。\n  还有很多诸如此类的，这些逻辑都需要幂等的特性来支持。\n  实现幂等性的技术方案\n  查询操作\n  查询一次和查询多次，在数据不变的情况下，查询结果是一样的，select是天然的幂等操作。\n  删除操作\n  删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个)\n  唯一索引，防止新增脏数据\n  拿资金账户和用户账户来说，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，在新增的时候只有一个请求成功，剩下都会抛出唯一索引重复异常。比如org.springframework.dao.DuplicateKeyException，这时候再查询一次就可以了，数据存在，返回结果。\n  token机制，防止页面重复提交\n  要求：页面的数据只能被点击提交一次\n  发生原因：由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交\n  解决办法：\n  集群环境：采用token加redis\n  单JVM环境：采用token加redis或token加jvm内存\n  处理流程：\n  数据提交前要向服务的申请token，token放到redis或jvm内存，token有效时间\n  提交后后台校验token，同时删除token，生成新的token返回\n  token特点：要申请，一次有效性，可以限流。\n  注意：redis要用删除操作来判断token，删除成功代表token校验通过，如果用select+delete来校验token，\n  存在并发问题，不建议使用\n  悲观锁\n  获取数据的时候加锁获取 select * from table_xxx where id=’xxx’ for update;   注意：id字段一定是主键或者唯一索引，不然是锁表，会出事的。悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用。\n  乐观锁\n  乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。乐观锁的实现方式多种多样可以通过version或者其他状态条件：\n  1.通过版本号实现 update table_xxx set name=#name#,version=version+1 where version=#version#   2.通过条件限制 update table_xxx set avai_amount=avai_amount-#subAmount# where avai_amount-#subAmount# \u0026gt;= 0   要求：avai_amount-subAmount \u0026gt;=0   这个情景适合不用版本号，只更新是做数据安全校验，适合库存模型，扣份额和回滚份额，性能更高。   注意：乐观锁的更新操作，最好用主键或者唯一索引来更新，这样是行锁，否则更新时会锁表，上面两个sql改成下面的两个更好。   update table_xxx set name=#name#,version=version+1 where id=#id# and version=#version#   update table_xxx set avai_amount=avai_amount-#subAmount# where id=#id# and avai_amount-#subAmount# \u0026gt;= 0\n  分布式锁\n  还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，其实就是为了控制多线程并发的操作，也是分布式系统中经常用到的解决思路。\n  select + insert\n  并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了。\n  注意：核心高并发流程不要用这种方法。\n  状态机幂等\n  在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。\n  注意：订单等单据类业务，存在很长的状态流转，一定要深刻理解状态机，对业务系统设计能力提高有很大帮助。\n  对外提供接口的api如何保证幂等\n  如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号source+seq在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求)。\n  重点：\n  对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。\n  最后总结：\n  幂等性应该是合格程序员的一个基因，在设计系统时，是首要考虑的问题，尤其是在像第三方支付平台，银行，互联网金融公司等涉及的网上资金系统，既要高效，数据也要准确，所以不能出现多扣款，多打款等问题，这样会很难处理，并会大大降低用户体验。\n  ","pubDate":"2021-02-15","title":"java \u003e thread \u003e 高并发和分布式中的幂等处理"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_thread_java_thread_%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5/","plain":"高并发高可用的架构实践 一、 设计理念  1.空间换时间   1)多级缓存，静态化 客户端页面缓存（http header中包含Expires/Cache of Control，last modified(304，server不返回body，客户端可以继续用cache，减少流量)，ETag） 反向代理缓存 应用端的缓存(memcache) 内存数据库 Buffer、cache机制（数据库，中间件等）\n  2)索引 哈希、B树、倒排、bitmap 哈希索引适合综合数组的寻址和链表的插入特性，可以实现数据的快速存取。 B树索引适合于查询为主导的场景，避免多次的IO，提高查询的效率。 倒排索引实现单词到文档映射关系的最佳实现方式和最有效的索引结构，广泛用在搜索领域。 Bitmap是一种非常简洁快速的数据结构，他能同时使存储空间和速度最优化（而不必空间换时间），适合于海量数据的的计算场景。\n  2.并行与分布式计算   1)任务切分、分而治之(MR) 在大规模的数据中，数据存在一定的局部性的特征，利用局部性的原理将海量数据计算的问题分而治之。 MR模型是无共享的架构，数据集分布至各个节点。处理时，每个节点就近读取本地存储的数据处理(map)，将处理后的数据进行合并(combine)、排序(shuffle and sort)后再分发(至reduce节点)，避免了大量数据的传输，提高了处理效率。\n  2)多进程、多线程并行执行(MPP) 并行计算（Parallel Computing）是指同时使用多种计算资源解决计算问题的过程，是提高计算机系统计算速度和处理能力的一种有效手段。它的基本思想是用多个处理器/进程/线程来协同求解同一问题，即将被求解的问题分解成若干个部分，各部分均由一个独立的处理机来并行计算。 和MR的区别在于，它是基于问题分解的，而不是基于数据分解。\n  3.多维度的可用   1)负载均衡、容灾、备份 随着平台并发量的增大，需要扩容节点进行集群，利用负载均衡设备进行请求的分发；负载均衡设备通常在提供负载均衡的同时，也提供失效检测功能；同时为了提高可用性，需要有容灾备份，以防止节点宕机失效带来的不可用问题；备份有在线的和离线备份，可以根据失效性要求的不同，进行选择不同的备份策略。\n  2)读写分离 读写分离是对数据库来讲的，随着系统并发量的增大，提高数据访问可用性的一个重要手段就是写数据和读数据进行分离；当然在读写分离的同时，需要关注数据的一致性问题；对于一致性的问题，在分布式的系统CAP定量中，更多的关注于可用性。\n  3)依赖关系 平台中各个模块之间的关系尽量是低耦合的，可以通过相关的消息组件进行交互，能异步则异步，分清楚数据流转的主流程和副流程，主副是异步的，比如记录日志可以是异步操作的，增加整个系统的可用性。 当然在异步处理中，为了确保数据得到接收或者处理，往往需要确认机制(confirm、ack)。 但是有些场景中，虽然请求已经得到处理，但是因其他原因(比如网络不稳定)，确认消息没有返回，那么这种情况下需要进行请求的重发，对请求的处理设计因重发因素需要考虑幂等性。\n  4)监控 监控也是提高整个平台可用性的一个重要手段，多平台进行多个维度的监控；模块在运行时候是透明的，以达到运行期白盒化。\n  4.伸缩   1)拆分 拆分包括对业务的拆分和对数据库的拆分。 系统的资源总是有限的，一段比较长的业务执行如果是一竿子执行的方式，在大量并发的操作下，这种阻塞的方式，无法有效的及时释放资源给其他进程执行，这样系统的吞吐量不高。 需要把业务进行逻辑的分段，采用异步非阻塞的方式，提高系统的吞吐量。 随着数据量和并发量的增加，读写分离不能满足系统并发性能的要求，需要对数据进行切分，包括对数据进行分库和分表。这种分库分表的方式，需要增加对数据的路由逻辑支持。\n  2)无状态 对于系统的伸缩性而言，模块最好是无状态的，通过增加节点就可以提高整个的吞吐量。\n  5.优化资源利用   1)系统容量有限 系统的容量是有限的，承受的并发量也是有限的，在架构设计时，一定需要考虑流量的控制，防止因意外攻击或者瞬时并发量的冲击导致系统崩溃。在设计时增加流控的措施，可考虑对请求进行排队，超出预期的范围，可以进行告警或者丢弃。\n  2)原子操作与并发控制 对于共享资源的访问，为了防止冲突，需要进行并发的控制，同时有些交易需要有事务性来保证交易的一致性，所以在交易系统的设计时，需考虑原子操作和并发控制。 保证并发控制一些常用高性能手段有，乐观锁、Latch、mutex、写时复制、CAS等；多版本的并发控制MVCC通常是保证一致性的重要手段，这个在数据库的设计中经常会用到。\n  3)基于逻辑的不同，采取不一样的策略 平台中业务逻辑存在不同的类型，有计算复杂型的，有消耗IO型的，同时就同一种类型而言，不同的业务逻辑消耗的资源数量也是不一样的，这就需要针对不同的逻辑采取不同的策略。 针对IO型的，可以采取基于事件驱动的异步非阻塞的方式，单线程方式可以减少线程的切换引起的开销，或者在多线程的情况下采取自旋spin的方式，减少对线程的切换(比如Oraclelatch设计)；对于计算型的，充分利用多线程进行操作。 同一类型的调用方式，不同的业务进行合适的资源分配，设置不同的计算节点数量或者线程数量，对业务进行分流，优先执行优先级别高的业务。\n  4)容错隔离 系统的有些业务模块在出现错误时，为了减少并发下对正常请求的处理的影响，有时候需要考虑对这些异常状态的请求进行单独渠道的处理，甚至暂时自动禁止这些异常的业务模块。 有些请求的失败可能是偶然的暂时的失败(比如网络不稳定)，需要进行请求重试的考虑。\n  5)资源释放 系统的资源是有限的，在使用资源时，一定要在最后释放资源，无论是请求走的是正常路径还是异常的路径，以便于资源的及时回收，供其他请求使用。 在设计通信的架构时，往往需要考虑超时的控制。\n 二、 静态架构蓝图  整个架构是分层的分布式的架构，纵向包括CDN，负载均衡/反向代理，web应用，业务层，基础服务层，数据存储层。水平方向包括对整个平台的配置管理部署和监控。  三、 剖析架构    CDN     CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度。 对于大规模电子商务平台一般需要建CDN做网络加速，大型平台如淘宝、京东都采用自建CDN，中小型的企业可以采用第三方CDN厂商合作，如蓝汛、网宿、快网等。 当然在选择CDN厂商时，需要考虑经营时间长短，是否有可扩充的带宽资源、灵活的流量和带宽选择、稳定的节点、性价比。\n   负载均衡、反向代理     一个大型的平台包括很多个业务域，不同的业务域有不同的集群，可以用DNS做域名解析的分发或轮询，DNS方式实现简单，但是因存在cache而缺乏灵活性；一般基于商用的硬件F5、NetScaler或者开源的软负载lvs在4层做分发，当然会采用做冗余(比如lvs+keepalived)的考虑，采取主备方式。 4层分发到业务集群上后，会经过web服务器如nginx或者HAProxy在7层做负载均衡或者反向代理分发到集群中的应用节点。 选择哪种负载，需要综合考虑各种因素（是否满足高并发高性能，Session保持如何解决，负载均衡的算法如何，支持压缩，缓存的内存消耗）；下面基于几种常用的负载均衡软件做个介绍。 LVS，工作在4层，Linux实现的高性能高并发、可伸缩性、可靠的的负载均衡器，支持多种转发方式(NAT、DR、IP Tunneling)，其中DR模式支持通过广域网进行负载均衡。支持双机热备(Keepalived或者Heartbeat)。对网络环境的依赖性比较高。 Nginx工作在7层，事件驱动的、异步非阻塞的架构、支持多进程的高并发的负载均衡器/反向代理软件。可以针对域名、目录结构、正则规则针对http做一些分流。通过端口检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点，不过其中缺点就是不支持url来检测。对于session sticky，可以基于ip hash的算法来实现，通过基于cookie的扩展nginx-sticky-module支持session sticky。 HAProxy支持4层和7层做负载均衡，支持session的会话保持，cookie的引导；支持后端url方式的检测；负载均衡的算法比较丰富，有RR、权重等。 对于图片，需要有单独的域名，独立或者分布式的图片服务器或者如mogileFS，可以图片服务器之上加varnish做图片缓存。\n   App接入     应用层运行在jboss或者tomcat容器中，代表独立的系统，比如前端购物、用户自主服务、后端系统等 协议接口，HTTP、JSON 可以采用servlet3.0,异步化servlet,提高整个系统的吞吐量 http请求经过Nginx，通过负载均衡算法分到到App的某一节点，这一层层扩容起来比较简单。 除了利用cookie保存少量用户部分信息外(cookie一般不能超过4K的大小)，对于App接入层，保存有用户相关的session数据，但是有些反向代理或者负载均衡不支持对session sticky支持不是很好或者对接入的可用性要求比较高(app接入节点宕机，session随之丢失)，这就需要考虑session的集中式存储，使得App接入层无状态化，同时系统用户变多的时候，就可以通过增加更多的应用节点来达到水平扩展的目的。 Session的集中式存储，需要满足以下几点要求： a、高效的通讯协议 b、session的分布式缓存，支持节点的伸缩，数据的冗余备份以及数据的迁移 c、session过期的管理\n   业务服务     代表某一领域的业务提供的服务，对于电商而言，领域有用户、商品、订单、红包、支付业务等等，不同的领域提供不同的服务， 这些不同的领域构成一个个模块，良好的模块划分和接口设计非常重要，一般是参考高内聚、接口收敛的原则， 这样可以提高整个系统的可用性。当然可以根据应用规模的大小，模块可以部署在一起，对于大规模的应用，一般是独立部署的。 高并发： 业务层对外协议以NIO的RPC方式暴露，可以采用比较成熟的NIO通讯框架，如netty、mina 可用性： 为了提高模块服务的可用性，一个模块部署在多个节点做冗余，并自动进行负载转发和失效转移; 最初可以利用VIP+heartbeat方式，目前系统有一个单独的组件HA,利用zookeeper实现(比原来方案的优点) 一致性、事务： 对于分布式系统的一致性，尽量满足可用性，一致性可以通过校对来达到最终一致的状态。\n   基础服务中间件      通信组件 通信组件用于业务系统内部服务之间的调用，在大并发的电商平台中，需要满足高并发高吞吐量的要求。 整个通信组件包括客户端和服务端两部分。 客户端和服务器端维护的是长连接，可以减少每次请求建立连接的开销，在客户端对于每个服务器定义一个连接池，初始化连接后，可以并发连接服务端进行rpc操作，连接池中的长连接需要心跳维护，设置请求超时时间。 对于长连接的维护过程可以分两个阶段，一个是发送请求过程，另外一个是接收响应过程。在发送请求过程中，若发生IOException，则把该连接标记失效。接收响应时，服务端返回SocketTimeoutException，如果设置了超时时间，那么就直接返回异常，清除当前连接中那些超时的请求。否则继续发送心跳包(因为可能是丢包，超过pingInterval间隔时间就发送ping操作)，若ping不通(发送IOException)，则说明当前连接是有问题的，那么就把当前连接标记成已经失效；若ping通，则说明当前连接是可靠的，继续进行读操作。失效的连接会从连接池中清除掉。 每个连接对于接收响应来说都以单独的线程运行，客户端可以通过同步(wait,notify)方式或者异步进行rpc调用， 序列化采用更高效的hession序列化方式。 服务端采用事件驱动的NIO的MINA框架，支撑高并发高吞吐量的请求。\n  路由Router 在大多数的数据库切分解决方案中，为了提高数据库的吞吐量，首先是对不同的表进行垂直切分到不同的数据库中， 然后当数据库中一个表超过一定大小时，需要对该表进行水平切分，这里也是一样，这里以用户表为例； 对于访问数据库客户端来讲，需要根据用户的ID，定位到需要访问的数据； 数据切分算法， 根据用户的ID做hash操作，一致性Hash，这种方式存在失效数据的迁移问题，迁移时间内服务不可用 维护路由表，路由表中存储用户和sharding的映射关系,sharding分为leader和replica，分别负责写和读 这样每个biz客户端都需要保持所有sharding的连接池，这样有个缺点是会产生全连接的问题； 一种解决方法是sharding的切分提到业务服务层进行，每个业务节点只维护一个shard的连接即可。 见图（router）\n  路由组件的实现是这样的（可用性、高性能、高并发） 基于性能方面的考虑，采用MongoDB中维护用户id和shard的关系，为了保证可用性，搭建replicatset集群。 biz的sharding和数据库的sharding是一一对应的，只访问一个数据库sharding. biz业务注册节点到zookeeper上/bizs/shard/下。 router监听zookeeper上/bizs/下节点状态，缓存在线biz在router中。 client请求router获取biz时，router首先从mongodb中获取用户对应的shard,router根据缓存的内容通过RR算法获取biz节点。 为了解决router的可用性和并发吞吐量问题，对router进行冗余，同时client监听zookeeper的/routers节点并缓存在线router节点列表。 3) HA 传统实现HA的做法一般是采用虚拟IP漂移，结合Heartbeat、keepalived等实现HA， Keepalived使用vrrp方式进行数据包的转发，提供4层的负载均衡，通过检测vrrp数据包来切换，做冗余热备更加适合与LVS搭配。Linux Heartbeat是基于网络或者主机的服务的高可用，HAProxy或者Nginx可以基于7层进行数据包的转发，因此Heatbeat更加适合做HAProxy、Nginx，包括业务的高可用。 在分布式的集群中，可以用zookeeper做分布式的协调，实现集群的列表维护和失效通知，客户端可以选择hash算法或者roudrobin实现负载均衡；对于master-master模式、master-slave模式，可以通过zookeeper分布式锁的机制来支持。 4) 消息Message 对于平台各个系统之间的异步交互，是通过MQ组件进行的。 在设计消息服务组件时，需要考虑消息一致性、持久化、可用性、以及完善的监控体系。 业界开源的消息中间件主要RabbitMQ、kafka有两种， RabbitMQ,遵循AMQP协议，由内在高并发的erlanng语言开发；kafka是Linkedin于2010年12月份开源的消息发布订阅系统,它主要用于处理活跃的流式数据,大数据量的数据处理上。 对消息一致性要求比较高的场合需要有应答确认机制，包括生产消息和消费消息的过程；不过因网络等原理导致的应答缺失，可能会导致消息的重复，这个可以在业务层次根据幂等性进行判断过滤；RabbitMQ采用的是这种方式。还有一种机制是消费端从broker拉取消息时带上LSN号，从broker中某个LSN点批量拉取消息，这样无须应答机制，kafka分布式消息中间件就是这种方式。 消息的在broker中的存储，根据消息的可靠性的要求以及性能方面的综合衡量，可以在内存中，可以持久化到存储上。 对于可用性和高吞吐量的要求，集群和主备模式都可以在实际的场景应用的到。RabbitMQ解决方案中有普通的集群和可用性更高的mirror queue方式。kafka采用zookeeper对集群中的broker、consumer进行管理，可以注册topic到zookeeper上；通过zookeeper的协调机制，producer保存对应topic的broker信息，可以随机或者轮询发送到broker上；并且producer可以基于语义指定分片，消息发送到broker的某分片上。 总体来讲，RabbitMQ用在实时的对可靠性要求比较高的消息传递上。kafka主要用于处理活跃的流式数据,大数据量的数据处理上。 5) Cache\u0026amp;Buffer Cache系统 在一些高并发高性能的场景中，使用cache可以减少对后端系统的负载，承担可大部分读的压力，可以大大提高系统的吞吐量，比如通常在数据库存储之前增加cache缓存。 但是引入cache架构不可避免的带来一些问题，cache命中率的问题, cache失效引起的抖动，cache和存储的一致性。 Cache中的数据相对于存储来讲，毕竟是有限的，比较理想的情况是存储系统的热点数据，这里可以用一些常见的算法LRU等等淘汰老的数据；随着系统规模的增加，单个节点cache不能满足要求，就需要搭建分布式Cache；为了解决单个节点失效引起的抖动 ，分布式cache一般采用一致性hash的解决方案，大大减少因单个节点失效引起的抖动范围；而对于可用性要求比较高的场景，每个节点都是需要有备份的。数据在cache和存储上都存有同一份备份，必然有一致性的问题，一致性比较强的，在更新数据库的同时，更新数据库cache。对于一致性要求不高的，可以去设置缓存失效时间的策略。 Memcached作为高速的分布式缓存服务器，协议比较简单，基于libevent的事件处理机制。 Cache系统在平台中用在router系统的客户端中，热点的数据会缓存在客户端，当数据访问失效时，才去访问router系统。 当然目前更多的利用内存型的数据库做cache，比如Redis、mongodb；redis比memcache有丰富的数据操作的API；redis和mongodb都对数据进行了持久化，而memcache没有这个功能，因此memcache更加适合在关系型数据库之上的数据的缓存。 Buffer系统 用在高速的写操作的场景中，平台中有些数据需要写入数据库，并且数据是分库分表的，但对数据的可靠性不是那么高，为了减少对数据库的写压力，可以采取批量写操作的方式。 开辟一个内存区域，当数据到达区域的一定阀值时如80%时，在内存中做分库梳理工作(内存速度还是比较快的)，后分库批量flush。 6) 搜索 在电子商务平台中搜索是一个非常的重要功能，主要有搜索词类目导航、自动提示和搜索排序功能。 开源的企业级搜索引擎主要有lucene,sphinx，这里不去论述哪种搜索引擎更好一些，不过选择搜索引擎除了基本的功能需要支持外，非功能方面需要考虑以下两点： a、 搜索引擎是否支持分布式的索引和搜索，来应对海量的数据，支持读写分离，提高可用性 b、 索引的实时性 c、 性能 Solr是基于lucene的高性能的全文搜索服务器，提供了比lucene更为丰富的查询语言，可配置可扩展，对外提供基于http协议的XML/JSON格式的接口。 从Solr4版本开始提供了SolrCloud方式来支持分布式的索引，自动进行sharding数据切分；通过每个sharding的master-slave(leader、replica)模式提高搜索的性能；利用zookeeper对集群进行管理，包括leader选举等等，保障集群的可用性。 Lucene索引的Reader是基于索引的snapshot的，所以必须在索引commit的后，重新打开一个新的snapshot，才能搜索到新添加的内容；而索引的commit是非常耗性能的，这样达到实时索引搜索效率就比较低下。 对于索引搜索实时性，Solr4的之前解决方案是结合文件全量索引和内存增量索引合并的方式，参见下图。\nSolr4提供了NRT softcommit的解决方案，softcommit无需进行提交索引操作，就可以搜素到最新对索引的变更，不过对索引的变更并没有sync commit到硬盘存储上，若发生意外导致程序非正常结束，未commit的数据会丢失，因此需要定时的进行commit操作。 平台中对数据的索引和存储操作是异步的，可以大大提高可用性和吞吐量；只对某些属性字段做索引操作，存储数据的标识key，减少索引的大小；数据是存储在分布式存储Hbase中的，HBase对二级索引搜索支持的不好，然而可以结合Solr搜索功能进行多维度的检索统计。 索引数据和HBase数据存储的一致性，也就是如何保障HBase存储的数据都被索引过，可以采用confirm确认机制，通过在索引前建立待索引数据队列，在数据存储并索引完成后，从待索引数据队列中删除数据。 7) 日志收集 在整个交易过程中，会产生大量的日志，这些日志需要收集到分布式存储系统中存储起来，以便于集中式的查询和分析处理。 日志系统需具备三个基本组件，分别为agent（封装数据源，将数据源中的数据发送给collector），collector（接收多个agent的数据，并进行汇总后导入后端的store中），store（中央存储系统，应该具有可扩展性和可靠性，应该支持当前非常流行的HDFS）。 开源的日志收集系统业界使用的比较多的是cloudera的Flume和facebook的Scribe，其中Flume目前的版本FlumeNG对Flume从架构上做了较大的改动。 在设计或者对日志收集系统做技术选型时，通常需要具有以下特征： a、 应用系统和分析系统之间的桥梁，将他们之间的关系解耦 b、 分布式可扩展，具有高的扩展性，当数据量增加时，可以通过增加节点水平扩展 日志收集系统是可以伸缩的，在系统的各个层次都可伸缩，对数据的处理不需要带状态，伸缩性方面也比较容易实现。 c、 近实时性 在一些时效性要求比较高的场景中，需要可以及时的收集日志，进行数据分析； 一般的日志文件都会定时或者定量的进行rolling，所以实时检测日志文件的生成，及时对日志文件进行类似的tail操作，并支持批量发送提高传输效率；批量发送的时机需要满足消息数量和时间间隔的要求。 d、 容错性 Scribe在容错方面的考虑是，当后端的存储系统crash时，scribe会将数据写到本地磁盘上，当存储系统恢复正常后，scribe将日志重新加载到存储系统中。 FlumeNG通过Sink Processor实现负载均衡和故障转移。多个Sink可以构成一个Sink Group。一个Sink Processor负责从一个指定的Sink Group中激活一个Sink。Sink Processor可以通过组中所有Sink实现负载均衡；也可以在一个Sink失败时转移到另一个。 e、 事务支持 Scribe没有考虑事务的支持。 Flume通过应答确认机制实现事务的支持，参见下图，\n通常提取发送消息都是批量操作的，消息的确认是对一批数据的确认，这样可以大大提高数据发送的效率。 f、 可恢复性 FlumeNG的channel根据可靠性的要求的不同，可以基于内存和文件持久化机制，基于内存的数据传输的销量比较高，但是在节点宕机后，数据丢失，不可恢复；而文件持久化宕机是可以恢复的。 g、 数据的定时定量归档 数据经过日志收集系统归集后，一般存储在分布式文件系统如Hadoop，为了便于对数据进行后续的处理分析，需要定时(TimeTrigger)或者定量(SizeTrigger的rolling分布式系统的文件。 8) 数据同步 在交易系统中，通常需要进行异构数据源的同步，通常有数据文件到关系型数据库，数据文件到分布式数据库，关系型数据库到分布式数据库等。数据在异构源之间的同步一般是基于性能和业务的需求，数据存储在本地文件中一般是基于性能的考虑，文件是顺序存储的，效率还是比较高的；数据同步到关系型数据一般是基于查询的需求；而分布式数据库是存储越来越多的海量数据的，而关系型数据库无法满足大数据量的存储和查询请求。 在数据同步的设计中需要综合考虑吞吐量、容错性、可靠性、一致性的问题 同步有实时增量数据同步和离线全量数据区分，下面从这两个维度来介绍一下， 实时增量一般是Tail文件来实时跟踪文件变化，批量或者多线程往数据库导出,这种方式的架构类似于日志收集框架。这种方式需要有确认机制，包括两个方面。 一个方面是Channel需要给agent确认已经批量收到数据记录了，发送LSN号给agent，这样在agent失效恢复时，可以从这个LSN点开始tail；当然对于允许少量的重复记录的问题(发生在channel给agent确认的时，agent宕机并未受到确认消息)，需要在业务场景中判断。 另外一个方面是sync给channel确认已经批量完成写入到数据库的操作，这样channel可以删除这部分已经confirm的消息。 基于可靠性的要求，channel可以采用文件持久化的方式。 参见下图\n离线全量遵循空间间换取时间，分而治之的原则，尽量的缩短数据同步的时间，提高同步的效率。 需要对源数据比如MySQL进行切分，多线程并发读源数据，多线程并发批量写入分布式数据库比如HBase,利用channel作为读写之间的缓冲，实现更好的解耦，channel可以基于文件存储或者内存。参见下图：\n对于源数据的切分，如果是文件可以根据文件名称设置块大小来切分。 对于关系型数据库，由于一般的需求是只离线同步一段时间的数据(比如凌晨把当天的订单数据同步到HBase)，所以需要在数据切分时(按照行数切分)，会多线程扫描整个表(及时建索引，也要回表)，对于表中包含大量的数据来讲，IO很高，效率非常低；这里解决的方法是对数据库按照时间字段(按照时间同步的)建立分区，每次按照分区进行导出。 9) 数据分析 从传统的基于关系型数据库并行处理集群、用于内存计算近实时的，到目前的基于hadoop的海量数据的分析，数据的分析在大型电子商务网站中应用非常广泛，包括流量统计、推荐引擎、趋势分析、用户行为分析、数据挖掘分类器、分布式索引等等。 并行处理集群有商业的EMC Greenplum，Greenplum的架构采用了MPP(大规模并行处理)，基于postgresql的大数据量存储的分布式数据库。 内存计算方面有SAP的HANA，开源的nosql内存型的数据库mongodb也支持mapreduce进行数据的分析。 海量数据的离线分析目前互联网公司大量的使用Hadoop，Hadoop在可伸缩性、健壮性、计算性能和成本上具有无可替代的优势，事实上已成为当前互联网企业主流的大数据分析平台 Hadoop通过MapReuce的分布式处理框架，用于处理大规模的数据，伸缩性也非常好；但是MapReduce最大的不足是不能满足实时性的场景，主要用于离线的分析。 基于MapRduce模型编程做数据的分析，开发上效率不高，位于hadoop之上Hive的出现使得数据的分析可以类似编写sql的方式进行，sql经过语法分析、生成执行计划后最终生成MapReduce任务进行执行，这样大大提高了开发的效率，做到以ad-hoc(计算在query发生时)方式进行的分析。 基于MapReduce模型的分布式数据的分析都是离线的分析，执行上都是暴力扫描，无法利用类似索引的机制；开源的Cloudera Impala是基于MPP的并行编程模型的，底层是Hadoop存储的高性能的实时分析平台，可以大大降低数据分析的延迟。 目前Hadoop使用的版本是Hadoop1.0，一方面原有的MapReduce框架存在JobTracker单点的问题，另外一方面JobTracker在做资源管理的同时又做任务的调度工作，随着数据量的增大和Job任务的增多，明显存在可扩展性、内存消耗、线程模型、可靠性和性能上的缺陷瓶颈；Hadoop2.0 yarn对整个框架进行了重构，分离了资源管理和任务调度，从架构设计上解决了这个问题。 参考Yarn的架构 10) 实时计算 在互联网领域，实时计算被广泛实时监控分析、流控、风险控制等领域。电商平台系统或者应用对日常产生的大量日志和异常信息，需要经过实时过滤、分析，以判定是否需要预警； 同时需要对系统做自我保护机制，比如对模块做流量的控制，以防止非预期的对系统压力过大而引起的系统瘫痪，流量过大时，可以采取拒绝或者引流等机制；有些业务需要进行风险的控制，比如彩票中有些业务需要根据系统的实时销售情况进行限号与放号。 原始基于单节点的计算，随着系统信息量爆炸式产生以及计算的复杂度的增加，单个节点的计算已不能满足实时计算的要求，需要进行多节点的分布式的计算，分布式实时计算平台就出现了。 这里所说的实时计算，其实是流式计算，概念前身其实是CEP复杂事件处理，相关的开源产品如Esper，业界分布式的流计算产品Yahoo S4,Twitter storm等，以storm开源产品使用最为广泛。 对于实时计算平台，从架构设计上需要考虑以下几个因素： 1、 伸缩性 随着业务量的增加，计算量的增加，通过增加节点处理，就可以处理。 2、 高性能、低延迟 从数据流入计算平台数据，到计算输出结果，需要性能高效且低延迟，保证消息得到快速的处理，做到实时计算。 3、 可靠性 保证每个数据消息得到一次完整处理。 4、 容错性 系统可以自动管理节点的宕机失效，对应用来说，是透明的。 Twitter的Storm在以上这几个方面做的比较好，下面简介一下Storm的架构。\n整个集群的管理是通过zookeeper来进行的。 客户端提交拓扑到nimbus。 Nimbus针对该拓扑建立本地的目录根据topology的配置计算task，分配task，在zookeeper上建立assignments节点存储task和supervisor机器节点中woker的对应关系。 在zookeeper上创建taskbeats节点来监控task的心跳；启动topology。 Supervisor去zookeeper上获取分配的tasks，启动多个woker进行，每个woker生成task，一个task一个线程；根据topology信息初始化建立task之间的连接;Task和Task之间是通过zeroMQ管理的；之后整个拓扑运行起来。 Tuple是流的基本处理单元，也就是一个消息，Tuple在task中流转，Tuple的发送和接收过程如下： 发送Tuple，Worker提供了一个transfer的功能，用于当前task把tuple发到到其他的task中。以目的taskid和tuple参数，序列化tuple数据并放到transfer queue中。 在0.8版本之前，这个queue是LinkedBlockingQueue，0.8之后是DisruptorQueue。 在0.8版本之后，每一个woker绑定一个inbound transfer queue和outbond queue，inbound queue用于接收message，outbond queue用于发送消息。 发送消息时，由单个线程从transferqueue中拉取数据，把这个tuple通过zeroMQ发送到其他的woker中。 接收Tuple，每个woker都会监听zeroMQ的tcp端口来接收消息，消息放到DisruptorQueue中后，后从queue中获取message(taskid,tuple)，根据目的taskid,tuple的值路由到task中执行。每个tuple可以emit到direct steam中，也可以发送到regular stream中，在Reglular方式下，由Stream Group（stream id\u0026ndash;\u0026gt;component id \u0026ndash;\u0026gt;outbond tasks）功能完成当前tuple将要发送的Tuple的目的地。 通过以上分析可以看到，Storm在伸缩性、容错性、高性能方面的从架构设计的角度得以支撑；同时在可靠性方面，Storm的ack组件利用异或xor算法在不失性能的同时，保证每一个消息得到完整处理的同时。 11) 实时推送 实时推送的应用场景非常多，比如系统的监控动态的实时曲线绘制，手机消息的推送，web实时聊天等。 实时推送有很多技术可以实现，有Comet方式，有websocket方式等。 Comet基于服务器长连接的“服务器推”技术，包含两种： Long Polling：服务器端在接到请求后挂起，有更新时返回连接即断掉，然后客户端再发起新的连接 Stream方式:每次服务端数据传送不会关闭连接，连接只会在通信出现错误时，或是连接重建时关闭（一些防火墙常被设置为丢弃过长的连接， 服务器端可以设置一个超时时间， 超时后通知客户端重新建立连接，并关闭原来的连接）。 Websocket：长连接，全双工通信 是HTML5的一种新的协议。它实现了浏览器与服务器的双向通讯。webSocket API中，浏览器和服务器端只需要通过一个握手的动作，便能形成浏览器与客户端之间的快速双向通道，使得数据可以快速的双向传播。 Socket.io是一个NodeJS websocket库，包括客户端的JS和服务端的的nodejs，用于快速构建实时的web应用。 12) 推荐引擎 待补充 6. 数据存储 数据库存储大体分为以下几类，有关系型（事务型）的数据库，以oracle、mysql为代表，有keyvalue数据库，以redis和memcached db为代表，有文档型数据库如mongodb，有列式分布式数据库以HBase，cassandra,dynamo为代表，还有其他的图形数据库、对象数据 库、xml数据库等。每种类型的数据库应用的业务领域是不一样的，下面从内存型、关系型、分布式三个维度针对相关的产品做性能可用性等方面的考量分析。\n 内存型数据库 内存型的数据库，以高并发高性能为目标，在事务性方面没那么严格，以开源nosql数据库mongodb、redis为例 Ø Mongodb 通信方式 多线程方式，主线程监听新的连接，连接后，启动新的线程做数据的操作（IO切换）。 数据结构  数据库\u0026ndash;\u0026gt;collection\u0026ndash;\u0026gt;record MongoDB在数据存储上按命名空间来划分，一个collection是一个命名空间，一个索引也是一个命名空间。 同一个命名空间的数据被分成很多个Extent，Extent之间使用双向链表连接。 在每一个Extent中，保存了具体每一行的数据，这些数据也是通过双向链接连接的。 每一行数据存储空间不仅包括数据占用空间，还可能包含一部分附加空间，这使得在数据update变大后可以不移动位置。 索引以BTree结构实现。 如果你开启了jorunaling日志，那么还会有一些文件存储着你所有的操作记录。 持久化存储 MMap方式把文件地址映射到内存的地址空间，直接操作内存地址空间就可以操作文件，不用再调用write,read操作，性能比较高。 mongodb调用mmap把磁盘中的数据映射到内存中的，所以必须有一个机制时刻的刷数据到硬盘才能保证可靠性，多久刷一次是与syncdelay参数相关的。 journal（进行恢复用）是Mongodb中的redo log，而Oplog则是负责复制的binlog。如果打开journal，那么即使断电也只会丢失100ms的数据，这对大多数应用来说都可以容忍了。从1.9.2+，mongodb都会默认打开journal功能，以确保数据安全。而且journal的刷新时间是可以改变的，2-300ms的范围,使用\u0026ndash;journalCommitInterval命令。Oplog和数据刷新到磁盘的时间是60s，对于复制来说，不用等到oplog刷新磁盘，在内存中就可以直接复制到Sencondary节点。 事务支持 Mongodb只支持对单行记录的原子操作 HA集群 用的比较多的是Replica Sets，采用选举算法，自动进行leader选举，在保证可用性的同时，可以做到强一致性要求。\n当然对于大量的数据，mongodb也提供了数据的切分架构Sharding。 Ø Redis 丰富的数据结构，高速的响应速度，内存操作 通信方式 因都在内存操作，所以逻辑的操作非常快，减少了CPU的切换开销，所以为单线程的模式（逻辑处理线程和主线程是一个）。 reactor模式，实现自己的多路复用NIO机制（epoll，select，kqueue等） 单线程处理多任务 数据结构 hash+bucket结构，当链表的长度过长时，会采取迁移的措施（扩展原来两倍的hash表，把数据迁移过去，expand+rehash） 持久化存储 a、全量持久化RDB（遍历redisDB,读取bucket中的key,value），save命令阻塞主线程，bgsave开启子进程进行snapshot持久化操作，生成rdb文件。 在shutdown时，会调用save操作 数据发生变化，在多少秒内触发一次bgsave sync，master接受slave发出来的命令 b、增量持久化（aof类似redolog），先写到日志buffer,再flush到日志文件中（flush的策略可以配置的，而已单条，也可以批量），只有flush到文件上的，才真正返回客户端。 要定时对aof文件和rdb文件做合并操作（在快照过程中，变化的数据先写到aof buf中等子进程完成快照\u0026lt;内存snapshot\u0026gt;后，再进行合并aofbuf变化的部分以及全镜像数据）。 在高并发访问模式下，RDB模式使服务的性能指标出现明显的抖动，aof在性能开销上比RDB好，但是恢复时重新加载到内存的时间和数据量成正比。 集群HA 通用的解决方案是主从备份切换，采用HA软件，使得失效的主redis可以快速的切换到从redis上。主从数据的同步采用复制机制，该场景可以做读写分离。 目前在复制方面，存在的一个问题是在遇到网络不稳定的情况下，Slave和Master断开（包括闪断）会导致Master需要将内存中的数据全部重新生成rdb文件（快照文件），然后传输给Slave。Slave接收完Master传递过来的rdb文件以后会将自身的内存清空，把rdb文件重新加载到内存中。这种方式效率比较低下，在后面的未来版本Redis2.8作者已经实现了部分复制的功能。 2) 关系型数据库 关系型数据库在满足并发性能的同时，也需要满足事务性，以mysql数据库为例，讲述架构设计原理，在性能方面的考虑，以及如何满足可用性的需求。 Ø mysql的架构原理(innodb) 在架构上，mysql分为server层和存储引擎层。 Server层的架构对于不同的存储引擎来讲都是一样的,包括连接/线程处理、查询处理(parser、optimizer)以及其他系统任务。存储引擎层有很多种，mysql提供了存储引擎的插件式结构，支持多种存储引擎，用的最广泛的是innodb和myisamin；inodb主要面向OLTP方面的应用，支持事务处理，myisam不支持事务，表锁，对OLAP操作速度快。 以下主要针对innodb存储引擎做相关介绍。\n在线程处理方面，Mysql是多线程的架构，由一个master线程，一个锁监控线程，一个错误监控线程，和多个IO线程组成。并且对一个连接会开启一个线程进行服务。io线程又分为节省随机IO的insert buffer，用于事务控制的类似于oracle的redo log，以及多个write，多个read的硬盘和内存交换的IO线程。 在内存分配方面，包括innodb buffer pool，以及log buffer。其中innodb buffer pool包括insert buffer、datapage、index page、数据字典、自适应hash。Log buffer用于缓存事务日志，提供性能。 在数据结构方面，innodb包括表空间、段、区、页/块，行。索引结构是B+tree结构，包括二级索引和主键索引，二级索引的叶子节点是主键PK，根据主键索引的叶子节点指向存储的数据块。这种B+树存储结构可以更好的满足随机查询操作IO要求，分为数据页和二级索引页，修改二级索引页面涉及到随机操作，为了提高写入时的性能，采用insert buffer做顺序的写入，再由后台线程以一定频率将多个插入合并到二级索引页面。为了保证数据库的一致性(内存和硬盘数据文件)，以及缩短实例恢复的时间，关系型数据库还有一个checkpoint的功能，用于把内存buffer中之前的脏页按照比例(老的LSN)写入磁盘，这样redolog文件的LSN以前的日志就可以被覆盖了，进行循环使用；在失效恢复时，只需要从日志中LSN点进行恢复即可。 在事务特性支持上，关系型数据库需要满足ACID四个特性，需要根据不同的事务并发和数据可见性要求，定义了不同的事务隔离级别，并且离不开对资源争用的锁机制，要避免产生死锁，mysql在Server层和存储引擎层做并发控制，主要体现在读写锁，根据锁粒度不同，有各个级别的锁(表锁、行锁、页锁、MVCC)；基于提高并发性能的考虑，使用多版本并发控制MVCC来支持事务的隔离，并基于undo来实现，在做事务回滚时，也会用到undo段。mysql用redolog来保证数据的写入的性能和失效恢复，在修改数据时只需要修改内存，再把修改行为记录到事务日志中(顺序IO)，不用每次将数据修改本身持久化到硬盘(随机IO)，大大提高性能。 在可靠性方面，innodb存储引擎提供了两次写机制double writer用于防止在flush页面到存储上出现的错误，解决磁盘half-writern的问题。 Ø 对于高并发高性能的mysql来讲，可以在多个维度进行性能方面的调优。 a、硬件级别， 日志和数据的存储，需要分开，日志是顺序的写，需要做raid1+0，并且用buffer-IO；数据是离散的读写，走direct IO即可，避免走文件系统cache带来的开销。 存储能力，SAS盘raid操作（raid卡缓存，关闭读cache，关闭磁盘cache，关闭预读，只用writeback buffer，不过需要考虑充放电的问题），当然如果数据规模不大，数据的存储可以用高速的设备，Fusion IO、SSD。 对于数据的写入，控制脏页刷新的频率，对于数据的读取，控制cache hit率；因此而估算系统需要的IOPS，评估需要的硬盘数量(fusion io上到IOPS在10w以上，普通的硬盘150)。 Cpu方面，单实例关闭NUMA，mysql对多核的支持不是太好，可以对多实例进行CPU绑定。 b、操作系统级别， 内核以及socket的优化，网络优化bond、文件系统、IO调度 innodb主要用在OLTP类应用，一般都是IO密集型的应用，在提高IO能力的基础上，充分利用cache机制。需要考虑的内容有， 在保证系统可用内存的基础上，尽可能的扩大innodb buffer pool，一般设置为物理内存的3/4 文件系统的使用，只在记录事务日志的时候用文件系统的cache；尽量避免mysql用到swap(可以将vm.swappiness=0，内存紧张时，释放文件系统cache) IO调度优化，减少不必要的阻塞，降低随机IO访问的延时(CFQ、Deadline、NOOP) c、server以及存储引擎级别（连接管理、网络管理、table管理、日志） 包括cache/buffer、Connection、IO d、应用级别（比如索引的考虑，schema的优化适当冗余；优化sql查询导致的CPU问题和内存问题，减少锁的范围，减少回表扫描，覆盖索引） Ø 在高可用实践方面， 支持master-master、master-slave模式，master-master模式是一个作为主负责读写，另外一个作为standby提供灾备，maser-slave是一个作为主提供写操作，其他几个节点作为读操作，支持读写分离。 对于节点主备失效检测和切换，可以采用HA软件，当然也可以从更细粒度定制的角度，采用zookeeper作为集群的协调服务。 对于分布式的系统来讲，数据库主备切换的一致性始终是一个问题，可以有以下几种方式： a、集群方式，如oracle的rack，缺点是比较复杂 b、共享SAN存储方式，相关的数据文件和日志文件都放在共享存储上，优点是主备切换时数据保持一致，不会丢失，但由于备机有一段时间的拉起，会有短暂的不可用状态 c、主备进行数据同步的方式，常见的是日志的同步，可以保障热备，实时性好，但是切换时，可能有部分数据没有同步过来，带来了数据的一致性问题。可以在操作主数据库的同时，记录操作日志，切换到备时，会和操作日志做个check，补齐未同步过来的数据； d、还有一种做法是备库切换到主库的regolog的存储上，保证数据不丢失。 数据库主从复制的效率在mysql上不是太高，主要原因是事务是严格保持顺序的，索引mysql在复制方面包括日志IO和relog log两个过程都是单线程的串行操作，在数据复制优化方面，尽量减少IO的影响。不过到了Mysql5.6版本，可以支持在不同的库上的并行复制。 Ø 基于不同业务要求的存取方式 平台业务中，不同的业务有不同的存取要求，比如典型的两大业务用户和订单，用户一般来讲总量是可控的，而订单是不断地递增的，对于用户表首先采取分库切分，每个sharding做一主多读，同样对于订单因更多需求的是用户查询自己的订单，也需要按照用户进行切分订单库，并且支持一主多读。 在硬件存储方面，对于事务日志因是顺序写，闪存的优势比硬盘高不了多少，所以采取电池保护的写缓存的raid卡存储；对于数据文件，无论是对用户或者订单都会存在大量的随机读写操作，当然加大内存是一个方面，另外可以采用高速的IO设备闪存，比如PCIe卡fusion-io。使用闪存也适合在单线程的负载中，比如主从复制，可以对从节点配置fusion-IO卡，降低复制的延迟。 对于订单业务来讲，量是不断递增的，PCIe卡存储容量比较有限，并且订单业务的热数据只有最近一段时间的(比如近3个月的)，对此这里列两种解决方案，一种是flashcache方式，采用基于闪存和硬盘存储的开源混合存储方式，在闪存中存储热点的数据。另外一种是可以定期把老的数据导出到分布式数据库HBase中，用户在查询订单列表是近期的数据从mysql中获取，老的数据可以从HBase中查询，当然需要HBase良好的rowkey设计以适应查询需求。 3) 分布式数据库 对于数据的高并发的访问，传统的关系型数据库提供读写分离的方案，但是带来的确实数据的一致性问题提供的数据切分的方案；对于越来越多的海量数据，传统的数据库采用的是分库分表，实现起来比较复杂，后期要不断的进行迁移维护；对于高可用和伸缩方面，传统数据采用的是主备、主从、多主的方案，但是本身扩展性比较差，增加节点和宕机需要进行数据的迁移。对于以上提出的这些问题，分布式数据库HBase有一套完善的解决方案，适用于高并发海量数据存取的要求。 Ø HBase 基于列式的高效存储降低IO 通常的查询不需要一行的全部字段，大多数只需要几个字段 对与面向行的存储系统，每次查询都会全部数据取出，然后再从中选出需要的字段 面向列的存储系统可以单独查询某一列，从而大大降低IO 提高压缩效率 同列数据具有很高的相似性，会增加压缩效率 Hbase的很多特性，都是由列存储决定的 高性能 LSM Tree 适合高速写的场景\n强一致的数据访问 MVCC HBase的一致性数据访问是通过MVCC来实现的。 HBase在写数据的过程中，需要经过好几个阶段，写HLog，写memstore，更新MVCC; 只有更新了MVCC，才算真正memstore写成功，其中事务的隔离需要有mvcc的来控制，比如读数据不可以获取别的线程还未提交的数据。 高可靠 HBase的数据存储基于HDFS，提供了冗余机制。 Region节点的宕机，对于内存中的数据还未flush到文件中，提供了可靠的恢复机制。\n可伸缩，自动切分，迁移 通过Zookeeper定位目标Region Server，最后定位Region。 Region Server扩容，通过将自身发布到Master，Master均匀分布。 可用性 存在单点故障，Region Server宕机后，短时间内该server维护的region无法访问，等待failover生效。 通过Master维护各Region Server健康状况和Region分布。 多个Master，Master宕机有zookeeper的paxos投票机制选取下一任Master。Master就算全宕机，也不影响Region读写。Master仅充当一个自动运维角色。 HDFS为分布式存储引擎，一备三，高可靠，0数据丢失。 HDFS的namenode是一个SPOF。 为避免单个region访问过于频繁，单机压力过大，提供了split机制 HBase的写入是LSM-TREE的架构方式，随着数据的append，HFile越来越多，HBase提供了HFile文件进行compact，对过期数据进行清除，提高查询的性能。 Schema free HBase没有像关系型数据库那样的严格的schema，可以自由的增加和删除schema中的字段。 HBase分布式数据库，对于二级索引支持的不太好，目前只支持在rowkey上的索引，所以rowkey的设计对于查询的性能来讲非常关键。 7. 管理与部署配置 统一的配置库 部署平台 8. 监控、统计 大型分布式系统涉及各种设备，比如网络交换机，普通PC机，各种型号的网卡，硬盘，内存等等，还有应用业务层次的监控，数量非常多的时候，出现错误的概率也会变大，并且有些监控的时效性要求比较高，有些达到秒级别；在大量的数据流中需要过滤异常的数据，有时候也对数据会进行上下文相关的复杂计算，进而决定是否需要告警。因此监控平台的性能、吞吐量、已经可用性就比较重要，需要规划统一的一体化的监控平台对系统进行各个层次的监控。 平台的数据分类 应用业务级别：应用事件、业务日志、审计日志、请求日志、异常、请求业务metrics、性能度量 系统级别：CPU、内存、网络、IO 时效性要求 阀值，告警： 实时计算： 近实时分钟计算 按小时、天的离线分析 实时查询 架构 节点中Agent代理可以接收日志、应用的事件以及通过探针的方式采集数据，agent采集数据的一个原则是和业务应用的流程是异步隔离的，不影响交易流程。 数据统一通过collector集群进行收集，按照数据的不同类型分发到不同的计算集群进行处理；有些数据时效性不是那么高，比如按小时进行统计，放入hadoop集群；有些数据是请求流转的跟踪数据，需要可以查询的，那么就可以放入solr集群进行索引；有些数据需要进行实时计算的进而告警的，需要放到storm集群中进行处理。 数据经过计算集群处理后，结果存储到Mysql或者HBase中。 监控的web应用可以把监控的实时结果推送到浏览器中，也可以提供API供结果的展现和搜索。\n","pubDate":"2021-02-15","title":"java \u003e thread \u003e 高并发高可用的架构实践"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java_%E5%A4%9A%E7%BA%BF%E7%A8%8B_%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E9%97%AE%E9%A2%98/","plain":"结束线程的方式  1:Thread.stop() 不推荐使用了  thread.stop()\r 2:thread.setDaemon() 设置为守护线程,JVM退出自动终止   Thread thread = new Thread(() -\u0026gt; {\r},\u0026quot;T-1\u0026quot;) ;\rthread.setDaemon(true);\rthread.start();\r 3:共享变量 通过一个推出表示开关  public class MyTask implements Runnable {\rprivate boolean shouldExit = false;\rpublic void setShouldExit(boolean newExit) {\rthis.shouldExit = newExit;\r}\r@Override\rpublic void run() {\rwhile (!shouldExit){\r//执行线程操作\r}\r}\r}\r 4:利用中断机制thread.interrupt()  A:void interrupt() 相某个线程发出中断信号,将会设置该线程的中断状态位，即设置为true，中断的结果线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序本身。线程会不时地检测这个中断标示位，以判断线程是否应该被中断（中断标示值是否为true）。它并不像stop方法那样会中断一个正在运行的线程。\rB:boolean isInterrupted() 查询某个线程是否有获得中断信号\rC:static boolean interrupted() 查询当前线程是否获得中断信号,查询后会重置中断的信号的状态 也就是说如果你连续两次调用这个方法,那么第一次是true,第二次是false\r 5:较优雅的退出方式  Thread thread = new Thread(new Runnable() {\r@Override\rpublic void run() {\rwhile (!Thread.currentThread().isInterrupted()){\r//线程要处理的任务\r//如果耗时较长的任务,可在在任务中间要退出的部分增加isInterrupted()的判断\rtry {\rThread.sleep(100);\r} catch (InterruptedException e) {\r//退出循环\rbreak;\r}\r}\rSystem.out.println(\u0026quot;thread exits.\u0026quot;);\r//关闭打开的资源,退出线程\r}\r}, \u0026quot;T-1\u0026quot;) ;\rthread.start();\rthread.interrupt();\r","pubDate":"2021-02-15","title":"java \u003e 多线程 \u003e 线程中断问题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java_%E5%A4%9A%E7%BA%BF%E7%A8%8B_%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/","plain":"线程状态 public enum State {\r/**\r尚未启动的线程的线程状态 ,这个时候还没有在堆栈中分配内存等数据\r*/\rNEW,\r/**\r线程可能等待也可能阻塞\r*/\rRUNNABLE,\r/**\r阻塞 等待锁的状态\r*/\rBLOCKED,\r/**\r线程等待状态\r*/\rWAITING,\r/**\r和WAITING类似但是有时间的等待\r*/\rTIMED_WAITING,\r/**\r线程终止\r*/\rTERMINATED;\r}\r","pubDate":"2021-02-15","title":"java \u003e 多线程 \u003e 线程状态"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java_%E5%A4%9A%E7%BA%BF%E7%A8%8Binfo/","plain":"1、在 java 中守护线程和本地线程区别？\njava 中的线程分为两种：守护线程（Daemon）和用户线程（User）。\n任何线程都可以设置为守护线程和用户线程，通过方法 Thread.setDaemon(boolon)；true 则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon()必须在 Thread.start()之前调用，否则运行时会抛出异常。\n两者的区别：\n唯一的区别是判断虚拟机(JVM)何时离开，Daemon 是为其他线程提供服务，如果全部的 User Thread 已经撤离，Daemon 没有可服务的线程，JVM 撤离。也可以理解为守护线程是 JVM 自动创建的线程（但不一定），用户线程是程序创建的线程；比如 JVM 的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是 Java 虚拟机上仅剩的线程时，Java 虚拟机会自动离开。\n扩展：Thread Dump 打印出来的线程信息，含有 daemon 字样的线程即为守护进程，可能会有：服务守护进程、编译守护进程、windows 下的监听 Ctrl+break的守护进程、Finalizer 守护进程、引用处理守护进程、GC 守护进程。\n2、线程与进程的区别？\n进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。\n一个程序至少有一个进程,一个进程至少有一个线程。\n3、什么是多线程中的上下文切换？\n多线程会共同使用一组计算机上的 CPU，而线程数大于给程序分配的 CPU 数量时，为了让各个线程都有执行的机会，就需要轮转使用 CPU。不同的线程切换使用 CPU发生的切换数据等就是上下文切换。\n4、死锁与活锁的区别，死锁与饥饿的区别？\n死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。\n产生死锁的必要条件：\n1、互斥条件：所谓互斥就是进程在某一时间内独占资源。\n2、请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。\n3、不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。\n4、循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。\n活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。\n活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。\n饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。\nJava 中导致饥饿的原因：\n1、高优先级线程吞噬所有的低优先级线程的 CPU 时间。\n2、线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。\n3、线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait 方法)，因为其他线程总是被持续地获得唤醒。\n5、Java 中用到的线程调度算法是什么？\n采用时间片轮转的方式。可以设置线程的优先级，会映射到下层的系统上面的优先级上，如非特别需要，尽量不要用，防止线程饥饿。\n6、什么是线程组，为什么在 Java 中不推荐使用？\nThreadGroup 类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。\n为什么不推荐使用？因为使用有很多的安全隐患吧，没有具体追究，如果需要使用，推荐使用线程池。\n7、为什么使用 Executor 框架？\n每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的。\n调用 new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。\n接使用 new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。\n8、在 Java 中 Executor 和 Executors 的区别？\nExecutors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。\nExecutor 接口对象能执行我们的线程任务。\nExecutorService 接口继承了 Executor 接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。\n使用 ThreadPoolExecutor 可以创建自定义线程池。\nFuture 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用 get()方法获取计算的结果。\n9、如何在 Windows 和 Linux 上查找哪个线程使用的 CPU 时间最长？\n10、什么是原子操作？在 Java Concurrency API 中有哪些原子类(atomic classes)？\n原子操作（atomic operation）意为”不可被中断的一个或一系列操作” 。\n处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。在 Java 中可以通过锁和循环 CAS 的方式来实现原子操作。 CAS 操作——Compare \u0026amp; Set，或是 Compare \u0026amp; Swap，现在几乎所有的 CPU 指令都支持 CAS的原子操作。\n原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。\nint++并不是一个原子操作，所以当一个线程读取它的值并加 1 时，另外一个线程有可能会读到之前的值，这就会引发错误。\n为了解决这个问题，必须保证增加操作是原子的，在 JDK1.5 之前我们可以使用同步技术来做到这一点。到 JDK1.5，java.util.concurrent.atomic 包提供了 int 和long 类型的原子包装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。\njava.util.concurrent 这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。\n原子类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference\n原子数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray\n原子属性更新器：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater\n解决 ABA 问题的原子类：AtomicMarkableReference（通过引入一个 boolean来反映中间有没有变过），AtomicStampedReference（通过引入一个 int 来累加来反映中间有没有变过）\n11、Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？\nLock 接口比同步方法和同步块提供了更具扩展性的锁操作。\n他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。\n它的优势有：\n可以使锁更公平\n可以使线程在等待锁的时候响应中断\n可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间\n可以在不同的范围，以不同的顺序获取和释放锁\n整体上来说 Lock 是 synchronized 的扩展版，Lock 提供了无条件的、可轮询的(tryLock 方法)、定时的(tryLock 带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition 方法)锁操作。另外 Lock 的实现类基本都支持非公平锁(默认)和公平锁，synchronized 只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。\n12、什么是 Executors 框架？\nExecutor 框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。\n无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用Executors 框架可以非常方便的创建一个线程池。\n13、什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？\n阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。\n这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。\n阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。\nJDK7 提供了 7 个阻塞队列。分别是：\nArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。\nLinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。\nPriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。\nDelayQueue：一个使用优先级队列实现的无界阻塞队列。\nSynchronousQueue：一个不存储元素的阻塞队列。\nLinkedTransferQueue：一个由链表结构组成的无界阻塞队列。\nLinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。\nJava 5 之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好，wait ,notify,notifyAll,sychronized 这些关键字。而在 java 5 之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。\nBlockingQueue 接口是 Queue 的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性，当生产者线程试图向BlockingQueue 放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞，正是因为它所具有这个特性，所以在程序中多个线程交替向 BlockingQueue 中放入元素，取出元素，它可以很好的控制线程之间的通信。\n阻塞队列使用最经典的场景就是 socket 客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程不断从队列取数据解析。\n14、什么是 Callable 和 Future?\nCallable 接口类似于 Runnable，从名字就可以看出来了，但是 Runnable 不会返回结果，并且无法抛出返回结果的异常，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值。\n可以认为是带有回调的 Runnable。\nFuture 接口表示异步任务，是还没有完成的任务给出的未来结果。所以说 Callable用于产生结果，Future 用于获取结果。\n15、什么是 FutureTask?使用 ExecutorService 启动任务。\n在 Java 并发程序中 FutureTask 表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是调用了 Runnable接口所以它可以提交给 Executor 来执行。\n16、什么是并发容器的实现？\n何为同步容器：可以简单地理解为通过 synchronized 来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。比如 Vector，Hashtable，以及 Collections.synchronizedSet，synchronizedList 等方法返回的容器。可以通过查看 Vector，Hashtable 等这些同步容器的实现代码，可以看到这些容器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上关键字 synchronized。\n并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，例如在 ConcurrentHashMap 中采用了一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任意数量的读线程并发地访问 map，并且执行读操作的线程和写操作的线程也可以并发的访问 map，同时允许一定数量的写操作线程并发地修改 map，所以它可以在并发环境下实现更高的吞吐量。\n17、多线程同步和互斥有几种实现方法，都是什么？\n线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。\n线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。\n用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内核模式下的方法有：事件，信号量，互斥量。\n18、什么是竞争条件？你怎样发现和解决竞争？\n当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，则我们认为这发生了竞争条件（race condition）。\n19、你将如何使用 thread dump？你将如何分析 Thread dump？\n新建状态（New）\n用 new 语句创建的线程处于新建状态，此时它和其他 Java 对象一样，仅仅在堆区中被分配了内存。\n就绪状态（Runnable）\n当一个线程对象创建后，其他线程调用它的 start()方法，该线程就进入就绪状态，Java 虚拟机会为它创建方法调用栈和程序计数器。处于这个状态的线程位于可运行池中，等待获得 CPU 的使用权。\n运行状态（Running）\n处于这个状态的线程占用 CPU，执行程序代码。只有处于就绪状态的线程才有机会转到运行状态。\n阻塞状态（Blocked）\n阻塞状态是指线程因为某些原因放弃 CPU，暂时停止运行。当线程处于阻塞状态时，Java 虚拟机不会给线程分配 CPU。直到线程重新进入就绪状态，它才有机会转到运行状态。\n阻塞状态可分为以下 3 种：\n位于对象等待池中的阻塞状态（Blocked in object’s wait pool）：\n当线程处于运行状态时，如果执行了某个对象的 wait()方法，Java 虚拟机就会把线程放到这个对象的等待池中，这涉及到“线程通信”的内容。\n位于对象锁池中的阻塞状态（Blocked in object’s lock pool）：\n当线程处于运行状态时，试图获得某个对象的同步锁时，如果该对象的同步锁已经被其他线程占用，Java 虚拟机就会把这个线程放到这个对象的锁池中，这涉及到“线程同步”的内容。\n其他阻塞状态（Otherwise Blocked）：\n当前线程执行了 sleep()方法，或者调用了其他线程的 join()方法，或者发出了 I/O请求时，就会进入这个状态。\n死亡状态（Dead）\n当线程退出 run()方法时，就进入死亡状态，该线程结束生命周期。\n20、为什么我们调用 start()方法时会执行 run()方法，为什么我们不能直接调用 run()方法？\n当你调用 start()方法时你将创建新的线程，并且执行在 run()方法里的代码。\n但是如果你直接调用 run()方法，它不会创建新的线程也不会执行调用线程的代码，只会把 run 方法当作普通方法去执行。\n21、Java 中你怎样唤醒一个阻塞的线程？\n在 Java 发展史上曾经使用 suspend()、resume()方法对于线程进行阻塞唤醒，但随之出现很多问题，比较典型的还是死锁问题。\n解决方案可以使用以对象为目标的阻塞，即利用 Object 类的 wait()和 notify()方法实现线程阻塞。\n首 先 ，wait、notify 方法是针对对象的，调用任意对象的 wait()方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的 notify()方法则将随机解除该对象阻塞的线程，但它需要重新获取改对象的锁，直到获取成功才能往下执行；其次，wait、notify 方法必须在 synchronized 块或方法中被调用，并且要保证同步块或方法的锁对象与调用 wait、notify 方法的对象是同一个，如此一来在调用 wait 之前当前线程就已经成功获取某对象的锁，执行 wait 阻塞后当前线程就将之前获取的对象锁释放。\n22、在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？\nCyclicBarrier 可以重复使用，而 CountdownLatch 不能重复使用。\nJava 的 concurrent 包里面的 CountDownLatch 其实可以把它看作一个计数器，只不过这个计数器的操作是原子操作，同时只能有一个线程去操作这个计数器，也就是同时只能有一个线程去减这个计数器里面的值。你可以向 CountDownLatch 对象设置一个初始的数字作为计数值，任何调用这个对象上的 await()方法都会阻塞，直到这个计数器的计数值被其他的线程减为 0 为止。\n所以在当前计数到达零之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await 的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。如果需要重置计数，请考虑使用 CyclicBarrier。CountDownLatch 的一个非常典型的应用场景是：有一个任务想要往下执行，但必须要等到其他的任务执行完毕后才可以继续往下执行。假如我们这个想要继续往下执行的任务调用一个 CountDownLatch 对象的 await()方法，其他的任务执行完自己的任务后调用同一个 CountDownLatch 对象上的 countDown()方法，这个调用 await()方法的任务将一直阻塞等待，直到这个 CountDownLatch 对象的计数值减到 0 为止。\nCyclicBarrier 一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。\n23、什么是不可变对象，它对写并发应用有什么帮助？\n不可变对象(Immutable Objects)即对象一旦被创建它的状态（对象的数据，也即对象属性值）就不能改变，反之即为可变对象(Mutable Objects)。\n不可变对象的类即为不可变类(Immutable Class)。Java 平台类库中包含许多不可变类，如 String、基本类型的包装类、BigInteger 和 BigDecimal 等。\n不可变对象天生是线程安全的。它们的常量（域）是在构造函数中创建的。既然它们的状态无法修改，这些常量永远不会变。\n不可变对象永远是线程安全的。\n只有满足如下状态，一个对象才是不可变的；\n它的状态不能在创建后再被修改；\n所有域都是 final 类型；并且，它被正确创建（创建期间没有发生 this 引用的逸出）。\n24、什么是多线程中的上下文切换？\n在上下文切换过程中，CPU 会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行。从这个角度来看，上下文切换有点像我们同时阅读几本书，在来回切换书本的同时我们需要记住每本书当前读到的页码。在程序中，上下文切换过程中的“页码”信息是保存在进程控制块（PCB）中的。PCB 还经常被称作“切换桢”（switchframe）。“页码”信息会一直保存到 CPU 的内存中，直到他们被再次使用。\n上下文切换是存储和恢复 CPU 状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。\n25、Java 中用到的线程调度算法是什么？\n计算机通常只有一个 CPU,在任意时刻只能执行一条机器指令,每个线程只有获得CPU 的使用权才能执行指令.所谓多线程的并发运行,其实是指从宏观上看,各个线程轮流获得 CPU 的使用权,分别执行各自的任务.在运行池中,会有多个处于就绪状态的线程在等待 CPU,JAVA 虚拟机的一项任务就是负责线程的调度,线程调度是指按照特定机制为多个线程分配 CPU 的使用权.\n有两种调度模型：分时调度模型和抢占式调度模型。\n分时调度模型是指让所有的线程轮流获得 cpu 的使用权,并且平均分配每个线程占用的 CPU 的时间片这个也比较好理解。\nJava虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。\n26、什么是线程组，为什么在 Java 中不推荐使用？\n线程组和线程池是两个不同的概念，他们的作用完全不同，前者是为了方便线程的管理，后者是为了管理线程的生命周期，复用线程，减少创建销毁线程的开销。\n27、为什么使用 Executor 框架比使用应用创建和管理线程好？\n为什么要使用 Executor 线程池框架\n1、每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的。\n2、调用 new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。\n3、直接使用 new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。\n使用 Executor 线程池框架的优点\n1、能复用已存在并空闲的线程从而减少线程对象的创建从而减少了消亡线程的开销。\n2、可有效控制最大并发线程数，提高系统资源使用率，同时避免过多资源竞争。\n3、框架中已经有定时、定期、单线程、并发数控制等功能。\n综上所述使用线程池框架 Executor 能更好的管理线程、提供系统资源使用率。\n28、java 中有几种方法可以实现一个线程？\n继承 Thread 类\n实现 Runnable 接口\n实现 Callable 接口，需要实现的是 call() 方法\n29、如何停止一个正在运行的线程？\n使用共享变量的方式\n在这种方式中，之所以引入共享变量，是因为该变量可以被多个执行相同任务的线程用来作为是否中断的信号，通知中断线程的执行。\n使用 interrupt 方法终止线程\n如果一个线程由于等待某些事件的发生而被阻塞，又该怎样停止该线程呢？这种情况经常会发生，比如当一个线程由于需要等候键盘输入而被阻塞，或者调用Thread.join()方法，或者 Thread.sleep()方法，在网络中调用ServerSocket.accept()方法，或者调用了 DatagramSocket.receive()方法时，都有可能导致线程阻塞，使线程处于处于不可运行状态时，即使主程序中将该线程的共享变量设置为 true，但该线程此时根本无法检查循环标志，当然也就无法立即中断。这里我们给出的建议是，不要使用 stop()方法，而是使用 Thread 提供的interrupt()方法，因为该方法虽然不会中断一个正在运行的线程，但是它可以使一个被阻塞的线程抛出一个中断异常，从而使线程提前结束阻塞状态，退出堵塞代码。\n30、notify()和 notifyAll()有什么区别？\n当一个线程进入 wait 之后，就必须等其他线程 notify/notifyall,使用 notifyall,可以唤醒所有处于 wait 状态的线程，使其重新进入锁的争夺队列中，而 notify 只能唤醒一个。\n如果没把握，建议 notifyAll，防止 notigy 因为信号丢失而造成程序异常。\n31、什么是 Daemon 线程？它有什么意义？\n所谓后台(daemon)线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这个线程并不属于程序中不可或缺的部分。因此，当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。反过来说，只要有任何非后台线程还在运行，程序就不会终止。必须在线程启动之前调用setDaemon()方法，才能把它设置为后台线程。注意：后台进程在不执行 finally子句的情况下就会终止其 run()方法。\n比如：JVM 的垃圾回收线程就是 Daemon 线程，Finalizer 也是守护线程。\n32、java 如何实现多线程之间的通讯和协作？\n中断 和 共享变量\n33、什么是可重入锁（ReentrantLock）？\n举例来说明锁的可重入性\npublic class UnReentrant{\nLock lock = new Lock();\npublic void outer(){\nlock.lock();\ninner();\nlock.unlock();\n}\npublic void inner(){\nlock.lock();\n//do something\nlock.unlock();\n}\n}\nouter 中调用了 inner，outer 先锁住了 lock，这样 inner 就不能再获取 lock。其实调用 outer 的线程已经获取了 lock 锁，但是不能在 inner 中重复利用已经获取的锁资源，这种锁即称之为 不可重入可重入就意味着：线程可以进入任何一个它已经拥有的锁所同步着的代码块。\nsynchronized、ReentrantLock 都是可重入的锁，可重入锁相对来说简化了并发编程的开发。\n34、当一个线程进入某个对象的一个 synchronized 的实例方法后，其它线程是否可进入此对象的其它方法？\n如果其他方法没有 synchronized 的话，其他线程是可以进入的。\n所以要开放一个线程安全的对象时，得保证每个方法都是线程安全的。\n35、乐观锁和悲观锁的理解及如何实现，有哪些实现方式？\n悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。\n乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。在 Java中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。\n乐观锁的实现方式：\n1、使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。\n2、java 中的 Compare and Swap 即 CAS ，当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。 CAS 操作中包含三个操作数 —— 需要读写的内存位置（V）、进行比较的预期原值（A）和拟写入的新值(B)。如果内存位置 V 的值与预期原值 A 相匹配，那么处理器会自动将该位置值更新为新值 B。否则处理器不做任何操作。\nCAS 缺点：\n1、ABA 问题：\n比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。从 Java1.5 开始 JDK 的 atomic包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。\n2、循环时间长开销大：\n对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。\n3、只能保证一个共享变量的原子操作：\n当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。\n36、SynchronizedMap 和 ConcurrentHashMap 有什么区别？\nSynchronizedMap 一次锁住整张表来保证线程安全，所以每次只能有一个线程来访为 map。\nConcurrentHashMap 使用分段锁来保证在多线程下的性能。\nConcurrentHashMap 中则是一次锁住一个桶。ConcurrentHashMap 默认将hash 表分为 16 个桶，诸如 get,put,remove 等常用操作只锁当前需要用到的桶。\n这样，原来只能一个线程进入，现在却能同时有 16 个写线程执行，并发性能的提升是显而易见的。\n另外 ConcurrentHashMap 使用了一种不同的迭代方式。在这种迭代方式中，当iterator 被创建后集合再发生改变就不再是抛出\nConcurrentModificationException，取而代之的是在改变时 new 新的数据从而不影响原有的数据 ，iterator 完成后再将头指针替换为新的数据 ，这样 iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变。\n37、CopyOnWriteArrayList 可以用于什么应用场景？\nCopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出 ConcurrentModificationException。在CopyOnWriteArrayList 中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。\n1、由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc；\n2、不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个 set操作后，读取到数据可能还是旧的,虽然 CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求；\nCopyOnWriteArrayList 透露的思想\n1、读写分离，读和写分开\n2、最终一致性\n3、使用另外开辟空间的思路，来解决并发冲突\n38、什么叫线程安全？servlet 是线程安全吗?\n线程安全是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。\nServlet 不是线程安全的，servlet 是单实例多线程的，当多个线程同时访问同一个方法，是不能保证共享变量的线程安全性的。\nStruts2 的 action 是多实例多线程的，是线程安全的，每个请求过来都会 new 一个新的 action 分配给这个请求，请求完成后销毁。\nSpringMVC 的 Controller 是线程安全的吗？不是的，和 Servlet 类似的处理流程。\nStruts2 好处是不用考虑线程安全问题；Servlet 和 SpringMVC 需要考虑线程安全问题，但是性能可以提升不用处理太多的 gc，可以使用 ThreadLocal 来处理多线程的问题。\n39、volatile 有什么用？能否用一句话说明下 volatile 的应用场景？\nvolatile 保证内存可见性和禁止指令重排。\nvolatile 用于多线程环境下的单次操作(单次读或者单次写)。\n40、为什么代码会重排序？\n在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：\n在单线程环境下不能改变程序运行的结果；\n存在数据依赖关系的不允许重排序\n需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。\n41、在 java 中 wait 和 sleep 方法的不同？\n最大的不同是在等待时 wait 会释放锁，而 sleep 一直持有锁。Wait 通常被用于线程间交互，sleep 通常被用于暂停执行。\n42、用 Java 实现阻塞队列\n43、一个线程运行时发生异常会怎样？\n如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候 JVM 会使用 Thread.getUncaughtExceptionHandler()来查询线程的 UncaughtExceptionHandler 并将线程和异常作为参数传递给handler 的 uncaughtException()方法进行处理。\n44、如何在两个线程间共享数据？\n在两个线程间共享变量即可实现共享。\n一般来说，共享变量要求变量本身是线程安全的，然后在线程内使用的时候，如果有对共享变量的复合操作，那么也得保证复合操作的线程安全性。\n45、Java 中 notify 和 notifyAll 有什么区别？\nnotify() 方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而 notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。\n46、为什么 wait, notify 和 notifyAll 这些方法不在 thread类里面？\n一个很明显的原因是 JAVA 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。由于 wait，notify 和 notifyAll 都是锁级别的操作，所以把他们定义在 Object 类中因为锁属于对象。\n47、什么是 ThreadLocal 变量？\nThreadLocal 是 Java 里一种特殊的变量。每个线程都有一个 ThreadLocal 就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用 ThreadLocal 让SimpleDateFormat 变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。\n48、Java 中 interrupted 和 isInterrupted 方法的区别？\ninterrupt\ninterrupt 方法用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。\n注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出interruptedException 的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。\ninterrupted\n查询当前线程的中断状态，并且清除原状态。如果一个线程被中断了，第一次调用 interrupted 则返回 true，第二次和后面的就返回 false 了。\nisInterrupted\n仅仅是查询当前线程的中断状态\n49、为什么 wait 和 notify 方法要在同步块中调用？\nJava API 强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException 异常。还有一个原因是为了避免 wait 和 notify之间产生竞态条件。\n50、为什么你应该在循环中检查等待条件?\n处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。\n51、Java 中的同步集合与并发集合有什么区别？\n同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在 Java1.5 之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5 介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。\n52、什么是线程池？ 为什么要使用它？\n创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5 开始，Java API 提供了 Executor 框架让你可以创建不同的线程池。\n53、怎么检测一个线程是否拥有锁？\n在 java.lang.Thread 中有一个方法叫 holdsLock()，它返回 true 如果当且仅当当前线程拥有某个具体对象的锁。\n54、你如何在 Java 中获取线程堆栈？\nkill -3 [java pid]\n不会在当前终端输出，它会输出到代码执行的或指定的地方去。比如，kill -3\ntomcat pid, 输出堆栈到 log 目录下。\nJstack [java pid]\n这个比较简单，在当前终端显示，也可以重定向到指定文件中。\n-JvisualVM：Thread Dump\n不做说明，打开 JvisualVM 后，都是界面操作，过程还是很简单的。\n55、JVM 中哪个参数是用来控制线程的栈堆栈小的?\n-Xss 每个线程的栈大小\n56、Thread 类中的 yield 方法有什么作用？\n使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。\n当前线程到了就绪状态，那么接下来哪个线程会从就绪状态变成执行状态呢？可能是当前线程，也可能是其他线程，看系统的分配了。\n57、Java 中 ConcurrentHashMap 的并发度是什么？\nConcurrentHashMap 把实际 map 划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是 ConcurrentHashMap 类构造函数的一个可选参数，默认值为 16，这样在多线程情况下就能避免争用。\n在 JDK8 后，它摒弃了 Segment（锁段）的概念，而是启用了一种全新的方式实现,利用 CAS 算法。同时加入了更多的辅助变量来提高并发度，具体内容还是查看源码吧。\n58、Java 中 Semaphore 是什么？\nJava 中的 Semaphore 是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore 只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。\n59、Java 线程池中 submit() 和 execute()方法有什么区别？\n两个方法都可以向线程池提交任务，execute()方法的返回类型是 void，它定义在Executor 接口中。\n而 submit()方法可以返回持有计算结果的 Future 对象，它定义在ExecutorService 接口中，它扩展了 Executor 接口，其它线程池类像ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 都有这些方法。\n60、什么是阻塞式方法？\n阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket 的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。\n61、Java 中的 ReadWriteLock 是什么？\n读写锁是用来提升并发程序性能的锁分离技术的成果。\n62、volatile 变量和 atomic 变量有什么不同？\nVolatile 变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用 volatile 修饰 count 变量那么 count++ 操作就不是原子性的。\n而 AtomicInteger 类提供的 atomic 方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。\n63、可以直接调用 Thread 类的 run ()方法么？\n当然可以。但是如果我们调用了 Thread 的 run()方法，它的行为就会和普通的方法一样，会在当前线程中执行。为了在新的线程中执行我们的代码，必须使用Thread.start()方法。\n64、如何让正在运行的线程暂停一段时间？\n我们可以使用 Thread 类的 Sleep()方法让线程暂停一段时间。需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为 Runnable，并且根据线程调度，它将得到执行。\n65、你对线程优先级的理解是什么？\n每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个 int 变量(从 1-10)，1 代表最低优先级，10 代表最高优先级。\njava 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。\n66、什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing )？\n线程调度器是一个操作系统服务，它负责为 Runnable 状态的线程分配 CPU 时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。同上一个问题，线程调度并不受到 Java 虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。\n时间分片是指将可用的 CPU 时间分配给可用的 Runnable 线程的过程。分配 CPU时间可以基于线程优先级或者线程等待的时间。\n67、你如何确保 main()方法所在的线程是 Java 程序最后结束的线程？\n我们可以使用 Thread 类的 join()方法来确保所有程序创建的线程在 main()方法退出前结束。\n68、线程之间是如何通信的？\n当线程间是可以共享资源时，线程间通信是协调它们的重要的手段。Object 类中wait()\\notify()\\notifyAll()方法可以用于线程间通信关于资源的锁的状态。\n69、为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？\nJava 的每个对象中都有一个锁(monitor，也可以成为监视器) 并且 wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在 Java 的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是 Object 类的一部分，这样 Java 的每一个类都有用于线程间通信的基本方法。\n70、为什么 wait(), notify()和 notifyAll ()必须在同步方法或者同步块中被调用？\n当一个线程需要调用对象的 wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的 notify()方法。同样的，当一个线程需要调用对象的 notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。\n71、为什么 Thread 类的 sleep()和 yield ()方法是静态的？\nThread 类的 sleep()和 yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。\n72、如何确保线程安全？\n在 Java 中可以有很多方法来保证线程安全——同步，使用原子类(atomic concurrent classes)，实现并发锁，使用 volatile 关键字，使用不变类和线程安全类。\n73、同步方法和同步块，哪个是更好的选择？\n同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。\n同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。\n74、如何创建守护线程？\n使用 Thread 类的 setDaemon(true)方法可以将线程设置为守护线程，需要注意的是，需要在调用 start()方法前调用这个方法，否则会抛出IllegalThreadStateException 异常。\n75、什么是 Java Timer 类？如何创建一个有特定时间间隔的任务？\njava.util.Timer 是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer 类可以用安排一次性任务或者周期任务。\njava.util.TimerTask 是一个实现了 Runnable 接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用 Timer 去安排它的执行。\n","pubDate":"2021-02-15","title":"java \u003e 多线程info"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java_%E5%A4%9A%E7%BA%BF%E7%A8%8Bsynchronized/","plain":"synchronized  synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性\n  用法:  \rpublic synchronized void doSomething(){\r//这里的代码不会同时有几个线程执行\r}\rsynchronized (this){\r//这里的代码也不会有几个代码同时执行 }\r synchronized监视器 synchronized(object) object是监视器 被synchronized修饰的方法 静态方法:监视器是所属类的class对象 非静态方法:监视器是this 同一个监视器内所以代码都是同步的,不论是否在同一函数、同一类内如:   监视器不要使用Long,Integer等基本类型对象做监视器这样不好  public synchronized void methodA(){\r}\rpublic synchronized void methodB(){\r}\rpublic void methodC(){\rsynchronized (this){\r}\r}\r//如果有一个线程已经运行ABC三处中的任意一个代码块，那么其它线程都不能执行这三个代码块的任意一个地方\r 下面是一些监视器  public class Sync {\rpublic void doA(){\rsynchronized (this){\r//A 监视器Sync.this\r}\r}\rpublic synchronized void doB1(){\r//B1 监视器Sync.this\r}\rpublic synchronized void doB2(){\r//B2 监视器Sync.this\r}\rpublic static synchronized void doC(){\r//C 监视器 Sync.class\r}\rpublic void doD(){\rsynchronized (Sync.class){\r//D 监视器 Sync.class\r}\r}\r}\r 关于同步的一些写法   private Object object = new Object();\rpublic void doA()throws InterruptedException{\robject.wait();//错误用法 会抛出无效的异常监视器状态\r}\rpublic void doB(){\robject.notify();//错误用法\r}\r 正确用法  private Object object = new Object();\rpublic void doA() throws InterruptedException {\rsynchronized (object) {//获得锁\robject.wait();//释放锁,待其它线程notify或者notifyAll后重新获得锁后继续运行\r}//释放锁\r}\rpublic void doB() {\rsynchronized(object){//获得锁\robject.notify(); //通知一个被wait此监视器的线程\r}//释放锁\r}\r 一个例子下面程序输出多少  public class MonitorObject {\rprivate Object object = new Object();\rpublic void doA()throws InterruptedException{\rsynchronized (object){\rSystem.out.println(\u0026quot;1\u0026quot;);\robject.wait();\rSystem.out.println(\u0026quot;2\u0026quot;);\r}\r}\rpublic void doB()throws InterruptedException{\rsynchronized (object){\rSystem.out.println(\u0026quot;3\u0026quot;);\robject.notify();\rThread.sleep(500);\rSystem.out.println(\u0026quot;4\u0026quot;);\r}\r}\rpublic static void main(String[] args) {\rMonitorObject mo = new MonitorObject();\rThread t1 = new Thread(new Runnable() {\r@Override\rpublic void run() {\rtry {\rmo.doA();\r} catch (InterruptedException e) {\r}\r}\r}, \u0026quot;t1\u0026quot;);\rThread t2 = new Thread(new Runnable() {\r@Override\rpublic void run() {\rtry {\rmo.doB();\r} catch (InterruptedException e) {\r}\r}\r}, \u0026quot;t2\u0026quot;);\rt1.start();\rtry {\rThread.sleep(100);\r} catch (InterruptedException e) {\r}\rt2.start();\r}\r}\r 解答  ","pubDate":"2021-02-15","title":"java \u003e 多线程synchronized"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java_%E5%A4%9A%E7%BA%BF%E7%A8%8Bsynchronized.answer/","plain":"1\r3\r4\r2\r  首先t1线程最先执行所以输出1没问题\n  输出t1后执行了object.wait(),当前执行线程放弃了此监视器上的锁,并且被挂起(等待此监视器上的其它线程来唤醒) 这里最重要的是把此监视器上的锁给放弃了\n  t2线程去竞争object上的锁,由于目前只有它一个线程是属于非挂起状态因此t2就获得了object上的锁.因此输出了3没问题\n  接着t2线程又执行了object.notify(),这个方法是随机唤醒此监视器上被挂起的线程,并且刚好只有2个线程中的一个被挂起那么t1就被唤醒了,注意仅仅是唤醒而已,并没有使得t2放弃锁或者t1获得锁,因此t1还是不能执行\n  接着t2线程执行了sleep(500)这个方法,但是这个方法同样并没有使得t2线程放弃锁,仅仅是暂停了那么一会,这就像打战弱势的一方拿空间换时间做战略撤退，实际上并没有投降依然属于不投降状态\n  因此当t2线程执行完之后t1最好才能执行接着打印出2\n  ","pubDate":"2021-02-15","title":"java \u003e 多线程synchronized.answer"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6%E5%8E%9F%E7%90%86_java_%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6%E5%8E%9F%E7%90%86/","plain":"接口回调法 模拟输出监听事件 第一步先定义事件接口 public interface PrintListener {\rpublic void print();\r}\r第二步自定义输出类 public class Out {\rPrintListener listener=null;\rpublic Out() {\r}\rpublic Out(PrintListener listener) {\rthis.listener=listener;\r}\rpublic void printlen(String s) {\rSystem.out.println(s);\rif(listener!=null) {\rlistener.print();\r}\r}\r}\r第三步实现监听事件接口 public class PrintListenerDemo implements PrintListener {\r@Override\rpublic void print() {\rSystem.out.println(\u0026quot;监听到输出事件\u0026quot;);\r}\r}\r测试 public class Test {\rpublic static void main(String[] args) {\r//新建一个默认输出类\rOut b=new Out();\rb.printlen(\u0026quot;这里不会被监听到输出事件\u0026quot;);\t//新建一个输出类,为输出类添加一个输出监听事件\rOut b1=new Out(new PrintListenerDemo());\rb1.printlen(\u0026quot;这里输出后会被监听到输出事件\u0026quot;);\r}\r}\r结果 监听事件使用  在javaweb中,不论与ServletContext,HttpSession,ServletRequest相关的监听接口\n  开发者只需要直接实现这些监听接口事件,其他的源码别人己经写好了,我们不用关心它是如何实现\n ","pubDate":"2021-02-15","title":"java \u003e 监听事件原理"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_java_javareadme/","plain":"Java技术体系 消息队列,nosql,sql,dubbo,zookeeper,nginx,springcloud,springboot,spring,jpa,mybatis\rjava语法，java多线程与并发,jdbc,设计模式\rjava基础总结大全 Java的程序结构 多线程 swing jsp el 表达式 Java多线程编程 JVM体系 redis apache-common工具包 Guava-common IO spring工具 spring常用的工具类 js_console.log用法 dom4j Jsoup ","pubDate":"2021-02-15","title":"javaReadme"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","plain":"JMM(Java内存模型)  主要有三个特性:可见性,有序性,原子性\n 可见性   计算机内存模型   Java内存模型简易   ","pubDate":"2021-02-15","title":"java内存模型"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_java%E8%AF%95%E9%A2%98%E7%BB%8F%E5%85%B87/","plain":" {width=\u0026ldquo;5.848421916010499in\u0026rdquo; height=\u0026ldquo;9.791119860017497e-3in\u0026rdquo;}更多请关注微信公众号：Java技术栈\n 什么是 Java 虚拟机？为什么 Java 被称作是\u0026quot;平台无关的编程语言\u0026quot;？ 参考答案 Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。Java 源文件被编译成能被 Java 虚拟机执行的字节码文件。\nJava 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和 其他特性。\nJDK 和 JRE 的区别是什么？ 参考答案 Java 运行时环境(JRE)是将要执行 Java 程序的 Java 虚拟机。它同时也包含了执行 applet 需要的浏览器插件。Java 开发工具包(JDK)是完整的 Java 软件开发包，包含了 JRE，编译器和其他的工具(比如：JavaDoc，Java 调试器)，可以让开发者开发、编译、执行 Java 应 用程序。\n\u0026ldquo;static\u0026quot;关键字是什么意思？Java 中是否可以覆盖(override)一个 private 或者是  static 的方法？\n 参考答案 \u0026ldquo;static\u0026quot;关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。\nJava 中static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用。\n是否可以在 static 环境中访问非 static 变量？ 参考答案 static 变量在 Java 中是属于类的，它在所有的实例中的值是一样的。当类被 Java 虚拟机载入的时候，会对 static 变量进行初始化。如果你的代码尝试不用实例来访问非 static 的变量， 编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。\nJava 支持的数据类型有哪些？什么是自动拆装箱？ 参考答案 Java 语言支持的 8 种基本数据类型是：\nbyte short int long float double\nboolean char\n自动装箱是 Java 编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如： 把 int 转化 成 Integer ， double 转化 成 Double ， 等 等 。 反 之 就 是 自 动 拆 箱 。\n {width=\u0026ldquo;5.848421916010499in\u0026rdquo; height=\u0026ldquo;9.791119860017497e-3in\u0026rdquo;}更多请关注微信公众号：Java技术栈\n Java 中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？ 参考答案 Java 中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名， 参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。\nJava 中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？ 参考答案 当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提 供构造函数的情况下，Java 编译器会为这个类创建一个默认的构造函数。\nJava 中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函 数必须有它自己唯一的参数列表。\nJava 不支持像C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java 不会创建默认的复制构造函数。\nJava 支持多继承么？ 参考答案 Java 中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是 java 中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应 的功能）。\n接口和抽象类的区别是什么？ 参考答案 Java 提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：\n接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。类可以实现很多个接口，但是只能继承一个抽象类\n类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽 象的。\n抽象类可以在不提供接口方法实现的情况下实现接口。\nJava 接口中声明的变量默认都是 final 的。抽象类可以包含非final 的变量。\nJava 接口中的成员函数默认是 public 的。抽象类的成员函数可以是 private，protected 或者是 public。\n接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含 main 方法的话是可以被调用的。\n也可以参考 JDK8 中抽象类和接口的区别\n什么是值传递和引用传递？ 参考答案 值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量.\n {width=\u0026ldquo;5.848421916010499in\u0026rdquo; height=\u0026ldquo;9.791119860017497e-3in\u0026rdquo;}更多请关注微信公众号：Java技术栈\n 引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 所以对引用对象进行操作会同时改变原对象.\n一般认为,java 内的传递都是值传递.\n进程和线程的区别是什么？ 参考答案 进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。 线程又叫做轻量级进程。\n创建线程有几种不同的方式？你喜欢哪一种？为什么？ 参考答案 有三种方式可以用来创建线程： 继承 Thread 类\n实现Runnable 接口\n应用程序可以使用Executor 框架来创建线程池\n实现Runnable 接口这种方式更受欢迎，因为这不需要继承 Thread 类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而 Java 不支持多继承），只能实现接口。同时， 线程池也是非常高效的，很容易实现和使用。\n概括的解释下线程的几种可用状态。 参考答案   新建( new )：新创建了一个线程对象。\n  可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。 3. 运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行 程序代码。\n  4. 阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种：\n(一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。\n(二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。\n(三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时，JVM 会把该线程置为阻塞状态。 当 sleep ()状态超时、join () 等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。 5. 死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该 线程结束生命周期。死亡的线程不可再次复生。\n {width=\u0026ldquo;5.848421916010499in\u0026rdquo; height=\u0026ldquo;9.791119860017497e-3in\u0026rdquo;}{width=\u0026ldquo;6.296774934383202in\u0026rdquo; height=\u0026ldquo;3.53625in\u0026rdquo;}更多请关注微信公众号：Java技术栈\n*同步方法和同步代码块的区别是什么？ *\n 参考答案 区别：\n同步方法默认用 this 或者当前类 class 对象作为锁；\n同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；\n在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？ 参考答案 监视器和锁在 Java 虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。\n什么是死锁(deadlock)？ 参考答案 两个线程或两个以上线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是这些线程都陷入了无限的等待中。\n如何确保 N 个线程可以访问 N 个资源同时又不导致死锁？ 参考答案 使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程\n按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出 现死 锁 了 。\n {width=\u0026ldquo;5.848421916010499in\u0026rdquo; height=\u0026ldquo;9.791119860017497e-3in\u0026rdquo;}更多请关注微信公众号：Java技术栈\n Java 集合类框架的基本接口有哪些？ 参考答案 集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。\nJava 集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java 集合类里面最基本的接口有：\nCollection：代表一组对象，每一个对象都是它的子元素。Set：不包含重复元素的 Collection。\nList：有顺序的 collection，并且可以包含重复元素。Map：可以把键(key)映射到值(value)的对象，键不能重复。\n为什么集合类没有实现 Cloneable 和 Serializable 接口？ 参考答案 克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。\n什么是迭代器(Iterator)？ 参考答案 Iterator 接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的\n迭代方法。迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的\nremove(Object Obj)删除，可以通过迭代器的 remove()方法删除。\nIterator 和 ListIterator 的区别是什么？ 参考答案 下面列出了他们的区别：\nIterator 可用来遍历Set 和 List 集合，但是 ListIterator 只能用来遍历 List。Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。\nListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。\n快速失败(fail-•fast)和安全失败(fail-•safe)的区别是什么？ 参考答案 Iterator 的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util 包下面的所有的集合类都是快速失败的，而 java.util.concurrent 包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException 异常，而安全失败的 迭代器永远不会抛出这样的异常。\nJava 中的 HashMap 的工作原理是什么？ 参考答案  {width=\u0026ldquo;5.848421916010499in\u0026rdquo; height=\u0026ldquo;9.791119860017497e-3in\u0026rdquo;}更多请关注微信公众号：Java技术栈\n Java 中的HashMap 是以键值对(key-•value)的形式存储元素的。HashMap 需要一个 hash 函数，它使用 hashCode()和 equals()方法来向集合/从集合添加和检索元素。当调用 put() 方法的时候，HashMap 会计算 key 的 hash 值，然后把键值对存储在集合中合适的索引上。 如果key 已经存在了，value 会被更新成新值。HashMap 的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。\nhashCode()和 equals()方法的重要性体现在什么地方？ 参考答案 Java 中的HashMap 使用 hashCode()和 equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的 hash 值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。 所以这两个方法的实现对HashMap 的精确性和正确性是至关重要的。\nHashMap 和 Hashtable 有什么区别？ 参考答案 HashMap 和Hashtable 都实现了 Map 接口，因此很多特性非常相似。但是，他们有以下不 同点：\nHashMap 允许键和值是 null，而 Hashtable 不允许键或者值是 null。\nHashtable 是同步的，而 HashMap 不是。因此，HashMap 更适合于单线程环境，而 Hashtable\n适合于多线程环境。\nHashMap 提供了可供应用迭代的键的集合，因此，HashMap 是快速失败的。另一方面，\nHashtable 提供了对键的列举(Enumeration)。一般认为Hashtable 是一个遗留的类。\n数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用 Array 而不是  ArrayList？\n 参考答案 下面列出了 Array 和ArrayList 的不同点：\nArray 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。\nArray 大小是固定的，ArrayList 的大小是动态变化的。\nArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。\n对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数 据类型的时候，这种方式相对比较慢。\nArrayList 和 LinkedList 有什么区别？ 参考答案 ArrayList 和 LinkedList 都实现了 List 接口，他们有以下的不同点：\nArrayList 是基于索引的数据接口，它的底层是数组。它可以以 O(1)时间复杂度对元素进行\n随机访问。与此对应，LinkedList 是以元素列表的形式存储它的数据，每一个元素都和它的 前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是 O(n)。\n相对于 ArrayList，LinkedList 的插入，添加，删除操作速度更快，因为当元素被添加到集合 任意 位 置 的 时 候 ， 不 需 要 像 数 组 那 样 重 新 计 算 大 小 或 者 是 更 新 索 引 。\n {width=\u0026ldquo;5.848421916010499in\u0026rdquo; height=\u0026ldquo;9.791119860017497e-3in\u0026rdquo;}更多请关注微信公众号：Java技术栈\n LinkedList 比ArrayList 更占内存，因为 LinkedList 为每一个节点存储了两个引用，一个指 向前一个元素，一个指向下一个元素。\n也可以参考 ArrayList vs. LinkedList。\nComparable 和 Comparator 接口是干什么的？列出它们的区别。 参考答案 Java 提供了只包含一个 compareTo()方法的 Comparable 接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对 象。Java 提供了包含 compare()和 equals()两个方法的 Comparator 接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和 comparator 相等。只有当输入参数也是一个comparator 并且输入参数和当前 comparator 的排序结果是相同的时候，这个方法才返回 true。\n什么是 Java 优先级队列(Priority Queue)？ 参考答案 PriorityQueue 是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)排序的。在创建的时候，我们可以给它提供一个负责给元素排序的比较器。PriorityQueue 不 允许 null 值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后， PriorityQueue 不是线程安全的，入队和出队的时间复杂度是 O(log(n))。\n你了解大 O 符号(big-O•  参考答案\n notation)么？你能给出不同数据结构的例子么？ 大O 符号描述了当数据结构里面的元素增加的时候，算法的规模或者是性能在最坏的场景下有多么好。\n大O 符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我 们一般使用大 O 符号基于时间，内存和性能来选择最好的实现。大O 符号可以对大量数据 的性能给出一个很好的说明。\n如何权衡是使用无序的数组还是有序的数组？ 参考答案 有序数组最大的好处在于查找的时间复杂度是 O(log n)，而无序数组是 O(n)。有序数组的缺点是插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置。 相反，无序数组的插入时间复杂度是常量 O(1)。\nJava 集合类框架的最佳实践有哪些？ 参考答案 根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的大小是固\n定的，而且能事先知道，我们就应该用Array 而不是 ArrayList。\n有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置 初始 容 量 来 避 免 重 新 计 算 hash 值 或 者 是 扩 容 。\n {width=\u0026ldquo;5.848421916010499in\u0026rdquo; height=\u0026ldquo;9.791119860017497e-3in\u0026rdquo;}更多请关注微信公众号：Java技术栈\n 为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的ClassCastException。\n使用 JDK 提供的不变类(immutable class)作为 Map 的键可以避免为我们自己的类实现\nhashCode()和 equals()方法。编程的时候接口优于实现。\n底层的集合实际上是空的情况下，返回长度是 0 的集合或者是数组，不要返回 null。\nEnumeration 接口和 Iterator 接口的区别有哪些？ 参考答案 Enumeration 速度是 Iterator 的 2 倍，同时占用更少的内存。但是，Iterator 远远比Enumeration安全，因为其他线程不能够修改正在被 iterator 遍历的集合里面的对象。同时， Iterator 允许调用者删除底层集合里面的元素，这对 Enumeration 来说是不可能的。\nHashSet 和 TreeSet 有什么区别？ 参考答案 HashSet 是由一个 hash 表来实现的，因此，它的元素是无序的。add()，remove()，contains() 方法的时间复杂度是 O(1)。\n另一方面，TreeSet 是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，\nremove()，contains()方法的时间复杂度是 O(logn)。\nJava 中垃圾回收有什么目的？什么时候进行垃圾回收？ 参考答案 垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。\nSystem.gc()和 Runtime.gc()会做什么事情？ 参考答案 这两个方法用来提示 JVM 要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于 JVM 的。\nfinalize()方法什么时候被调用？析构函数(finalization)的目的是什么？ 参考答案 垃圾回收器(garbage colector)决定回收某对象时，就会运行该对象的 finalize()方法 但是在Java 中很不幸，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说 filalize() 可能永远不被执行，显然指望它做收尾工作是靠不住的。 那么finalize()究竟是做什么的呢？ 它最主要的用途是回收特殊渠道申请的内存。Java 程序有垃圾回收器，所以一般情况下内\n存问题不用程序员操心。但有一种JNI(Java Native Interface)调用non-•Java 程序（C 或C++）， finalize()的工作就是回收这部分的内存。\n如果对象的引用被置为 null，垃圾收集器是否会立即释放对象占用的内存？ 参考答案 不会，在下一个垃圾回收周期中，这个对象将是可被回收的。\n {width=\u0026ldquo;5.848421916010499in\u0026rdquo; height=\u0026ldquo;9.791119860017497e-3in\u0026rdquo;}更多请关注微信公众号：Java技术栈\n Java 堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)? 参考答案 JVM 的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在 JVM 启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。\n堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。\n串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？ 参考答案 吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。而串行收集器对大多数的小应用(在现代处理器上需要大概 100M 左右的内存)就足够了。\n在 Java 中，对象什么时候可以被垃圾回收？ 参考答案 当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。\nJVM 的永久代中会发生垃圾回收么？ 参考答案 垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC 是非常重要的原因。请参考下 Java8：从永久代 到元数据区\n(注：Java8 中已经移除了永久代，新加了一个叫做元数据区的 native 内存区)\nJava 中的两种异常类型是什么？他们有什么区别？ 参考答案 Java 中有两种异常：受检查的(checked)异常和不受检查的(unchecked)异常。不受检查的异常不需要在方法或者是构造函数上声明，就算方法或者是构造函数的执行可能会抛出这样的异常，并且不受检查的异常可以传播到方法或者是构造函数的外面。相反，受检查的异常必须要用 throws 语句在方法或者是构造函数上声明。这里有 Java 异常处理的一些小建议。\nJava 中 Exception 和 Error 有什么区别？ 参考答案 Exception 和Error 都是Throwable 的子类。Exception 用于用户程序可以捕获的异常情况。\nError 定义了不期望被用户程序捕获的异常。\nthrow 和 throws 有什么区别？ 参考答案  {width=\u0026ldquo;5.848421916010499in\u0026rdquo; height=\u0026ldquo;9.791119860017497e-3in\u0026rdquo;}更多请关注微信公众号：Java技术栈\n throw 关键字用来在程序中明确的抛出异常，相反，throws 语句用来表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。\n异常处理完成以后，Exception 对象会发生什么变化？ 参考答案 Exception 对象会在下一个垃圾回收过程中被回收掉。\nfinally 代码块和 finalize()方法有什么区别？ 参考答案 无论是否抛出异常，finally 代码块都会执行，它主要是用来释放应用占用的资源。finalize() 方法是 Object 类的一个 protected 方法，它是在对象被垃圾回收之前由 Java 虚拟机来调用的。\n什么是 JDBC？ 参考答案 JDBC 是允许用户在不同数据库之间做选择的一个抽象层。JDBC 允许开发者用JAVA 写数据库应用程序，而不需要关心底层特定数据库的细节。\n解释下驱动(Driver)在 JDBC 中的角色。 参考答案 JDBC 驱动提供了特定厂商对JDBC API 接口类的实现，驱动必须要提供 java.sql 包下面这些类的实现：Connection, Statement, PreparedStatement,CallableStatement, ResultSet 和Driver。\nClass.forName()方法有什么作用？ 参考答案 初始化参数指定的类，并且返回此类对应的Class 对象\nPreparedStatement 比 Statement 有什么优势？ 参考答案  {width=\u0026ldquo;5.848421916010499in\u0026rdquo; height=\u0026ldquo;9.791119860017497e-3in\u0026rdquo;}更多请关注微信公众号：Java技术栈\n PreparedStatements 是预编译的，因此，性能会更好。同时，不同的查询参数值，\nPreparedStatement 可以重用。\n什么时候使用 CallableStatement？用来准备 CallableStatement 的方法是什么？ 参考答案 CallableStatement 用来执行存储过程。存储过程是由数据库存储和提供的。存储过程可以接受输入参数，也可以有返回结果。非常鼓励使用存储过程，因为它提供了安全性和模块化。 准备一个CallableStatement 的方法是：\nCallableStament.prepareCall();;\n数据库连接池是什么意思？ 参考答案 像打开关闭数据库连接这种和数据库的交互可能是很费时的，尤其是当客户端数量增加的时 候，会消耗大量的资源，成本是非常高的。可以在应用服务器启动的时候建立很多个数据库连接并维护在一个池中。连接请求由池中的连接提供。在连接使用完毕以后，把连接归还到 池中，以用于满足将来更多的请求。\n什么是 RMI？ 参考答案 Java 远程方法调用(Java RMI)是 Java API 对远程过程调用(RPC)提供的面向对象的等价形式，支持直接传输序列化的 Java 对象和分布式垃圾回收。远程方法调用可以看做是激活远程正在运行的对象上的方法的步骤。RMI 对调用者是位置透明的，因为调用者感觉方法是 执行在本地运行的对象上的。看下RMI 的一些注意事项。\n什么是分布式垃圾回收(DGC)？它是如何工作的？ 参考答案  更多请关注微信公众号：Java技术栈\n {width=\u0026ldquo;5.848421916010499in\u0026rdquo; height=\u0026ldquo;9.791119860017497e-3in\u0026rdquo;}\nDGC 叫做分布式垃圾回收。RMI 使用DGC 来做自动垃圾回收。因为RMI 包含了跨虚拟机的远程对象的引用，垃圾回收是很困难的。DGC 使用引用计数算法来给远程对象提供自动 内存管理。\n什么是分布式垃圾回收(DGC)？它是如何工作的？ 参考答案 DGC 叫做分布式垃圾回收。RMI 使用DGC 来做自动垃圾回收。因为RMI 包含了跨虚拟机的远程对象的引用，垃圾回收是很困难的。DGC 使用引用计数算法来给远程对象提供自动 内存管理。\nRMI 中使用 RMI 安全管理器(RMISecurityManager)的目的是什么？ 参考答案 RMISecurityManager 使用下载好的代码提供可被 RMI 应用程序使用的安全管理器。如果没有设置安全管理器，RMI 的类加载器就不会从远程下载任何的类。\n解释下 Marshalling 和 demarshalling。 参考答案 当应用程序希望把内存对象跨网络传递到另一台主机或者是持久化到存储的时候，就必须要把对象在内存里面的表示转化成合适的格式。这个过程就叫做 Marshalling，反之就是demarshalling。\n解释下 Serialization 和 Deserialization。 参考答案 Java 提供了一种叫做对象序列化的机制，他把对象表示成一连串的字节，里面包含了对象的数据，对象的类型信息，对象内部的数据的类型信息等等。因此，序列化可以看成是为了把对象存储在磁盘上或者是从磁盘上读出来并重建对象而把对象扁平化的一种方式。反序列化是把对象从扁平状态转化成活动对象的相反的步骤。\nServlet\n什么是 Servlet？ 参考答案 Servlet 是用来处理客户端请求并产生动态网页内容的 Java 类。Servlet 主要是用来处理或者是存储 HTML 表单提交的数据，产生动态内容，在无状态的 HTTP 协议下管理状态信息。\n说一下 Servlet 的体系结构。 参考答案 所有的 Servlet 都必须要实现的核心的接口是javax.servlet.Servlet。每一个 Servlet 都必须要直接或者是间接实现这个接口，或者是继承 javax.servlet.GenericServlet 或者javax.servlet.http.HTTPServlet。最后，Servlet 使用多线程可以并行的为多个请求服务。\nGenericServlet 和 HttpServlet 有什么区别？ 参考答案 GenericServlet 是一个通用的协议无关的Servlet，它实现了Servlet 和ServletConfig 接口。 继承自 GenericServlet 的Servlet 应该要覆盖 service()方法。最后，为了开发一个能用在网页上服务于使用HTTP 协议请求的 Servlet，你的 Servlet 必须要继承自HttpServlet。这里有 Servlet 的例子。\n解释下 Servlet 的生命周期。 参考答案 对每一个客户端的请求，Servlet 引擎载入Servlet，调用它的 init()方法，完成Servlet 的初始化。然后，Servlet 对象通过为每一个请求单独调用service()方法来处理所有随后来自客 户端的请求，最后，调用Servlet(译者注：这里应该是 Servlet 而不是 server)的 destroy() 方法把Servlet 删除掉。\ndoGet()方法和 doPost()方法有什么区别？ 参考答案 doGet：GET 方法会把名值对追加在请求的 URL 后面。因为 URL 对字符数目有限制，进而限制了用在客户端请求的参数值的数目。并且请求中的参数值是可见的，因此，敏感信息不 能用这种方式传递。\ndoPOST：POST 方法通过把请求参数值放在请求体中来克服 GET 方法的限制，因此，可以发送的参数的数目是没有限制的。最后，通过 POST 请求传递的敏感信息对外部客户端 是不可见的。\n什么是Web 应用程序？ 参考答案 Web 应用程序是对Web 或者是应用服务器的动态扩展。有两种类型的Web 应用：面向表现的和面向服务的。面向表现的 Web 应用程序会产生包含了很多种标记语言和动态内容的交互的 web 页面作为对请求的响应。而面向服务的Web 应用实现了Web 服务的端点(endpoint)。一般来说，一个 Web 应用可以看成是一组安装在服务器 URL 名称空间的特定 子集下面的Servlet 的集合。\n什么是服务端包含(Server Side Include)？ 参考答案 服务端包含(SSI)是一种简单的解释型服务端脚本语言，大多数时候仅用在Web 上，用\nservlet 标签嵌入进来。SSI 最常用的场景把一个或多个文件包含到Web 服务器的一个Web\n {width=\u0026ldquo;5.848421916010499in\u0026rdquo; height=\u0026ldquo;9.791119860017497e-3in\u0026rdquo;}更多请关注微信公众号：Java技术栈\n 页面中。当浏览器访问Web 页面的时候，Web 服务器会用对应的 servlet 产生的文本来替换Web 页面中的 servlet 标签。\n什么是 Servlet 链(Servlet Chaining)？ 参考答案 Servlet 链是把一个Servlet 的输出发送给另一个Servlet 的方法。第二个 Servlet 的输出可以发送给第三个 Servlet，依次类推。链条上最后一个 Servlet 负责把响应发送给客户端。\n如何知道是哪一个客户端的机器正在请求你的 Servlet？ 参考答案 ServletRequest 类可以找出客户端机器的 IP 地址或者是主机名。getRemoteAddr()方法获取客户端主机的 IP 地址，getRemoteHost()可以获取主机名。看下这里的例子。\nHTTP 响应的结构是怎么样的？ 参考答案 HTTP 响应由三个部分组成：\n状态码(Status Code)：描述了响应的状态。可以用来检查是否成功的完成了请求。请求失败的情况下，状态码可用来找出失败的原因。如果Servlet 没有返回状态码，默认会返回成功的状态码HttpServletResponse.SC_OK。\nHTTP 头部(HTTP Header)：它们包含了更多关于响应的信息。比如：头部可以指定认为响应过期的过期日期，或者是指定用来给用户安全的传输实体内容的编码格式。如何在 Serlet 中检索HTTP 的头部看这里。\n主体(Body)：它包含了响应的内容。它可以包含 HTML 代码，图片，等等。主体是由传输在HTTP 消息中紧跟在头部后面的数据字节组成的。\n什么是 cookie？session 和 cookie 有什么区别？ 参考答案 cookie 是Web 服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个Web 服务器存储 cookie。以后浏览器在给特定的 Web 服务器发请求的时候，同时会发送所有为该服务器存储的 cookie。下面列出了 session 和 cookie 的区别：\n无论客户端浏览器做怎么样的设置，session 都应该能正常工作。客户端可以选择禁用cookie， 但是，session 仍然是能够工作的，因为客户端无法禁用服务端的 session。\n在存储的数据量方面session 和cookies 也是不一样的。session 能够存储任意的Java 对象，\ncookie 只能存储String 类型的对象。\n浏览器和 Servlet 通信使用的是什么协议？ 参考答案 浏览器和Servlet 通信使用的是HTTP 协议。\n什么是 HTTP 隧道？ 参考答案  {width=\u0026ldquo;5.848421916010499in\u0026rdquo; height=\u0026ldquo;9.791119860017497e-3in\u0026rdquo;}更多请关注微信公众号：Java技术栈\n HTTP 隧道是一种利用 HTTP 或者是HTTPS 把多种网络协议封装起来进行通信的技术。因此，HTTP 协议扮演了一个打通用于通信的网络协议的管道的包装器的角色。把其他协议的请求掩盖成HTTP 的请求就是HTTP 隧道。\nsendRedirect()和 forward()方法有什么区别？ 参考答案 sendRedirect()方法会创建一个新的请求，而 forward()方法只是把请求转发到一个新的目标上。重定向(redirect)以后，之前请求作用域范围以内的对象就失效了，因为会产生一个新的请求，而转发(forwarding)以后，之前请求作用域范围以内的对象还是能访问的。一般认为sendRedirect()比 forward()要慢。\n什么是 URL 编码和 URL 解码？ 参考答案 URL 编码是负责把 URL 里面的空格和其他的特殊字符替换成对应的十六进制表示，反之就是解码。\nJSP 请求是如何被处理的？ 参考答案 浏览器首先要请求一个以.jsp 扩展名结尾的页面，发起 JSP 请求，然后，Web 服务器读取这个请求，使用 JSP 编译器把 JSP 页面转化成一个Servlet 类。需要注意的是，只有当第 一次请求页面或者是 JSP 文件发生改变的时候 JSP 文件才会被编译，然后服务器调用servlet 类，处理浏览器的请求。一旦请求执行结束，servlet 会把响应发送给客户端。这里 看下如何在 JSP 中获取请求参数。\n什么是 JSP 指令(Directive)？JSP 中有哪些不同类型的指令？ 参考答案  {width=\u0026ldquo;5.848421916010499in\u0026rdquo; height=\u0026ldquo;9.791119860017497e-3in\u0026rdquo;}更多请关注微信公众号：Java技术栈\n Directive 是当 JSP 页面被编译成 Servlet 的时候，JSP 引擎要处理的指令。Directive 用来设置页面级别的指令，从外部文件插入数据，指定自定义的标签库。Directive 是定义在 \u0026lt;%@ 和 %\u0026gt;之间的。下面列出了不同类型的 Directive：\n包含指令(Include directive)：用来包含文件和合并文件内容到当前的页面。\n页面指令(Page directive)：用来定义 JSP 页面中特定的属性，比如错误页面和缓冲区。\nTaglib 指令： 用来声明页面中使用的自定义的标签库。\n什么是 JSP 动作(JSP action)？ 参考答案 JSP 动作以 XML 语法的结构来控制Servlet 引擎的行为。当 JSP 页面被请求的时候，JSP 动作会被执行。它们可以被动态的插入到文件中，重用 JavaBean 组件，转发用户到其他的 页面，或者是给 Java 插件产生HTML 代码。下面列出了可用的动作：\njsp:include-•当 JSP 页面被请求的时候包含一个文件。\njsp:useBean-找• 出或者是初始化 Javabean。\njsp:setProperty-•设置 JavaBean 的属性。jsp:getProperty-•获取 JavaBean 的属性。jsp:forward-•把请求转发到新的页面。jsp:plugin-•产生特定浏览器的代码。\n什么是表达式(Expression)？ 参考答案 【列表很长，可以分上、中、下发布】\nJSP 表达式是 Web 服务器把脚本语言表达式的值转化成一个 String 对象，插入到返回给客户端的数据流中。表达式是在\u0026lt;%=和%\u0026gt;这两个标签之间定义的。\n隐含对象是什么意思？有哪些隐含对象？ 参考答案 JSP 隐含对象是页面中的一些 Java 对象，JSP 容器让这些 Java 对象可以为开发者所使用。开发者不用明确的声明就可以直接使用他们。JSP 隐含对象也叫做预定义变量。下面列出 了JSP 页面中的隐含对象：\napplication page\n {width=\u0026ldquo;5.848421916010499in\u0026rdquo; height=\u0026ldquo;9.791119860017497e-3in\u0026rdquo;}更多请关注微信公众号：Java技术栈\n request response session exception out config\npageContext\n面向对象软件开发的优点有哪些？ 参考答案 代码开发模块化，更易维护和修改。代码复用。\n增强代码的可靠性和灵活性。增加代码的可理解性。\n面向对象编程有很多重要的特性，比如：封装，继承，多态和抽象。下面的章节我们会逐个 分析这些特性。\n封装的定义和好处有哪些？ 参考答案 封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在 Java 当中，有 3 种修饰符：public，private 和 protected。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。\n下面列出了使用封装的一些好处：\n通过隐藏对象的属性来保护对象内部的状态。\n提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。禁止对象之间的不良交互提高模块化。\n参考这个文档获取更多关于封装的细节和示例。\n多态的定义？ 参考答案 多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。\n继承的定义？ 参考答案 继承给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。\n抽象的定义？抽象和封装的不同点？ 参考答案 抽象是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。Java 支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目\n {width=\u0026ldquo;5.848421916010499in\u0026rdquo; height=\u0026ldquo;9.791119860017497e-3in\u0026rdquo;}更多请关注微信公众号：Java技术栈\n 的是把类的行为和实现细节分离开。\n抽象和封装是互补的概念。一方面，抽象关注对象的行为。另一方面，封装关注对象行为的细节。一般是通过隐藏对象内部状态信息做到封装，因此，封装可以看成是用来提供抽象的 一种策略。\n 更多请关注微信公众号：Java技术栈\n {width=\u0026ldquo;2.5416666666666665in\u0026rdquo; height=\u0026ldquo;2.6875in\u0026rdquo;}\n","pubDate":"2021-02-15","title":"Java试题经典7"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_tool_js_console.log%E7%94%A8%E6%B3%95/","plain":"Console 对象方法   常用 Console 调试命令\n  console.log('hello');\rconsole.info('信息');\rconsole.error('错误');\rconsole.warn('警告');\rassert()  ssert方法接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。  // 实例\rconsole.assert(true === false, \u0026quot;判断条件不成立\u0026quot;)\r// Assertion failed: 判断条件不成立\rclear()  清除当前控制台的所有输出，将光标回置到第一行。  console.clear()\rcount()  用于计数，输出它被调用了多少次。  (function() {\rfor (var i = 0; i \u0026lt; 5; i++) { console.count('count'); }\r})()\rerror()  输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈。  console.error(\u0026quot;Error: %s (%i)\u0026quot;, \u0026quot;Server is not responding\u0026quot;,500)\rgroup()  用于将显示的信息分组，可以把信息进行折叠和展开。  console.group('第一层');\rconsole.group('第二层');\rconsole.log('error');\rconsole.error('error');\rconsole.warn('error');\rconsole.groupEnd(); console.groupEnd();\rinfo()  console.log 别名，输出信息  console.info(\u0026quot;runoob\u0026quot;)\rlog()  输出信息  console.log(\u0026quot;runoob\u0026quot;)\rtable()  将复合类型的数据转为表格显示。  var arr= [ { num: \u0026quot;1\u0026quot;},\r{ num: \u0026quot;2\u0026quot;}, { num: \u0026quot;3\u0026quot; }\r];\rconsole.table(arr);\rvar obj= {\ra:{ num: \u0026quot;1\u0026quot;},\rb:{ num: \u0026quot;2\u0026quot;},\rc:{ num: \u0026quot;3\u0026quot; }\r};\rconsole.table(obj);\rtime() ++ 计时开始\nconsole.time('计时器1');\rfor (var i = 0; i \u0026lt; 100; i++) {\rfor (var j = 0; j \u0026lt; 100; j++) {}\r}\rconsole.timeEnd('计时器1');\rconsole.time('计时器2');\rfor (var i = 0; i \u0026lt; 1000; i++) {\rfor (var j = 0; j \u0026lt; 1000; j++) {}\r}\rconsole.timeEnd('计时器2');\rtimeEnd()  计时结束  console.time('计时器1');\rfor (var i = 0; i \u0026lt; 100; i++) {\rfor (var j = 0; j \u0026lt; 100; j++) {}\r}\rconsole.timeEnd('计时器1');\rconsole.time('计时器2');\rfor (var i = 0; i \u0026lt; 1000; i++) {\rfor (var j = 0; j \u0026lt; 1000; j++) {}\r}\rconsole.timeEnd('计时器2');\rwarn()  输出警告信息  console.warn(\u0026quot;警告\u0026quot;)\r 最常用的就是 console.log 了。 console上述的集中度支持printf的占位符格式，支持的占位符有：字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）:   占位符\t作用\r%s\t字符串\r%d or %i\t整数\r%f\t浮点数\r%o\t可展开的DOM\r%O\t列出DOM的属性\r%c\t根据提供的css样式格式化字符串\r实例:\rconsole.log(\u0026quot;%d年%d月%d日\u0026quot;,2011,3,26);\r","pubDate":"2021-02-15","title":"js \u003e console.log用法"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_tool_jsoup/","plain":"jsoup学习文档 简介  Jsoup是用于解析HTML，就类似XML解析器用于解析XML。 Jsoup它解析HTML成为真实世界的HTML。 它与jquery选择器的语法非常相似，并且非常灵活容易使用以获得所需的结果\n +jsoup api 6个包提供用于开发jsoup应用程序的类和接口。\norg.jsoup\rorg.jsoup.examples\rorg.jsoup.helper\rorg.jsoup.nodes\rorg.jsoup.parser\rorg.jsoup.safety\rorg.jsoup.salect\r引入 //大多数情况使用jsoup\rorg.jsoup.nodes.Document document = Jsoup.parse(html);\rDocument doc = Jsoup.parse(new URL(\u0026quot;http://www.funi.com/\u0026quot;),7000);\r//少数情况使用httpUnit\rWebClient webClient = new WebClient() ;\rHtmlPage htmlPage = webClient.getPage(\u0026quot;http://www.89ip.cn/\u0026quot;);\rhtmlPage.asXml()//html\r使用(maven) \u0026lt;dependency\u0026gt;\r\u0026lt;!-- jsoup HTML parser library @ http://jsoup.org/ --\u0026gt;\r\u0026lt;groupId\u0026gt;org.jsoup\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;jsoup\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.10.2\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;!-- httpclient --\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.apache.httpcomponents\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;httpclient\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;4.5.6\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;net.sourceforge.htmlunit\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;htmlunit\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;2.26\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r解析一个body片断  假如你有一个HTML片断 (比如. 一个 div 包含一对 p 标签; 一个不完整的HTML文档) 想对它进行解析。这个HTML片断可以是用户提交的一条评论或在一个CMS页面中编辑body部分。\n 办法:使用Jsoup.parseBodyFragment(String html) ,Document.body() 方法能够取得文档body元素的所有子元素，与 doc.getElementsByTag(\u0026ldquo;body\u0026rdquo;)相同\nString html = \u0026quot;\u0026lt;div\u0026gt;\u0026lt;p\u0026gt;Lorem ipsum.\u0026lt;/p\u0026gt;\u0026quot;;\rDocument doc = Jsoup.parseBodyFragment(html);\rSystem.out.println(doc.html());//可以看到我们的html片段被包裹了一个body\rElement body = doc.body();\rSystem.out.println(body.html());\r/*\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt;Lorem ipsum.\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r*/\r/**\r\u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt;Lorem ipsum.\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r*/\r从一个URL加载一个Document  你需要从一个网站获取和解析一个HTML文档，并查找其中的相关数据。你可以使用下面解决方法\n 办法:使用 Jsoup.connect(String url)方法\nDocument doc = Jsoup.parse(new URL(\u0026quot;http://www.funi.com/\u0026quot;),6000) ;\rDocument doc2 = Jsoup.connect(\u0026quot;http://www.funi.com/\u0026quot;)\r// .data(\u0026quot;query\u0026quot;, \u0026quot;Java\u0026quot;)\r.userAgent(\u0026quot;Mozilla\u0026quot;)\r.cookie(\u0026quot;auth\u0026quot;, \u0026quot;token\u0026quot;)\r.timeout(3000)\r.get();\r从一个文件加载一个文档  在本机硬盘上有一个HTML文件，需要对它进行解析从中抽取数据或进行修改\n 办法:可以使用静态 Jsoup.parse(File in, String charsetName, String baseUri)方法\nFile input = new File(\u0026quot;/tmp/input.html\u0026quot;);\rDocument doc = Jsoup.parse(input, \u0026quot;UTF-8\u0026quot;, \u0026quot;http://example.com/\u0026quot;);\r下面例子都使用成都市房产透明网的网站和国家统计局\n使用DOM方法来遍历一个文档  你有一个HTML文档要从中提取数据，并了解这个HTML文档的结构。\n Document doc = null;\rCloseableHttpClient httpClient = HttpClients.createDefault();\rHttpGet httpGet = new HttpGet(\u0026quot;http://www.funi.com/\u0026quot;);\r//使用chrome 头伪装\rhttpGet.setHeader(\u0026quot;User-Agent\u0026quot;, \u0026quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36\u0026quot;);\r//设置基本的配置\rRequestConfig config = RequestConfig.custom()\r.setConnectTimeout(5000) // 设置连接超时时间 5秒钟\r.setSocketTimeout(4000) // 设置读取超时时间4秒钟\r.build();\rhttpGet.setConfig(config);\rCloseableHttpResponse httpResponse = null;\rtry {\rhttpResponse = httpClient.execute(httpGet);\rHttpEntity httpEntity = httpResponse.getEntity();\rif (httpEntity == null){\rreturn;\r}\rString html = EntityUtils.toString(httpEntity, \u0026quot;utf-8\u0026quot;);\rif (StringUtils.isNotEmpty(html)) {\rdoc = Jsoup.parse(html);\r}\r} catch (Exception e) {\rlogger.error(\u0026quot;获取html失败!\u0026quot;, e);\r} finally {\r//关闭处理\rhttpResponse.close();\rhttpClient.close();\r}\rElement body = doc.body();\rElements foot = body.getElementsByClass(\u0026quot;foot\u0026quot;).first().getElementsByClass(\u0026quot;footer clearfix\u0026quot;).first().getElementsByTag(\u0026quot;dl\u0026quot;);\rfor (Element ele : foot) {\rSystem.out.println(ele.html());\rfor (int i = 0; i \u0026lt; 20; i++) {\rSystem.out.print('.');\r}\r}\r使用选择器语法来查找元素  你想使用类似于CSS或jQuery的语法来查找和操作元素\n Element 查看元素\n getElementById(String id) return Element getElementsByTag(String tag) return Elements getElementsByClass(String className) return Elements getElementsByAttribute(String key) return Elements 查找具有命名属性集的元素。不区分大小写 siblingElements() return Elements 获取同级元素。如果元素没有同级元素，则返回空列表。元素不是同级元素本身，所以不会包含在返回的列表中(列表) firstElementSibling() return Element 获取此元素的第一个同级元素 lastElementSibling() return Element 获取此元素的最后一个同级元素 previousElementSibling() return Element 获取此元素的上一个同级元素 nextElementSibling() return Element 获取此元素的下一个同级元素 parents() return Elements 获取此元素的父级和父级，直到文档根 parent() return Element 获取此元素的父级 children() return Elements 获取此元素的子元素 child(int index) return Element 获取此元素的子元素，方法是使用其基于0的索引号 attributes() 获取元素的所有属性 return Attributes  元素数据\n attr(String key)获取属性attr(String key, String value)设置属性 attributes()获取所有属性 id(), className() and classNames() text()获取文本内容text(String value) 设置文本内容 html()获取元素内HTMLhtml(String value)设置元素内的HTML内容 outerHtml()获取元素外HTML内容 data()获取数据内容（例如：script和style标签) tag() and tagName()  操作HTML和文本\n append(String html), prepend(String html) appendText(String text), prependText(String text) appendElement(String tagName), prependElement(String tagName) html(String value)  选择器语法来查找元素  tagname: 通过标签查找元素，比如：a #id: 通过ID查找元素，比如：#logo .class: 通过class名称查找元素，比如：.masthead  Document doc = null;\rCloseableHttpClient httpClient = HttpClients.createDefault();\rHttpGet httpGet = new HttpGet(\u0026quot;http://www.stats.gov.cn/\u0026quot;);\r//使用chrome 头伪装\rhttpGet.setHeader(\u0026quot;User-Agent\u0026quot;, \u0026quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36\u0026quot;);\r//设置基本的配置\rRequestConfig config = RequestConfig.custom()\r.setConnectTimeout(5000) // 设置连接超时时间 5秒钟\r.setSocketTimeout(4000) // 设置读取超时时间4秒钟\r.build();\rhttpGet.setConfig(config);\rCloseableHttpResponse httpResponse = null;\rtry {\rhttpResponse = httpClient.execute(httpGet);\rHttpEntity httpEntity = httpResponse.getEntity();\rString html = EntityUtils.toString(httpEntity, \u0026quot;utf-8\u0026quot;);\rif (StringUtils.isNotEmpty(html)) {\rdoc = Jsoup.parse(html);\r}\r} catch (Exception e) {\rlogger.error(\u0026quot;获取html失败!\u0026quot;, e);\r} finally {\r// 关闭处理\rhttpResponse.close();\rhttpClient.close();\r}\rElement body = doc.body();\r// Elements selects = body.select(\u0026quot;.top .top03 #nav ul li\u0026quot;);//和下面的一样\rElements selects = body.getElementsByClass(\u0026quot;top\u0026quot;).first().getElementsByClass(\u0026quot;top03\u0026quot;).first().getElementById(\u0026quot;nav\u0026quot;).getElementsByTag(\u0026quot;ul\u0026quot;).first().getElementsByTag(\u0026quot;li\u0026quot;);\rfor (Element ele : selects) {\rSystem.out.println(ele);\r}\r主要运用了上面三种选择方式\r 【attribute】: 利用属性查找元素，比如：【href】 【^attr】: 利用属性名前缀来查找元素，比如：可以用【^data-】 来查找带有HTML5 Dataset属性的元素 【attr=value】: 利用属性值来查找元素，比如：【width=500】 【attr^=value】, 【attr$=value】, 【attr*=value】: 利用匹配属性值开头、结尾或包含属性值来查找元素，比如：【href*=/path/】 【attr~=regex】: 利用属性值匹配正则表达式来查找元素，比如： img【src~=(?i).(png|jpe?g)】 *: 这个符号将匹配所有元素  Element body = doc.body();\rElements selects = body.select(\u0026quot;.top a[href]\u0026quot;);//获取拥有href属性的所有元素\r\u0026lt;a href=\u0026quot;/was5/web/search?channelid=288041\u0026amp;amp;andsen=%E6%80%BB%E4%BA%BA%E5%8F%A3\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;总人口\u0026lt;/a\u0026gt;\r\u0026lt;a href=\u0026quot;/was5/web/search?channelid=288041\u0026amp;amp;andsen=%E7%A4%BE%E4%BC%9A%E6%B6%88%E8%B4%B9%E5%93%81%E9%9B%B6%E5%94%AE%E6%80%BB%E9%A2%9D\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;社会消费品零售总额\u0026lt;/a\u0026gt;\r\u0026lt;a href=\u0026quot;./zjtj/\u0026quot; target=\u0026quot;_top\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;./images/top03_1.png\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\r\u0026lt;a name=\u0026quot;PL_MENU_NAME\u0026quot; href=\u0026quot;./zjtj/gjtjj/\u0026quot; target=\u0026quot;_top\u0026quot;\u0026gt;国家统计局\u0026lt;/a\u0026gt;\r\u0026lt;a name=\u0026quot;PL_MENU_NAME\u0026quot; href=\u0026quot;http://jcj.ndrc.gov.cn/\u0026quot; target=\u0026quot;_top\u0026quot;\u0026gt;派驻纪检组\u0026lt;/a\u0026gt;\r\u0026lt;a name=\u0026quot;PL_MENU_NAME\u0026quot; href=\u0026quot;./zjtj/jgzn/\u0026quot; target=\u0026quot;_top\u0026quot;\u0026gt;机构职能\u0026lt;/a\u0026gt;\rElements selects = body.select(\u0026quot;.top a[name=PL_MENU_NAME]\u0026quot;);//获取name=PL_MENU_NAME的所有这类元素\r\u0026lt;a name=\u0026quot;PL_MENU_NAME\u0026quot; href=\u0026quot;./zjtj/gjtjj/\u0026quot; target=\u0026quot;_top\u0026quot;\u0026gt;国家统计局\u0026lt;/a\u0026gt;\r\u0026lt;a name=\u0026quot;PL_MENU_NAME\u0026quot; href=\u0026quot;http://jcj.ndrc.gov.cn/\u0026quot; target=\u0026quot;_top\u0026quot;\u0026gt;派驻纪检组\u0026lt;/a\u0026gt;\r\u0026lt;a name=\u0026quot;PL_MENU_NAME\u0026quot; href=\u0026quot;./zjtj/jgzn/\u0026quot; target=\u0026quot;_top\u0026quot;\u0026gt;机构职能\u0026lt;/a\u0026gt;\r\u0026lt;a name=\u0026quot;PL_MENU_NAME\u0026quot; href=\u0026quot;./tjsj/zxfb/\u0026quot; target=\u0026quot;_top\u0026quot;\u0026gt;最新发布\u0026lt;/a\u0026gt;\r\u0026lt;a name=\u0026quot;PL_MENU_NAME\u0026quot; href=\u0026quot;http://data.stats.gov.cn/\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;数据查询\u0026lt;/a\u0026gt;\r\u0026lt;a name=\u0026quot;PL_MENU_NAME\u0026quot; href=\u0026quot;./tjsj/sjjd/\u0026quot; target=\u0026quot;_top\u0026quot;\u0026gt;数据解读\u0026lt;/a\u0026gt;\r\u0026lt;a name=\u0026quot;PL_MENU_NAME\u0026quot; href=\u0026quot;./tjgz/tjdt/\u0026quot; target=\u0026quot;_top\u0026quot;\u0026gt;统计动态\u0026lt;/a\u0026gt;\rElements selects = body.select(\u0026quot;.top a[name^=PL]\u0026quot;);//以PL开头\rElements selects = body.select(\u0026quot;.top div[^cl]\u0026quot;); //获取div 为tag class等属性的元素\r 伪选择器selectors :lt(n): 查找哪些元素的同级索引值（它的位置在DOM树中是相对于它的父节点）小于n，比如：td:lt(3) 表示小于三列的元素 :gt(n):查找哪些元素的同级索引值大于n，比如： div p:gt(2)表示哪些div中有包含2个以上的p元素 :eq(n): 查找哪些元素的同级索引值与n相等，比如：form input:eq(1)表示包含一个input标签的Form元素 :has(seletor): 查找匹配选择器包含元素的元素，比如：div:has(p)表示哪些div包含了p元素  Elements selects = body.select(\u0026quot;.center div:eq(0) ul li:lt(3)\u0026quot;); //eq(0)选取第一个,lt(3)表示小于三列的元素\r  Selector选择器组合使用\n  el#id: 元素+ID，比如： div#logo\n  el.class: 元素+class，比如： div.masthead\n  el[attr]: 元素+class，比如： a[href]\n  任意组合，比如：a[href].highlight\n  ancestor child: 查找某个元素下子元素，比如：可以用.body p 查找在\u0026quot;body\u0026quot;元素下的所有 p元素\n  parent \u0026gt; child: 查找某个父元素下的直接子元素，比如：可以用div.content \u0026gt; p 查找 p 元素，也可以用body \u0026gt; * 查找body标签下所有直接子元素\n  siblingA + siblingB: 查找在A元素之前第一个同级元素B，比如：div.head + div\n  siblingA ~ siblingX: 查找A元素之前的同级X元素，比如：h1 ~ p\n  el, el, el:多个选择器组合，查找匹配任一选择器的唯一元素，例如：div.masthead, div.logo\n  伪选择器selectors\n  :lt(n): 查找哪些元素的同级索引值（它的位置在DOM树中是相对于它的父节点）小于n，比如：td:lt(3) 表示小于三列的元素\n  :gt(n):查找哪些元素的同级索引值大于n，比如： div p:gt(2)表示哪些div中有包含2个以上的p元素\n  :eq(n): 查找哪些元素的同级索引值与n相等，比如：form input:eq(1)表示包含一个input标签的Form元素\n  :has(seletor): 查找匹配选择器包含元素的元素，比如：div:has(p)表示哪些div包含了p元素\n  :not(selector): 查找与选择器不匹配的元素，比如： div:not(.logo) 表示不包含 class=\u0026ldquo;logo\u0026rdquo; 元素的所有 div 列表\n  :contains(text): 查找包含给定文本的元素，搜索不区分大不写，比如： p:contains(jsoup)\n  :containsOwn(text): 查找直接包含给定文本的元素\n  :matches(regex): 查找哪些元素的文本匹配指定的正则表达式，比如：div:matches((?i)login)\n  :matchesOwn(regex): 查找自身包含文本匹配指定正则表达式的元素\n  注意：上述伪选择器索引是从0开始的，也就是说第一个元素索引值为0，第二个元素index为1等\n  ","pubDate":"2021-02-15","title":"jsoup"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_el%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B_jsp_el%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/","plain":"EL基础教程 El标签语法  ${参数名}\n EL标签的功能   可以访问JSP中不同的域的对象    可以访问JavaBean中的属性    可以访问集合元素    支持简单的运算操作   访问JSP中不同的域的对象 \u0026lt;%\rpageContext.setAttribute(\u0026quot;name1\u0026quot;, \u0026quot;zhangsan\u0026quot;);\rrequest.setAttribute(\u0026quot;name2\u0026quot;, \u0026quot;lisi\u0026quot;);\rsession.setAttribute(\u0026quot;name3\u0026quot;, \u0026quot;wangwu\u0026quot;);\rapplication.setAttribute(\u0026quot;name4\u0026quot;, \u0026quot;liuliu\u0026quot;);\r%\u0026gt;\r\u0026lt;!--范围.参数名 --\u0026gt;\r${pageScope.name1 } ${requestScope.name2 } ${sessionScope.name3 }\r${applicationScope.name4 }\r\u0026lt;br\u0026gt;\r\u0026lt;!-- 直接写参数名称 --\u0026gt;\r${name1 } ${name2 } ${name3 } ${name4 }\r 访问JavaBean中的属性 \u0026lt;%\rUser user=new User(\u0026quot;zhangsan\u0026quot;,20,\u0026quot;北京\u0026quot;);\rrequest.setAttribute(\u0026quot;user\u0026quot;, user);\r%\u0026gt;\ruser name:${user.name }\u0026lt;br\u0026gt; user age:${user.age }\u0026lt;br\u0026gt; user address:${user.address }\r 访问集合元素 \u0026lt;%\r//数组\rint[] array=new int[]{1,2,3};\r//列表\rList list=new ArrayList();\rlist.add(\u0026quot;list1\u0026quot;);\rlist.add(20);\rlist.add(true);\rpageContext.setAttribute(\u0026quot;array\u0026quot;, array);\rpageContext.setAttribute(\u0026quot;list\u0026quot;, list);\r%\u0026gt;\r数组:${array[0] },${array[1] },${array[2] }\u0026lt;br\u0026gt; List列表:${list }\u0026lt;br\u0026gt;\r 简单的运算操作 算术运算符:\n2+3=${2+3 }\r2-3=${2-3 }\r2*3=${2*3 }\r2/3=${2/3 }\r 逻辑运算符:\ntrue\u0026amp;\u0026amp;false=${true\u0026amp;\u0026amp;false }\ttrue||false=${true||false }\t!true=${!true }\t 关系运算符:\n2==5 ${2==5 }\r2!=5 ${2!=5 }\r2\u0026gt;5 ${2\u0026gt;5 }\r2\u0026lt;5 ${2\u0026lt;5 }\r2\u0026gt;=5 ${2\u0026gt;=5 }\r2\u0026lt;=5 ${2\u0026lt;=5 }\r 其他运算符:\n\u0026lt;%\rUser user=new User();\rUser user1=new User(\u0026quot;zhangsan\u0026quot;,20,\u0026quot;北京\u0026quot;);\rString arr=new String();\rString[] arr1=new String[]{\u0026quot;one\u0026quot;,\u0026quot;two\u0026quot;};\tpageContext.setAttribute(\u0026quot;user\u0026quot;, user);\rpageContext.setAttribute(\u0026quot;user1\u0026quot;, user1);\rpageContext.setAttribute(\u0026quot;arr\u0026quot;, arr);\tpageContext.setAttribute(\u0026quot;arr1\u0026quot;, arr1);\r%\u0026gt;\ruser 是否为空:${empty user }\rarr 是否为空:${empty arr }\ruser1 是否为空:${empty user1 }\rarr1 是否为空:${empty arr1 }\r三元目运算符2\u0026lt;5?yes:no:${2\u0026lt;5?\u0026quot;yes\u0026quot;:\u0026quot;no\u0026quot; }\ruser1.address:${user1.address }\rarr1[1]:${arr1[1] }\r EL标签的隐形变量   page \u0026lt;==============================\u0026gt; pageScope    request \u0026lt;============================\u0026gt; requestScope    session \u0026lt;============================\u0026gt; sessionScope    application \u0026lt;=========================\u0026gt; applicationScope    request.getParameter(String name) \u0026lt;=======\u0026gt; param   A.jsp\n\u0026lt;form action=\u0026quot;B.jsp\u0026quot; method=\u0026quot;get\u0026quot;\u0026gt;\r\u0026lt;input name=\u0026quot;name\u0026quot;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot;\u0026gt;\r\u0026lt;/form\u0026gt;\r B.jsp\n${param.name }\r  request.getParameterValues(String name) \u0026lt;==\u0026gt; paramValues   A.jsp\n\u0026lt;form action=\u0026quot;B.jsp\u0026quot; method=\u0026quot;get\u0026quot;\u0026gt;\r\u0026lt;input name=\u0026quot;name\u0026quot;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input name=\u0026quot;name\u0026quot;\u0026gt;\u0026lt;br\u0026gt;\r\u0026lt;input type=\u0026quot;submit\u0026quot;\u0026gt;\r\u0026lt;/form\u0026gt;\r B.jsp\n${paramValues.name[0] },${paramValues.name[1] }\r  request.getHeader(String name) \u0026lt;=========\u0026gt; header    request.getHeaderNames() \u0026lt;=============\u0026gt; headerValues    所有请求cookie \u0026lt;=====================\u0026gt; cookie    application.getInitParameter(String name) \u0026lt;==\u0026gt; initParam    pageContext   ${pageContext.request.queryString}\u0026lt;!-- 获取请求名参数 --\u0026gt;\r${pageContext.request.requestURL}\u0026lt;!-- 获取请求的URL --\u0026gt;\r${pageContext.request.contextPath }\u0026lt;!-- 获取服务应用的名称 --\u0026gt;\r${pageContext.request.method }\u0026lt;!-- 获取http提交方法 --\u0026gt;\r${pageContext.request.protocol }\u0026lt;!-- 获取使用的协议 --\u0026gt;\r${pageContext.request.remoteUser }\u0026lt;!-- 获取登录用户名 --\u0026gt;\r${pageContext.request.remoteAddr }\u0026lt;!-- 获取登录用户IP地址 --\u0026gt;\r${pageContext.session.id }\u0026lt;!-- 获取session的ID --\u0026gt;\r${pageContext.servletContext.serverInfo }\u0026lt;!-- 获取主机端的服务信息 --\u0026gt;\r ","pubDate":"2021-02-15","title":"jsp \u003e EL基础教程"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_jstl%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B_jsp_jstl_core%E6%A0%87%E7%AD%BE%E5%BA%93/","plain":"﻿# JSTL标签库\nJSTL主要有五大类标签库\n core标签库(核心标签库),包括通用标签(输出标签),流程控制和循环控制标签 fmt标签库,包括格式化,国际格式化标签等 fn标签库,函数标签库 XML标签库,关于XML操作的标签库 SQL标签库,操作数据库标签  core标签库用法 使用core标签前必须添加taglie指令\n %@ taglib prefix=\u0026ldquo;c\u0026rdquo; uri=\u0026ldquo;http://java.sun.com/jsp/jstl/core\u0026quot; %\u0026gt;\n  \u0026lt;c:set\u0026gt;在某个范围设定某个值   \u0026lt;c:set value=\u0026ldquo;表达式\u0026rdquo; var=\u0026ldquo;varname\u0026rdquo; [scope=\u0026ldquo;request|page|session|application\u0026rdquo;]\u0026gt;\u0026lt;/c:set\u0026gt;\n \u0026lt;c:set value=\u0026quot;${1+2 }\u0026quot; var=\u0026quot;variable\u0026quot;\u0026gt;\u0026lt;/c:set\u0026gt;\r${variable }\r \u0026lt;c:out\u0026gt;把表达式的结构输出到页面中   \u0026lt;c:out value=\u0026ldquo;表达式\u0026rdquo; [escapeXml=\u0026ldquo;true|false\u0026rdquo;]\u0026gt;\u0026lt;/c:out\u0026gt;\n \u0026lt;c:set value=\u0026quot;${1+2 }\u0026quot; var=\u0026quot;variable\u0026quot;\u0026gt;\u0026lt;/c:set\u0026gt;\r\u0026lt;c:out value=\u0026quot;${variable }\u0026quot;\u0026gt;\u0026lt;/c:out\u0026gt;\r \u0026lt;c:if\u0026gt;条件判断   \u0026lt;c:if test=\u0026ldquo;判断条件\u0026rdquo; [var=\u0026ldquo;varname\u0026rdquo;] [scope=\u0026ldquo;request|page|session|application\u0026rdquo;]\u0026gt; 条件为真执行的语句 \u0026lt;/c:if\u0026gt;\n \u0026lt;c:if test=\u0026quot;${1\u0026lt;2 }\u0026quot; var=\u0026quot;result\u0026quot;\u0026gt;\r\u0026lt;c:out value=\u0026quot;${result }\u0026quot;\u0026gt;\u0026lt;/c:out\u0026gt;\r\u0026lt;/c:if\u0026gt;\r \u0026lt;c:choose\u0026gt;,\u0026lt;c:when\u0026gt;,\u0026lt;c:otherwise\u0026gt;流程控制标签   \u0026lt;c:choose\u0026gt; \u0026lt;c:when test=\u0026ldquo;表达式\u0026rdquo;\u0026gt; 表达式为真执行的语句 \u0026lt;/c:when\u0026gt; [\u0026lt;c:otherwise\u0026gt; 表达式为假执行的语句 \u0026lt;/c:otherwise\u0026gt;] \u0026lt;/c:choose\u0026gt;\n  \u0026lt;c:when\u0026gt;必须在\u0026lt;c:otherwise\u0026gt;前边,\u0026lt;c:choose\u0026gt;可以添加多个\u0026lt;c:choose\u0026gt;,类似于if else if写法\n \u0026lt;c:set value=\u0026quot;8\u0026quot; var=\u0026quot;variable1\u0026quot;\u0026gt;\u0026lt;/c:set\u0026gt;\r\u0026lt;c:set value=\u0026quot;9\u0026quot; var=\u0026quot;variable2\u0026quot;\u0026gt;\u0026lt;/c:set\u0026gt;\r\u0026lt;c:choose\u0026gt;\r\u0026lt;c:when test=\u0026quot;${variable1%2==0 }\u0026quot;\u0026gt;\r\u0026lt;c:out value=\u0026quot;variable1:偶数\u0026quot;\u0026gt;\u0026lt;/c:out\u0026gt;\r\u0026lt;c:choose\u0026gt;\r\u0026lt;c:when test=\u0026quot;${variable2%2==0 }\u0026quot;\u0026gt;\r\u0026lt;c:out value=\u0026quot;variable2:偶数\u0026quot;\u0026gt;\u0026lt;/c:out\u0026gt;\r\u0026lt;/c:when\u0026gt;\r\u0026lt;c:otherwise\u0026gt;\r\u0026lt;c:out value=\u0026quot;variable2:奇数\u0026quot;\u0026gt;\u0026lt;/c:out\u0026gt;\r\u0026lt;/c:otherwise\u0026gt;\r\u0026lt;/c:choose\u0026gt;\r\u0026lt;/c:when\u0026gt;\r\u0026lt;c:otherwise\u0026gt;\r\u0026lt;c:out value=\u0026quot;variable1:奇数\u0026quot;\u0026gt;\u0026lt;/c:out\u0026gt;\r\u0026lt;/c:otherwise\u0026gt;\r\u0026lt;/c:choose\u0026gt;\r \u0026lt;c:forEach\u0026gt;迭代标签   \u0026lt;c:forEach [var=\u0026ldquo;varname\u0026rdquo;] [varStatus=\u0026ldquo;varStatusName\u0026rdquo;] [begin=\u0026ldquo;开始\u0026rdquo;] [end=\u0026ldquo;结束\u0026rdquo;] [step=\u0026ldquo;步数\u0026rdquo;]\u0026gt; java or html code \u0026lt;/c:forEach\u0026gt;\n \u0026lt;table\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;td\u0026gt;行号1\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;行号2\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;当前迭代项\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;是否第一项\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;是否最后一项\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;结果\u0026lt;/td\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;c:forEach var=\u0026quot;i\u0026quot; varStatus=\u0026quot;j\u0026quot; begin=\u0026quot;1\u0026quot; end=\u0026quot;10\u0026quot; step=\u0026quot;2\u0026quot;\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;td\u0026gt;${j.index }\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;${j.count }\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;${j.current }\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;${j.first }\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;${j.last }\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;${i }\u0026lt;/td\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;/c:forEach\u0026gt;\r\u0026lt;/table\u0026gt;\r  \u0026lt;c:forEach item=\u0026ldquo;collection\u0026rdquo; [varStatus=\u0026ldquo;varStatusName\u0026rdquo; [begin=\u0026ldquo;开始\u0026rdquo;] [end=\u0026ldquo;结束\u0026rdquo;] [step=\u0026ldquo;步数\u0026rdquo;]]\u0026gt; java or heml code \u0026lt;/c:forEach\u0026gt;\n \u0026lt;%\rList list=new ArrayList();\rlist.add(\u0026quot;zhangsan\u0026quot;);\rlist.add(\u0026quot;lisi\u0026quot;);\rlist.add(\u0026quot;wangwu\u0026quot;);\rlist.add(\u0026quot;liuliu\u0026quot;);\rpageContext.setAttribute(\u0026quot;collection\u0026quot;, list);\r%\u0026gt;\r\u0026lt;table\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;td\u0026gt;行号1\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;行号2\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;当前迭代项\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;是否第一项\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;是否最后一项\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;姓名\u0026lt;/td\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;c:forEach items=\u0026quot;${collection }\u0026quot; var=\u0026quot;i\u0026quot; varStatus=\u0026quot;j\u0026quot;\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;td\u0026gt;${j.index }\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;${j.count }\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;${j.current }\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;${j.first }\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;${j.last }\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;${i }\u0026lt;/td\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;/c:forEach\u0026gt;\r\u0026lt;/table\u0026gt;\r \u0026lt;c;forTokens\u0026gt;字符串分割标签   \u0026lt;c:forTokens items=\u0026ldquo;字符串\u0026rdquo; delims=\u0026ldquo;分割符\u0026rdquo; [var=\u0026ldquo;別名\u0026rdquo;] [varStatus=\u0026ldquo;varStatusName\u0026rdquo;] [begin=\u0026ldquo;开始\u0026rdquo;] [end=\u0026ldquo;结束\u0026rdquo;] [step=\u0026ldquo;步数\u0026rdquo;]\u0026gt; java or html code \u0026lt;/c:forTokens\u0026gt;\n \u0026lt;table\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;td\u0026gt;行号1\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;行号2\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;当前迭代项\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;是否第一项\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;是否最后一项\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;子字符串\u0026lt;/td\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;c:forTokens items=\u0026quot;this is a jstl code\u0026quot; delims=\u0026quot; \u0026quot; var=\u0026quot;i\u0026quot; varStatus=\u0026quot;j\u0026quot;\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;td\u0026gt;${j.index }\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;${j.count }\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;${j.current }\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;${j.first }\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;${j.last }\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;${i }\u0026lt;/td\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;/c:forTokens\u0026gt;\r \u0026lt;c;remove\u0026gt;删除某个范围内的值   \u0026lt;c:remove var=\u0026ldquo;varname\u0026rdquo; [scope=\u0026ldquo;request|page|session|application\u0026rdquo;]/\u0026gt;\n \u0026lt;%\rpageContext.setAttribute(\u0026quot;varname1\u0026quot;, \u0026quot;one\u0026quot;);\rrequest.setAttribute(\u0026quot;varname2\u0026quot;, \u0026quot;two\u0026quot;);\rsession.setAttribute(\u0026quot;varname3\u0026quot;, \u0026quot;three\u0026quot;);\rapplication.setAttribute(\u0026quot;varname4\u0026quot;, \u0026quot;four\u0026quot;);\r%\u0026gt;\r\u0026lt;table\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;th\u0026gt;pageContext\u0026lt;/th\u0026gt;\r\u0026lt;th\u0026gt;request\u0026lt;/th\u0026gt;\r\u0026lt;th\u0026gt;session\u0026lt;/th\u0026gt;\r\u0026lt;th\u0026gt;application\u0026lt;/th\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;td\u0026gt;${varname1 }\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;${varname2 }\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;${varname3 }\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;${varname4 }\u0026lt;/td\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;/table\u0026gt;\r\u0026lt;c:remove var=\u0026quot;varname1\u0026quot;/\u0026gt;\r\u0026lt;c:remove var=\u0026quot;varname2\u0026quot;/\u0026gt;\r\u0026lt;c:remove var=\u0026quot;varname3\u0026quot;/\u0026gt;\r\u0026lt;c:remove var=\u0026quot;varname4\u0026quot;/\u0026gt;\r\u0026lt;c:out value=\u0026quot;删除后\u0026quot;\u0026gt;\u0026lt;/c:out\u0026gt;\u0026lt;br\u0026gt;\r\u0026lt;table\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;th\u0026gt;pageContext\u0026lt;/th\u0026gt;\r\u0026lt;th\u0026gt;request\u0026lt;/th\u0026gt;\r\u0026lt;th\u0026gt;session\u0026lt;/th\u0026gt;\r\u0026lt;th\u0026gt;application\u0026lt;/th\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;td\u0026gt;${varname1 }\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;${varname2 }\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;${varname3 }\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;${varname4 }\u0026lt;/td\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;/table\u0026gt;\r \u0026lt;c:catch\u0026gt;抛出异常标签   \u0026lt;c:catch [var=\u0026ldquo;varname\u0026rdquo;]\u0026gt; code \u0026lt;/c:catch\u0026gt;\n \u0026lt;c:catch var=\u0026quot;error\u0026quot;\u0026gt;\r\u0026lt;%\rint[] arr=new int[4];\rint j=arr[5];\r%\u0026gt;\r\u0026lt;/c:catch\u0026gt;\r\u0026lt;c:out value=\u0026quot;错误信息:${error }\u0026quot;\u0026gt;\u0026lt;/c:out\u0026gt;\u0026lt;br\u0026gt;\r\u0026lt;c:catch var=\u0026quot;error1\u0026quot;\u0026gt;\r\u0026lt;%\rint j=5/0;\r%\u0026gt;\r\u0026lt;/c:catch\u0026gt;\r\u0026lt;c:out value=\u0026quot;错误信息:${error1 }\u0026quot;\u0026gt;\u0026lt;/c:out\u0026gt;\r \u0026lt;c:param\u0026gt;向导入的页面传入参数,与\u0026lt;c:import\u0026gt;结合使用   \u0026lt;c:param name=\u0026ldquo;paramName\u0026rdquo; value=\u0026ldquo;paramValue\u0026rdquo;\u0026gt;\u0026lt;/c:param\u0026gt;\n \u0026lt;c:import\u0026gt;导入静|动态文件   \u0026lt;c:import url=\u0026ldquo;url\u0026rdquo; [context=\u0026ldquo;context\u0026rdquo;] [var=\u0026ldquo;varname\u0026rdquo;] [scope=\u0026ldquo;request|page|session|application\u0026rdquo;] [charEncoding=\u0026ldquo;coding\u0026rdquo;]\u0026gt; [\u0026lt;c:param name=\u0026ldquo;paramName\u0026rdquo; [value=\u0026ldquo;valueName\u0026rdquo;]\u0026gt;\u0026lt;/c:param\u0026gt;] \u0026lt;/c:import\u0026gt;\n \u0026lt;c:import url=\u0026quot;https://www.baidu.com/s\u0026quot;\u0026gt;\r\u0026lt;c:param name=\u0026quot;wd\u0026quot; value=\u0026quot;java\u0026quot;/\u0026gt;\r\u0026lt;/c:import\u0026gt;\r \u0026lt;c:redirect\u0026gt;重定向另一个页面   \u0026lt;c:redirect url=\u0026ldquo;url\u0026rdquo; [contex=\u0026ldquo;context\u0026rdquo;]\u0026gt; [\u0026lt;c:param name=\u0026ldquo;paramName\u0026rdquo; [value=\u0026ldquo;valueName\u0026rdquo;]\u0026gt;\u0026lt;/c:param\u0026gt;] \u0026lt;/c:redirect\u0026gt;\n \u0026lt;c:redirect url=\u0026quot;https://www.baidu.com/s\u0026quot;\u0026gt;\r\u0026lt;c:param name=\u0026quot;wd\u0026quot; value=\u0026quot;java\u0026quot;/\u0026gt;\r\u0026lt;/c:redirect\u0026gt;  \u0026lt;c:url\u0026gt;生成一个url   \u0026lt;c:url value=\u0026ldquo;url\u0026rdquo; [context=\u0026ldquo;context\u0026rdquo;] var=\u0026ldquo;varname\u0026rdquo; [scope=\u0026ldquo;request|page|session|application\u0026rdquo;]\u0026gt; [\u0026lt;c:param name=\u0026ldquo;paramName\u0026rdquo; [value=\u0026ldquo;valueName\u0026rdquo;]\u0026gt;\u0026lt;/c:param\u0026gt;] \u0026lt;/c:url\u0026gt;\n \u0026lt;c:url value=\u0026quot;https://www.baidu.com/s\u0026quot; var=\u0026quot;varname\u0026quot;\u0026gt;\r\u0026lt;c:param name=\u0026quot;wd\u0026quot; value=\u0026quot;java\u0026quot;\u0026gt;\u0026lt;/c:param\u0026gt;\r\u0026lt;/c:url\u0026gt;\r\u0026lt;c:out value=\u0026quot;${varname }\u0026quot;\u0026gt;\u0026lt;/c:out\u0026gt;\r\u0026lt;br\u0026gt;\r\u0026lt;c:url value=\u0026quot;/index.jsp\u0026quot; var=\u0026quot;varname\u0026quot;\u0026gt;\u0026lt;/c:url\u0026gt;\r\u0026lt;c:out value=\u0026quot;${varname }\u0026quot;\u0026gt;\u0026lt;/c:out\u0026gt;\r 表格合并   \u0026lt;div class=\u0026quot;page-inner mt--5\u0026quot; style=\u0026quot;margin-bottom: 1rem;\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;row mt--2\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;col-md-12\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;card full-height\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;card-header\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;card-head-row\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;card-title\u0026quot;\u0026gt;工作事项配置\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;card-body\u0026quot;\u0026gt;\r\u0026lt;form class=\u0026quot;form-horizontal\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;row form-group\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;col-md-12\u0026quot;\u0026gt;\r\u0026lt;table class=\u0026quot;table table-bordered table-striped\u0026quot;\u0026gt;\r\u0026lt;thead\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;th\u0026gt;阶段\u0026lt;/th\u0026gt;\r\u0026lt;th\u0026gt;工作事项\u0026lt;/th\u0026gt;\r\u0026lt;th\u0026gt;名称\u0026lt;/th\u0026gt;\r\u0026lt;th\u0026gt;排序\u0026lt;/th\u0026gt;\r\u0026lt;th\u0026gt;责任人\u0026lt;/th\u0026gt;\r\u0026lt;th\u0026gt;描述\u0026lt;/th\u0026gt;\r\u0026lt;th\u0026gt;编辑\u0026lt;/th\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;/thead\u0026gt;\r\u0026lt;tbody\u0026gt;\r\u0026lt;c:forEach items=\u0026quot;${projectWorkStageConfigVoList}\u0026quot; var=\u0026quot;ProjectWorkStageConfigVo\u0026quot; varStatus=\u0026quot;StatusWorkStageConfigVo\u0026quot;\u0026gt;\r\u0026lt;c:forEach items=\u0026quot;${ProjectWorkStageConfigVo.projectPhaseConfigVoList}\u0026quot; var=\u0026quot;ProjectPhaseConfigVo\u0026quot; varStatus=\u0026quot;StatusPhaseConfigVo\u0026quot;\u0026gt;\r\u0026lt;c:forEach items=\u0026quot;${ProjectPhaseConfigVo.projectPhaseConfigList}\u0026quot; var=\u0026quot;ProjectPhaseConfig\u0026quot; varStatus=\u0026quot;StatusConfig\u0026quot;\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;c:choose\u0026gt;\r\u0026lt;c:when test=\u0026quot;${ StatusConfig.first \u0026amp;\u0026amp; StatusPhaseConfigVo.first}\u0026quot;\u0026gt;\r\u0026lt;td rowspan=\u0026quot;${fn:length(ProjectWorkStageConfigVo.projectPhaseConfigVoList) * fn:length(ProjectPhaseConfigVo.projectPhaseConfigList)}\u0026quot;\u0026gt;\r${ProjectWorkStageConfigVo.workStageName}\r\u0026lt;/td\u0026gt;\r\u0026lt;/c:when\u0026gt;\r\u0026lt;/c:choose\u0026gt;\r\u0026lt;c:choose\u0026gt;\r\u0026lt;c:when test=\u0026quot;${ StatusConfig.first}\u0026quot;\u0026gt;\r\u0026lt;td rowspan=\u0026quot;${fn:length(ProjectPhaseConfigVo.projectPhaseConfigList)}\u0026quot;\u0026gt;\r${ProjectPhaseConfigVo.projectPhaseName}\r\u0026lt;/td\u0026gt;\r\u0026lt;/c:when\u0026gt;\r\u0026lt;/c:choose\u0026gt;\r\u0026lt;td \u0026gt;${ProjectPhaseConfig.parName} \u0026lt;/td\u0026gt;\r\u0026lt;td \u0026gt;${ProjectPhaseConfig.sorting} \u0026lt;/td\u0026gt;\r\u0026lt;td \u0026gt;${ProjectPhaseConfig.parValues} \u0026lt;/td\u0026gt;\r\u0026lt;td \u0026gt;${ProjectPhaseConfig.remark} \u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;\r\u0026lt;button type=\u0026quot;button\u0026quot; onclick=\u0026quot;editProjectPhaseConfig('${ProjectPhaseConfig.id}');\u0026quot;\rstyle=\u0026quot;margin-left: 5px;\u0026quot;\rclass=\u0026quot;btn btn-primary btn-xs tooltips\u0026quot;\rdata-placement=\u0026quot;bottom\u0026quot; data-original-title=\u0026quot;编辑\u0026quot;\u0026gt;\r\u0026lt;i class=\u0026quot;fa fa-pen\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\r\u0026lt;/button\u0026gt;\r\u0026lt;/td\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;/c:forEach\u0026gt;\r\u0026lt;/c:forEach\u0026gt;\r\u0026lt;/c:forEach\u0026gt;\r\u0026lt;/tbody\u0026gt;\r\u0026lt;/table\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/form\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r","pubDate":"2021-02-15","title":"jsp \u003e JSTL \u003e core标签库"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_session_jsp_jstl_session/","plain":"Session  HTTP是无状态协议，这意味着每次客户端检索网页时，都要单独打开一个服务器连接，因此服务器不会记录下先前客户端请求的任何信息   会话,当用户打开一个浏览器连接到web应用或者打开某个页面,直到关闭浏览器这个过程叫做会话   Session是保存在服务器上的数据结构，用于跟踪用户的状态。此数据可以保存在群集、数据库、文件中  Session常用方法   public boolean isNew()\n返回是否为一个新的客户端，或者客户端是否拒绝加入session     public Enumeration getAttributeNames()\n返回session对象中所有的对象名称     public int getMaxInactiveInterval()\n返回最大时间间隔，以秒为单位，servlet 容器将会在这段时间内保持会话打开     public long getCreationTime()\n返回session对象被创建的时间， 以毫秒为单位，从1970年1月1号凌晨开始算起     public long getLastAccessedTime()\n返回客户端最后访问的时间，以毫秒为单位，从1970年1月1号凌晨开始算起     public Object getAttribute(String name)\n返回session对象中与指定名称绑定的对象，如果不存在则返回null     public Object getAttribute(String name)\n返回session对象中与指定名称绑定的对象，如果不存在则返回null     public String getId()\n返回session对象的ID     public void invalidate()\n将session无效化，解绑任何与该session绑定的对象     public void removeAttribute(String name)\n移除session中指定名称的对象     public void setAttribute(String name, Object value)\n使用指定的名称和值来产生一个对象并绑定到session中     public void setMaxInactiveInterval(int interval)\n用来指定时间，以秒为单位，servlet容器将会在这段时间内保持会话有效   Session应用 新建SessionDemo类 @WebServlet(\u0026quot;/SessionDemo\u0026quot;)\rpublic class SessionDemo extends HttpServlet {\rprivate int count=0;\rprotected void doGet(HttpServletRequest request, HttpServletResponse response)\rthrows ServletException, IOException {\rrequest.setCharacterEncoding(\u0026quot;utf-8\u0026quot;);\rresponse.setCharacterEncoding(\u0026quot;utf-8\u0026quot;);\rcount++;\rHttpSession session = request.getSession();\rString id = session.getId();\rlong startTime = session.getCreationTime();\rlong lastTime = session.getLastAccessedTime();\rlong validTime = session.getMaxInactiveInterval();\rsession.setMaxInactiveInterval(60);\rSimpleDateFormat myFormat=new SimpleDateFormat(\u0026quot;yyyy/MM/dd HH:mm:ss\u0026quot;);\rresponse.setContentType(\u0026quot;text/html\u0026quot;);\rPrintWriter out = response.getWriter();\rout.println(\u0026quot;\u0026lt;!DOCTYPE HTML PUBLIC \\\u0026quot;-\rout.println(\u0026quot;\u0026lt;HTML\u0026gt;\u0026quot;);\rout.println(\u0026quot; \u0026lt;HEAD\u0026gt;\u0026lt;TITLE\u0026gt;A Servlet\u0026lt;/TITLE\u0026gt;\u0026lt;/HEAD\u0026gt;\u0026quot;);\rout.println(\u0026quot; \u0026lt;BODY\u0026gt;\u0026quot;);\rif(session.isNew()) {\rout.println(\u0026quot;新客户\u0026lt;br\u0026gt;\u0026quot;);\r}else {\rout.println(\u0026quot;不是新客户\u0026lt;br\u0026gt;\u0026quot;);\r}\rout.println(\u0026quot;会话ID:\u0026quot; + id+\u0026quot;\u0026lt;br\u0026gt;\u0026quot;);\rout.println(\u0026quot;会话创建时间:\u0026quot;+myFormat.format(startTime)+\u0026quot;\u0026lt;br\u0026gt;\u0026quot;);\rout.println(\u0026quot;会话有效时间:\u0026quot;+validTime+\u0026quot;秒\u0026lt;br\u0026gt;\u0026quot;);\rout.println(\u0026quot;当前会话有效时间:\u0026quot;+session.getMaxInactiveInterval()+\u0026quot;秒\u0026lt;br\u0026gt;\u0026quot;);\rout.println(\u0026quot;最后访问时间:\u0026quot;+myFormat.format(lastTime)+\u0026quot;\u0026lt;br\u0026gt;\u0026quot;);\rout.println(\u0026quot;访问次数:\u0026quot;+count+\u0026quot;\u0026lt;br\u0026gt;\u0026quot;);\rout.println(\u0026quot; \u0026lt;/BODY\u0026gt;\u0026quot;);\rout.println(\u0026quot;\u0026lt;/HTML\u0026gt;\u0026quot;);\rout.flush();\rout.close();\r}\r}\r会话监听器 新建SerssionListenerDemo类 @WebListener\rpublic class SerssionListenerDemo implements HttpSessionListener{\rprivate static int count=0;\r@Override\rpublic void sessionCreated(HttpSessionEvent se) {\rHttpSessionListener.super.sessionCreated(se);\rcount++;\rSystem.out.println(\u0026quot;第\u0026quot;+count+\u0026quot;个会话被创建\u0026quot;);\r}\r@Override\rpublic void sessionDestroyed(HttpSessionEvent se) {\r// TODO Auto-generated method stub\rHttpSessionListener.super.sessionDestroyed(se);\rSystem.out.println(\u0026quot;会话被毁灭\u0026quot;);\rcount--;\rSystem.out.println(\u0026quot;当前剩余\u0026quot;+count+\u0026quot;个会话\u0026quot;);\r}\r}\r新建SessionAttributeListener类 @WebListener\rpublic class SessionAttributeListener implements HttpSessionAttributeListener{\r@Override\rpublic void attributeAdded(HttpSessionBindingEvent event) {\rHttpSessionAttributeListener.super.attributeAdded(event);\rSystem.out.println(\u0026quot;session添加了一个属性\u0026quot;);\r}\r@Override\rpublic void attributeRemoved(HttpSessionBindingEvent event) {\rHttpSessionAttributeListener.super.attributeRemoved(event);\rSystem.out.println(\u0026quot;session删除了某个属性\u0026quot;);\r}\r@Override\rpublic void attributeReplaced(HttpSessionBindingEvent event) {\rHttpSessionAttributeListener.super.attributeReplaced(event);\rSystem.out.println(\u0026quot;session修改了某个属性\u0026quot;);\r}\r}\r新建ServletRequestListener类 @WebListener\rpublic class ServletRequestListener implements javax.servlet.ServletRequestListener{\r@Override\rpublic void requestInitialized(ServletRequestEvent sre) {\rjavax.servlet.ServletRequestListener.super.requestInitialized(sre);\rSystem.out.println(\u0026quot;生成新的请求\u0026quot;);\r}\r@Override\rpublic void requestDestroyed(ServletRequestEvent sre) {\rjavax.servlet.ServletRequestListener.super.requestDestroyed(sre);\rSystem.out.println(\u0026quot;请求毁灭\u0026quot;);\r}\r}\r","pubDate":"2021-02-15","title":"jsp \u003e jstl \u003e Session"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_jsp_jsp_%E5%AD%97%E7%AC%A6%E4%B8%B2el%E8%A1%A8%E8%BE%BE%E5%BC%8F/","plain":"字符串el表达式 fn:contains 判断字符串是否包含另外一个字符串 \u0026lt;c:if test=\u0026quot;${fn:contains(name, searchString)}\u0026quot;\u0026gt;\rfn:containsIgnoreCase 判断字符串是否包含另外一个字符串(大小写无关) \u0026lt;c:if test=\u0026quot;${fn:containsIgnoreCase(name, searchString)}\u0026quot;\u0026gt;\rfn:endsWith 判断字符串是否以另外字符串结束 \u0026lt;c:if test=\u0026quot;${fn:endsWith(filename, \u0026quot;.txt\u0026quot;)}\u0026quot;\u0026gt;\rfn:escapeXml 把一些字符转成XML表示，例如 \u0026lt;字符应该转为\u0026lt; ${fn:escapeXml(param:info)}\rfn:indexOf 子字符串在母字符串中出现的位置 ${fn:indexOf(name, \u0026quot;-\u0026quot;)}\rfn:join 将数组中的数据联合成一个新字符串，并使用指定字符格开 ${fn:join(array, \u0026quot;;\u0026quot;)}\rfn:length 获取字符串的长度，或者数组的大小 ${fn:length(shoppingCart.products)}\rfn:replace 替换字符串中指定的字符 ${fn:replace(text, \u0026quot;-\u0026quot;, \u0026quot;?\u0026quot;)}\rfn:split 把字符串按照指定字符切分 ${fn:split(customerNames, \u0026quot;;\u0026quot;)}\rfn:startsWith 判断字符串是否以某个子串开始 \u0026lt;c:if test=\u0026quot;${fn:startsWith(product.id, \u0026quot;100-\u0026quot;)}\u0026quot;\u0026gt;\rfn:substring 获取子串 ${fn:substring(zip, 6, -1)}\rfn:substringAfter 获取从某个字符所在位置开始的子串 ${fn:substringAfter(zip, \u0026quot;-\u0026quot;)}\rfn:substringBefore 获取从开始到某个字符所在位置的子串 ${fn:substringBefore(zip, \u0026quot;-\u0026quot;)}\rfn:toLowerCase 转为小写 ${fn.toLowerCase(product.name)}\rfn:toUpperCase 转为大写字符 ${fn.UpperCase(product.name)}\rfn:trim 去除字符串前后的空格 ${fn.trim(name)}\r函数 描述\rfn:contains(string, substring)\r如果参数string中包含参数substring，返回true\rfn:containsIgnoreCase(string, substring)\r如果参数string中包含参数substring（忽略大小写），返回true\rfn:endsWith(string, suffix)\r如果参数 string 以参数suffix结尾，返回true\rfn:escapeXml(string)\r将有特殊意义的XML (和HTML)转换为对应的XML character entity code，并返回\rfn:indexOf(string, substring)\r返回参数substring在参数string中第一次出现的位置\rfn:join(array, separator)\r将一个给定的数组array用给定的间隔符separator串在一起，组成一个新的字符串并返回。\rfn:length(item)\r返回参数item中包含元素的数量。参数Item类型是数组、collection或者String。如果是String类型,返回值是String中的字符数。\rfn:replace(string, before, after)\r返回一个String对象。用参数after字符串替换参数string中所有出现参数before字符串的地方，并返回替换后的结果 fn:split(string, separator)\r返回一个数组，以参数separator 为分割符分割参数string，分割后的每一部分就是数组的一个元素\rfn:startsWith(string, prefix)\r如果参数string以参数prefix开头，返回true\rfn:substring(string, begin, end)\r返回参数string部分字符串, 从参数begin开始到参数end位置，包括end位置的字符\rfn:substringAfter(string, substring)\r返回参数substring在参数string中后面的那一部分字符串?? fn:substringBefore(string, substring)\r返回参数substring在参数string中前面的那一部分字符串\rfn:toLowerCase(string)\r将参数string所有的字符变为小写，并将其返回\rfn:toUpperCase(string)\r将参数string所有的字符变为大写，并将其返回\rfn:trim(string)\r在jsp中 使用EL表达式时，不可以使用java提供的功能，比如indexOf()等。\r\u0026lt;c:if test=\u0026quot;${Boolean.valueOf(requestScope.addresult)==false}\u0026quot;\u0026gt; ","pubDate":"2021-02-15","title":"jsp \u003e 字符串el表达式"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_assembly_link/","plain":"bootstrap3整合 \u0026lt;%@include file=\u0026quot;/css/cssBootStrap.jsp\u0026quot; %\u0026gt;\rbootstrap4整合 \u0026lt;%@include file=\u0026quot;/css/bootstrap4.jsp\u0026quot; %\u0026gt;\rthymeleaf \u0026lt;div th:include=\u0026quot;css/cssBootStrap :: html\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r图标 # Alibaba国际站图标库\r${pageContext.request.contextPath}/components/images/Alibaba国际站图标库/all.png\rFont Awesome ###url http://fontawesome.dashgame.com/\r##引入方式\r\u0026lt;link href=\u0026quot;${pageContext.request.contextPath}/components/font-awesome-4.7.0/css/font-awesome.css\u0026quot; rel=\u0026quot;stylesheet\u0026quot; type=\u0026quot;text/css\u0026quot;\u0026gt;\r##基本写法\r\u0026lt;li class=\u0026quot;list-group-item\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;fa fa-camera-retro\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/li\u0026gt;\r##大图标\r\u0026lt;i class=\u0026quot;fa fa-camera-retro fa-lg\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; fa-lg\r\u0026lt;i class=\u0026quot;fa fa-camera-retro fa-2x\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; fa-2x\r\u0026lt;i class=\u0026quot;fa fa-camera-retro fa-3x\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; fa-3x\r\u0026lt;i class=\u0026quot;fa fa-camera-retro fa-4x\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; fa-4x\r\u0026lt;i class=\u0026quot;fa fa-camera-retro fa-5x\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; fa-5x\r##固定宽度 使用 fa-fw 可以将图标设置为一个固定宽度。主要用于不同宽度图标无法对齐的情况。 尤其在列表或导航时起到重要作用\r\u0026lt;div class=\u0026quot;list-group\u0026quot;\u0026gt;\r\u0026lt;a class=\u0026quot;list-group-item\u0026quot; href=\u0026quot;#\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;fa fa-home fa-fw\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\u0026amp;nbsp; Home\u0026lt;/a\u0026gt;\r\u0026lt;a class=\u0026quot;list-group-item\u0026quot; href=\u0026quot;#\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;fa fa-book fa-fw\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\u0026amp;nbsp; Library\u0026lt;/a\u0026gt;\r\u0026lt;a class=\u0026quot;list-group-item\u0026quot; href=\u0026quot;#\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;fa fa-pencil fa-fw\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\u0026amp;nbsp; Applications\u0026lt;/a\u0026gt;\r\u0026lt;a class=\u0026quot;list-group-item\u0026quot; href=\u0026quot;#\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;fa fa-cog fa-fw\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\u0026amp;nbsp; Settings\u0026lt;/a\u0026gt;\r\u0026lt;/div\u0026gt;\r## 用于列表 使用 fa-ul 和 fa-li 便可以简单的将无序列表的默认符号替换掉\r\u0026lt;ul class=\u0026quot;fa-ul\u0026quot;\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;i class=\u0026quot;fa-li fa fa-check-square\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;List icons\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;i class=\u0026quot;fa-li fa fa-check-square\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;can be used\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;i class=\u0026quot;fa-li fa fa-spinner fa-spin\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;as bullets\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;i class=\u0026quot;fa-li fa fa-square\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;in lists\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r## 动画 使用 fa-spin 类来使任意图标旋转，现在您还可以使用 fa-pulse 来使其进行8方位旋转。尤其适合 fa-spinner、fa-refresh 和 fa-cog 。\r\u0026lt;i class=\u0026quot;fa fa-spinner fa-spin\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\r\u0026lt;i class=\u0026quot;fa fa-circle-o-notch fa-spin\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\r\u0026lt;i class=\u0026quot;fa fa-refresh fa-spin\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\r\u0026lt;i class=\u0026quot;fa fa-cog fa-spin\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\r\u0026lt;i class=\u0026quot;fa fa-spinner fa-pulse\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\r## Bootstrap 3 示例\rFont Awesome 完全兼容 Bootstrap 的所有组件。\r\u0026lt;a class=\u0026quot;btn btn-danger\u0026quot; href=\u0026quot;#\u0026quot;\u0026gt;\r\u0026lt;i class=\u0026quot;fa fa-trash-o fa-lg\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; Delete\u0026lt;/a\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-default btn-sm\u0026quot; href=\u0026quot;#\u0026quot;\u0026gt;\r\u0026lt;i class=\u0026quot;fa fa-cog\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; Settings\u0026lt;/a\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-lg btn-success\u0026quot; href=\u0026quot;#\u0026quot;\u0026gt;\r\u0026lt;i class=\u0026quot;fa fa-flag fa-2x pull-left\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; Font Awesome\u0026lt;br\u0026gt;Version 4.7.0\u0026lt;/a\u0026gt;\r\u0026lt;div class=\u0026quot;btn-group\u0026quot;\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-default\u0026quot; href=\u0026quot;#\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;fa fa-align-left\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/a\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-default\u0026quot; href=\u0026quot;#\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;fa fa-align-center\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/a\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-default\u0026quot; href=\u0026quot;#\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;fa fa-align-right\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/a\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-default\u0026quot; href=\u0026quot;#\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;fa fa-align-justify\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/a\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;input-group margin-bottom-sm\u0026quot;\u0026gt;\r\u0026lt;span class=\u0026quot;input-group-addon\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;fa fa-envelope-o fa-fw\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/span\u0026gt;\r\u0026lt;input class=\u0026quot;form-control\u0026quot; type=\u0026quot;text\u0026quot; placeholder=\u0026quot;Email address\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;input-group\u0026quot;\u0026gt;\r\u0026lt;span class=\u0026quot;input-group-addon\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;fa fa-key fa-fw\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/span\u0026gt;\r\u0026lt;input class=\u0026quot;form-control\u0026quot; type=\u0026quot;password\u0026quot; placeholder=\u0026quot;Password\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;btn-group open\u0026quot;\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-primary\u0026quot; href=\u0026quot;#\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;fa fa-user fa-fw\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; User\u0026lt;/a\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-primary dropdown-toggle\u0026quot; data-toggle=\u0026quot;dropdown\u0026quot; href=\u0026quot;#\u0026quot;\u0026gt;\r\u0026lt;span class=\u0026quot;fa fa-caret-down\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\r\u0026lt;ul class=\u0026quot;dropdown-menu\u0026quot;\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;#\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;fa fa-pencil fa-fw\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; Edit\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;#\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;fa fa-trash-o fa-fw\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; Delete\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;#\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;fa fa-ban fa-fw\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; Ban\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li class=\u0026quot;divider\u0026quot;\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;#\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;i\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; Make admin\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r","pubDate":"2021-02-15","title":"link"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_linux_linux%E4%B8%8B%E8%AE%BE%E7%BD%AE%E5%92%8C%E6%9F%A5%E7%9C%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","plain":"\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;||\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- Linux的变量种类 按变量的生存周期来划分，Linux变量可分为两类： 1 永久的：需要修改配置文件，变量永久生效。 2 临时的：使用export命令声明即可，变量在关闭shell时失效。\n设置变量的三种方法 1 在/etc/profile文件中添加变量【对所有用户生效(永久的)】 用VI在文件/etc/profile文件中增加变量，该变量将会对Linux下所有用户有效，并且是“永久的”。 例如：编辑/etc/profile文件，添加CLASSPATH变量\nvi /etc/profile export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib\n注：修改文件后要想马上生效还要运行# source /etc/profile不然只能在下次重进此用户时生效。\n2 在用户目录下的.bash_profile文件中增加变量【对单一用户生效(永久的)】 用VI在用户目录下的.bash_profile文件中增加变量，改变量仅会对当前用户有效，并且是“永久的”。 例如：编辑guok用户目录(/home/guok)下的.bash_profile $ vi /home/guok/.bash.profile 添加如下内容： export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib 注：修改文件后要想马上生效还要运行$ source /home/guok/.bash_profile不然只能在下次重进此用户时生效。\n3 直接运行export命令定义变量【只对当前shell(BASH)有效(临时的)】 在shell的命令行下直接使用[export 变量名=变量值] 定义变量，\n该变量只在当前的shell(BASH)或其子shell(BASH)下是有效的，\nshell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的话还需要重新定义。\n环境变量的查看 1 使用echo命令查看单个环境变量。例如： echo $PATH 2 使用env查看所有环境变量。例如： env 3 使用set查看所有本地定义的环境变量。\n使用unset删除指定的环境变量 set可以设置某个环境变量的值。清除环境变量的值用unset命令。如果未指定值，则该变量值将被设为NULL。示例如下： $ export TEST=\u0026ldquo;Test\u0026hellip;\u0026rdquo; #增加一个环境变量TEST $ env|grep TEST #此命令有输入，证明环境变量TEST已经存在了 TEST=Test\u0026hellip; unset TEST #删除环境变量TEST $ env|grep TEST #此命令没有输出，证明环境变量TEST已经删除\n常用的环境变量 PATH 决定了shell将到哪些目录中寻找命令或程序 HOME 当前用户主目录 HISTSIZE　历史记录数 LOGNAME 当前用户的登录名 HOSTNAME　指主机的名称 SHELL 当前用户Shell类型 LANGUGE 语言相关的环境变量，多语言可以修改此环境变量 MAIL　当前用户的邮件存放目录 PS1　基本提示符，对于root用户是#，对于普通用户是$\n","pubDate":"2021-02-15","title":"Linux下设置和查看环境变量"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_linux_linux%E5%91%BD%E4%BB%A4/","plain":"linux命令 文件管理 文件基本操作   less命令 (Q退出less命令)([pagedown]： 向下翻动一页)([pageup]： 向上翻动一页) less ss.md\n  cat命令 (cat -n ss.md \u0026gt; sdfsd.txt)把 ss.md 的文档内容加上行号后输入 sdfsd.txt 这个文档里, 这要注意假如sdfsd.txt先有文档会被清空,另外(cat ss.md)可以把消息打印到输出流中,cat 软盘功能暂时不予以考虑\n  ls命令 (ls -a)显示所有文件及目录包括隐藏文件,相当于la命令,ll显示具体信息\n  touch命令 主要用作创建文件如touch ss.md,(touch -m miss,touch -a miss)可以改变文件的读取时间,另外touch miss也可以改变文件的读取时间, 当且仅当miss不存在的时候会创建miss空文件\n  mkdir命令 主要用作创建文件目录;(mkdir dd)创建一个dd目录,(mkdir -p dd/ffg)在当前目录下建立一个dd目录并且在dd下创建一个ffg目录,假如dd不存在会自动创建的\n  mv命令 (mv missA miss.txt)把missA修改为miss.txt (mv sskg /home/zhou/fontconfig/dgsd/sdfg)把sskg移到sdfg目录 (mv ss.md ~)\n  file命令 (file -c ss.md)详细显示指令执行过程(file -v ss.md)显示版本信息 (tar zcvf ss.tar ss.md,file -z ss.tar)尝试去解读压缩文件的内容\n  find命令 (find . -type f)将目前目录其其下子目录中所有一般文件列出(find . -ctime -20)将目前目录及其子目录下所有最近 20 天内更新过的文件列出 (find /home/zhou/fontconfig -name \u0026lsquo;**.md\u0026rsquo;)任意的以md结尾的文件,-name改为-iname会忽略大小写(find /home/zhou/fontconfig -size 0)所有文件长度为0的普通文件\n  split命令 ( split -2 sdfsd.txt) 每隔２行分割成一个文件\u0026ndash;\u0026gt; 分割后:xaa xab xac xad xae xaf xag\n  pwd命令 (pwd)pwd命令用于显示工作目录\n  rm命令 删除操作 (rm xaa)删除单一文件xaa文本文件,这里也是可以用正则的如rm x** ,(rm -r dgsd)递归删除文件目录dgsd下的所有文件包括其本身; (rm -rf baba)加了一个f此命令表示即使原档案属性设为唯读，亦直接删除，无需逐一确认\n  cp命令 复制或者说是拷贝命令 (cp ss.md s1)注意是在同级目录下 (cp /home/zhou/fontconfig/s1/ss.md ~),将ss.md复制到主home下,这的~可以随便换为其它目录 (cp -a s1 /home/zhou/fontconfig/s2,cp -a s1 s2)当cp的是目录时要加上-a参数,当然如果加上-p就更好了,因为-p表示把file拥有的权限也一起复制 如:(cp -ap s1 /home/zhou/fontconfig/s2),(cp -ap ./* /home/zhou/fontconfig/s3)在某个目录把所有内容都复制到s3下\n  chmod 权限命令 Linux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用。\n  u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。 r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行\n  (chmod ugo+r miss.txt)将文件miss.txt 设为所有人皆可读取;(chmod u+x ex1.py)将 ex1.py 设定为只有该文件拥有者可以执行;(chmod 777 file)chmod也可以用数字来表示权限如\n  文本操作  假如是ubuntu则可以直接使用gedit (sudo apt-get install gedit) vi命令 切换模式(i：光标处开始插入,l：光标所在行首开始插入,a：光标所在行尾开始插入,o：光标下插入新行) 进入编辑模式,当编辑完成时,在按Esc按键退出编辑模式,保存并退出：wq, 不保存退出： q！  备份与压缩  zip (zip -r cc.zip s*)-r递归处理，将指定目录下的所有文件和子目录一并处理 (zip -rP 123456 miss.zip miss.txt)-P加密压缩密码123456 解压 unzip miss.zip zip文件乱码问题 unzip -O cp936 xxx.zip tar (tar zcvf ss.tar.gz miss.txt)压缩 (tar zxvf ss.tar.gz)解压 rar (rar x xxx.rar)解压  系统操作  (shutdown -h now)立即关机 (shutdown +5 \u0026ldquo;system 5mine\u0026rdquo;)指定5分钟后关机 (export -p)列出所有的环境变量 uname -sr 内核版本查看 ubuntu (root密码修改 sudo passwd 输入两次就是root密码)  ","pubDate":"2021-02-15","title":"linux命令"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_memorypath_memory/","plain":"记忆方法  提高记忆的关键，在于想象和创意 编故事有助于提高记忆力  通过编故事，再加上逻辑或地点（后者更多一些）;\r编故事是加强了记忆桩之间的联系\r记忆和创造力  记忆本身与创造力密不可分 ， 训练记忆力在很大程度上取决于你的创造力  要想记住毫不相关的信息和扑克牌，\r首先就要把它们变成图像。\r通过这种方式，\r那些零散的信息才可能会建立某种联系\r联想 利用事物间的联系通过联想进行记忆的方法。\r联想是由当前感知或思考的事物想起有关的另一事物，\r或者由头脑中想起的一件事物，又引起想到另一件事物。\r由于客观事物是相互联系的，各种知识也是相互联系的，因而在思维中，\r联想是一种基本的思维形式，是记忆的一种方法。\r联想，就是当人脑接受某一剌激时，浮现出与该刺激有关的事物形象的心理过程。\r一般来说，互相接近的事物、相反的事物、相似的事物之间容易产生联想。\r用联想来增强记忆是一种很常用的方法。\r记忆的一种主要机能就是在有关经验中建立联系，思维中的联想越活跃，经验的联系就越牢固。\r如能经常形成联想和运用联想，就可增强记忆的效果。\r联想是有规律可循的，联想的规律有接近律、类似律、对比律、因果律等，有接近联想、类似联想、对比联想、因果联想。\r  联想不仅快速，而且它还不是一个简单、一维的东西。首先，你在联想中会加入一些情感因素，甚至还没回想起一段经历，就已经产生了某种情绪。\n  一旦学会动用感情和感官，还有逻辑和创造力，来与不同事物间建立联系，你的记忆能力就会大大提高。除此之外，你还会慢慢习惯放松大脑，以最快的速度在不同事物之间建立联系。瞬间联想之所以对提高记忆力如此重要，是因为一个人在瞬间建立的联系往往是最牢靠的\n  如何在两个并无联系的单词之间建立联系\u0026ndash;记忆的关键，就在于将二者结合到一起。\n  如果没有过去的某些参照物作为参考，你就不能在两个概念( 包括单词、物体、活动等)之间建立联系。你的过去为你提供了某种经验，而正是这种经验可以帮助你由一个概念想到另一件概念。你的生活中发生的一切都像是积木中的模块，正是这一个个模块帮助你搭建了自己的人生大厦。要想在两个模块之间尽快建立联系，你需要用尽可能少的连接物来实现过渡。也就是说，要想从一件事情想到另外一件事情，最快的方式就是直接找到二者之间的联系\n   比如说我想记住两个单词：墙壁和小鸡。\r每个单词都能激发我丰富的联想，我必须找到某种连接物将两个单词连接起来。\r比如说：\r墙壁会让我想到一个相册，想找到我小时候放学后经常爬的墙等。\r随着联想越来越细致、快速，我突然想到了一个最明显的连接：一首叫\u0026lt;\u0026lt;小胖鸡\u0026gt;\u0026gt;的儿歌。\r好极了！小胖鸡坐着墙壁上，它是一个鸡蛋----而鸡蛋又是小鸡下的。\r这时我就会展开联想，想象一只小鸡坐在墙下下蛋。\r为了让这个联想更加生动，我想起了小时候我在唱歌时的样子，\r然后自然而然地想到了自己看着小鸡下蛋时吃吃发笑的情形。\r虽然我并不记得发生过这件事，但它却足以激发我的联想。\r这个过程听起来可能有些复杂、繁琐，但事实上，这在大脑中只是一瞬间发生的事情。\r链条法  如何使用链条法记住5个单词 小提琴、武士、箱子、项链、雪球  首先想想你突然听到小提琴发出的悠扬乐声。\r然后看到一个武士在演奏小提琴，\r你甚至可以清楚地看到他把小提琴放到下巴下面--这武士满副盔甲，很是搞笑。\r然后你看到他脚边放了一个箱子，可能颜色很鲜艳，也可能已经很破旧了。\r你打开箱子，发现里面有一挂价值连城的钻石项链，钻石反射阳光，分外耀眼。\r最后你转过头去，突然一个雪球砸中你的脸颊，你甚至感觉到右脸有些发疼。\r记住，你越练习动用五官来加强想象，你的大脑就会越熟悉这种练习，你也就越容易记住自己想象的场景。\r  要要记住五个单词以及单词之间的顺序，需要在单词之间建立联系\n  使用链条法，关键在于上下文，我们可以把本来毫不关联的信息连接起来，将其放到一个场景中，这样它们就会变得很容易记住了。\n  你想象的东西一定要合理，或者至少应该符合逻辑。它们可以有些出奇，甚至古怪，但从理论上一定是合理或可能的。\n  在使用链条法记忆时，一定要注意你所想象的故事顺序。最简单的办法是按照顺序用这些单词编一个故事，故事本身应当有一定的逻辑性，只有这样，你才能记住单词的顺序。在回忆时忘记任何一个单词，都说明你编的故事不够清晰。如果真是这样，建议换个故事试试。\n  路径记忆法   例子\n  第一个记忆桩：前门\n  第二个记忆桩：隔壁邻居家的房子\n  第三个记忆桩：公共汽车站\n  第四个记忆桩：商店\n  第五个记忆桩：停车场\n  在设计了固定的路径，并为每张扑克设定了一个具体的物体代码之后，我要做的就是把扑克放在路径中适当的记忆桩。\r比如说翻开的前5张牌是:方块6、黑桃3、梅花5、红桃8、方块4。记忆方式如下:\r我想象一架飞机(方块6)停在我家门口;\r邻居家门外有段木头(黑桃3)靠在篱笆墙上;\r在公共汽车站，我的小狗(梅花5)正在跳上跳下，冲着路过的汽车狂吠;\r商店里面，我(红桃8)正在买一份报纸;\r停车场里有一捆现金(方块4)。\r  重要:把要记忆的数据变换后放入路径中适当的记忆桩,相当于把数据嵌入记忆桩中,这也是为什么说联想是记忆中最重要的一点\n  这下我不会再记混顺序了，因为这段路径已经把每件事物都排好了位置。我用20张扑克进行测试，完全成功！连一个错误都没有。于是我决定延长这段路径，从我家大门开始，穿过村子，经过酒吧，穿过板球场，沿着一条可以看到大片绿色草坪的小路\u0026hellip;\u0026hellip;最后我的整个路径包括了52个记忆桩，正好是一幅扑克牌。\n  一条成功的路径必须满足三个条件:\n   1:记忆桩必须多样; 2:记忆桩之间的差异必须明显; 3:我与这些记忆桩必须有明显的互动。    地点就像是记忆中的锚\u0026ndash;它们可以成为我们回忆往事的参照点。我相信，如果没有这些地点，我们的思想，尤其是我们的记忆，就会变成一团乱麻，凌乱无序。\n  提高记忆能力的关键有三个:联想、地点、和想象\n  创建记忆路径库的5个秘诀\n   1:选择你非常熟悉的路径 2:选择对你比较有意义的路径 3:选择比较富于变化的路径 4:用特点路径来记忆特点事物 5:选择视角最佳的路径  想象感官训练(2)  建议每天练习，直到确信自己可以在两个看似毫不相关的事物间建立生动具体的联系  方案一:\t想象你手里正拿着个足球，它散发出新鲜橘子味，\r慢慢把这两个感觉汇集到一起。好了，然后想象足球是果冻做的在\r像时钟一样滴答走动，尝起来味道像巧克力。别着急，让这个形象至少在脑海里停留5分钟，尽量让它们鲜活起来。如果感觉大脑开始走神，立刻从头开始重复整个练习。\r然全熟悉第一套方案后，再进入下面的练习\r方案二:\r想象一头身上有粉点的灰色大象，它会像只猫咪一样喵喵叫，\r味道像块生姜，皮肤像是一根根刺人的荨麻，浑身散发出一股\r新鲜咖啡豆的味道。还是老样子，别着急，让这个形象在脑海里至少停留5分钟，尽量鲜活起来。\r记忆\u0026quot;自由玩耍\u0026quot; (3)  词汇能引发记忆。迅速浏览一下下面的词汇，看看它们能让你想到什么。每个单词只要看一两秒即可，尽量不要去左右自己的想法，只是看着它们能让你想起什么就可以了。然后尽量去感受你所想到的形象、念头、情绪和感觉等\u0026mdash;-这可能只是一瞬间的事，也可能需要花上好几分钟。接着看下一个单词。这项训练的目的只是让你熟练使用自由联想，学会激发你的情绪和感觉。  kitten (猫咪)\rrainbow (彩虹)\rtoy (玩具)\rbirthday (生日)\rice cream (冰淇淋)\rsnow (雪)\rchurch (教堂)\rcushion (靠垫)\rsand (沙子)\rtoe nail (脚趾甲)\r 该项练习不仅能帮你回忆事件，还能帮你记住一些想法，以及伴随这些想法的情绪和感受。刚开始不要在意速度，你练习越久，速度就越快。  建立联系 (4)  看看下面的单词，尽量用它们在你脑中激发出的第一反应在每一对单词之间建立联想。千万不要对这些联想做任何修改\u0026mdash;你只要放松大脑，在二者之间建立联系就可以了。这就是记忆两条不相关的信息，叫做链条法  你的第一段路径(练习N)   1：围绕你的住所设计一个由12个记忆桩组成的路径\n  2: 在大脑中反复重复这条路径，直到你烂熟于心。如果可能，你甚至可以亲自走一趟\n  3:确定自己很熟悉这条路径之后，你可以用我前面提到的方法记住12件物品(蛋糕、马、报纸、水壶、鞭子、加农炮、香蕉、电话、猫王、天文望远镜、钟、咖啡)。你的想象要尽量鲜活\u0026ndash;记住，你可以动用逻辑、创造性，以及你所有的感官和情绪。\n  4: 接着盖着清单，看看你能按照正确的顺序记住多少。\n  5:顺序倒过来呢?\n  ","pubDate":"2021-02-15","title":"memory"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_mysql_mysql_basis/","plain":"  停止命令：net stop mysql\n  启动命令：net start mysql\n  登陆 mysql -u 用户名 -p\n  查看数据库版本: mysql \u0026ndash;version：用于在未登录情况下，查看本机mysql版本,select version();：登录情况下，查看链接的库版本\n  显示所有数据库：show databases;\n  进入指定的库：use 库名;\n  显示当前库中所有的表：show tables;\n  查看其他库中所有的表：show tables from 库名;\n  查看表的创建语句：show create table 表名;\n  查看表结构：desc 表名;\n  SQL的语言分类 DQL（Data Query Language）：数据查询语言\rselect 相关语句\rDML（Data Manipulate Language）：数据操作语言\rinsert 、update、delete 语句\rDDL（Data Define Languge）：数据定义语言\rcreate、drop、alter 语句\rTCL（Transaction Control Language）：事务控制语言\rset autocommit=0、start transaction、savepoint、commit、rollback\rmysql语法规范 不区分大小写，但建议关键字大写，表名、列名小写\r每条命令最好用英文分号结尾\r每条命令根据需要，可以进行缩进或换行\r注释\r单行注释：#注释文字\r单行注释：-- 注释文字 ，注意， 这里需要加空格\r多行注释：/* 注释文字 */\rMySQL删除数据库中的所有表 SELECT CONCAT('drop table ',table_name,';') FROM information_schema.`TABLES` WHERE table_schema='数据库名';\r# 然后复制结果 然后重新执行\r","pubDate":"2021-02-15","title":"mysql \u003e basis"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_mysql_mysql_data/","plain":" 数据准备  数据准备\ndrop datbase ch10;\rcreate database ch10;\ruse ch10;\rCREATE TABLE fruits\r(\rf_id char(10) NOT NULL,\rs_id INT NOT NULL,\rf_name char(255) NOT NULL,\rf_price decimal(8,2) NOT NULL,\rPRIMARY KEY(f_id) );\rINSERT INTO fruits (f_id, s_id, f_name, f_price)\rVALUES('a1', 101,'apple',5.2),\r('b1',101,'blackberry', 10.2),\r('bs1',102,'orange', 11.2),\r('bs2',105,'melon',8.2),\r('t1',102,'banana', 10.3),\r('t2',102,'grape', 5.3),\r('o2',103,'coconut', 9.2),\r('c0',101,'cherry', 3.2),\r('a2',103, 'apricot',2.2),\r('l2',104,'lemon', 6.4),\r('b2',104,'berry', 7.6),\r('m1',106,'mango', 15.6),\r('m2',105,'xbabay', 2.6),\r('t4',107,'xbababa', 3.6),\r('m3',105,'xxtt', 11.6),\r('b5',107,'xxxx', 3.6);\rCREATE TABLE customers\r(\rc_id int NOT NULL AUTO_INCREMENT,\rc_name char(50) NOT NULL,\rc_address char(50) NULL,\rc_city char(50) NULL,\rc_zip char(10) NULL,\rc_contact char(50) NULL,\rc_email char(255) NULL,\rPRIMARY KEY (c_id)\r);\rINSERT INTO customers(c_id, c_name, c_address, c_city, c_zip, c_contact, c_email) VALUES(10001, 'RedHook', '200 Street ', 'Tianjin', '300000', 'LiMing', 'LMing@163.com'),\r(10002, 'Stars', '333 Fromage Lane',\r'Dalian', '116000', 'Zhangbo','Jerry@hotmail.com'),\r(10003, 'Netbhood', '1 Sunny Place', 'Qingdao', '266000',\r'LuoCong', NULL),\r(10004, 'JOTO', '829 Riverside Drive', 'Haikou', '570000', 'YangShan', 'sam@hotmail.com');\rCREATE TABLE orderitems\r(\ro_num int NOT NULL,\ro_item int NOT NULL,\rf_id char(10) NOT NULL,\rquantity int NOT NULL,\ritem_price decimal(8,2) NOT NULL,\rPRIMARY KEY (o_num,o_item)\r) ;\rINSERT INTO orderitems(o_num, o_item, f_id, quantity, item_price)\rVALUES(30001, 1, 'a1', 10, 5.2),\r(30001, 2, 'b2', 3, 7.6),\r(30001, 3, 'bs1', 5, 11.2),\r(30001, 4, 'bs2', 15, 9.2),\r(30002, 1, 'b3', 2, 20.0),\r(30003, 1, 'c0', 100, 10),\r(30004, 1, 'o2', 50, 2.50),\r(30005, 1, 'c0', 5, 10),\r(30005, 2, 'b1', 10, 8.99),\r(30005, 3, 'a2', 10, 2.2),\r(30005, 4, 'm1', 5, 14.99);\rCREATE TABLE suppliers\r(\rs_id int NOT NULL AUTO_INCREMENT,\rs_name char(50) NOT NULL,\rs_city char(50) NULL,\rs_zip char(10) NULL,\rs_call CHAR(50) NOT NULL,\rPRIMARY KEY (s_id)\r) ;\rINSERT INTO suppliers(s_id, s_name,s_city, s_zip, s_call)\rVALUES(101,'FastFruit Inc.','Tianjin','300000','48075'),\r(102,'LT Supplies','Chongqing','400000','44333'),\r(103,'ACME','Shanghai','200000','90046'),\r(104,'FNK Inc.','Zhongshan','528437','11111'),\r(105,'Good Set','Taiyuang','030000', '22222'),\r(106,'Just Eat Ours','Beijing','010', '45678'),\r(107,'DK Inc.','Zhengzhou','450000', '33332');\rCREATE TABLE orders\r(\ro_num int NOT NULL AUTO_INCREMENT,\ro_date datetime NOT NULL,\rc_id int NOT NULL,\rPRIMARY KEY (o_num)\r) ;\rINSERT INTO orders(o_num, o_date, c_id)\rVALUES(30001, '2008-09-01', 10001),\r(30002, '2008-09-12', 10003),\r(30003, '2008-09-30', 10004),\r(30004, '2008-10-03', 10005),\r(30005, '2008-10-08', 10001);\rCREATE TABLE dept\r(\rd_no INT NOT NULL PRIMARY KEY AUTO_INCREMENT,\rd_name VARCHAR(50),\rd_location VARCHAR(100)\r);\r# 由于employee表dept_no依赖于父表dept的主键d_no，因此需要先创建dept表，然后创建employee表。\rCREATE TABLE employee\r(\re_no INT NOT NULL PRIMARY KEY,\re_name VARCHAR(100) NOT NULL,\re_gender CHAR(2) NOT NULL,\rdept_no INT NOT NULL,\re_job VARCHAR(100) NOT NULL,\re_salary SMALLINT NOT NULL,\rhireDate DATE,\rCONSTRAINT dno_fk FOREIGN KEY(dept_no)\rREFERENCES dept(d_no)\r);\rINSERT INTO dept VALUES (10, 'ACCOUNTING', 'ShangHai'),\r(20, 'RESEARCH ', 'BeiJing '),\r(30, 'SALES ', 'ShenZhen '),\r(40, 'OPERATIONS ', 'FuJian ');\rINSERT INTO employee VALUES (1001, 'SMITH', 'm',20, 'CLERK',800,'2005-11-12'),\r(1002, 'ALLEN', 'f',30, 'SALESMAN', 1600,'2003-05-12'),\r(1003, 'WARD', 'f',30, 'SALESMAN', 1250,'2003-05-12'),\r(1004, 'JONES', 'm',20, 'MANAGER', 2975,'1998-05-18'),\r(1005, 'MARTIN', 'm',30, 'SALESMAN', 1250,'2001-06-12'), (1006, 'BLAKE', 'f',30, 'MANAGER', 2850,'1997-02-15'),\r(1007, 'CLARK', 'm',10, 'MANAGER', 2450,'2002-09-12'),\r(1008, 'SCOTT', 'm',20, 'ANALYST', 3000,'2003-05-12'),\r(1009, 'KING', 'f',10, 'PRESIDENT', 5000,'1995-01-01'),\r(1010, 'TURNER', 'f',30, 'SALESMAN', 1500,'1997-10-12'),\r(1011, 'ADAMS', 'm',20, 'CLERK', 1100,'1999-10-05'),\r(1012, 'JAMES', 'm',30, 'CLERK', 950,'2008-06-15');\r","pubDate":"2021-02-15","title":"mysql \u003e data"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_mysql_mysql_distinguish/","plain":"前言 在互联网还未崛起的时代,我们的传统应用都有这样一个特点：访问量、数据量都比较小，单库单表都完全可以支撑整个业务。\r随着互联网的发展和用户规模的迅速扩大,对系统的要求也越来越高。因此传统的MySQL单库单表架构的性能问题就暴露出来了。而有下面几个因素会影响数据库性能:\r 数据量  MySQL单库数据量在5000万以内性能比较好,超过阈值后性能会随着数据量的增大而变弱。\rMySQL单表的数据量是500w-1000w之间性能比较好,超过1000w性能也会下降。\r 磁盘  因为单个服务的磁盘空间是有限制的,如果并发压力下,所有的请求都访问同一个节点,肯定会对磁盘IO造成非常大的影响。\r 数据库连接  数据库连接是非常稀少的资源,如果一个库里既有用户、商品、订单相关的数据,当海量用户同时操作时,数据库连接就很可能成为瓶颈。\r为了提升性能,所以我们必须要解决上述几个问题,那就有必要引进分库分表。\r垂直拆分 or 水平拆分？ 当我们单个库太大时,我们先要看一下是因为表太多还是数据量太大，如果是表太多,则应该将部分表进行迁移(可以按业务区分),这就是所谓的垂直切分。\r如果是数据量太大,则需要将表拆成更多的小表,来减少单表的数据量,这就是所谓的水平拆分。\r垂直拆分  垂直分库  垂直分库针对的是一个系统中的不同业务进行拆分,比如用户一个库,商品一个库,订单一个库。 一个购物网站对外提供服务时,会同时对用户、商品、订单表进行操作。没拆分之前, 全部都是落到单一的库上的,这会让数据库的单库处理能力成为瓶颈。如果垂直分库后还是将用户、商品、订单放到同一个服务器上,只是分到了不同的库,这样虽然会减少单库的压力,但是随着用户量增大,这会让整个数据库的处理能力成为瓶颈,还有单个服务器的磁盘空间、内存也会受非常大的影响。 所以我们要将其拆分到多个服务器上，这样上面的问题都解决了，以后也不会面对单机资源问题。\r 垂直分表  也就是“大表拆小表”，基于列字段进行的。一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的拆分到“扩展表“。一般是针对那种几百列的大表，也避免查询时，数据量太大造成的“跨页”问题。\r水平拆分  水平分表  和垂直分表有一点类似,不过垂直分表是基于列的,而水平分表是基于全表的。水平拆分可以大大减少单表数据量,提升查询效率。\r 水平分库分表  将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。\r几种常用的分库分表的策略  HASH取模  假设有用户表user,将其分成3个表user0,user1,user2.路由规则是对3取模,当uid=1时,对应到的是user1,uid=2时,对应的是user2。\r 范围分片  从1-10000一个表,10001-20000一个表。\r 地理位置分片  华南区一个表,华北一个表。\r 时间分片  按月分片，按季度分片等等,可以做到冷热数据。\r分库分表后引入的问题  分布式事务问题  如果我们做了垂直分库或者水平分库以后,就必然会涉及到跨库执行SQL的问题,这样就引发了互联网界的老大难问题-\u0026quot;分布式事务\u0026quot;。那要如何解决这个问题呢？\r1.使用分布式事务中间件 2.使用MySQL自带的针对跨库的事务一致性方案(XA),不过性能要比单库的慢10倍左右。3.能否避免掉跨库操作(比如将用户和商品放在同一个库中)\r 跨库join的问题  分库分表后表之间的关联操作将受到限制，我们无法join位于不同分库的表，也无法join分表粒度不同的表， 结果原本一次查询能够完成的业务，可能需要多次查询才能完成。粗略的解决方法： 全局表：基础数据，所有库都拷贝一份。 字段冗余：这样有些字段就不用join去查询了。 系统层组装：分别查询出所有，然后组装起来，较复杂。\r 横向扩容的问题  当我们使用HASH取模做分表的时候,针对数据量的递增,可能需要动态的增加表,此时就需要考虑因为reHash导致数据迁移的问题。\r 结果集合并、排序的问题  因为我们是将数据分散存储到不同的库、表里的,当我们查询指定数据列表时,数据来源于不同的子库或者子表,就必然会引发结果集合并、排序的问题。如果每次查询都需要排序、合并等操作,性能肯定会受非常大的影响。走缓存可能一条路!\r使用分库分表中间件  Mycat  Mycat发展到现在，适用的场景已经很丰富，而且不断有新用户给出新的创新性的方案，以下是几个典型的应用场景：\r单纯的读写分离，此时配置最为简单，支持读写分离，主从切换\r分表分库，对于超过1000万的表进行分片，最大支持1000亿的单表分片\r多租户应用，每个应用一个库，但应用程序只连接Mycat，从而不改造程序本身，实现多租户化报表系统，借助于Mycat的分表能力，处理大规模报表的统计\r替代Hbase，分析大数据作为海量数据实时查询的一种简单有效方案，比如100亿条频繁查询的记录需要在3秒内查询出来结果，除了基于主键的查询，还可能存在范围查询或其他属性查询，此时Mycat可能是最简单有效的选择。\r Sharding-JDBC  当当网开发的简单易用、轻量级的中间件。\r此外还有淘宝的TDDL,支付宝的OneProxy,360的Atlas等。\r","pubDate":"2021-02-15","title":"mysql \u003e distinguish"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_mysql_mysql_install/","plain":"mysql安装  这里我们不再采用exe的安装的方式,我们使用压缩包的方式安装\n   地址 https://downloads.mysql.com/archives/community/\n  将页面拉到最下面选择选择操作系统后，选择要下载的版本点击 Downloads\n  我选择安装的版本为8.0.13。如果不想要最新的版本也可以进Archives页面选择其他版本\n  选择压缩包的版本哦\n  一:配置环境变量   因为下载的mysql数据库包的格式是zip的，下载完成后直接解压就可以用，但解压后需要进行配置。\n  首先进行环境变量的配置：右击计算机-\u0026gt;属性-\u0026gt;高级系统设置-\u0026gt;环境变量，选择双击Path，在最后面添加你的mysql bin文件夹的路径\n  我的目录是：D:\\databases\\mysql-8.0.13-winx64\n   必须设置这个才行,因为后面我们要在控制台运行命令,假如你不设置这个环境变量那么在控制台根本识别不了,exe安装会自动在环境中设置,而压缩包没有设置  二:在 D:\\databases\\mysql-8.0.13-winx64 目录下新建一个my.ini的文件 [mysqld]\r# skip-grant-tables 暂时注释了 容易引起 mysql服务启动后立马关闭 这个错误\r# 设置3306端口\rport=3306\r# 自定义设置mysql的安装目录，即解压mysql压缩包的目录\r# 切记此处一定要用双斜杠\\\\，单斜杠这里会出错。\rbasedir=D:\\\\databases\\\\mysql-8.0.13-winx64\r# 自定义设置mysql数据库的数据存放目录\rdatadir=D:\\\\databases\\\\mysql-8.0.13-winx64\\\\data\r# 允许最大连接数\rmax_connections=200\r# 允许连接失败的次数，这是为了防止有人从该主机试图攻击数据库系统\rmax_connect_errors=10\r# 服务端使用的字符集默认为UTF8\rcharacter-set-server=utf8mb4\r# 创建新表时将使用的默认存储引擎\rdefault-storage-engine=INNODB\r# 默认使用“mysql_native_password”插件认证\rdefault_authentication_plugin=mysql_native_password\r[mysql]\r# 设置mysql客户端默认字符集\rdefault-character-set=utf8mb4\r[client]\r# 设置mysql客户端连接服务端时默认使用的端口和默认字符集\rport=3306\rdefault-character-set=utf8mb4\r三:windows下运行控制台程序  进入 C:\\Windows\\System32 中搜索   右键用管理员权限执行  四:初始化mysql  mysqld \u0026ndash;initialize \u0026ndash;console，等待一会出现几行代码，root@localhost：后面的是随机生成的数据库初始密码，将初始密码记下来后面会用到。 没记住初始密码的话，删掉初始化的 data目录，再执行一遍初始化命令又会重新生成  D:\\databases\\mysql-8.0.13-winx64\\bin\u0026gt;mysqld --initialize --console\r2020-04-06T07:51:43.421098Z 0 [System] [MY-013169] [Server] D:\\databases\\mysql-8.0.13-winx64\\bin\\mysqld.exe (mysqld 8.0.13) initializing of server in progress as process 21400\r2020-04-06T07:52:04.903297Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: gMmik3IyFW!D\r2020-04-06T07:52:19.868074Z 0 [System] [MY-013170] [Server] D:\\databases\\mysql-8.0.13-winx64\\bin\\mysqld.exe (mysqld 8.0.13) initializing of server has completed\r五:mysql执行核心插件服务 D:\\databases\\mysql-8.0.13-winx64\\bin\u0026gt;mysqld --install\rService successfully installed.\r六:启动服务 net start mysql，启动服务,假如要关闭则是net stop mysql\rD:\\databases\\mysql-8.0.13-winx64\\bin\u0026gt;net start mysql\rMySQL 服务正在启动 ...\rMySQL 服务已经启动成功。\r七:登录 # gMmik3IyFW!D 上面这个就是随即临时密码\rD:\\databases\\mysql-8.0.13-winx64\\bin\u0026gt;mysql -u root -p\rEnter password: ************\rWelcome to the MySQL monitor. Commands end with ; or \\g.\rYour MySQL connection id is 8\rServer version: 8.0.13\rCopyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.\rOracle is a registered trademark of Oracle Corporation and/or its\raffiliates. Other names may be trademarks of their respective\rowners.\rType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\r# 显示为这样就表示登录成功了\r八:修改密码 mysql\u0026gt; alter user root@localhost identified by '123456';\rQuery OK, 0 rows affected (0.20 sec)\r","pubDate":"2021-02-15","title":"mysql \u003e install"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_mysql_mysql_install_problem/","plain":"windows下 Mysql安装的一些问题解决方法 1: The service already exists   在mysql安装的时候要执行 mysqld \u0026ndash;install 这个命令,假如你已经安装完之后觉得不对，但是mysql服务已经生成(windows注册服务已经有mysql了),你不删除此服务为报一个错误\n  The service already exists\n  决绝方法就是 删除mysql相关的服务\n  首先查询下是否存在mysql服务\n  sc query mysql\rSERVICE_NAME: mysql\rTYPE : 10 WIN32_OWN_PROCESS\rSTATE : 4 RUNNING\r(STOPPABLE, PAUSABLE, ACCEPTS_SHUTDOWN)\rWIN32_EXIT_CODE : 0 (0x0)\rSERVICE_EXIT_CODE : 0 (0x0)\rCHECKPOINT : 0x0\rWAIT_HINT : 0x0\r# 这种情况就是mysql 没有删除干净\r 删除该mysql  sc delete mysql\r Please consider using UTF8MB4 in order to be unambiguous.  utf 的别名是 UTF8MB4\r这里在my.ini 的文件中最好是设置 default-character-set=utf8mb4  windows系统下Mysql服务启动后立即关闭问题-排查及解决方法  查看 my.ini 中 多了这个 skip-grant-tables ,这个的原意思是跳过检查,但是在不同版本有些命令是不能使用的\r然后就是目前我暂时发现我自己使用的这个版本出了这个问题,在不同版本下最好是仔细查看配置和日志才是解决之道\r","pubDate":"2021-02-15","title":"mysql \u003e install \u003e problem"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_mysql_mysql_%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/","plain":"数据库设计的规范  数据库表和字段都大写 表都要加业务后缀，例如_C客户表 _B基础表 _P权限表 必须有主键，主键是表名去掉业务后缀，加_ID，大多表的主键使用UUID 字段多个单词时，全大写，用下划线隔开 类型INT/LONG/DOUBLE/TIMESTAMP/CHAR/VARCHAR2 尽量化在这几个类型中，这样数据库设计相当简单 排序号定死名称ORDER_NO 权限两个字段CREATE_BY创建人，CREATE_DEPT创建部门 记录创建时间CREATE_TIME  ","pubDate":"2021-02-15","title":"mysql \u003e 开发规范"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_mysql_mysql_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F/","plain":" 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。\n  目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。\n 数据库三范式 第一范式（1NF）  所谓第一范式（1NF）是指在关系模型中，对域添加的一个规范要求，所有的域都应该是原子性的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。简而言之，第一范式就是无重复的域。 说明：在任何一个关系数据库中，第一范式（1NF）是对关系模式的设计基本要求，一般设计中都必须满足第一范式（1NF）。不过有些关系模型中突破了1NF的限制，这种称为非1NF的关系模型。换句话说，是否必须满足1NF的最低要求，主要依赖于所使用的关系模型。  第二范式（2NF）  在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖） 第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或记录必须可以被唯一地区分。选取一个能区分每个实体的属性或属性组，作为实体的唯一标识。例如在员工表中的身份证号码即可实现每个一员工的区分，该身份证号码即为候选键，任何一个候选键都可以被选作主键。在找不到候选键时，可额外增加属性以实现区分，如果在员工关系中，没有对其身份证号进行存储，而姓名可能会在数据库运行的某个时间重复，无法区分出实体时，设计辟如ID等不重复的编号以实现区分，被添加的编号或ID选作主键。（该主键的添加是在ER设计时添加，不是建库时随意添加） 第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是在第一范式的基础上属性完全依赖于主键。  第三范式（3NF）  在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） 第三范式（3NF）是第二范式（2NF）的一个子集，即满足第三范式（3NF）必须满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个关系中不包含已在其它关系已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性，也就是在满足2NF的基础上，任何非主属性不得传递依赖于主属性。  巴斯-科德范式（BCNF）  Boyce-Codd Normal Form（巴斯-科德范式）\n  在3NF基础上，任何非主属性不能对主键子集依赖（在3NF基础上消除对主码子集的依赖） 巴斯-科德范式（BCNF）是第三范式（3NF）的一个子集，即满足巴斯-科德范式（BCNF）必须满足第三范式（3NF）。通常情况下，巴斯-科德范式被认为没有新的设计规范加入，只是对第二范式与第三范式中设计规范要求更强，因而被认为是修正第三范式，也就是说，它事实上是对第三范式的修正，使数据库冗余度更小。这也是BCNF不被称为第四范式的原因。某些书上，根据范式要求的递增性将其称之为第四范式是不规范，也是更让人不容易理解的地方。而真正的第四范式，则是在设计规范中添加了对多值及依赖的要求。 定义：关系模式R\u0026lt;U,F\u0026gt;∈1FNF,若X→Y且Y不是X的子集时X必含有码，则R\u0026lt;U,F\u0026gt;∈BCNF。也就是说，关系模式R\u0026lt;U,F\u0026gt;中，若每一个决定因素都包含码，则R\u0026lt;U,F\u0026gt;∈BCNF。   由BCNF的定义可以得到结论，一个满足BCNF的关系模式有：\n  -所有非主属性对每一个码都是完全函数依赖。 -所有主属性对每一个不包含它的码也是完全函数依赖。 -没有任何属性完全函数依赖于非码的任何一组属性。 若R∈BCNF，按定义排除了任何属性对码的传递依赖与部分依赖，所以R∈3NF。[1] 一般关系型数据库设计中，达到BCNF就可以了！  #【数据库五大约束】\n 1.primary KEY:设置主键约束； 2.UNIQUE：设置唯一性约束，不能有重复值； 3.DEFAULT 默认值约束，height DOUBLE(3,2)DEFAULT 1.2 height不输入是默认为1,2 4.NOT NULL：设置非空约束，该字段不能为空； 5.FOREIGN key :设置外键约束。  【主键】  1.主键的注意事项？ 主键默认非空，默认唯一性约束，只有主键才能设置自动增长，自动增长一定是主键，主键不一定自动增长； 2.设置主键的方式？ 在定义列时设置：ID INT PRIMARY KEY 在列定义完之后设置：primary KEY（id）  【外键】  1.设置外键的注意事项：  只有INNODB的数据库引擎支持外键，修改my.ini文件设置default-storage-engine=INNODB 外键必须与参照列的数据类型必须相同（数值型要求长度和无符号都相同，字符串要求类型相同，长度可以不同）。\n  2设置外键的语法：\nCONSTRAINT 外键名 FOREIGN KEY (外键字段)REFERENCES 参照表 (参照字段) ON DELETE SET NULL ON UPDATE CASCADE 设置参照完整性\n  3.外键约束的参照操作？\n   参照表的完整性操作：当对参照表的参照字段进行删除或更新时，外键表中的外键如何应对；\n  参照操作可选值：\n   RESTRICT拒绝参照表删除或更新参照字段；\n  RESTRICT和NO ACTION相同，但这个指令只在mysql生效;\n  CASCADE删除或更新参照表的参照字段时，外键表的记录同步删除更新；\n  SET NULL 删除或更新参照表的参照字段时，外键表的外键设为NULL;\n   1NF, 字段不可再分。这个关系数据库强制了，想建立复合的字段也建立不起来。关系数据库出现之前才有这个问题。 2NF，主键依赖，就是一张表里面的字段，必须是跟主键相关的，不能把无关的数据放进来。主键依赖，实质就是，这个信息如果是对象的属性，就放进来，否则就不放。 3NF，就是不能重复存储相同的信息。这个情况，其实是在一个对象里引用了另外一个对象，这个时候，存一个引用就够了，而不是重复的存储这个对象的多个副本。 2NF和3NF的本质是，对象的属性依赖对象。数据库的主键，作用是什么？它用来唯一的标识这个对象，同时，用来给其他对象引用 引用 引用（重要的事情说三次） 所以，实战中，所有数据库都是用int类型做主键（int，或者bigint），而且，主键一律是自增，这是不成文的规则，凡是不遵守这个规则的，都是错的（虽然理论上可以）这样， 数据库写数据的时候，几乎是永远不写入同一个对象的重复信息的，需要重复的时候，只写这个对象的ID  create table Courses(\rCourseID int identity primary key,\rCourseName nvarchar(50) not null\r)\rcreate table Departments( DepartmentID int identity primary key,\tDepartmentName nvarchar(50) not null,\tHeadName nvarchar(50) not null);\rcreate table Students(\tStudentID int identity primary key,\tName nvarchar(50),\tDepartmentID int not null\tConstraint FkStudentDepartment foreign key (DepartmentID) references Departments(DepartmentID));\rcreate table Results(\tResultID int identity primary key,\tStudentID int not null,\tCourseID int not null,\tResult int not null,\rConstraint FkResultStudent foreign key (StudentID) references Students(StudentID));\r11.数据库设计基础原则：三范式  1）表必须有主键 2）字段内容不能是其他的字段加工而成 3）行数据不能相同  12.现今业界主流数据库设计原则：反三范式  1）表不是必须有主键 2）字段存一些加工后的中间的结果，冗余设计 3）记录冗余   三范式追求的目标存储空间尽量小；反三范式追求的目标是查询速度。 创建数据库设计时首先按三范式设计，然后局部优化。\n ","pubDate":"2021-02-15","title":"mysql \u003e 数据库设计三范式"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_mysql_mysql%E4%BA%8B%E5%8A%A1/","plain":"","pubDate":"2021-02-15","title":"mysql事务"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_mysql_mysql%E5%87%BD%E6%95%B0/","plain":"日期函数   返回当前日期，只包含年月日 select curdate()\n  返回当前时间，只包含时分秒 select curtime()\n  返回当前的日期和时间，年月日时分秒全都包含 select now()\n  提取具体日期类型  year() yearweek() ,hour(),month()等等   select year(now()) as \u0026lsquo;年\u0026rsquo;,yearweek(now()) as \u0026lsquo;年,周\u0026rsquo;,hour(now()) as \u0026lsquo;周\u0026rsquo;,minute(now()) as \u0026lsquo;小时\u0026rsquo;,month(now()) \u0026lsquo;月\u0026rsquo;,monthname(now()) \u0026lsquo;月名字\u0026rsquo;,dayofmonth(now()) as \u0026lsquo;当月多少日\u0026rsquo;   EXTRACT() 函数用于返回日期/时间的单独部分，比如年、月、日、小时、分钟等等。   (select extract(year from now()),extract(month from now()),extract(day from now()),extract(hour from now()),extract(minute from now()))  日期格式  DATE_FORMAT(date,fmt)函数：按字符串 fmt 格式化日期 date 值 (select date_format(now(),'%Y-%m-%d'))  日期运算   date_add(date,interval number dateType) example (select date_add(now(),interval 2 year) as \u0026lsquo;add 2 year date\u0026rsquo;) (select date_add(now(),interval -2 hour) as \u0026lsquo;add 2\u0026rsquo;)也可以传入负数即回到过去某个时间\n  date_sub(date,interval number dateType) example (select date_sub(now(),interval 2 year))\n  datediff(date,date) 计算两个日期之间相差的天数 (select datediff(now(),date_add(now(),interval 2 month)) as \u0026lsquo;计算两个日期之间相差天数\u0026rsquo;)\n  流程函数  if 函数  create table salary (userid int,salary decimal(9,2));\rinsert into salary values(1,1000),(2,2000), (3,3000),(4,4000),(5,5000), (1,null);\r (select if(s.salary\u0026gt;2000,\u0026lsquo;high\u0026rsquo;,\u0026lsquo;low\u0026rsquo;),s.salary from salary s)   IFNULL(value1,value2)函数：这个函数一般用来替换 NULL 值的，我们知道 NULL 值是不能参与数值运算的   (select ifnull(s.salary,0),s.salary from salary s)当检测到值的时候用0代替  数值函数  ABS(x)函数：返回 x 的绝对值   select abs(-56),abs(round(rand()*10))   cell(x)函数 返回大于 x 的最大整数值 相当于向上取   SELECT ceil(0.6),ceiling(0.3),ceil(round(rand()))   floor()返回小于 x 的最大整数值 相当于向下取   SELECT floor(0.6),floor(0.3),floor(round(rand()))   mod(x,y) 返回 x/y 的模   SELECT mod(5,3)   rand() 返回 0 到 1 内的随机值 ROUND(x,y) 返回参数 x 的四舍五入的有 y 位小数的值   SELECT round(2.5,3)   sum()函数   select sum(f.f_price) as \u0026lsquo;总价格\u0026rsquo; from fruits f  字符串函数  CANCAT(S1,S2,…Sn) 连接 S1,S2,…Sn 为一个字符串   SELECT concat(\u0026lsquo;hello\u0026rsquo;,\u0026lsquo;wrold\u0026rsquo;),concat(curdate(),' \u0026lsquo;,curtime())   INSERT(str,x,y,instr) 将字符串 str 从第 x 位置开始，y 个字符长的子串替换为字符串 instr(可以用作修改和删除以及增加)   SELECT insert(\u0026lsquo;Highlights of Premier Li'\u0026rsquo;s news conference\u0026rsquo;,11,0,'\u0026mdash;') 在index=11 取0个字符串替换为xxx   REPEAT(str,x) 返回 str 重复 x 次的结果   select REPEAT(\u0026lsquo;Tech aims to help restless sleepers \\n\u0026rsquo;,3) 字符串重复3次   REPLACE(str,a,b)函数：用字符串 b 替换字符串 str 中所有出现的字符串 a。   select replace(\u0026lsquo;hello_world!\u0026rsquo;,'_\u0026rsquo;,' \u0026lsquo;) 把下划线替换为空格   SUBSTRING(str,x,y)函数：返回从字符串 str 中的第 x 位置起 y 个字符长度的字串。此函数经常用来对给定字符串进行字串的提取(ps也可以用作随机字符串)   select substring(\u0026lsquo;Century-old folding fan store attracts foreign apprentice\u0026rsquo;,12,8) 截取字符串函数   length() 获取字符串长度 select length(''+uuid_short()) as uuidShort , length(uuid()) 这里使用了mysql的uuid  ","pubDate":"2021-02-15","title":"mysql函数"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_mysql_mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/","plain":"MySQL 存储引擎概述  MySQL 5.0 支持的存储引擎包括 MyISAM、 InnoDB、 BDB、 MEMORY、 MERGE、 EXAMPLE、 NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED 等，其中 InnoDB 和 BDB 提供事务安 全表，其他存储引擎都是非事务安全表。\n  查看当前引擎 show ENGINES  MyISAM存储引擎  不支持事务、也不支持外键，优势是访问速度快，对事务完整性没有 要求或者以select，insert为主的应用基本上可以用这个引擎来创建表\n  支持3种不同的存储格式，分别是：静态表；动态表；压缩表   静态表：表中的字段都是非变长字段，这样每个记录都是固定长度的，优点存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多（因为存储时会按照列的宽度定义补足空格）ps：在取数据的时候，默认会把字段后面的空格去掉，如果不注意会把数据本身带的空格也会忽略。 动态表：记录不是固定长度的，这样存储的优点是占用的空间相对较少；缺点：频繁的更新、删除数据容易产生碎片，需要定期执行OPTIMIZE TABLE或者myisamchk-r命令来改善性能 压缩表：因为每个记录是被单独压缩的，所以只有非常小的访问开支\n  动态表：记录不是固定长度的，这样存储的优点是占用的空间相对较少；缺点：频繁的更新、删除数据容易产生碎片，需要定期执行OPTIMIZE TABLE或者myisamchk-r命令来改善性能\n  压缩表：因为每个记录是被单独压缩的，所以只有非常小的访问开支\n InnoDB存储引擎  nnoDB 存储表和索引有两种方式\n  使用共享表空间存储，这种方式创建的表的表结构保存在.frm 文件中，数据和索引 保存在 innodb_data_home_dir 和 innodb_data_file_path 定义的表空间中，可以是 多个文件。 使用多表空间存储，这种方式创建的表的表结构仍然保存在.frm 文件中，但是每个 表的数据和索引单独保存在.ibd 中。如果是个分区表，则每个分区对应单独的.ibd 文件，文件名是“表名+分区名” ，可以在创建分区的时候指定每个分区的数据文件 的位置，以此来将表的 IO 均匀分布在多个磁盘 多表空间的数据文件没有大小限制，不需要设置初始大小，也不需要设置文件的最大限 制、扩展大小等参数。 对于使用多表空间特性的表，可以比较方便地进行单表备份和恢复操作，但是直接复 制.ibd 文件是不行的，因为没有共享表空间的数据字典信息，直接复制的.ibd 文件和.frm 文 件恢复时是不能被正确识别的，但可以通过以下命令：  ALTER TABLE tbl_name DISCARD TABLESPACE;\rALTER TABLE tbl_name IMPORT TABLESPACE;\rMEMORY存储引擎  Memory存储引擎使用存在于内存中的内容来创建表。每个memory表只实际对应一个磁盘文件，格式是.frm。 memory类型的表访问非常的快，因为它的数据是放在内存中的，并且默认使用HASH索引，但是一旦服务关闭，表中的数据就会丢失掉。 MEMORY存储引擎的表可以选择使用BTREE索引或者HASH索引，两种不同类型的索引有其不同的使用范围\n  Hash索引优点： Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。 Hash索引缺点： 那么不精确查找呢，也很明显，因为hash算法是基于等值计算的，所以对于“like”等范围查找hash索引无效，不支持；\n  Memory类型的存储引擎主要用于哪些内容变化不频繁的代码表，或者作为统计操作的中间结果表，便于高效地对中间结果进行分析并得到最终的统计结果，。 对存储引擎为memory的表进行更新操作要谨慎，因为数据并没有实际写入到磁盘中，所以一定要对下次重新启动服务后如何获得这些修改后的数据有所考虑。\n MERGE存储引擎  Merge存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，merge表本身并没有数据，对merge类型的表可以进行查询，更新，删除操作，这些操作实际上是对内部的MyISAM表进行的。\n ","pubDate":"2021-02-15","title":"mysql存储引擎"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_mysql_mysql%E6%9F%A5%E8%AF%A2/","plain":"mysql学习(下面所有都是针对mysql而言) sql排序语句  升序   (select f.* from fruits f WHERE s_id IN (101,102) order by f_name)==(select f.* from fruits f WHERE s_id IN (101,102) order by f_name asc)   对于sql的升序而言,当使用了order by之后如果不添加desc那么默认是升序 order by f_name 和 order by f_name ASC 效果一致 降序   (select f.* from fruits f WHERE s_id not IN (101,102) order by f_name DESC )   order by之后加上DESC结果集就是降序   上面结合了 关键字in可以看到 in (101,102)和not in (101,102)\n 带between and 的范围查询  (select f.* from fruits f WHERE f.f_price between 2.00 and 14.00)查询价格在2.00元到14.00元之间的数据,这样也可以(select f.* from fruits f WHERE f.f_price\u0026gt;2.00 and f.f_price\u0026lt;12.67)  带like的字符串匹配查询  (select f.* from fruits f WHERE f.f_name like \u0026lsquo;%g%')查询f_name包含g的记录 (select f.* from fruits f WHERE f.f_name like \u0026lsquo;b%')查询以b开头的记录,同理结尾的字符也是一样原理  查询null值  (select c.* from customers c WHERE c.c_email is null)查询email为null的数据  带and 的多条件查询  (select f.* from fruits f WHERE f.s_id=\u0026lsquo;101\u0026rsquo; and f.f_price\u0026gt;=5)  带or 的多条件查询  (select f.* from fruits f WHERE f.s_id=\u0026lsquo;101\u0026rsquo; or f.s_id=\u0026lsquo;102\u0026rsquo;)  查询结果不重复  (select distinct f.* from fruits f)添加了过滤字段distinct  分组查询  (select f.s_id,count(*) as total from fruits f group by f.s_id) (select f.s_id,count(*) as total,group_concat(f.f_name) as g_name from fruits f group by f.s_id) 这里使用了一个函数group_concat (select f.s_id,count(*) as total,group_concat(f.f_name) as g_name,sum(f.f_price) as price from fruits f group by f.s_id)  HAVING  [在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用]   (select f.s_id,count(*) as total,group_concat(f.f_name) as g_name,sum(f.f_price) as price from fruits f group by f.s_id having sum(f.f_price)\u0026gt;20)  分页查询  (select f.* from fruits f LIMIT 10,5) ||(3-1)*5,5  连接查询(多表)  (select c.,o. from customers c,orders o where c.c_id=o.c_id)普通查询 (select c.,o. from customers c inner join orders o on o.c_id=c.c_id)内连接查询,这里需要注意的是内连接查询的是公共部分,必须是两者都有相同的记录 外连接包括左外连接和右外连接 (select c.,o. from customers c right join orders o on o.c_id=c.c_id)右连接是orders table和customers table的公共部分+orders表记录 (select c.,o. from customers c left join orders o on o.c_id=c.c_id)左连接是orders table和customers table的公共部分+customers表记录 (由于mysql不支持全连接full join,所以必须采用其它方法)//select * from orders full join customers on orders.c_id=customers.c_id  索引 create table myUser(\rid VARCHAR(255) NOT NULL PRIMARY KEY ,\rname VARCHAR(255),\rcreateTime TIMESTAMP,\rINDEX indexName (name(244))\r)ENGINE=InnoDB DEFAULT CHARSET=utf8\r (show INDEX from myUser)查看所在表的索引  DROP TABLE IF EXISTS user_test;\rCREATE TABLE user_test(\rid int AUTO_INCREMENT PRIMARY KEY,\ruser_name varchar(30) NOT NULL,\rsex bit(1) NOT NULL DEFAULT b'1',\rcity varchar(50) NOT NULL,\rage int NOT NULL\r) ENGINE=InnoDB DEFAULT CHARSET=utf8\r 创建一个组合索引： ALTER TABLE user_test ADD INDEX idx_user(user_name , city , age) 匹配最左前缀是指优先匹配最左索引列，如：上面创建的索引可用于查询条件为：（user_name ）、（user_name, city）、（user_name , city , age）  注：满足最左前缀查询条件的顺序与索引列的顺序无关，如：（city, user_name）、（age, city, user_name）\n","pubDate":"2021-02-15","title":"mysql查询"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_mysql_mysql%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90/","plain":" mysql.version=5.7 (必须注意版本)\n 创建用户  ( CREATE USER \u0026lsquo;bob\u0026rsquo;@'%' IDENTIFIED BY \u0026lsquo;07fa533360d9\u0026rsquo;; ) 创建bob用户 密码:07fa533360d9 ( CREATE USER \u0026ldquo;test\u0026rdquo;@\u0026ldquo;localhost\u0026rdquo; IDENTIFIED BY \u0026lsquo;123456\u0026rsquo; )创建test用户　密码123456 ( CREATE USER \u0026ldquo;test\u0026rdquo;@\u0026ldquo;192.168.87.26\u0026rdquo; IDENTIFIED BY \u0026lsquo;123456\u0026rsquo; )创建test用户　密码123456   参数说明:'%\u0026lsquo;表示所有情况都能访问;\u0026lsquo;localhost\u0026rsquo;表示本机才能访问;\u0026lsquo;192.168.87.26\u0026rsquo; 某个具体 ip 才能访问\n 授权命令 (GRANT privileges ON databasename.tablename TO \u0026lsquo;username\u0026rsquo;@\u0026lsquo;host\u0026rsquo; ) GRANT SELECT,INSERT privileges on spring.* to \u0026lsquo;alice\u0026rsquo;@\u0026lsquo;localhost\u0026rsquo; identified by \u0026lsquo;123456\u0026rsquo;\n 参数说明:databasename表示数据库名字;tablename数据库表的名字;username用户名;host表示链接地址如本机localhost,远程任意%,具体ip192.168.87.26\n 授权test用户拥有testDB数据库的所有权限 create database testDB;\rgrant all privileges on testDB.* to \u0026quot;test\u0026quot;@\u0026quot;localhost\u0026quot; identified by '123456'\r指定部分权限给用户 grant select,update on testDB.* to \u0026quot;blake\u0026quot;@\u0026quot;localhost\u0026quot; identified by '123456';\rGRANT SELECT, INSERT ON spring.user TO 'alice'@'localhost'; 撤销权限 REVOKE privilege ON databasename.tablename FROM 'username'@'host'; #撤销\rREVOKE grant option ON databasename.tablename FROM 'username'@'host'; #收回\r修改用户密码 update mysql.user set authentication_string=password('123456') where User='blake' and Host='localhost';\r 关于修改密码也可以这样 1:select password(\u0026lsquo;1234\u0026rsquo;); 得到string 如1234==\u0026gt;*A4B6157319038724E3560894F7F932C8886EBFCF\n update mysql.user set authentication_string=\u0026quot;*A4B6157319038724E3560894F7F932C8886EBFCF\u0026quot; where User='bob' and Host='localhost';\r 关于远程访问修改\n UPDATE user SET Host='%' WHERE User='alice' AND Host='localhost' LIMIT 1;\rUPDATE user SET Host='192.168.87.26' WHERE User='alice' AND Host='%' LIMIT 1;\r删除用户bob delete from user WHERE User='bob'\r刷新系统权限表 flush privileges; 查看权限 show grants for 'blake'@'localhost';\r","pubDate":"2021-02-15","title":"mysql用户与权限"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_mysql_mysql%E7%B4%A2%E5%BC%95/","plain":"索引  所有 MySQL 列类型都可以被索引，对相关列使用索引是提高 SELECT 操作性能的最佳途 径.根据存储引擎可以定义每个表的最大索引数和最大索引长度， 每种存储引擎 （如 MyISAM、 InnoDB、BDB、MEMORY 等）对每个表至少支持 16 个索引，总索引长度至少为 256 字节。 大多数存储引擎有更高的限制。\n  MyISAM 和 InnoDB 存储引擎的表默认创建的都是 BTREE 索引。MySQL 目前还不支持函 数索引，但是支持前缀索引，即对索引字段的前 N 个字符创建索引。前缀索引的长度跟存 储引擎相关，对于 MyISAM 存储引擎的表，索引的前缀长度可以达到 1000 字节长，而对于 InnoDB 存储引擎的表，索引的前缀长度最长是 767 字节。请注意前缀的限制应以字节为单 位进行测量，而 CREATE TABLE 语句中的前缀长度解释为字符数。\n  MySQL 中还支持全文本（FULLTEXT）索引，该索引可以用于全文搜索。但是当前最新版 本中（5.0）只有 MyISAM 存储引擎支持 FULLTEXT 索引，并且只限于 CHAR、 VARCHAR 和 TEXT 列。索引总是对整个列进行的，不支持局部（前缀）索引\n  默认情况下，MEMORY 存储引擎使用 HASH 索引，但也支持 BTREE 索引\n ","pubDate":"2021-02-15","title":"mysql索引"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_linux_nginx/","plain":"nginx学习 基础操作  start ./sbin/nginx stop ./sbin/nginx -s stop quite ./sbin/nginx -s quit   启动成功标志\n Welcome to nginx!\r 默认监听的端口是80 也就是说访问此端口就可以得到启动成功的标识符号\n  简单的负载均衡配置    http 模块中配置  #配置开始 author zhou\rupstream myproject{\rserver 127.0.0.1:8000 weight=3;\rserver 127.0.0.1:8080 weight=10;\rserver 127.0.0.1:8090;\r}\r#配置结束 author zhou\r location模块配置  proxy_pass http://myproject;\r注意:这的myproject要和上面的name一致\r测试结果 (这的测试用到了session的唯一性)\n http://localhost/nginx_test/ sessionId=8D9C4ACEE65EB24301B1C0D9E4CF3A6E\rhttp://localhost:8080/nginx_test/ sessionId=8D9C4ACEE65EB24301B1C0D9E4CF3A6E\rhttp://localhost:8090/nginx_test/ sessionId=7539B2C4AFD433ECEFAC8F2B2EBCC411\r 由于配置了权重 因此大部分是8080端口\n参数解释   1）down\n表示单前的server暂时不参与负载\n  2）Weight\n默认为1.weight越大，负载的权重就越大。\n  3）max_fails\n允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误\n  4）fail_timeout\nmax_fails 次失败后，暂停的时间。\n  5）Backup\n其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。\n  service nginx start\rservice nginx stop\rnginx\r","pubDate":"2021-02-15","title":"nginx"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_linux_notepad++%E5%AE%89%E8%A3%85/","plain":"Notepad++是一套非常有特色的自由软件的纯文字编辑器(许可证:GPL)。有完整的中文化接口及支持多国语言编写的功能(UTF8 技术)。 它的功能比 Windows 中的 Notepad(记事本)强大，除了可以用来制作一般的纯文字说明文件，也十分适合当作编写电脑程序的编辑器。 Notepad++ 不仅有语法高亮度显示，也有语法折叠功能，并且支持宏以及扩充基本功能的外挂模组。但是可惜的是Notepad++只能在Windows平台下使用。 工作中必须使用Windows时，Notepad++是众多程序员最喜爱的文本编辑器，在Ubuntu下是否能够使用到相同的软件呢？Notepadqq就是这样一款与Notepad++非常接近的编辑器，拥有几乎相同的功能。 如果您是一个Notepad++粉丝，我们推荐您尝试下Notepadqq。\n对于Ubuntu发行版本可以通过PPA安装，命令如下： sudo add-apt-repository ppa:notepadqq-team/notepadqq sudo apt-get update sudo apt-get install notepadqq 类似的，卸载命令如下：\nsudo apt-get remove notepadqq sudo add-apt-repository \u0026ndash;remove ppa:notepadqq-team/notepadqq\n","pubDate":"2021-02-15","title":"Notepad++安装"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_selfeducation_number/","plain":"① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳\n㉑ ㉒ ㉓ ㉔ ㉕ ㉖ ㉗ ㉘ ㉙ ㉚ ㉛ ㉜ ㉝ ㉞ ㉟ ㊱ ㊲ ㊳ ㊴ ㊵ ㊶ ㊷ ㊸ ㊹ ㊺ ㊻ ㊼ ㊽ ㊾ ㊿\n","pubDate":"2021-02-15","title":"number"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_postgresql_postgresql_create%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90/","plain":"权限  系统权限 role和user都是用户,只不过role属性不能登录当然也可以指定 超级权限 不做权限检查(实际中是很危险的)\n Pg权限分为两部分，一部分是“系统权限”或者数据库用户的属性，可以授予role或user（两者区别在于login权限）；\r一部分为数据库对象上的操作权限。对超级用户不做权限检查，其它走acl。\r对于数据库对象，开始只有所有者和超级用户可以做任何操作，其它走acl。\r在pg里，对acl模型做了简化，组和角色都是role，用户和角色的区别是角色没有login权限。\r超级权限  创建超级用户(create user alice with superuser password \u0026lsquo;123456\u0026rsquo;;)系统不会做权限操作校验,仅仅是不能够创建用户与删除用户  系统权限   (create role blake password \u0026lsquo;123456\u0026rsquo;;)(create user bob password \u0026lsquo;123456\u0026rsquo;;)(create database testdb;)\n  (grant all on database testdb to bob;grant all on database testdb to blake;)\n  测试如下 用户bob可以登录而blake不能登录直接抛出了FATL:role blake is not \u0026lsquo;permitted to log in\u0026rsquo;\n  ( drop database testdb;drop role blake;drop user bob;)\n  (create user bob password \u0026lsquo;123456\u0026rsquo;;)(alter user bob set default_transaction_read_only=on;grant all on database testdb to bob;grant select on all tables in schema public to bob; )\n  (revoke all on database testdb from bob;revoke select on all tables in schema public from bob;)删除前撤销(drop user bob)\n  (grant DELETE,UPDATE,SELECT,INSERT on all tables in schema public to bob;)\n  查询  查询系统中用户的权限(SELECT * FROM pg_roles;) 显示用户和用户的用户属性(\\du) 查看全部可设置的管理权限(\\h)  删除  (drop user bob) (drop role bob)要注意在删除前必须把权限先删除,还有一种笨办法就是把数据库先备份然后在删除这时就可以删除用户了  系统登录  (sudo su postgres -c psql template1)(psql -U alice -d testdb -h localhost -W)参数含义: -U指定用户 -d要连接的数据库 -h要连接的主机 -W提示输入密码。  修改系统密码  (sudo passwd -d postgres)  sudo su postgres -c psql template1\r会出现 postgres=#\r输入postgres=# \\password\r输入２次密码\r然后输入(退出)\rpostgres=# \\q\r","pubDate":"2021-02-15","title":"postgresql \u003e create用户与权限"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_redis_redis/","plain":"一.Redis介绍 1.1引言  1:由于用户量大，请求了随之增大，数据压力过大。 2:多台服务器之间数据不同步 3:多台服务器之间的锁已经不存在互斥性了\n  1.2 NOSQL  redis就是nosql\n  非关系数据库 \u0026gt; not only sql\n 1:key-value redis 2:文档型 solr,Mongodb,ElasticSearch 3:面向列 Hbase(一般大数据) 4:图形化 Neo4j\n  1.3 redis介绍  Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 Redis是一款基于Key-Value的NOSQL，而且Redis是基于内存存储数据的,Redis还提供了多种持久化机制，Redis还提供了主从、哨兵以及集群的搭建方式，可以更方便的横向扩展以及垂直扩展\n  操作都是原子的\n 所有 Redis 的操作都是原子的，从而确保当两个客户同时访问 Redis 服务器时，得到的是更新后的值（最新值）。在需要高并发的场合可以考虑使用 Redis 的事务，处理一些需要锁的业务。\n  二.Redis安装 三.Redis命令  keys * 获取所有的key\rclear 清除屏幕\rquit ,exit 退出\rset name blake 设置值\rsetex ip 5 192.1.1.168 设置值并且设置过期时长\rget name 取出值\rdel name 删除key所对应的值\rexists key 判断是否存在key\rmset key1,key2...设置多个值\rmget key1,key2...取出多个值\rappend age 1 追加key的value\rstrlen key 获取某个key的value的长度\rselect index 选择数据库 (注意redis一共16个数据库 并且从0开始)\rmove key db或者 move key index (redis一共16个数据库 move age 7) 将某个key移动到某个数据库中\rflushdb 清除当前数据库\rflushall 清除16个数据库\rtype key 获取数据类型 (type name == \u0026gt; string)\r3.1 redis存储数据结构  字符串列表 key-string 无序不重复的字符串集合 key-set 有序不重复的字符串集合 key-list 键、值都为字符串的哈希表 key-hash 有序集合 key-zset  3.2存储结构用处  key-string :最常用的，一般用于存储一个值 key-hash:存储一个对象数据的 key-list:使用list结构实现栈和队列结构 key-set: 交集、差集、并集操作 key-zset : 排行榜,积分存储  ","pubDate":"2021-02-15","title":"redis"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_study_script/","plain":"脚本  dos,lua,sheel,python,js\n   dos 可以使用VisualBat编辑器编写以及调试\n  lua 可以运行在redis ,dos,Java,c++等里面另外还可以用来写触屏精灵 http://www.touchsprite.com/docs/5362 ==\u0026gt; https://www.zybuluo.com/miniknife/note/317045#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5\n  sheel脚本 运行在linux或者unix上相当于windows上的dos\n  python 胶水语言 可以直接在linux当成sheel使用,也是人工智能的一种使用工具\n  js 浏览器脚本\n  ","pubDate":"2021-02-15","title":"script"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/","plain":"Spring boot 教 程 目录   Spring boot helloworld  介绍     自从structs2 出现上次的漏洞以后，对spring 的关注度开始越来越浓。\n以前 spring 开发需要配置一大堆的 xml,后台 spring 加入了 annotaion，使得 xml 配置简化了很多，当然还是有些配置需要使用xml,比如申明component scan 等。\nSpring 开了一个新的model spring boot,主要思想是降低spring 的入门，使得新手可以以最快的速度让程序在spring 框架下跑起来。\n那么如何写Hello world 呢？ Hello 之步骤:\n (1) 新建一个Maven Java 工程\n(2) 在pom.xml 文件中添加Spring Boot Maven 依赖(3)编写启动类\n (4)运行程序\n  Hello 之New   这个步骤很简单，相比大家都会，小编在此为了文档的完整性，稍作简单说明：\n首先使用 IDE（Eclipse,MyEclipse）工具新建一个 Maven 工程，可以是 Maven Java Project,也可以是 Maven Web Project,随便取一个工程名称。我使用的是STS，工程名是spring-boot-hello1。\n  Hello 之Maven   第二步，在 pom.xml 中引入 spring-boot-start-parent,spring 官方的解释叫什么 stater poms,它可以提供dependency management,也就是说依赖管理，引入以后在申明其它 dependency 的时候就不需要 version 了， 后面可以看到。\n  Hello 之maven web   第三步，因为我们开发的是 web 工程，所以需要在 pom.xml 中引入 spring-boot-starter-web,spring 官方解释说spring-boot-start-web 包含了spring webmvc 和tomcat 等web 开发的特性。\n  Hello 之Maven Run Application   如果我们要直接 Main 启动 spring，那么以下 plugin 必须要添加，否则是无法启动的。如果使用 maven 的spring-boot:run 的话是不需要此配置的。（我在测试的时候，如果不配置下面的 plugin 也是直接在 Main 中运行的。）\n  Hello 之coding   第四步，真正的程序开始啦，我们需要一个启动类，然后在启动类申明让 spring boot 自动给我们配置spring 需要的配置，比如：@SpringBootApplication,为了可以尽快让程序跑起来，我们简单写一个通过浏览器访问 hello world 字样的例子：\n其中@SpringBootApplication 申明让 spring boot 自动给程序进行必要的配置，等价于以默认属性使用\n@Configuration，@EnableAutoConfiguration 和@ComponentScan\n@RestController 返回json 字符串的数据，直接可以编写RESTFul 的接口；\n  Hello 之Run   第五步，就是运行我们的Application 了，我们先介绍第一种运行方式。第一种方式特别简单：右键Run As\n-\u0026gt; Java Application。之后打开浏览器输入地址：[http://127.0.0.1:8080/]{.underline} 就可以看到Hello world!了。第二种方式右键project \u0026ndash; Run as \u0026ndash; Maven build \u0026ndash; 在Goals 里输入spring-boot:run ,然后Apply,最后点击Run。\n  Hello 之Error   顺利的情况下当然是皆大欢喜了，但是程序吧往往会给你开个小玩笑。那么我们要注意什么呢？主要是 jdk 的版本之类的，请看官方说明：\n {width=\u0026ldquo;5.213333333333333in\u0026rdquo; height=\u0026ldquo;1.4266655730533684in\u0026rdquo;}\n Spring boot 返回 json 数据   在做如下操作之前，我们对之前的 Hello 进行简单的修改，我们新建一个包 com.hpit.test.web 然后新建一个类HelloControoler, 然后修改App.java 类，主要是的这个类就是一个单纯的启动类。\n主要代码如下： App.java\npublic class App {\ncom.hpit.test.web.HelloController ：\n运行代码和之前是一样的效果的。\n我们在编写接口的时候，时常会有需求返回 json 数据，那么在 spring boot 应该怎么操作呢？主要是在 class 中加入注解@RestController,。\n返回 JSON 之步骤：\n(1)编写一个实体类Demo (2)编写DemoController；\n(3)在DemoController 加上@RestController 和@RequestMapping 注解； (4)测试\n具 体 代 码 如 下 ： com.hpit.test.bean.Demo :\ncom.hpit.test.web.DemoController：\n那么在浏览器访问地址：[http://127.0.0.1:8080/demo/getDemo]{.underline} 返回如下数据：\n{\nid: 1,\nname: \u0026quot;Zjs\u0026quot;\n}\n是不是很神奇呢，其实Spring Boot 也是引用了JSON 解析包Jackson，那么自然我们就可以在 Demo 对象上使用Jackson 提供的json 属性的注解，对时间进行格式化，对一些字段进行忽略等等。\nSpring boot 热部署\n在编写代码的时候，你会发现我们只是简单把打印信息改变了下，就需要重新部署，如果是这样的编码方式，那 么我们估计一天下来之后就真的是打几个 Hello World 之后就下班了。那么如何解决热部署的问题呢？那就是springloaded，加入如下配置：\n如果是使用spring-boot:run 的话，那么到此配置结束，现在你就可以体验coding\u0026hellip;coding 的爽了。如果使用的run as \u0026ndash; java application 的话，那么还需要做一些处理哦：\n把 spring-loader-1.2.4.RELEASE.jar 下载下来，放到项目的 lib 目录中，然后把 IDEA 的 run 参数里 VM 参数设\n置为：\n-javaagent:.\\lib\\springloaded-1.2.4.RELEASE.jar -noverify\n然后启动就可以了，这样在run as 的时候，也能进行热部署了。\n  Spring boot 使用其他 json 转换框架   个人使用比较习惯的 json 框架是 fastjson,所以 spring boot 默认的 json 使用起来就很陌生了，所以很自然我就想我能不能使用fastjson 进行json 解析呢？\n这里要说下很重要的话，官方文档说的 1.2.10 以后，会有两个方法支持 HttpMessageconvert，一个是FastJsonHttpMessageConverter，支持 4.2 以下的版本，一个是 FastJsonHttpMessageConverter4 支持 4.2 以上的版本，具体有什么区别暂时没有深入研究。这里也就是说：低版本的就不支持了，所以这里最低要求就是1.2.10+。\n配 置 fastjon\n支持两种方法： 第一种方法：\n   启动类继承extends WebMvcConfigurerAdapter\n  覆盖方法configureMessageConverters 第二种方法:\n   （1）在App.java 启动类中，注入Bean : HttpMessageConverters 具体代码如下：\n代码：App.java\nimport java.util.List;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.http.converter.HttpMessageConverter;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;\nimport com.alibaba.fastjson.serializer.SerializerFeature;\nimport com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter;\n//如果想集成其他的[json]{.underline}框架需要继承WebMvcConfigurerAdapter，并重写configureMessageConverters @SpringBootApplication\npublic class App extends WebMvcConfigurerAdapter {\n// 第一种方式，重写configureMessageConverters，并将FastJsonConverter设置到系统中\n@Override\npublic void configureMessageConverters(List\u0026lt;HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; converters) { FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter(); converter.setFeatures(SerializerFeature.PrettyFormat);\nconverters.add(converter);\nsuper.configureMessageConverters(converters);\n}\n// 第二种方法：注入beanHttpMessageConverters\n  Spring boot 全局异常捕捉   在一个项目中的异常我们我们都会统一进行处理的，那么如何进行统一进行处理呢？ 新建一个类GlobalDefaultExceptionHandler，\n在class 注解上@ControllerAdvice,\n@CONTROLLERADVICE：即把@CONTROLLERADVICE 注解内部使用@EXCEPTIONHANDLER、@INITBINDER、\n@MODELATTRIBUTE 注解的方法应用到所有的 @REQUESTMAPPING 注解的方法。非常简单，不过只有当使用@EXCEPTIONHANDLER 最有用，另外两个用处不大。\n在方法上注解上@ExceptionHandler(value = Exception.class)，具体代码如下\n[com.hpit.test.web]{.underline}.DemoController 加入方法：\n访问：[http://127.0.0.1:8080/zeroException]{.underline} 这个方法肯定是抛出异常的,那么在控制台就可以看到我们全局捕捉的异常信息了\n  Spring boot JPA 连接数据库   在任何一个平台都逃离不了数据库的操作，那么在spring boot 中怎么接入数据库呢？\n很简单，我们需要在 application.properties 进行配置一下，application.properties 路径是src/main/resources 下，对于application.properties 更多的介绍请自行百度进行查找相关资料进行查看，在此不进行过多的介绍，以下只是mysql 的配置文件。\n大体步骤：\n (1) 在application.properties 中加入datasouce 的配置\n(2) 在pom.xml 加入mysql 的依赖。\n(3) 获取DataSouce 的Connection 进行测试。\n src/main/resouces/application.properties：\npom.xml 配置：\n到此相关配置就ok 了，那么就可以在项目中进行测试了，我们可以新建一个 class Demo 进行测试，实体类创建完毕之后，我们可能需要手动进行编写建表语句，这时候我们可能就会想起 Hibernate 的好处了。那么怎么在spring boot 使用Hibernate 好的特性呢？So easy,具体怎么操作，请看下篇之JPA \u0026ndash; Hibernate。\n  Spring boot 配 置 JPA   在说具体如何在spring boot 使用Hibernate 前，先抛装引玉些知识点？什么是JPA 呢？\nJPA 全称Java Persistence API.JPA 通过JDK 5.0 注解或XML 描述对象－关系表的映射关系，并将运行期的实体[对象持久化]{.underline}到数据库中。\n[http://baike.baidu.com/link?url=LdqIXvzTr0RDjY2yoRdpogDdzaZ_L-]{.underline}\n[DrIOpLLzK1z38quk6nf2ACoXEf3pWKTElHACS7vTawPTmoFv_QftgT_q]{.underline}\n接下里就说本文章重点了，那么怎么操作呢？只需要如下配置就可以了？ pom.xml 配置：\n\u0026lt;/dependency\u0026gt;\napplication.properties 配置：\n那么就可以使用Hibernate 带来的好处了，在实体类注解@Entity 就会自动进行表的DDL 操作了\n我们在 [com.hpit.test.bean]{.underline}.Demo 中加入注解：@Entity\n这时候运行就会在数据库看到demo 表了。\n  Spring boot 整合 JPA 保存数据   总体步骤：\n (1) 创建实体类Demo,如果已经存在，可以忽略。\n(2) 创建jpa repository 类操作持久化。\n(3) 创建service 类。\n(4) 创建restful 请求类。\n(5) 测试\n 代 码 如 下 ： com.hpit.test.bean.Demo ：\n[com.hpit.test.dao]{.underline}.DemoRepository（这是一个接口，没有具体的实现，这就是JPA）:\n到这里保存数据的方法就写完了。CrudRepository 类把一些常用的方法都已经进行定义和实现了。那么你现在就可以在别的类引入调用了。\n另外就是在Spring Data 的核心接口里面Repository 是最基本的接口了, spring 提供了很多实现了该接口的基本接口,如:CrudRepository，PagingAndSortingRepository，SimpleJpaRepository，QueryDslJpaRepository 等大量查询接口\ncom.hpit.test.service.DemoService :\n开发数据保存控制器：\n{width=\u0026ldquo;5.453333333333333in\u0026rdquo; height=\u0026ldquo;1.5in\u0026rdquo;}运行程序，查看效果：\n  Spring boot 使用 JdbcTemplate 保存数据   整体步骤：\n (1) 在pom.xml 加入jdbcTemplate 的依赖；\n(2) 编写DemoDao 类，声明为：@Repository，引入JdbcTemplate\n(3) 编写DemoService 类，引入DemoDao 进行使用\n(4) 编写Demo2Controller 进行简单测试。具体操作流程如下：\n 使用JdbcTemplate 类需要加入（如果在JPA 已经加入的话，这个步骤就可以忽略了） 那么只需要在需要使用的类中加入：\n这样就可以使用jdbcTemplate 进行数据库的操作了。比如：\n具体案例\n定义Dao 层代码\n  开发业务逻辑层\n  开发控制器\n  启动应用，查看效果\n  {width=\u0026ldquo;5.683287401574803in\u0026rdquo; height=\u0026ldquo;2.1458333333333335in\u0026rdquo;}\n 当前前提是你的数据库中有id=1 的数据了，不然会报错的： org.springframework.dao.EmptyResultDataAccessException\n  Spring boot 常用配置   程序基本配置   Spring boot 默认端口是 8080，如果想要进行更改的话，只需要修改 applicatoin.properties 文件，在配置文件中加入：\n常用配置：\n######################################################## ###EMBEDDED SERVER CONFIGURATION (ServerProperties) ########################################################\n#server.port=8080\n#server.address= # bind to a specific NIC #server.session-timeout= # session timeout in seconds #the context path, defaults to '/'\n#server.context-path=/spring-boot **#**修改默认访问路径\n#server.servlet-path= # the servlet path, defaults to '/' #server.tomcat.access-log-pattern= # log pattern of the access log #server.tomcat.access-log-enabled=false # is access logging enabled #server.tomcat.protocol-header=x-forwarded-proto # ssl forward headers #server.tomcat.remote-ip-header=x-forwarded-for\n#server.tomcat.basedir=/tmp # base dir (usually not needed, defaults to tmp) #server.tomcat.background-processor-delay=30; # in seconds #server.tomcat.max-threads = 0 # number of threads in protocol handler\n#server.tomcat.uri-encoding = UTF-8 # character encoding to use for URL decoding\n  修改 java 编译版本   Spring Boot 在编译的时候，是有默认 JDK 版本的，如果我们期望使用我们要的 JDK 版本的话，那么要怎么配置呢？\n这个只需要修改pom.xml 文件的\u0026lt;build\u0026gt; -- \u0026lt;plugins\u0026gt;加入一个plugin 即可。\n添加了plugin 之后，需要右键 Maven à Update Projects,这时候你可以看到工程根目录下的JRE System Library 版本更改了。\n  Spring boot 静态资源处理  默认静态资源处理  Spring Boot 默认为我们提供了静态资源处理，使用 WebMvcAutoConfiguration 中的配置各种属性。建议大家使用Spring Boot 的默认配置方式，如果需要特殊处理的再通过配置进行修改。\n如果想要自己完全控制 WebMVC ，就需要在@Configuration 注解的配置类上增加@EnableWebMvc\n（ @SpringBootApplication 注 解 的 程 序 入 口 类 已 经 包 含 @Configuration ）， 增 加 该 注 解 以 后WebMvcAutoConfiguration 中配置就不会生效，你需要自己来配置需要的每一项。这种情况下的配置还是要多看一下WebMvcAutoConfiguration 类。\n我们既然是快速使用Spring Boot，并不想过多的自己再重新配置。本文还是主要针对 Spring Boot 的默认处理方\n式，部分配置在application 配置文件中（.properties 或 .yml）\n默认资源映射\n我们在启动应用的时候，可以在控制台中看到如下信息：\n2016-01-08 09:29:30.362 INFO 24932 ---[ main]o.s.w.s.handler.SimpleUrlHandlerMapping : MappedURLpath[/webjars/**]ontohandleroftype[class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]\n2016-01-08 09:29:30.362 INFO 24932 ---[ main]o.s.w.s.handler.SimpleUrlHandlerMapping : MappedURLpath[/**]ontohandleroftype[class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]\n2016-01-08 09:29:30.437 INFO 24932 ---[ main]o.s.w.s.handler.SimpleUrlHandlerMapping :\nMappedURLpath[/**/favicon.ico]ont\n其中默认配置的 /** 映射到 /static （或/public、/resources、/META-INF/resources） 其中默认配置的 /webjars/** 映射到 classpath:/META-INF/resources/webjars/\nPS：上面的 static、public、resources 等目录都在 classpath: 下面（如 src/main/resources/static）。\n如果我按如下结构存放相同名称的图片，那么Spring Boot 读取图片的优先级是怎样的呢？\n{width=\u0026ldquo;1.886042213473316in\u0026rdquo; height=\u0026ldquo;2.34375in\u0026rdquo;}如下图：\n当我们访问地址 [http://localhost:8080/test.jpg]{.underline} 的时候，显示哪张图片？这里可以直接告诉大家，优先级顺序为： META/resources \u0026gt; resources \u0026gt; static \u0026gt; public (已进行测试)\n如果我们想访问test2.jpg，请求地址 [http://localhost:8080/img/test2.jpg]{.underline}\n 自定义静态资源处理  面我们介绍了Spring Boot 的默认资源映射，一般够用了，那我们如何自定义目录？\n这些资源都是打包在 jar 包中的，然后实际应用中，我们还有很多资源是在管理系统中动态维护的，并不可能在程序包中，对于这种随意指定目录的资源，如何访问？\n自定义目录\n以增加 /myres/* 映射到 classpath:/myres/* 为例的代码处理为：\n实现类继承 WebMvcConfigurerAdapter 并重写方法 addResourceHandlers （对于访问 myres 文件夹中的test.jpg 图片的地址为 [http://localhost:8080/myres/test.jpg]{.underline}\n访问myres 文件夹中的test.jpg 图片的地址为 [http://localhost:8080/myres/test.jpg]{.underline}\n这样使用代码的方式自定义目录映射，并不影响Spring Boot 的默认映射，可以同时使用。\n如果我们将/myres/* 修改为 /* 与默认的相同时，则会覆盖系统的配置，可以多次使用 addResourceLocations 添加目录，优先级先添加的高于后添加的。\n其 中 addResourceLocations 的 参 数 是 动 参 ， 可 以 这 样 写 addResourceLocations(\u0026ldquo;classpath:/img1/\u0026rdquo;,\n\u0026ldquo;classpath:/img2/\u0026rdquo;, \u0026ldquo;classpath:/img3/\u0026quot;);\n使用外部目录\n如果我们要指定一个绝对路径的文件夹（如 D:/data/api_files ），则只需要使用 addResourceLocations 指定即可。\n// 可以直接使用addResourceLocations 指定磁盘绝对路径，同样可以配置多个位置，注意路径写法需要加上file:\nregistry.addResourceHandler(\u0026quot;/api_files/**\u0026quot;).addResourceLocations(\u0026quot;file:D:/data/api_files\u0026quot;);\n  Srping boot 实现任务调度   spring boot 实现任务调度非常简单， 只需要在调度类头上添加@Configuration， 然后再调度方法上添加\n@Schuldle 注解，并为@Schuldle 指定CronExpress 表达式。代码如下：\n  Spring boot 普通类调用 Bean   我们知道如果我们要在一个类使用spring 提供的bean 对象，我们需要把这个类注入到 spring 容器中，交给 spring 容器进行管理，但是在实际当中，我们往往会碰到在一个普通的Java 类中，想直接使用spring 提供的其他对象或者说有一些不需要交给 spring 管理，但是需要用到 spring 里的一些对象。如果这是 spring 框架的独立应用程序，我们通过:\n这样的方式就可以很轻易的获取我们所需要的对象。\n但是往往我们所做的都是Web Application，这时我们启动 spring 容器是通过在web.xml 文件中配置，这样就不适合使用上面的方式在普通类去获取对象了，因为这样做就相当于加载了两次 spring 容器，而我们想是否可以通过在启动web 服务器的时候，就把Application 放在某一个类中，我们通过这个类在获取，这样就可以在普通类获取spring bean 对象了，让我们接着往下看。\n普通类调用 Spring bean 对象:\n可以参考：[http://412887952-qq-com.iteye.com/blog/1479445]{.underline}\n这里有更多这方面的介绍，比较详细，在这里只是抛装引玉说明在Spring Boot 是如何进行调用的。在Spring Boot 可以扫描的包下\n假设我们编写的工具类为SpringUtil。\n如果我们编写的 SpringUtil 在 Spring Boot 可以扫描的包下或者使用@ComponentScan 引入自定义的包了，那么原理很简单，只需要使得 SpringUtil 实现接口：ApplicationContextAware，然后加上@Component 注解即可， 具体编码如下：\n不在Spring Boot 的扫描包下方式一\n这种情况处理起来也很简单，先编写SpringUtil 类，同样需要实现接口：ApplicationContextAware，具体编\n码 如 下 ： simple.plugin.spring.SpringUtil package simple.plugin.spring;\nimport org.springframework.beans.BeansException;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.ApplicationContextAware;\n public class SpringUtil implements ApplicationContextAware{\nprivate static ApplicationContext applicationContext = null;\n @Override\npublic void setApplicationContext(ApplicationContext applicationContext) throws BeansException\n{\nif(SpringUtil.applicationContext == null){ SpringUtil.applicationContext = applicationContext;\n}\nSystem.out.println(\u0026quot; \u0026quot;); System.out.println(\u0026quot; \u0026quot;); System.out.println(\u0026quot;---------------simple.plugin.spring.SpringUtil--------------------------------------\n\u0026quot;);\nSystem.out.println(\u0026quot;========ApplicationContext 配 置 成 功 , 在 普 通 类 可 以 通 过 调 用SpringUtils.getAppContext() 获 取 applicationContext 对象,applicationContext=\u0026quot;+SpringUtil.applicationContext+\u0026quot;========\u0026quot;);\nSystem.out.println(\u0026quot; \u0026quot;);\n}\n//获取 applicationContext\npublic static ApplicationContext getApplicationContext() {\nreturnapplicationContext;\n}\n//通过 name 获取 Bean.\npublic static Object getBean(String name){\n之后这一步才是关键，使用@Bean 注解，在App.java 类中将SpringUtil 注解进来，代码如下：\n不在Spring Boot 的扫描包下方式二\n代码基本和上面都是相同的，主要是在App.java 中使用@Import 进行导入。\n而且在SpringUtil 是不需要添加@Component 注解\n说明以上 3 中方式都生效了，这 3 中方式根据实际情况选择一种方式就可以了。那么这样子在普通类既可以使用:\nSpringUtil.getBean() 获取到Spring IOC 容器中的bean。当然也可以在Spring 管理的类中使用：\n@Resouce 或者@Autowired 进行注入使用，当然我们这个类的核心是普通类可以调用 spring 的bean 进行使用了，是不是很神奇呢。\n  spring boot 使用模板引擎   使用 thymeleaf 模板引擎\n整体步骤：\n   在pom.xml 中引入thymeleaf;\n  如何关闭thymeleaf 缓存\n  编写模板文件.html\n   Spring Boot 默认就是使用thymeleaf 模板引擎的，所以只需要在pom.xml 加入依赖即可：\nThymeleaf 缓存在开发过程中， 肯定是不行的，那么就要在开发的时候把缓存关闭， 只需要在application.properties 进行配置即可：\n编写模板文件src/main/resouces/templates/helloHtml.html\n编写访问路径(com.hpit.test.web. ThymeleafController)：\n{width=\u0026ldquo;5.326610892388452in\u0026rdquo; height=\u0026ldquo;2.03125in\u0026rdquo;}启动应用，输入地址：http://127.0.0.1:8080/helloHtml 会输出：\n使用 freemarker 模板引擎\n使用freemarker 也很简单，\n在pom.xml 加入freemarker 的依赖\n剩下的编码部分都是一样的，说下application.properties 文件：\n开发freemarker 模板\nhelloHtml1.ftl\n开发控制器：\n{width=\u0026ldquo;7.13303258967629in\u0026rdquo; height=\u0026ldquo;1.2179166666666668in\u0026rdquo;}访问地址：[http://localhost:8080/freemarker/hello]{.underline}\nthymeleaf 和freemarker 是可以共存的。\n Spring boot 集成 JSP  这个部分比较复杂，所以单独创建一个工程来进行讲解；\n大体步骤：\n   创建Maven web project；\n  在pom.xml 文件添加依赖；\n  配置application.properties 支持jsp\n  编写测试Controller\n  编写JSP 页面\n  编写启动类App.java 1，FreeMarker 2，Groovy\n   3，Thymeleaf （Spring 官网使用这个） 4，Velocity\n5，JSP （貌似 Spring Boot 官方不推荐，STS 创建的项目会在 src/main/resources 下有个 templates 目录，这里就是让我们放模版文件的，然后并没有生成诸如 SpringMVC 中的webapp 目录）\n不过本文还是选择大家都熟悉的 JSP 来举例，因为使用 JSP 与默认支持的模版需要特殊处理，所以拿来举例更好。\n  创建Maven web project   使用Eclipse 新建一个Maven Web Project ，项目取名为： springboot02\n  在pom.xml 文件添加依赖   依赖包：\nJdk 编译版本：\n  application.properties 配置   上面说了spring-boot 不推荐JSP，想使用JSP 需要配置application.properties。添加src/main/resources/application.properties 内容：\n  编写测试Controller   编写类：com.hpit.sb.controller. HelloJSPController：\n  编写JSP 页面   在 src/main 下面创建 webapp/WEB-INF/views 目录用来存放我们的jsp 页面：index.jsp\n(6)编写启动类\n编写App.java 启动类：\n{width=\u0026ldquo;5.257905730533683in\u0026rdquo; height=\u0026ldquo;1.3854166666666667in\u0026rdquo;}运行程序，访问页面：\n附注：关于集成 JSP 几个问题：\n1、Spring Boot 使用 jsp 时，仍旧可以打成 jar 包的形式吗？\n2、Spring Boot 使用 jsp 时，比如说 css，image，js 等三种静态资源文件，应该放在什么目录下？这些静态资源映射，在 spring boot 中具体应该怎么做？\n例如，下面是 spring 中做的静态资源映射，但是在 spring boot 中不知道怎么处理：\n\u0026lt;!-- springmvc.xml 资源映射 --\u0026gt;\n\u0026lt;mvc:resources location=\u0026quot;/WEB-INF/css/\u0026quot; mapping=\u0026quot;/css/**\u0026quot;/\u0026gt;\n\u0026lt;mvc:resources location=\u0026quot;/WEB-INF/js/\u0026quot; mapping=\u0026quot;/js/**\u0026quot;/\u0026gt;\n\u0026lt;mvc:resources location=\u0026quot;/WEB-INF/image/\u0026quot; mapping=\u0026quot;/image/**\u0026quot;/\u0026gt;\n3、下面这个 tomcat 的包必须导入吗，spring-boot-starter-web 中不是有一个内嵌的 tomcat 吗？\n\u0026lt;1\u0026gt;、针对第一个问题，答案是不可以的。\n我们先看一段英文描述，如下：\nWhen running a Spring Boot application that uses an embedded servlet container (and is packaged as an executable archive), there are some limitations in the JSP support.\nWith Tomcat it should work if you use war packaging, i.e. an executable war will work, and will also be deployable to a standard container (not limited to, but including Tomcat). An executable jar will not work because of a hard coded file pattern in Tomcat.\nJetty does not currently work as an embedded container with JSPs.\nUndertow does not support JSPs.\n原文的大体意思就是：Tomcat 支持 war 的打包方式，spring boot 支持 war 打包方式。Jetty 现在不支持JSP 嵌入容器。Undertow 根本就不支持JSP。\n所以答案就是打包成war，jsp 会自然按照servlet 的标准部署。但也就意味着你不可以用嵌入式的方式运行，而是Tomcat Server + war 的部署方式。\n看到这里有些网友肯定会有疑问那什么是嵌入式的web 服务器？我们这边就拿jetty 来说明下。Jetty 可以非常容易的嵌入到应用程序当中而不需要程序为了使用 Jetty 做修改。\n从某种程度上，你也可以把 Jetty 理解为一个嵌入式的Web 服务器。所以我们经常会说嵌入式jetty。Jetty 有一个口号：不要把你的应用部署到 Jetty 中，把 Jetty 部署到你的应用中。Jetty 可以在 Java 应用\n程序中向其他 POJO 一样被实例化，换句话说，以嵌入式的模式运行 Jetty 是指将 Http 模块放入你的应用程序中，而非部署你的程序到一个HTTP 服务器。这就是所谓的嵌入式jetty。\n另外在说明一点就是JSP 解析是需要JSP 引擎处理的，tomcat 就提供了JSP 处理引擎。所以很显然 JSP 是依赖容器而存在的，不然就没法访问了。那么既然是依赖于tomcat 的话。\n有一网友找到一支持打成jar 包运行的插件： Using Spring Boot with JSPs in Executable Jars https://github.com/ghillert/spring-boot-jsp-demo\n经过java -jar xxx.jar 运行后，可以正常访问网页。\n这也可以说明原本是不支持的，但是如果非要支持的话，那么需要进行使用插件进行支持。\n\u0026lt;2\u0026gt;针对第二个问题\n对于第二个问题，如果看过之前的章节就很好解决了，只需要在 src/main/resouces 下新建一个 static 目录，然后在 static 下新建子目录：css,images,js 目录，在 images 放入一张 test.jpg 图片，那么访问路径是： http://127.0.0.1:8080/images/test.jpg\n当前目录结构应该是这样子的： (1)--src/java/resources\n(2)-- static\n(3)-- css\n(3)-- images\n(3)-- js\n{width=\u0026ldquo;3.4266666666666667in\u0026rdquo; height=\u0026ldquo;0.8533333333333334in\u0026rdquo;}那么有人会有疑问这个，打包的时候能打上嘛，答案是可以的，请看实际打包解压图：\n Spring boot 集 成 servlet  Web 开发使用 Controller 基本上可以完成大部分需求，但是我们还可能会用到 Servlet、Filter、Listener、\nInterceptor 等等。\n当使用Spring-Boot 时，嵌入式Servlet 容器通过扫描注解的方式注册Servlet、Filter 和Servlet 规范的所有监听\n器（如HttpSessionListener 监听器）。\nSpring boot 的主 Servlet 为 DispatcherServlet，其默认的url-pattern 为\u0026rdquo;/\u0026quot;。也许我们在应用中还需要定义更多的Servlet，该如何使用SpringBoot 来完成呢？\n在 spring boot 中添加自己的 Servlet 有两种方法，代码注册 Servlet 和注解自动注册（Filter 和 Listener 也是如此）。\n在 spring boot 中添加自己的 Servlet 有两种方法，代码注册 Servlet 和注解自动注册（Filter 和 Listener 也是如此）。\n一、代码注册通过 ServletRegistrationBean、 FilterRegistrationBean 和 ServletListenerRegistrationBean 获得\n控制。\n也可以通过实现 ServletContextInitializer 接口直接注册。\n二、在 SpringBootApplication 上使用@ServletComponentScan 注解后，Servlet、Filter、Listener 可以直接通过 @WebServlet、@WebFilter、@WebListener 注解自动注册，无需其他代码。\n通过代码注册Servlet 示例代码： com.hpit.sb.servlet.MyServlet1\n程序入口配置： com.hpit.sb. App\n第二种方式：使用注解注册Servlet 示例代码\ncom.hpit.sb.servlet. MyServlet2\n主程序配置： com.hpit.sb.App\n{width=\u0026ldquo;7.052595144356955in\u0026rdquo; height=\u0026ldquo;0.8990616797900263in\u0026rdquo;}启动日志：\n Spring boot 集成 Fliter 和 Linstener  上一章已经对定义 Servlet 的方法进行了说明，过滤器（Filter）和监听器（Listener）的注册方法和 Servlet 一样，不清楚的可以查看下上一篇文章（20）： 本文将直接使用@WebFilter 和@WebListener 的方式，完成一个 Filter 和一个 Listener；使用注解\n @ServletComponentScan//这个就是扫描相应的 Servlet 包;  开发Filter【：添加@ServletComponentScan 注解之后，使用注解开发的 Filter 和Linstener 将会被自动注册】\n具 体 实 现 代 码 ： com.hpit.sb.filter.MyFilter\n开发Linstener 具体实现代码：\ncom.hpit.sb.listener. Mylistener\n启动日志，并请求一个有效连接：\n{width=\u0026ldquo;7.136555118110236in\u0026rdquo; height=\u0026ldquo;3.65125in\u0026rdquo;}\n Spring boot 拦截器 HandlerInterceptor  上一章对过滤器的定义做了说明，也比较简单。过滤器属于Servlet 范畴的API，与Spring 没什么关系。\nWeb 开发中，我们除了使用 Filter 来过滤请 web 求外，还可以使用 Spring 提供的 HandlerInterceptor（拦截器）。\nHandlerInterceptor 的功能跟过滤器类似，但是提供更精细的的控制能力：在 request 被响应之前、request 被响应之后、视图渲染之前以及 request 全部结束之后。我们不能通过拦截器修改 request 内容，但是可以通过抛出异常（或者返回false）来暂停request 的执行。\n实现 UserRoleAuthorizationInterceptor 的拦截器有： ConversionServiceExposingInterceptor CorsInterceptor\nLocaleChangeInterceptor PathExposingHandlerInterceptor ResourceUrlProviderExposingInterceptor ThemeChangeInterceptor UriTemplateVariablesHandlerInterceptor UserRoleAuthorizationInterceptor\n其中 LocaleChangeInterceptor 和 ThemeChangeInterceptor 比较常用。\n配置拦截器也很简单， Spring 为什么提供了基础类 WebMvcConfigurerAdapter ，我们只需要重写addInterceptors 方法添加注册拦截器。\n实现自定义拦截器只需要 3 步：\n1、创建我们自己的拦截器类并实现 HandlerInterceptor 接口。\n2、创建一个Java 类继承WebMvcConfigurerAdapter，并重写 addInterceptors 方法。\n2、实例化我们自定义的拦截器，然后将对像手动添加到拦截器链中（在addInterceptors 方法中添加）。PS：本文重点在如何在Spring-Boot 中使用拦截器，关于拦截器的原理请大家查阅资料了解。\n代码：\ncom.hpit.sb.interceptors. MyInterceptor1\ncom.hpit.sb.interceptors. MyInterceptor2\n重写web 配置addInterceptors()方法，添加自定义拦截器： com.hpit.sb.config. MyWebAppConfig\n启动日志，请求任意控制器:日志输出：\n {width=\u0026ldquo;5.643725940507436in\u0026rdquo; height=\u0026ldquo;0.625in\u0026rdquo;}\nSpring boot 系统启动任务 CommandLineRunner  实际应用中，我们会有在项目服务启动的时候就去加载一些数据或做一些事情这样的需求。\n为了解决这样的问题，Spring Boot 为我们提供了一个方法，通过实现接口 CommandLineRunner 来实现。很简单，只需要一个类就可以，无需其他配置。\n创建任务类 1 实现CommandLineRunner 接口： com.hpit.sb.runner. MyCommandRunner1\ncom.hpit.sb.runner. MyCommandRunner2\nSpring Boot 应用程序在启动后，会遍历CommandLineRunner 接口的实例并运行它们的run 方法。也可以利用\n@Order 注解（或者实现Order 接口）来规定所有CommandLineRunner 实例的运行顺序。如下我们使用@Order 注解来定义执行顺序。\n{width=\u0026ldquo;4.670989720034996in\u0026rdquo; height=\u0026ldquo;0.53125in\u0026rdquo;}启动应用日志输出：\n  Spring boot 集成 Junit 单元测试   Junit 这种老技术，现在又拿出来说，不为别的，某种程度上来说，更是为了要说明它在项目中的重要性。那么先简单说一下为什么要写测试用例\n   可以避免测试点的遗漏，为了更好的进行测试，可以提高测试效率\n  可以自动测试，可以在项目打包前进行测试校验\n  可以及时发现因为修改代码导致新的问题的出现，并及时解决\n   那么本文从以下几点来说明怎么使用Junit，Junit4 比 3 要方便很多，细节大家可以自己了解下，主要就是版本 4 中对方法命名格式不再有要求，不再需要继承TestCase，一切都基于注解实现。\n那么Spring Boot 如何使用Junit 呢？ 1). 加入Maven 的依赖；\n  编写测试service;\n  编写测试类;\n    加入Maven 的依赖:\n  编 写 测 试 service: com.hpit.sb.service. HelloService\n   在src/test/java 下编写测试类：com.hpit.springboot02.test.TestHelloService\n  Spring boot 读取系统环境变量   凡是被 Spring 管理的类，实现接口 EnvironmentAware 重写方法 setEnvironment 可以在工程启动时，获取到\n系统环境变量和application 配置文件中的变量。\ncom.hpit.sb.environment.MyEnvironment\nimport org.apache.log4j.Logger;\nimport org.springframework.beans.factory.annotation.Value; import org.springframework.boot.bind.RelaxedPropertyResolver; import org.springframework.context.EnvironmentAware;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.env.Environment;\n/**\n  TODO 读取spring以及系统环境变量 主要是@Configuration，实现接口：EnvironmentAware就能获取到系统   环境信息;\n*\n  @author 郑江山   *\n*/ @Configuration\npublic class MyEnvironment implements EnvironmentAware {\n@Value(\u0026quot;${spring.datasource.url}\u0026quot;) // 使用el表达式读取spring主配置文件\nprivate String jdbcUrl;\nprivate Logger logger = Logger.getLogger(getClass()); @Override\npublic void setEnvironment(Environment environment) {\n// springEL表达式获取的值\nlogger.info(\u0026quot;springel表达式获取的值：\u0026quot; + jdbcUrl);\n// 获取系统属性：\nlogger.info(\u0026quot;JAVA_HOME\u0026quot; + environment.getProperty(\u0026quot;JAVA_HOME\u0026quot;));\n// 获取spring主配置文件中的属性\nlogger.info(\u0026quot;spring.datasource.url:\u0026quot; + environment.getProperty(\u0026quot;spring.datasource.url\u0026quot;));\n// 获取前缀是\u0026quot;spring.datasource\u0026quot;的所有属性值\nRelaxedPropertyResolver propertyResolver = new RelaxedPropertyResolver(environment,\n\u0026quot;spring.datasource.\u0026quot;);\nlogger.info(\u0026quot;通过前缀获取的url:\u0026quot; + propertyResolver.getProperty(\u0026quot;url\u0026quot;));\nlogger.info(\u0026quot;通过前缀获取的driverClassName:\u0026quot; + propertyResolver.getProperty(\u0026quot;driverClassName\u0026quot;));\n}\n}\n其中application.properties 文件信息是：\n{width=\u0026ldquo;6.869482720909886in\u0026rdquo; height=\u0026ldquo;0.7516666666666667in\u0026rdquo;}启动应用，查看日志输出：\n@Controller @Service 等被Spring 管理的类都支持，注意重写的方法 setEnvironment 是在系统启动的时候被执行。\n或 者 如 下 Controller： com.hpit.sb.controller.SystemEnvironmentController\n{width=\u0026ldquo;5.203527996500437in\u0026rdquo; height=\u0026ldquo;0.9479166666666666in\u0026rdquo;}请求控制器：查看效果\n日志输出：\n{width=\u0026ldquo;6.9262128171478565in\u0026rdquo; height=\u0026ldquo;0.1944925634295713in\u0026rdquo;}我们还可以通过@ConfigurationProperties 读取application 属性配置文件中的属性。具体代码：\ncom.hpit.sb.config.MyDataConfiguration\ncom.hpit.sb.config.MySqlConfig\n代码解释：\n@ConditionOnClass 表明该@Configuration 仅仅在一定条件下才会被加载，这里的条件是 Mongo.class 位于类\n路径上\n   @EnableConfigurationProperties 将 Spring Boot 的配置文件（ application.properties ）中的spring.data.mongodb.*属性映射为MongoProperties 并注入到MongoAutoConfiguration 中。\n  @ConditionalOnMissingBean 说明 Spring Boot 仅仅在当前上下文中不存在对象时，才会实例化一个Bean。这个逻辑也体现了 Spring Boot 的另外一个特性\u0026mdash;\u0026mdash;自定义的Bean 优先于框架的默认配置，我们如果显式的在业务代码中定义了一个对象，那么Spring Boot 就不再创建。\n   Spring boot 使用自定义 properties   spring boot 使用application.properties 默认了很多配置。但需要自己添加一些配置的时候，我们应该怎么做呢。例如在application.properties 配置文件中加入如下配置：\n那么如何在应用程序中进行读取呢？ 首 先 定 义 配 置 读 取 实 体 类 ： com.hpit.sb.properties.MyConfig\n[添加@ConfigurationProperties 注解用来读取application.properties 配置文件中以person]{.underline} 开头的所有配置。2.在spring boot 入口类加入：\n{width=\u0026ldquo;7.0881572615923005in\u0026rdquo; height=\u0026ldquo;0.9902077865266842in\u0026rdquo;}如何是定义其他配置文件中，需要将实体类改写为：\n  Spring boot 改变默认包扫描   在开发中我们知道Spring Boot 默认会扫描启动类同包以及子包下的注解，那么如何进行改变这种扫描包的方式\n呢，原理很简单就是：\n@ComponentScan 注解进行指定要扫描的包以及要扫描的类。接下来我们简单写个例子进行测试下。\n第一步：新建两个新包\n我们在项目中新建两个包cn.hpit ; org.hpit ；\n第二步：新建两个测试类；\n在这里为了方便测试，我们让我们的类在启动的时候就进行执行，所以我们就编写两个类， 实现接口CommandLineRunner，这样在启动的时候我们就可以看到打印信息了。\ncn.hpit.sb.MyCommandLineRunner3\ncn.hpit.sb.MyCommandLineRunner4\n在 spring boot 中添加自定义包扫描的路径\ncom.hpit.sb.App\n启动应用程序：\n{width=\u0026ldquo;4.670949256342957in\u0026rdquo; height=\u0026ldquo;0.5in\u0026rdquo;}日志输出：\n  Spring boot 自定义启动 Banner   对于使用过Spring Boot 的开发者来说，程序启动的时候输出的由字符组成的Spring 符号并不陌生。这个是Spring Boot 为自己设计的Banner：\n如果有人不喜欢这个输出，本章说一下怎么修改。\n第一种方式：修改的时候，进行设置,在Application 的main 方法中：\n第二种方式：修改banner.txt 配置文件\n在src/main/resouces 下新建banner.txt，在文件中加入：\n第三种方式：重写接口Banner 实现\nSpringBoot 提供了一个接口 org.springframework.boot.Banner，他的实例可以被传给 SpringApplication 的setBanner(banner) 方法。如果你闲得不行非要着重美化这个命令行输出的话，可以重写 Banner 接口的printBanner 方法。\n第四种方式：在application.properties 进行配置\n在application.proerpties 进行banner 的显示和关闭：\n  Spring boot 导入 spring XML 配置文件   在App.java 类编写HelloService2;\n首先我们这里有几个包：com.hpit,org.hpit,我们这里打算把 App.java 启动类放到 com.hpit 中，根据 Spring Boot 扫描（根包到子包的原则），我们把 HelloService2 写在 Spring Boot 可以扫描的位置，HelloService 写在 Spring Boot 无法扫描到的位置，那么我们使用配置文件bean 的方式进行引入，具体代码如下：\n  创建一个App 默认无法扫描到的bean   org.hpit.demo.service.HelloService\n   在resource 下创建spring 传统配置文件applicationContext.xml(名字任意) src/main/resource/applicationContext.xml\n  创建一个系统启动任务类，用于测试App 无法扫描到的Bean 是否能自动装配\n   com.hpit.springboot03.runner.TestXMLBeanRunner\n   在App.java 中配置引入配置文件的注解 @ImportResource\n  {width=\u0026ldquo;7.1322823709536305in\u0026rdquo; height=\u0026ldquo;2.019582239720035in\u0026rdquo;}启动应用，观察日志输出，发现系统可以引入App 无法扫描到的bean\n  Spring boot 热部署  进行热部署，但是有部分代码修改了，并不会进行部署。今天我们介绍的这个通过重启的机制就可以解决这个问 题了。\n我们今天要介绍的就是：spring-boot-devtools。\nspring-boot-devtools 是一个为开发者服务的一个模块，其中最重要的功能就是自动应用代码更改到最新的App 上面去。原理是在发现代码有更改之后，重新启动应用，但是比速度比手动停止后再启动还要更快，更快指的不是节省出来的手工操作的时间。\n其深层原理是使用了两个 ClassLoader，一个 Classloader 加载那些不会改变的类（第三方 Jar 包），另一个\nClassLoader 加载会更改的类，称为 restart ClassLoader\n,这样在有代码更改的时候，原来的restart ClassLoader 被丢弃，重新创建一个restart ClassLoader，由于需要加载的类相比较少，所以实现了较快的重启时间（5 秒以内）。\n那如何使用呢，大概两个步骤即可： 第一就是添加相应的依赖：\n第二加点：仅仅加入devtools 在我们的eclipse 中还不起作用，这时候还需要添加的spring-boot-maven-plugin：\n运行App.java ---- Run Application --- Java Application 即可进行测试。\n测试方法：\n   修改类--\u0026gt;保存：应用会重启\n  修改配置文件--\u0026gt;保存：应用会重启\n  修改页面--\u0026gt;保存：应用会重启，页面会刷新（原理是将spring.thymeleaf.cache 设为false）\n   不能使用分析：\n a. 对应的spring-boot 版本是否正确，我这里使用的是 1.3.3 版本；\nb. 是否加入plugin 了，以及属性\u0026lt;fork\u0026gt;true\u0026lt;/fork\u0026gt;\nc. Eclipse Project 是否开启了Build Automatically（我自己就在这里栽了坑，不知道为什么我的工具什么时候关闭了自动编译的功能）。\nd. 如果设置SpringApplication.setRegisterShutdownHook(false)，则自动重启将不起作用。\n 补充：\n默认情况下，/META-INF/maven，/META-INF/resources，/resources，/static，/templates，/public 这些文件夹下的文件修改不会使应用重启，但是会重新加载（devtools 内嵌了一个LiveReload server，当资源发生改变时，浏览器刷新）。\n   如果想改变默认的设置，可以自己设置不重启的目录：spring.devtools.restart.exclude=static/**,public/**， 这样的话，就只有这两个目录下的文件修改不会导致restart 操作了。\n  如果要在保留默认设置的基础上还要添加其他的排除目录：spring.devtools.restart.additional-exclude\n  如果想要使得当非 classpath 下的文件发生变化时应用得以重启，使用：spring.devtools.restart.additional- paths，这样devtools 就会将该目录列入了监听范围。\n   关闭自动重启\n设置 spring.devtools.restart.enabled 属性为 false，可以关闭该特性。可以在application.properties 中设置，也可以通过设置环境变量的方式。\npublic static void main(String[] args){ System.setProperty(\u0026quot;spring.devtools.restart.enabled\u0026quot;,\u0026quot;false\u0026quot;); SpringApplication.run(MyApp.class, args);\n  Spring boot 监控和管理生产环境   spring-boot-actuator 模块提供了一个监控和管理生产环境的模块，可以使用http、jmx、ssh、telnet 等拉管理和监控应用。审计（Auditing）、\n健康（health）、数据采集（metrics gathering）会自动加入到应用里面。首先，写一个最基本的spring boot 项目。\n基于Maven 的项目添加\u0026rsquo;starter\u0026rsquo;依赖：\n以下是所有监控描述：\n +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | \u0026gt; HTTP 方法 | \u0026gt; 路径 | \u0026gt; 描述 | \u0026gt; 鉴权 | +=================+=================+=================+=================+ | \u0026gt; GET | \u0026gt; /autoconfig | \u0026gt; 查看自动配置的使用情况，该 | \u0026gt; true | | | | 报告展示所有 | | | | | \u0026gt; auto-configur | | | | | ation | | | | | \u0026gt; 候 | | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\n+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | | | \u0026gt; 选者及它们被应用或未被应用 | | | | | 的原因 | | +=================+=================+=================+=================+ | \u0026gt; GET | \u0026gt; /configprops | \u0026gt; 显 示 一 个 | \u0026gt; true | | | | \u0026gt; 所 有 | | | | | \u0026gt; | | | | | \u0026gt; @Configuratio | | | | | nProperties | | | | | \u0026gt; 的整理列表 | | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | \u0026gt; GET | \u0026gt; /beans | \u0026gt; 显 示 一 个 | \u0026gt; true | | | | \u0026gt; 应 用 中 所 | | | | | \u0026gt; 有 Spring | | | | | \u0026gt; Beans | | | | | \u0026gt; 的完整列表 | | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | \u0026gt; GET | \u0026gt; /dump | \u0026gt; 打印线程栈 | \u0026gt; true | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | \u0026gt; GET | \u0026gt; /env | \u0026gt; 查看所有环境变量 | \u0026gt; true | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | \u0026gt; GET | \u0026gt; /env/{name} | \u0026gt; 查看具体变量值 | \u0026gt; true | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | \u0026gt; GET | \u0026gt; /health | \u0026gt; 查看应用健康指标 | \u0026gt; false | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | \u0026gt; GET | \u0026gt; /info | \u0026gt; 查看应用信息 | \u0026gt; false | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | \u0026gt; GET | \u0026gt; /mappings | \u0026gt; 查看所有 url | \u0026gt; true | | | | \u0026gt; 映射 | | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | \u0026gt; GET | \u0026gt; /metrics | \u0026gt; 查看应用基本指标 | \u0026gt; true | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | \u0026gt; GET | \u0026gt; /metrics/{nam | \u0026gt; 查看具体指标 | \u0026gt; true | | | e} | | | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | \u0026gt; POST | \u0026gt; /shutdown | \u0026gt; 允许应用以优雅的方式关闭（ | \u0026gt; true | | | | 默认情况下不启用） | | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | \u0026gt; GET | \u0026gt; /trace | \u0026gt; 查看基本追踪信息 | \u0026gt; true | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\nhealth  比如：http://localhost:8080/health\n你可以得到结果\n可以检查的其他一些情况的健康信息。下面的 HealthIndicators 会被 Spring Boot 自动配置：\n自定义当然也可以，你可以注册实现了 HealthIndicator 接口的 Spring beans，Health 响应需要包含一个\nstatus 和可选的用于展示的详情。\ntrace\n访问http://localhost:8080/trace 可以看到结果，默认为最新的一些HTTP 请求\n info  当执行 http://localhost:8080/info 的时候，结果什么没有\n但是，在application.properties 加入一些配置\n执行/info 就可以看到有些信息了。\n/info 是用来在构建的时候，自动扩展属性的。对于 Maven 项目，可以通过 @..@ 占位符引用 Maven 的\u0026rsquo;project properties'。\n更多的细节和探索，需要自己看看源码和spring boot 的官方文档。\n Spring boot starter 详解  1）spring-boot-starter\n这是Spring Boot 的核心启动器，包含了自动配置、日志和YAML。2）spring-boot-starter-actuator\n帮助监控和管理应用。3）spring-boot-starter-amqp\n通过spring-rabbit 来支持AMQP 协议（Advanced Message Queuing Protocol）。 4）spring-boot-starter-aop\n支持面向方面的编程即AOP，包括spring-aop 和AspectJ。 5）spring-boot-starter-artemis\n通过Apache Artemis 支持JMS 的API（Java Message Service API）。 6）spring-boot-starter-batch\n支持Spring Batch，包括HSQLDB 数据库。7）spring-boot-starter-cache\n支持Spring 的Cache 抽象。\n spring-boot-starter-cloud-connectors   支持Spring Cloud Connectors，简化了在像Cloud Foundry 或Heroku 这样的云平台上连接服务。\n spring-boot-starter-data-elasticsearch   支持ElasticSearch 搜索和分析引擎，包括spring-data-elasticsearch。10）spring-boot-starter-data-gemfire\n支持GemFire 分布式数据存储，包括spring-data-gemfire。11）spring-boot-starter-data-jpa\n支持JPA（Java Persistence API），包括 spring-data-jpa、spring-orm、Hibernate。 12）spring-boot-starter-data-mongodb\n支持MongoDB 数据，包括spring-data-mongodb。\n13）spring-boot-starter-data-rest\n通过spring-data-rest-webmvc，支持通过REST 暴露Spring Data 数据仓库。14）spring-boot-starter-data-solr\n支持Apache Solr 搜索平台，包括spring-data-solr。15）spring-boot-starter-freemarker\n支持FreeMarker 模板引擎。\n16）spring-boot-starter-groovy-templates\n支持Groovy 模板引擎。17）spring-boot-starter-hateoas\n通过spring-hateoas 支持基于HATEOAS 的RESTful Web 服务。18）spring-boot-starter-hornetq\n通过HornetQ 支持JMS。19）spring-boot-starter-integration 支持通用的spring-integration 模块。20）spring-boot-starter-jdbc\n支持JDBC 数据库。21）spring-boot-starter-jersey\n支持Jersey RESTful Web 服务框架。\n22）spring-boot-starter-jta-atomikos\n通过Atomikos 支持JTA 分布式事务处理。23）spring-boot-starter-jta-bitronix\n通过Bitronix 支持JTA 分布式事务处理。24）spring-boot-starter-mail\n支持javax.mail 模块。25）spring-boot-starter-mobile 支持spring-mobile。\n26）spring-boot-starter-mustache 支持Mustache 模板引擎。27）spring-boot-starter-redis\n支持Redis 键值存储数据库，包括spring-redis。28）spring-boot-starter-security\n支持spring-security。\n  spring-boot-starter-social-facebook 支持spring-social-facebook\n  spring-boot-starter-social-linkedin\n   支持pring-social-linkedin\n spring-boot-starter-social-twitter   支 持 pring-social-twitter 32）spring-boot-starter-test\n支持常规的测试依赖，包括JUnit、Hamcrest、Mockito 以及spring-test 模块。 33）spring-boot-starter-thymeleaf\n支持Thymeleaf 模板引擎，包括与Spring 的集成。34）spring-boot-starter-velocity\n支持Velocity 模板引擎。35）spring-boot-starter-web\nS 支持全栈式Web 开发，包括Tomcat 和spring-webmvc。36）spring-boot-starter-websocket\n支持WebSocket 开发。37）spring-boot-starter-ws 支持Spring Web Services。\nSpring Boot 应用启动器面向生产环境的还有 2 种，具体如下： 1）spring-boot-starter-actuator\n增加了面向产品上线相关的功能，比如测量和监控。2）spring-boot-starter-remote-shell\n增加了远程ssh shell 的支持。\n最后，Spring Boot 应用启动器还有一些替换技术的启动器，具体如下： 1）spring-boot-starter-jetty\n引入了Jetty HTTP 引擎（用于替换Tomcat）。 2）spring-boot-starter-log4j\n支持Log4J 日志框架。3）spring-boot-starter-logging\n引入了Spring Boot 默认的日志框架Logback。4）spring-boot-starter-tomcat\n引入了Spring Boot 默认的HTTP 引擎Tomcat。\n spring-boot-starter-undertow   引入了Undertow HTTP 引擎（用于替换Tomcat）。\n  Spring boot 依赖的版本   spring-boot 通过maven 的依赖管理为我们写好了很多依赖项及其版本，我们可拿来使用。spring-boot 文档介绍了两种使用方法，一是继承，二是导入。\n通过\u0026lt;parent\u0026gt;继承：\n或者在\u0026lt;dependencyManagement\u0026gt;中导入：\n此外，在其 文档 里说到， 继承时可简单地通过属性定制依赖项版本。比如， 改为使用较新的 spring- 4.1.6.RELEASE 版本：\n不过，此法只对继承有效，导入无效。以下摘自其文档说明：\nThis only works if your Maven project inherits (directly or indirectly) from spring-boot- dependencies. If you have added spring-boot-dependencies in your own dependencyManagement section with \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; you have to redefine the artifact yourself instead of overriding the property.\n导入时有没有较简单的方法呢？我们可先继承后导入！\n1、先建一个过渡性工程，继承后定制依赖项的版本。\n2、然后导入到自己的工程里。\n这样，虽然多建了一个过渡性工程，但定制依赖项版本同继承时一样简单。\n  Spring boot 文件上传   文件上传主要分以下几个步骤：\n   新建maven java project；\n  在pom.xml 加入相应依赖；\n  新建一个表单页面（这里使用thymleaf）;\n  编写controller;\n  测试；\n  对上传的文件做一些限制；\n  多文件上传实现\n   新建maven java project   新建一个名称为spring-boot-fileupload maven java 项目；\n  在pom.xml 加入相应依赖；   加入相应的maven 依赖，具体看以下解释： POM.XML\n\u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;[http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd]{.underline}\u0026quot;\u0026gt;\n\u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt;\n\u0026lt;groupId\u0026gt;com.hpit\u0026lt;/groupId\u0026gt;\n\u0026lt;artifactId\u0026gt;springboot03\u0026lt;/artifactId\u0026gt;\n\u0026lt;packaging\u0026gt;war\u0026lt;/packaging\u0026gt;\n\u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt;\n\u0026lt;name\u0026gt;springboot03 [Maven Webapp]{.underline}\u0026lt;/name\u0026gt;\n\u0026lt;url\u0026gt;http://maven.apache.org\u0026lt;/url\u0026gt;\n\u0026lt;properties\u0026gt;\n\u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt;\n\u0026lt;/properties\u0026gt;\n\u0026lt;!-- spring boot 项目依赖 --\u0026gt;\n\u0026lt;parent\u0026gt;\n\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\n\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;\n\u0026lt;version\u0026gt;1.4.0.RELEASE\u0026lt;/version\u0026gt;\n\u0026lt;/parent\u0026gt;\n\u0026lt;dependencies\u0026gt;\n\u0026lt;!-- spring boot web支持: 1、web [mvc]{.underline}; 2、restful; 3、[jackjson]{.underline}支持; 4、[aop]{.underline} .. --\u0026gt;\n\u0026lt;dependency\u0026gt;\n\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\n\u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt;\n\u0026lt;/dependency\u0026gt;\n\u0026lt;!--spring boot 集成[Junit]{.underline}依赖 --\u0026gt;\n\u0026lt;dependency\u0026gt;\n\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\n\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;\n\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;\n\u0026lt;/dependency\u0026gt;\n\u0026lt;!-- spring boot [thymeleaf]{.underline}模板引擎支持 --\u0026gt;\n\u0026lt;dependency\u0026gt;\n\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\n\u0026lt;artifactId\u0026gt;spring-boot-starter-[thymeleaf]{.underline}\u0026lt;/artifactId\u0026gt;\n\u0026lt;/dependency\u0026gt;\n\u0026lt;!-- spring boot 配置文件解析处理支持 --\u0026gt;\n\u0026lt;dependency\u0026gt;\n\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\n\u0026lt;artifactId\u0026gt;spring-boot-configuration-processor\u0026lt;/artifactId\u0026gt;\n\u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt;\n\u0026lt;/dependency\u0026gt;\n\u0026lt;!-- [servlet]{.underline} 依赖. --\u0026gt;\n\u0026lt;dependency\u0026gt;\n\u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt;\n  新建一个表单页面（这里使用thymleaf）   在 src/main/resouces 新建 templates(参照前面的章节，应该知道，templates 是 spring boot 存放模板文件的路径)，在templates 下新建一个file.html:\n  编写controller;   编写controller 进行测试，这里主要实现两个方法：其一就是提供访问的/file 路径；其二就是提供post 上\n传 的 /upload 方 法 ， 具 体 看 代 码 实 现 ： com.hpit.springboot03.web.FileUploadController import java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport org.apache.log4j.Logger;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.multipart.MultipartFile;\n/**\n  TODO 文件上传控制器   *\n  @author 郑江山   *\n*/ @Controller\npublic class FileUploadController {\nprivate Logger logger = Logger.getLogger(getClass()); @RequestMapping(value = \u0026quot;/upload\u0026quot;, method = RequestMethod.GET)\npublic String file() {\nlogger.info(\u0026quot;跳转文件上传控制器\u0026quot;);\nreturn \u0026quot;file\u0026quot;;\n}\n/**\n  TODO 文件上传控制器   *\n   @param file\n  @return\n  @throws IOException\n   */ @ResponseBody\n@RequestMapping(value = \u0026quot;/upload\u0026quot;, method = RequestMethod.POST)\npublic String upload(@RequestParam(\u0026quot;file\u0026quot;) MultipartFile file) throws IOException {// 文 件 上 传BufferedOutputStream outputStream = new BufferedOutputStream(\nnew FileOutputStream(new File(file.getOriginalFilename())));\nlogger.info(\u0026quot;文件名称：\u0026quot; + file.getOriginalFilename()); outputStream.write(file.getBytes()); outputStream.flush();\noutputStream.close();\nreturn \u0026quot;文件上传成功\u0026quot;;\n}\n}\n  编写App.java 然后测试   App.java 没什么代码，就是Spring Boot 的启动配置，具体如下：\n{width=\u0026ldquo;4.469998906386702in\u0026rdquo; height=\u0026ldquo;1.1666666666666667in\u0026rdquo;}然后你就可以访问：http://127.0.0.1 /upload 进行测试了，文件上传的路径是在工程的跟路径下，请刷新查看， 其它的请查看代码中的注释进行自行思考。\n 对上传的文件做一些限制；   对文件做一些限制是有必要的，在App.java 进行编码配置： 在App 主程序入口处添加如下配置：\n（7）多文件上传实现\n多文件对于前段页面比较简单，具体代码实现： 在src/main/resource 下面创建multifile.html\n添加控制实现：com.hpit.springboot03.web.MultiFileUploadController\n启动浏览器输入路径进行测试。\n{width=\u0026ldquo;2.7425371828521437in\u0026rdquo; height=\u0026ldquo;3.7124989063867018in\u0026rdquo;}项目结构图：\n  Spring boot 集成 redis 缓存   本章牵涉到的技术点比较多：Spring Data JPA、Redis、Spring MVC,Spirng Cache，所以在看这篇文章的时候， 需要对以上这些技术点有一定的了解或者也可以先看看这篇文章，针对文章中实际的技术点在进一步了解（注意， 您需要自己下载Redis Server 到您的本地，所以确保您本地的Redis 可用，这里还使用了MySql 数据库，当然你也可以内存数据库进行测试）。这篇文章会提供对应的 Eclipse 代码示例，具体大体的分如下几个步骤：\n   新建Java Maven Project;\n  在pom.xml 中添加相应的依赖包；\n  编写Spring Boot 启动类；\n  配置application.properties;\n  编写RedisCacheConfig 配置类；\n  编写DemoInfo 测试实体类；\n  编写DemoInfoRepository 持久化类；\n  编写DemoInfoService 类；\n  编写DemoInfoController 类；\n  测试代码是否正常运行了\n  自定义缓存key;\n   新建Java Maven Project;   这个步骤就不细说，新建一个spring-boot-redis Java maven project;\n  在pom.xml 中添加相应的依赖包；   在Maven 中添加相应的依赖包,主要有：spring boot 父节点依赖；spring boot web 支持；缓存服务 spring-context- support；添加redis 支持；JPA 操作数据库；mysql 数据库驱动，具体pom.xml 文件如下：\n\u0026lt;/properties\u0026gt;\n\u0026lt;!-- spring boot 父节点依赖,\n引入这个之后相关的引入就不需要添加 version 配置，\nspring boot 会自动选择最合适的版本进行添加。\n--\u0026gt;\n\u0026lt;parent\u0026gt;\n\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\n\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;\n\u0026lt;version\u0026gt;1.4.0.RELEASE\u0026lt;/version\u0026gt;\n\u0026lt;/parent\u0026gt;\n\u0026lt;dependencies\u0026gt;\n \u0026lt;dependency\u0026gt;\n \u0026lt;groupId\u0026gt;[junit]{.underline}\u0026lt;/groupId\u0026gt;\n\u0026lt;artifactId\u0026gt;[junit]{.underline}\u0026lt;/artifactId\u0026gt;\n\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;\n \u0026lt;/dependency\u0026gt;\n \u0026lt;!-- spring boot web 支持：[mvc]{.underline},[aop]{.underline}... --\u0026gt;\n\u0026lt;dependency\u0026gt;\n\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\n\u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt;\n\u0026lt;/dependency\u0026gt;\n\u0026lt;!--\n包含支持 UI 模版（Velocity，FreeMarker，JasperReports）， 邮件服务，\n脚本服务(JRuby)，\n缓存 Cache（EHCache），\n任务计划 Scheduling（[uartz]{.underline}）。\n--\u0026gt;\n\u0026lt;dependency\u0026gt;\n\u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt;\n\u0026lt;artifactId\u0026gt;spring-context-support\u0026lt;/artifactId\u0026gt;\n\u0026lt;/dependency\u0026gt;\n上面是完整的pom.xml 文件，每个里面都进行了简单的注释。\n   编写Spring Boot 启动类（com.hpit.App）；\n  配置application.properties;\n   这里主要是配置两个资源，第一就是数据库基本信息；第二就是redis 配置；第三就是JPA 的配置；\nSrc/main/resouces/application.properties：\n  编写RedisCacheConfig 配置类；   缓存主要有几个要实现的类：其一就是 CacheManager 缓存管理器；其二就是具体操作实现类；其三就是CacheManager 工厂类（这个可以使用配置文件配置的进行注入，也可以通过编码的方式进行实现）；其四就是缓存 key 生产策略（当然 Spring 自带生成策略，但是在 Redis 客户端进行查看的话是系列化的 key,对于我们肉眼来说就是感觉是乱码了，这里我们先使用自带的缓存策略）。\ncom.hpit.config/RedisCacheConfig：\nimport org.springframework.data.redis.cache.RedisCacheManager;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\n/**\n  [redis]{.underline} 缓存配置;   *\n  注意：RedisCacheConfig 这里也可以不用继承：CachingConfigurerSupport，也就是直接一个普通的   Class 就好了；\n*\n  这里主要我们之后要重新实现 key 的生成策略，只要这里修改 KeyGenerator，其它位置不用修改就生效了。   *\n  普通使用普通类的方式的话，那么在使用@Cacheable 的时候还需要指定 KeyGenerator 的名称;这样编码的时候比较麻烦。   *\n   @author Zjs\n  @version v.0.1\n   */ @Configuration\n@EnableCaching//启用缓存，这个注解很重要；\npublicclass RedisCacheConfig extends CachingConfigurerSupport {\n/**\n   缓存管理器.\n  @param redisTemplate\n  ######## @return\n   */ @Bean\npublic CacheManager cacheManager(RedisTemplate\u0026lt;?,?\u0026gt; redisTemplate) { CacheManager cacheManager = new RedisCacheManager(redisTemplate); returncacheManager;\n}\n/**\n  [redis]{.underline} 模板操作类,类似于 jdbcTemplate 的一个类;   *\n  虽然 CacheManager 也能获取到 Cache 对象，但是操作起来没有那么灵活；   *\n  这里在扩展下：RedisTemplate 这个类不见得很好操作，我们可以在进行扩展一个我们   *\n  自己的缓存类，比如：RedisStorage 类;   *\n   @param factory : 通过 Spring 进行注入，参数在 application.properties 进行配置；\n  ######## @return\n   */ @Bean\npublic RedisTemplate\u0026lt;String, String\u0026gt; redisTemplate(RedisConnectionFactory factory) { RedisTemplate\u0026lt;String, String\u0026gt; redisTemplate = new RedisTemplate\u0026lt;String,\nString\u0026gt;();\nredisTemplate.setConnectionFactory(factory);\n//key 序列化方式;（不然会出现乱码;）,但是如果方法上有 Long 等非 String 类型的话，会报类型转换错误；\n//所以在没有自己定义 key 生成策略的时候，以下这个代码建议不要这么写，可以不配置或者自己实现 ObjectRedisSerializer\n//或者 JdkSerializationRedisSerializer 序列化方式;\n// RedisSerializer\u0026lt;String\u0026gt; redisSerializer = new StringRedisSerializer();//Long 类 型不可以会出现异常信息;\n// redisTemplate.setKeySerializer(redisSerializer);\n// redisTemplate.setHashKeySerializer(redisSerializer);\nreturnredisTemplate;\n}\n}\n在以上代码有很详细的注释，在这里还是在简单的提下：\nRedisCacheConfig 这里也可以不用继承：CachingConfigurerSupport，也就是直接一个普通的 Class 就好了； 这里主要我们之后要重新实现 key 的生成策略，只要这里修改 KeyGenerator，其它位置不用修改就生效了。普通使用普通类的方式的话，那么在使用@Cacheable 的时候还需要指定KeyGenerator 的名称;这样编码的时候比较麻烦。\n  编写DemoInfo 测试实体类；   编写一个测试实体类：com.hpit.bean.DemoInfo：\nimport java.io.Serializable;\nimport javax.persistence.Entity;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.Id;\n/**\n   测试实体类，这个随便;\n  @author Zjs\n  @version v.0.1\n   */\n@Entity\npublicclass DemoInfo implements Serializable{ **privatestaticfinallong*serialVersionUID ***= 1L; @Id@GeneratedValue\nprivatelongid; private String name; private String pwd; publiclong getId() {\nreturnid;\n}\npublicvoid setId(longid) {\nthis.id = id;\n}\npublic String getName() {\nreturnname;\n}\npublicvoid setName(String name) {\nthis.name = name;\n}\npublic String getPwd() {\nreturnpwd;\n}\npublicvoid setPwd(String pwd) {\nthis.pwd = pwd;\n}\n@Override\npublic String toString() {\n   编 写 DemoInfoRepository 持 久 化 类 ； DemoInfoRepository 使用Spirng Data JPA 实现： com.hpit.repository.DemoInfoRepository：\n  编写DemoInfoService 类；\n   编写DemoInfoService，这里有两个技术方面，第一就是使用 Spring @Cacheable 注解方式和RedisTemplate 对象进行操作，具体代码如下：\ncom.hpit.service.DemoInfoService:\ncom.hpit.service.impl.DemoInfoServiceImpl:\npackage com.hpit.service.impl;\nimport javax.annotation.Resource;\nimport org.springframework.cache.annotation.CacheEvict; import org.springframework.cache.annotation.Cacheable; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.core.ValueOperations; import org.springframework.stereotype.Service;\nimport com.hpit.bean.DemoInfo;\nimport com.hpit.repository.DemoInfoRepository;\nimport com.hpit.service.DemoInfoService;\n/**\n*\n*DemoInfo 数据处理类\n*\n   @author Zjs\n  @version v.0.1\n   */ @Service\npublicclass DemoInfoServiceImpl implements DemoInfoService {\n@Resource\nprivate DemoInfoRepository demoInfoRepository;\n@Resource\nprivate RedisTemplate\u0026lt;String,String\u0026gt; redisTemplate;\n@Override\npublicvoid test(){\nValueOperations\u0026lt;String,String\u0026gt; valueOperations = redisTemplate.opsForValue(); valueOperations.set(\u0026quot;mykey4\u0026quot;, \u0026quot;random1=\u0026quot;+Math.random()); System.out.println(valueOperations.get(\u0026quot;mykey4\u0026quot;));\n   编写DemoInfoController 类；\n  测试代码是否正常运行了\n   启动应用程序，访问地址：[http://127.0.0.1:8080/test]{.underline}\n查看控制台可以查看：\n如果你看到以上的打印信息的话，那么说明缓存成功了。\n访问地址：[http://127.0.0.1:8080/test1]{.underline}\nrandom1=0.9985031320746356\nDemoInfoController.test1()\n二次访问：[http://127.0.0.1:8080/test]{.underline}\n这时候所有的数据都是执行缓存的。\n这时候执行删除动作：[http://127.0.0.1:8080/delete?id=1]{.underline} 然后在访问：[http://127.0.0.1:8080/test]{.underline}\n  自定义缓存key;   在com.hpit.config.RedisCacheConfig 类中重写CachingConfigurerSupport 中的keyGenerator ,具体实现代码如下：\n}\n这时候在redis 的客户端查看key 的话还是序列化的肉眼看到就是乱码了，那么我改变key 的序列方式，这个很简单，redis 底层已经有具体的实现类了，我们只需要配置下：\n综上以上分析:RedisCacheConfig 类的方法调整为：\n  普通使用普通类的方式的话，那么在使用@Cacheable 的时候还需要指定 KeyGenerator 的名称;这样编码的时候比较麻烦。   *\n   @author Zjs\n  @version v.0.1\n   */ @Configuration\n@EnableCaching//启用缓存，这个注解很重要；\npublicclass RedisCacheConfig extends CachingConfigurerSupport {\n/**\n   缓存管理器.\n  @param redisTemplate\n  ######## @return\n   */ @Bean\npublic CacheManager cacheManager(RedisTemplate\u0026lt;?,?\u0026gt; redisTemplate) { CacheManager cacheManager = new RedisCacheManager(redisTemplate); returncacheManager;\n}\n/**\n  RedisTemplate 缓存操作类,类似于 jdbcTemplate 的一个类;   *\n  虽然 CacheManager 也能获取到 Cache 对象，但是操作起来没有那么灵活；   *\n  这里在扩展下：RedisTemplate 这个类不见得很好操作，我们可以在进行扩展一个我们   *\n  自己的缓存类，比如：RedisStorage 类;   *\n   @param factory : 通过 Spring 进行注入，参数在 application.properties 进行配置；\n  ######## @return\n   */ @Bean\npublic RedisTemplate\u0026lt;String, String\u0026gt; redisTemplate(RedisConnectionFactory factory) { RedisTemplate\u0026lt;String, String\u0026gt; redisTemplate = new RedisTemplate\u0026lt;String,\nString\u0026gt;();\nredisTemplate.setConnectionFactory(factory);\n//key 序列化方式;（不然会出现乱码;）,但是如果方法上有 Long 等非 String 类型的话，会报类型转换错误；\n//所以在没有自己定义 key 生成策略的时候，以下这个代码建议不要这么写，可以不配置或者自己实现 ObjectRedisSerializer\n//或者 JdkSerializationRedisSerializer 序列化方式;\nRedisSerializer\u0026lt;String\u0026gt; redisSerializer = new StringRedisSerializer();//Long 类 型不可以会出现异常信息;\nredisTemplate.setKeySerializer(redisSerializer); redisTemplate.setHashKeySerializer(redisSerializer);\nreturnredisTemplate;\n}\n/**\n   自定义 key.\n  此方法将会根据类名+方法名+所有参数的值生成唯一的一个 key,即使@Cacheable 中的 value 属性一样，key 也会不一样。\n   */ @Override\npublic KeyGenerator keyGenerator() { System.out.println(\u0026quot;RedisCacheConfig.keyGenerator()\u0026quot;); returnnew KeyGenerator() {\n@Override\npublic Object generate(Object o, Method method, Object... objects) {\n// This will generate a unique key of the class name, the method name\n//and all method parameters appended. StringBuilder sb = new StringBuilder(); sb.append(o.getClass().getName()); sb.append(method.getName());\nfor (Object obj : objects) { sb.append(obj.toString());\n}\nSystem.out.println(\u0026quot;keyGenerator=\u0026quot; + sb.toString());\nreturnsb.toString();\n}\n};\n}\n这时候在访问地址：[http://127.0.0.1:8080/test]{.underline}\n这时候看到的Key 就是：com.hpit.service.impl.DemoInfoServiceImplfindById1 在控制台打印信息是：\n其中@Cacheable,@CacheEvict 下节进行简单的介绍，剩下的就需要靠你们自己进行扩展了。\n Spring boot 之 spring cache  Spring 3.1 引入了激动人心的基于注释（annotation）的缓存（cache）技术，它本质上不是一个具体的缓存实现方案（例如 EHCache 或者 OSCache），而是一个对缓存使用的抽象，通过在既有代码中添加少量它定义的各种 annotation，即能够达到缓存方法的返回对象的效果。\nSpring 的缓存技术还具备相当的灵活性，不仅能够使用 SpEL（Spring Expression Language）来定义缓存的 key\n和各种 condition，还提供开箱即用的缓存临时存储方案，也支持和主流的专业缓存例如 EHCache 集成。其特点总结如下：\n   通过少量的配置 annotation 注释即可使得既有代码支持缓存\n  支持开箱即用 Out-Of-The-Box，即不用安装和部署额外第三方组件即可使用缓存\n  支持 Spring Express Language，能使用对象的任何属性或者方法来定义缓存的 key 和 condition 4.支持 AspectJ，并通过其实现任何方法的缓存支持\n   5.支持自定义 key 和自定义缓存管理者，具有相当的灵活性和扩展性\n一、基于注解的支持\nSpring 为我们提供了几个注解来支持 Spring Cache。其核心主要是@Cacheable、@CachePut 和@CacheEvict。使用@Cacheable 标记的方法在执行后 Spring Cache 将缓存其返回结果，@CachePut 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存，和 @Cacheable 不同的是，它每次都会触发真实方法的调用，而使用@CacheEvict 标记的方法会在方法执行前或者执行后移除 Spring Cache 中的某些元素。\n ######## 1.@Cacheable\n @Cacheable 可以标记在一个方法上，也可以标记在一个类上。当标记在一个方法上时表示该方法是支持缓存的，当标记在一个类上时则表示该类所有的方法都是支持缓存的。对于一个支持缓存的方法，Spring 会在其被调用后将其返回值缓存起来，以保证下次利用同样的参数来执行该方法时可以直接从缓存中获取结果，而不需 要再次执行该方法。Spring 在缓存方法的返回值时是以键值对进行缓存的，值就是方法的返回结果，至于键的话，Spring 又支持两种策略，默认策略和自定义策略，需要注意的是当一个支持缓存的方法在对象内部被调用时是不会触发缓存功能的。@Cacheable 可以指定三个属性，value、key 和 condition。\nvalue：缓存的名称，在 spring 配置文件中定义，必须指定至少一个。如@Cacheable(value=\u0026ldquo;mycache\u0026rdquo;) 或者\n@Cacheable(value={\u0026ldquo;cache1\u0026rdquo;,\u0026ldquo;cache2\u0026rdquo;}\nkey：缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合。如@Cacheable(value=\u0026ldquo;testcache\u0026rdquo;,key=\u0026quot;#userName\u0026quot;)\ncondition：缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存。如\n@Cacheable(value=\u0026ldquo;testcache\u0026rdquo;,condition=\u0026quot;#userName.length()\u0026gt;2\u0026quot;)\n注：除了上述使用方法参数作为 key 之外，Spring 还为我们提供了一个 root 对象可以用来生成 key。通过该root 对象我们可以获取到以下信息。\n2.@CachePut\n在支持 Spring Cache 的环境下，对于使用@Cacheable 标注的方法，Spring 在每次执行前都会检查 Cache 中是否存在相同 key 的缓存元素，如果存在就不再执行该方法，而是直接从缓存中获取结果进行返回，否则才会执行并将返回结果存入指定的缓存中。@CachePut 也可以声明一个方法支持缓存功能。与@Cacheable 不同的是使用@CachePut 标注的方法在执行前不会去检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法， 并将执行结果以键值对的形式存入指定的缓存中。\n@CachePut 也可以标注在类上和方法上。使用@CachePut 时我们可以指定的属性跟@Cacheable 是一样的。\n3.@CacheEvict\n@CacheEvict 是用来标注在需要清除缓存元素的方法或类上的。当标记在一个类上时表示其中所有的方法的执行都会触发缓存的清除操作。@CacheEvict 可以指定的属性有 value、key、condition、allEntries 和beforeInvocation。其中 value、key 和 condition 的语义与@Cacheable 对应的属性类似。即 value 表示清除操作是发生在哪些 Cache 上的（对应 Cache 的名称）；key 表示需要清除的是哪个 key，如未指定则会使用默认策略生成的 key；condition 表示清除操作发生的条件。下面我们来介绍一下新出现的两个属性 allEntries 和beforeInvocation。\nallEntries：是否清空所有缓存内容，缺省为 false，如果指定为 true，则方法调用后将立即清空所有缓存。\n如：@CachEvict(value=\u0026ldquo;testcache\u0026rdquo;,allEntries=true)\nbeforeInvocation：是否在方法执行前就清空，缺省为 false，如果指定为 true，则在方法还没有执行的时候就清空缓存，缺省情况下，如果方法执行抛出异常，则不会清空缓存。如：@CachEvict(value=\u0026quot; testcache\u0026quot;，beforeInvocation=true)\n其他参数和@Cacheable 相同\n4.@Caching\n@Caching 注解可以让我们在一个方法或者类上同时指定多个 Spring Cache 相关的注解。其拥有三个属性： cacheable、put 和 evict，分别用于指定@Cacheable、@CachePut 和@CacheEvict。如： @Caching(cacheable\n= @Cacheable(\u0026quot;users\u0026quot;), evict = { @CacheEvict(\u0026quot;cache2\u0026quot;),@CacheEvict(value = \u0026quot;cache3\u0026quot;, allEntries = true) })\n二、实例\n使用 map 集合实现缓存管理，演示 spring cache 的使用。\n  创建缓存对象实例  +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 1. package | \u0026gt; org.springframework.cache.demo; | +===================================+===================================+ | 2. | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 3. import java.io.Serializab | | le; | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 4. | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 5. //缓存对象 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 6. public class User imple | | ments Serializable{ | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 7. | \u0026gt; /** | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 8. | \u0026gt; * | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 9. | \u0026gt; */ | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 10. *private static final long | | * serialVersionUID = 1L; | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 11. private int id; | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 12. private String name; | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 13. | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 14. public User(){ | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 15. } | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 16. | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 17. public User(String name) | | { | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 18. this.name= name; | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 19. } | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 20. | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 21. public int getId() { | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 22. return id; | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\n  对象服务实现类\n package org.springframework.cache.demo;    2. 3. import org.springframework.cache.annotation.CacheEvict; 4. import org.springframework.cache.annotation.Cacheable; 5. 6. /** 7. * 业务服务 8. * 9. */ 10. public class UserService { 11. 12. @Cacheable(value = \u0026quot;userCache\u0026quot;,key=\u0026quot;#userName\u0026quot;) 13. // 使用了一个缓存名叫 userCache 14. public User getUserByName(String userName) { 15. // 方法内部实现不考虑缓存逻辑，直接实现业务 16. return getFromDB(userName); 17. } 18. 19. @CacheEvict(value = \u0026quot;userCache\u0026quot;, key = \u0026quot;#user.name\u0026quot;) 20. // 清 空 accountCache 缓 存 21. public void updateUser(User user) { 22. updateDB(user); 23. } 24. 25. @CacheEvict(value = \u0026quot;userCache\u0026quot;, allEntries = true,beforeInvocation=true) 26. // 清 空 accountCache 缓 存 27. public void reload() { 28. } 29. 30. private User getFromDB(String userName) {\n31. System.out.println(\u0026quot;查询数据库...\u0026quot; + userName); 32. return new User(userName); 33. } 34. 35. private void updateDB(User user) { 36. System.out.println(\u0026quot;更新数据库数据...\u0026quot; + user.getName()); 37. } 38. }\n 缓存实现  1. package org.springframework.cache.demo.mycache; 2. 3. import java.util.Map; 4. import java.util.concurrent.ConcurrentHashMap; 5. 6. import org.springframework.cache.Cache; 7. import org.springframework.cache.support.SimpleValueWrapper; 8. 9. public class MyCache implements Cache { 10. 11. private String name; 12. private Map\u0026lt;String, Object\u0026gt; store = new ConcurrentHashMap\u0026lt;String, Object\u0026gt;();; 13. 14. public MyCache() { 15. } 16. 17. public MyCache(String name) { 18. this.name = name; 19. } 20. 21. public void setName(String name) { 22. this.name = name; 23. } 24. 25. public void clear() { 26. store.clear(); 27. } 28. 29. public void evict(Object obj) { 30. } 31. 32. public ValueWrapper get(Object key) { 33. ValueWrapper result = null; 34. Object thevalue = store.get(key);\n####### spring 配置\n+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 1. \u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\\ | | \u0026ldquo; | +=======================================================================+ | 2. xmlns:xsi=[\u0026quot;http://www.w3.org/2001/XMLSchema](http://www.w3.org/ | | 2001/XMLSchema-)- | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | \u0026gt; instance\u0026quot; | | \u0026gt; xmlns:cache=[\u0026quot;http://www.springframework.org/schema/cache\u0026quot;](http: | | //www.springframework.org/schema/cache) | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 3. xmlns:p=[\u0026quot;http://www.springframework.org/schema/p\u0026quot;](http://www. | | springframework.org/schema/p) | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 4. xsi:schemaLocation=\u0026quot;http://www.springframework.org/schema/beans | |  | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 5. http://www.springframework.org/schema/beans/spring-beans.xsd | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 6. http://www.springframework.org/schema/cache | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 7. [http://www.springframework.org/schema/cache/spring-cache.xsd\u0026quot;]( | | http://www.springframework.org/schema/cache/spring-cache.xsd)\u0026gt; | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 8. \u0026lt;!-- 启用缓存注解功能，这个是必须的，否则注解不会生效，另外，该注解一定要声明在 spring 主配置文件中 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | \u0026gt; 才会生效 --\u0026gt; | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 9. \u0026lt;cache:annotation-driven cache-manager=\u0026quot;cacheManager\u0026quot; /\\ | | \u0026gt; | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 10. | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 11. \u0026lt;bean id=\u0026quot;userService\u0026quot; class=\u0026quot;org.springframework.cache. | | demo.UserService\u0026quot; /\u0026gt; | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 12. | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\n13. \u0026lt;!-- generic cache manager --\u0026gt; 14. \u0026lt;bean id=\u0026quot;cacheManager\u0026quot; class=\u0026quot;org.springframework.cache.support.SimpleCacheManager\u0026quot;\u0026gt; 15. \u0026lt;property name=\u0026quot;caches\u0026quot;\u0026gt; 16. \u0026lt;set\u0026gt; 17. \u0026lt;bean class=\u0026quot;org.springframework.cache.demo.mycache.MyCache\u0026quot; 18. p:name=\u0026quot;userCache\u0026quot; /\u0026gt; 19. \u0026lt;/set\u0026gt; 20. \u0026lt;/property\u0026gt; 21. \u0026lt;/bean\u0026gt; 22. \u0026lt;/beans\u0026gt;\n 运行类  +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 1. package org.springframework.cache.demo.mycache; | +=======================================================================+ | 2. | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 3. import org.springframework.cache.demo.User; | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 4. import org.springframework.cache.demo.UserService; | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 5. import org.springframework.context.ApplicationContext; | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 6. import org.springframework.context.support.ClassPathXmlApplic | | ationContext; | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 7. | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 8. public class MyMain { | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 9. | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 10. @SuppressWarnings(\u0026quot;resource\u0026quot;) | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 11. public static void main(String[] args) { | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 12. ApplicationContext context = new ClassPathXmlApplicationCont | | ext(\u0026quot;spring-cache- | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | \u0026gt; mycache.xml\u0026quot;); | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 13. UserService userService = context.getBean(UserService.class) | | ; | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 14. // 第一次查询，应该走数据库 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 15. System.out.print(\u0026quot;第一次查询...\u0026quot;); | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 16. userService.getUserByName(\u0026quot;hello\u0026quot;); | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 17. // 第二次查询，应该不查数据库，直接返回缓存的值 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 18. System.out.println(\u0026quot;第二次查询...\u0026quot;); | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 19. userService.getUserByName(\u0026quot;hello\u0026quot;); | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 20. System.out.println(); | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 21. System.out.println(\u0026quot;==============\u0026quot;); | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 22. | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 23. // 更新某个记录的缓存，首先构造两个用户记录，然后记录到缓存中 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 24. User user1 = userService.getUserByName(\u0026quot;user1\u0026quot;); | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 25. // 开始更新其中一个 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 26. user1.setId(1000); | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 27. userService.updateUser(user1); | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 28. // 因为被更新了，所以会查询数据库 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 29. userService.getUserByName(\u0026quot;user1\u0026quot;); | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 30. // 再次查询，应该走缓存 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\n+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | 31. userService.getUserByName(\u0026quot;user1\u0026quot;); | +============================================+================+ | \u0026gt; 32. // | \u0026gt; 更新所有缓存 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | 33. userService.reload(); | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | 34. System.out.println(\u0026quot;清楚所有缓存\u0026quot;); | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | \u0026gt; 35. // | \u0026gt; 查询数据库 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | 36. userService.getUserByName(\u0026quot;user1\u0026quot;); | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | 37. userService.getUserByName(\u0026quot;user2\u0026quot;); | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | \u0026gt; 38. // | \u0026gt; 查询缓存 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | 39. userService.getUserByName(\u0026quot;user1\u0026quot;); | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | 40. userService.getUserByName(\u0026quot;user2\u0026quot;); | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | 41. } | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | 42. } | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\n 运行结果：\n  第一次查询...查询数据库...hello   3.\n5. 查询数据库...user1\n7. 清楚所有缓存\n9. 查询数据库...user2\n Spring boot 集 成 EHCache  那么我们先说说这一篇文章我们都会学到的技术点： Spring Data JPA,Spring Boot 使用 Mysql,Spring MVC,EHCache,Spring Cache 等（其中@Cacheable 请看上一节的理论知识），具体分如下几个步骤：\n   新建Maven Java Project\n  在pom.xml 中加入依赖包\n  编写Spring Boot 启动类；\n  配置application.properties;\n  编写缓存配置类以及ehcache.xml 配置文件；\n  编写DemoInfo 实体类进行测试；\n  编写持久类DemoInfoRepository;\n  编写处理类DemoInfoService;\n  编写DemoInfoController 测试类；\n  运行测试；\n   以上就是具体的步骤了，那么接下来我们一起按照这个步骤来进行实现吧。\n  新建Maven Java Project   新建一个工程名为spring-boot-ehcache 的maven java project。\n  在pom.xml 中加入依赖包   在pom.xml 文件中加入相应的依赖包，Spring Boot 父节点依赖包；spring boot web 支持；缓存依赖 spring-\ncontext-support；集成ehcache 需要的依赖；JPA 操作数据库；mysql 数据库驱动，具体pom.xml 文件：\n\u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot;xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLS chema-instance\u0026quot;\nxsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt;\n\u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt;\n\u0026lt;groupId\u0026gt;com.hpit\u0026lt;/groupId\u0026gt;\n\u0026lt;artifactId\u0026gt;spring-boot-[ehcache]{.underline}\u0026lt;/artifactId\u0026gt;\n\u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt;\n\u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt;\n\u0026lt;name\u0026gt;spring-boot-[ehcache]{.underline}\u0026lt;/name\u0026gt;\n\u0026lt;url\u0026gt;http://maven.apache.org\u0026lt;/url\u0026gt;\n\u0026lt;properties\u0026gt;\n\u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt;\n\u0026lt;!-- 配置 JDK 编译版本. --\u0026gt;\n\u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt;\n\u0026lt;/properties\u0026gt;\n\u0026lt;!-- spring boot 父节点依赖,\n引入这个之后相关的引入就不需要添加 version 配置，\nspring boot 会自动选择最合适的版本进行添加。\n--\u0026gt;\n\u0026lt;parent\u0026gt;\n\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\n\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;\n\u0026lt;version\u0026gt;1.4.0.RELEASE\u0026lt;/version\u0026gt;\n\u0026lt;/parent\u0026gt;\n\u0026lt;dependencies\u0026gt;\n\u0026lt;!-- 单元测试. --\u0026gt;\n\u0026lt;dependency\u0026gt;\n\u0026lt;groupId\u0026gt;[junit]{.underline}\u0026lt;/groupId\u0026gt;\n\u0026lt;artifactId\u0026gt;[junit]{.underline}\u0026lt;/artifactId\u0026gt;\n\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;\n\u0026lt;/dependency\u0026gt;\n\u0026lt;!-- spring boot web 支持：[mvc]{.underline},[aop]{.underline}... --\u0026gt;\n\u0026lt;dependency\u0026gt;\n\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\n\u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt;\n\u0026lt;/dependency\u0026gt;\n\u0026lt;!--\n包含支持 UI 模版（Velocity，FreeMarker，JasperReports）， 邮件服务，\n脚本服务(JRuby)，\n缓存 Cache（EHCache），\n任务计划 Scheduling（[uartz]{.underline}）。\n--\u0026gt;\n\u0026lt;dependency\u0026gt;\n\u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt;\n\u0026lt;artifactId\u0026gt;spring-context-support\u0026lt;/artifactId\u0026gt;\n\u0026lt;/dependency\u0026gt;\n\u0026lt;!-- 集成 [ehcache]{.underline} 需要的依赖--\u0026gt;\n\u0026lt;dependency\u0026gt;\n\u0026lt;groupId\u0026gt;net.sf.ehcache\u0026lt;/groupId\u0026gt;\n\u0026lt;artifactId\u0026gt;[ehcache]{.underline}\u0026lt;/artifactId\u0026gt;\n\u0026lt;/dependency\u0026gt;\n\u0026lt;!-- JPA 操作数据库. --\u0026gt;\n\u0026lt;dependency\u0026gt;\n\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\n\u0026lt;artifactId\u0026gt;spring-boot-starter-data-[jpa]{.underline}\u0026lt;/artifactId\u0026gt;\n\u0026lt;/dependency\u0026gt;\n\u0026lt;!-- [mysql]{.underline} 数据库驱动. --\u0026gt;\n\u0026lt;dependency\u0026gt;\n\u0026lt;groupId\u0026gt;[mysql]{.underline}\u0026lt;/groupId\u0026gt;\n\u0026lt;artifactId\u0026gt;[mysql]{.underline}-connector-java\u0026lt;/artifactId\u0026gt;\n\u0026lt;/dependency\u0026gt;\n\u0026lt;!-- Spring boot 单元测试. --\u0026gt;\n\u0026lt;dependency\u0026gt;\n   编写Spring Boot 启动类（com.hpit.App.java）；\n  配置application.properties;\n   在application.properties 中主要配置数据库连接和JPA 的基本配置,具体如下： Src/main/resouces/application.properties：\n  编写缓存配置类以及ehcache.xml 配置文件：   这个类主要是注册缓存管理对象 EhCacheCacheManager、缓存工厂对象 EhCacheManagerFactoryBean， 具体代码如下：\n*/ @Configuration\n@EnableCaching//标注启动缓存.\npublic class CacheConfiguration {\n/**\n   [ehcache]{.underline} 主要的管理器\n  @param bean\n  ######## @return\n   */ @Bean\npublic EhCacheCacheManager ehCacheCacheManager(EhCacheManagerFactoryBean bean){ System.out.println(\u0026quot;CacheConfiguration.ehCacheCacheManager()\u0026quot;);\nreturn new EhCacheCacheManager(bean.getObject());\n}\n/*\n   据 shared 与否的设置,\n  Spring 分别通过 CacheManager.create()\n  或 new CacheManager()方式来创建一个 [ehcache]{.underline} 基地.\n   *\n  也说是说通过这个来设置 cache 的基地是这里的 Spring 独用,还是跟别的(如 [hibernate]{.underline} 的   [Ehcache]{.underline} 共享)\n*\n*/ @Bean\npublic EhCacheManagerFactoryBean ehCacheManagerFactoryBean(){ System.out.println(\u0026quot;CacheConfiguration.ehCacheManagerFactoryBean()\u0026quot;); EhCacheManagerFactoryBean cacheManagerFactoryBean = new EhCacheManagerFactoryBea\nn ();\ncacheManagerFactoryBean.setConfigLocation\n(newClassPathResource(\u0026quot;conf/ehcache.xml\u0026quot;)); cacheManagerFactoryBean.setShared(true); return cacheManagerFactoryBean;\n}\n}\n在 src/main/resouces/conf 下编写 ehcache.xml 配置文件，当然这个文件你可以放在其它目录下：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\n\u0026lt;ehcache xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:noNamespaceSchemaLocation=\u0026quot;http://ehcache.org/ehcache.xsd\u0026quot; updateCheck=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;!--\ndiskStore：为缓存路径，ehcache 分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：\nuser.home \u0026ndash; 用户主目录\nuser.dir \u0026ndash; 用户当前工作目录\njava.io.tmpdir \u0026ndash; 默认临时文件路径\n--\u0026gt;\n\u0026lt;diskStore path=\u0026quot;java.io.tmpdir/Tmp_EhCache\u0026quot; /\u0026gt;\n\u0026lt;!--\ndefaultCache：默认缓存策略，当 ehcache 找不到定义的缓存时，则使用这个缓存策略。只能定义\n一个。\n--\u0026gt;\n\u0026lt;!--\nname:缓存名称。maxElementsInMemory:缓存最大数目\nmaxElementsOnDisk：硬盘最大缓存个数。\neternal:对象是否永久有效，一但设置了，timeout 将不起作用。\noverflowToDisk:是否保存到磁盘，当系统当机时\ntimeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当 eternal=false 对象不是永久有效时使用，可选属性，默认值是 0，也就是可闲置时间无穷大。\ntimeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当 eternal=false 对象不是永久有效时使用，默认是 0.，也就是对象存活时间无穷大。\ndiskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between\nrestarts of the Virtual Machine. The default value is false. diskSpoolBufferSizeMB：这个参数设置 DiskStore（磁盘缓存）的缓存区大小。默认是 30MB。每\n个 Cache 都应该有自己的一个缓冲区。\ndiskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是 120 秒。\nmemoryStoreEvictionPolicy：当达到 maxElementsInMemory 限制时，Ehcache 将会根据指定的策略去清理内存。默认策略是 LRU（最近最少使用）。你可以设置为 FIFO（先进先出）或是 LFU（较少使用）。\nclearOnFlush：内存数量最大时是否清除。\nmemoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先 出）、LFU（最少访问次数）。\nFIFO，first in first out，这个是大家最熟的，先进先出。\nLFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个 hit 属性，hit 值最小的将会被清出缓存。\nLRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓 存。\n--\u0026gt;\n\u0026lt;defaultCache eternal=\u0026quot;false\u0026quot;\nmaxElementsInMemory=\u0026quot;1000\u0026quot; overflowToDisk=\u0026quot;false\u0026quot; diskPersistent=\u0026quot;false\u0026quot; timeToIdleSeconds=\u0026quot;0\u0026quot; timeToLiveSeconds=\u0026quot;600\u0026quot; memoryStoreEvictionPolicy=\u0026quot;LRU\u0026quot; /\u0026gt;\n\u0026lt;cache\nname=\u0026quot;demo\u0026quot; eternal=\u0026quot;false\u0026quot; maxElementsInMemory=\u0026quot;100\u0026quot; overflowToDisk=\u0026quot;false\u0026quot; diskPersistent=\u0026quot;false\u0026quot; timeToIdleSeconds=\u0026quot;0\u0026quot; timeToLiveSeconds=\u0026quot;300\u0026quot;\nmemoryStoreEvictionPolicy=\u0026quot;LRU\u0026quot; /\u0026gt;\n\u0026lt;/ehcache\u0026gt;\n  编写 DemoInfo 实体类进行测试；   在 com.hpit.bean 下编写 DemoInfo 实体类进行缓存测试：\npackage com.hpit.bean;\nimport javax.persistence.Entity;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.Id;\n/**\n   测试实体类.\n  @author Zjs\n  @version v.0.1\n   */ @Entity\npublic class DemoInfo { @Id @GeneratedValue\nprivate longid;//主键.\nprivate String name;//名称;\nprivate String pwd;//密码;\nprivate intstate; public long getId() {\nreturnid;\n}\npublic void setId(longid) {\nthis.id = id;\n}\npublic String getName() {\nreturnname;\n}\npublicvoid setName(String name) {\nthis.name = name;\n}\npublic String getPwd() {\nreturnpwd;\n}\npublic void setPwd(String pwd) {\nthis.pwd = pwd;\n}\npublic int getState() {\nreturnstate;\n}\n  编写持久类 DemoInfoRepository;   编 写 持 久 类 DemoInfoRepository： [com.hpit.repository]{.underline}.DemoInfoRepository：\n  编写处理类DemoInfoService;   编写增删改查的方法，在这几个方法中都使用注解缓存，进行缓存的创建以及删除，修改等操作：\ncom.hpit.service.DemoInfoService：\n[com.hpit.service.impl]{.underline}.DemoInfoServiceImpl：\n/**\n* value 属性表示使用哪个缓存策略，缓存策略在 ehcache.xml\n*/\npublic static final String DEMO_CACHE_NAME = \u0026quot;demo\u0026quot;;\n/**\n   保存数据.\n  @param demoInfo\n   */ @CacheEvict(value=DEMO_CACHE_NAME,key=CACHE_KEY) @Override\npublic DemoInfo save(DemoInfo demoInfo){\nreturn demoInfoRepository.save(demoInfo);\n}\n/**\n   查询数据.\n  @param id\n  ######## @return\n   */ @Cacheable(value=DEMO_CACHE_NAME,key=\u0026quot;'demoInfo_'+#id\u0026quot;) @Override\npublic DemoInfo findById(Long id){ System.err.println(\u0026quot;没有走缓存！\u0026quot;+id); return demoInfoRepository.findOne(id);\n}\n/**\n  http://www.mincoder.com/article/2096.shtml:   *\n  修改数据.   *\n  在支持 Spring Cache 的环境下，对于使用@Cacheable 标注的方法，Spring 在每次执行前都会检查Cache 中是否存在相同 key 的缓存元素，如果存在就不再执行该方法，而是直接从缓存中获取结果进行返回， 否则才会执行并将返回结果存入指定的缓存中。@CachePut 也可以声明一个方法支持缓存功能。与@Cacheable 不同的是使用@CachePut 标注的方法在执行前不会去检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中。   样的。\n@CachePut 也可以标注在类上和方法上。使用@CachePut 时我们可以指定的属性跟@Cacheable 是一\n*\n   @param updated\n  ######## @return\n   *\n  @throws NotFoundException   */\n@CachePut(value = DEMO_CACHE_NAME,key = \u0026quot;'demoInfo_'+#updated.getId()\u0026quot;)\n//@CacheEvict(value = DEMO_CACHE_NAME,key = \u0026quot;'demoInfo_'+#updated.getId()\u0026quot;)//这是清除缓存.\n@Override\npublic DemoInfo update(DemoInfo updated) throws NotFoundException{ DemoInfo demoInfo = demoInfoRepository.findOne(updated.getId()); if(demoInfo == null){\nthrownew NotFoundException(\u0026quot;No find\u0026quot;);\n}\ndemoInfo.setName(updated.getName()); demoInfo.setPwd(updated.getPwd()); return demoInfo;\n}\n/**\n   删除数据.\n  @param id\n   */\n@CacheEvict(value = DEMO_CACHE_NAME,key = \u0026quot;'demoInfo_'+#id\u0026quot;)//这是清除缓存. @Override\npublic void delete(Long id){ demoInfoRepository.delete(id);\n}\n}\n  编写DemoInfoController 测试类； 编写一个rest 进行测试：   com.hpit.controller.DemoInfoController：\npackage com.hpit.controller;\nimport javax.annotation.Resource;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport com.hpit.bean.DemoInfo;\nimport com.hpit.service.DemoInfoService;\nimport javassist.NotFoundException;\n@RestController\npublic class DemoInfoController {\n@Resource\nprivate DemoInfoService demoInfoService;\n@RequestMapping(\u0026quot;/test\u0026quot;)\npublic String test(){\n//存入两条数据.\nDemoInfo demoInfo = new DemoInfo(); demoInfo.setName(\u0026quot; 张 三 \u0026quot;); demoInfo.setPwd(\u0026quot;123456\u0026quot;);\nDemoInfo demoInfo2 = demoInfoService.save(demoInfo);\n//不走缓存.\nSystem.out.println(demoInfoService.findById(demoInfo2.getId()));\n// 走 缓 存 . System.out.println(demoInfoService.findById(demoInfo2.getId()));\ndemoInfo = new DemoInfo(); demoInfo.setName(\u0026quot; 李 四 \u0026quot;); demoInfo.setPwd(\u0026quot;123456\u0026quot;);\nDemoInfo demoInfo3 = demoInfoService.save(demoInfo);\n  运行测试；   运行App.java 进行测试，访问：[http://127.0.0.1:8080/test]{.underline} 进行测试，主要是观察控制台的打印信息。\n  Spring boot 分布式 Session 共享   在使用spring boot 做负载均衡的时候，多个app 之间的session 要保持一致，这样负载到不同的app 时候，在一个app 登录之后，而访问到另外一台服务器的时候，session 丢失。\n常规的解决方案都是使用：如apache 使用mod_jk.conf，使用Memcached 进行共享。\n在开发spring boot app 的时候可以借助 spring session 和redis 或者ehcache，用外置的 redis 或者ehcache来存储session 的状态,这里使用redis 进行介绍，ehcache 实现是一样的。\n增加相关依赖\n ####### \u0026lt;dependency\u0026gt;\n \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\n\u0026lt;artifactId\u0026gt;spring-boot-starter-redis\u0026lt;/artifactId\u0026gt;\n\u0026lt;/dependency\u0026gt;\n\u0026lt;dependency\u0026gt;\n\u0026lt;groupId\u0026gt;org.springframework.session\u0026lt;/groupId\u0026gt;\n\u0026lt;artifactId\u0026gt;spring-session-data-redis\u0026lt;/artifactId\u0026gt;\n\u0026lt;/dependency\u0026gt;\nRedisSessionConfig.java\npackage com.wisely.base;\n ####### import org.springframework.context.annotation.Configuration;\n import org.springframework.session.data.redis.config.annotation.web.http.EnableRedisHtt pSession;\n@Configuration @EnableRedisHttpSession\npublic class RedisSessionConfig {\n ####### }\n 如果需要添加失效时间可以使用以下的写法：\n@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 60) //1 分钟失效\n 相关配置修改  在application.properties 修改redis 配置信息（请自行安装redis），请根据实际修改。如：\n ####### spring.redis.host=127.0.0.1\n 所有实体类实现Serializable 接口\n ######## public class UserInfo implements Serializable\n 查看效果\n这时候登录系统在不同的app 之间跳转的时候，session 都是一致了，redis 上可以看到：\n 总结  使用这些代码之后 ，无论你使用nginx 或者apache，都无须在关心多个app 之间的session 一致的问题了。\n注意事项\n   redis 版本号需要是 2.8 以上否则会抛异常：ERR Unsupported CONFIG parameter: notify-keyspace-events；\n  RedisSessionConfig 需要放在App.java 启动类可以扫描的位置；\n    Spring boot 集成 shiro 权限控制\n  Spring boot 使用 java 创建 bean 并注册到 spring 中\n  {width=\u0026ldquo;2.9273184601924758in\u0026rdquo; height=\u0026ldquo;2.9273184601924758in\u0026rdquo;}Spring boot 多数据源\n  ","pubDate":"2021-02-15","title":"SpringBoot学习笔记完整教程"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_tool_spring%E5%B7%A5%E5%85%B7/","plain":"spring工具类  Spring-core中提供了大量的工具类，常用的有StringUtils、ObjectUtils、NumberUtils、Base64Utils等，Spring工具类在spring-core.jar中的org.springframework.util包下。\n  1:StringUtils  方法名\t返回值类型\t作用\t备注\risEmpty(Object str)\tboolean\t判断字符串是否为Null或者空字符串\tnull和''都为true\rhasLength(CharSequence str)\tboolean\t判断字符串长度是否大于1\tnull和''都为false\rhasText(CharSequence str)\tboolean\t判断字符串中是否有字符\tnull和空字白符都为false\rcontainsWhitespace(CharSequence str)\tboolean\t字符串中是否含有空白字符\ttrimWhitespace(CharSequence str)\tString\t去掉字符串中首尾的空白字符\ttrimAllWhitespace(String str)\tString\t去 掉字符串中所有的空白字符\ttrimLeadingWhitespace(String str)\tString\t去掉字符串左边的空白字符\ttrimTrailingWhitespace(String str)\tString\t去掉字符串右边边的空白字符\tstartsWithIgnoreCase(String str, String prefix)\tString\t判断字符串是否以xx开头，并且忽略大小写\tgetFilename(String path)\tString\t获取文件名\t“mypath/myfile.txt” -\u0026gt; “myfile.txt”\rgetFilenameExtension(String path)\tString\t获取文件扩展名\t“mypath/myfile.txt” -\u0026gt; “txt”\rstripFilenameExtension(String path)\tString\t去掉文件扩展名\t“mypath/myfile.txt” -\u0026gt; “mypath/myfile”\rreplace(String inString, String oldPattern, String newPattern)\tString\t替换字符串\tdelete(String inString, String pattern)\tString\t从给定的字符串中删除所有匹配的字符\tdeleteAny(String inString, String charsToDelete)\tString\t删除所有指定字符\t“az\\n” will delete ‘a’s, ‘z’s and new lines\rSystem.out.println(org.springframework.util.StringUtils.containsWhitespace(\u0026quot;sfas\u0026quot;));//是否有空白 false\rSystem.out.println(org.springframework.util.StringUtils.trimWhitespace(\u0026quot; - dfasd- \u0026quot;));//去除前后空格\rSystem.out.println(org.springframework.util.StringUtils.trimAllWhitespace(\u0026quot; - - - - fshjk s j - -\u0026quot;));//去除所有空格\rSystem.out.println(org.springframework.util.StringUtils.trimLeadingWhitespace(\u0026quot; - - - - fshjk s j - - \u0026quot;));//去除第字符串开头的空格\rSystem.out.println(org.springframework.util.StringUtils.trimTrailingWhitespace(\u0026quot; - - - - fshjk s j - - \u0026quot;));//去除第字符串结尾的空格\rSystem.out.println(org.springframework.util.StringUtils.substringMatch(\u0026quot;f sdfc\u0026quot;,2,\u0026quot;sd\u0026quot;));//判断字符串第几个位置起为某值\rSystem.out.println(org.springframework.util.StringUtils.countOccurrencesOf(\u0026quot;qwertyrtttttt\u0026quot;, \u0026quot;t\u0026quot;));//判断字符串字符重复次数\rSystem.out.println(org.springframework.util.StringUtils.replace(\u0026quot;yuiyuiyui\u0026quot;, \u0026quot;y\u0026quot;, \u0026quot;m\u0026quot;));//字符替换\rSystem.out.println(org.springframework.util.StringUtils.delete(\u0026quot;yuiyuiyui\u0026quot;, \u0026quot;y\u0026quot;));//删除匹配的字符\rSystem.out.println(org.springframework.util.StringUtils.deleteAny(\u0026quot;yuiyuiyui\u0026quot;, \u0026quot;yi\u0026quot;));//删除出现且匹配的字符\rSystem.out.println(org.springframework.util.StringUtils.quote(\u0026quot;yuiyuiyui\u0026quot;));//为字符串加上''号\rSystem.out.println(org.springframework.util.StringUtils.unqualify(\u0026quot;yuiyuiy.ui\u0026quot;));//字符串截取，，从'.'号+1的未知开始\rSystem.out.println(org.springframework.util.StringUtils.unqualify(\u0026quot;yuiyuiy.ui\u0026quot;,'y'));//字符串截取，，从字符最后出现的位置+1开始\rSystem.out.println(org.springframework.util.StringUtils.capitalize(\u0026quot;yuiyuiy\u0026quot;));//首字母大写\rSystem.out.println(org.springframework.util.StringUtils.uncapitalize(\u0026quot;YuIyuiy\u0026quot;));//首字母小写\rSystem.out.println(org.springframework.util.StringUtils.uncapitalize(\u0026quot;YuIyuiy\u0026quot;));//首字母小写 changeFirstCharacterCase(String str, boolean capitalize),capitalize为true则为大写\rSystem.out.println(org.springframework.util.StringUtils.getFilename(\u0026quot;D://Java\u0026quot;));//截取最后一个\\出现的未知+1的字符串 Java\rSystem.out.println(org.springframework.util.StringUtils.getFilenameExtension(\u0026quot;D:/Java.fdsdf\u0026quot;));//获取路劲下的后缀名 fdsdf\rSystem.out.println(org.springframework.util.StringUtils.stripFilenameExtension(\u0026quot;D:/Java.fdsdf\u0026quot;));//获取路劲下的后缀名之前的部分 D:/Java\r 2:ObjectUtils  isEmpty(Object obj)\tboolean\t判断对象是否为空\t对象为null或者数组Map为空等都为true\risEmpty(Object[] array)\tboolean\t判断数组是否为空\tisArray(Object obj)\tboolean\t判断对象是否为数组\tcontainsElement(Object[] array, Object element)\tboolean\t判断数据组中是否包含给定的元素\taddObjectToArray(A[] array, O obj)\r 3:NumberUtils  convertNumberToTargetClass(Number number, Class targetClass)\t\u0026lt;T extends Number\u0026gt; T\t将Number转为指定的类型\rparseNumber(String text, Class targetClass)\t\u0026lt;T extends Number\u0026gt; T\t将字符串转为数值类型\rparseNumber(String text, Class targetClass, NumberFormat numberFormat)\t\u0026lt;T extends Number\u0026gt; T\t将字符串转为数值类型\r 4:Base64Utils  encode(byte[] src)\tbyte[]\t编码\rdecode(byte[] src)\tbyte[]\t解码\r","pubDate":"2021-02-15","title":"spring工具"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_tool_spring%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/","plain":"spring常用的工具类 内置的resouce类型 UrlResource\rClassPathResource\rFileSystemResource\rServletContextResource\rInputStreamResource\rByteArrayResource\rEncodedResource 也就是Resource加上encoding, 可以认为是有编码的资源\rVfsResource(在jboss里经常用到, 相应还有 工具类 VfsUtils)\rorg.springframework.util.xml.ResourceUtils 用于处理表达资源字符串前缀描述资源的工具. 如: \u0026amp;quot;classpath:\u0026amp;quot;. 有 getURL, getFile, isFileURL, isJarURL, extractJarFileURL 工具类 org.springframework.core.annotation.AnnotationUtils 处理注解\rorg.springframework.core.io.support.PathMatchingResourcePatternResolver 用 于处理 ant 匹配风格(com/*.jsp, com/**/*.jsp),找出所有的资源, 结合上面的resource的概念一起使用,对于遍历文件很有用. 具体请详细查看javadoc\rorg.springframework.core.io.support.PropertiesLoaderUtils 加载Properties资源工具类,和Resource结合\rorg.springframework.core.BridgeMethodResolver 桥接方法分析器. 关于桥接方法请参考: http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.12.4.5\rorg.springframework.core.GenericTypeResolver 范型分析器, 在用于对范型方法, 参数分析.\rorg.springframework.core.NestedExceptionUtils\rxml工具 org.springframework.util.xml.AbstractStaxContentHandler\rorg.springframework.util.xml.AbstractStaxXMLReader\rorg.springframework.util.xml.AbstractXMLReader\rorg.springframework.util.xml.AbstractXMLStreamReader\rorg.springframework.util.xml.DomUtils\rorg.springframework.util.xml.SimpleNamespaceContext\rorg.springframework.util.xml.SimpleSaxErrorHandler\rorg.springframework.util.xml.SimpleTransformErrorListener\rorg.springframework.util.xml.StaxUtils\rorg.springframework.util.xml.TransformerUtils\r其它工具集 org.springframework.util.xml.AntPathMatcherant风格的处理\rorg.springframework.util.xml.AntPathStringMatcher\rorg.springframework.util.xml.Assert断言,在我们的参数判断时应该经常用\rorg.springframework.util.xml.CachingMapDecorator\rorg.springframework.util.xml.ClassUtils用于Class的处理\rorg.springframework.util.xml.CollectionUtils用于处理集合的工具\rorg.springframework.util.xml.CommonsLogWriter\rorg.springframework.util.xml.CompositeIterator\rorg.springframework.util.xml.ConcurrencyThrottleSupport\rorg.springframework.util.xml.CustomizableThreadCreator\rorg.springframework.util.xml.DefaultPropertiesPersister\rorg.springframework.util.xml.DigestUtils摘要处理, 这里有用于md5处理信息的\rorg.springframework.util.xml.FileCopyUtils文件的拷贝处理, 结合Resource的概念一起来处理, 真的是很方便\rorg.springframework.util.xml.FileSystemUtils\rorg.springframework.util.xml.LinkedCaseInsensitiveMap\rkey值不区分大小写的LinkedMap\rorg.springframework.util.xml.LinkedMultiValueMap一个key可以存放多个值的LinkedMap\rorg.springframework.util.xml.Log4jConfigurer一个log4j的启动加载指定配制文件的工具类\rorg.springframework.util.xml.NumberUtils处理数字的工具类, 有parseNumber 可以把字符串处理成我们指定的数字格式, 还支持format格式, convertNumberToTargetClass 可以实现Number类型的转化. org.springframework.util.xml.ObjectUtils有很多处理null object的方法. 如nullSafeHashCode, nullSafeEquals, isArray, containsElement, addObjectToArray, 等有用的方法\rorg.springframework.util.xml.PatternMatchUtilsspring里用于处理简单的匹配. 如 Spring's typical \u0026amp;quot;xxx*\u0026amp;quot;, \u0026amp;quot;*xxx\u0026amp;quot; and \u0026amp;quot;*xxx*\u0026amp;quot; pattern styles\rorg.springframework.util.xml.PropertyPlaceholderHelper用于处理占位符的替换\rorg.springframework.util.xml.ReflectionUtils反映常用工具方法. 有 findField, setField, getField, findMethod, invokeMethod等有用的方法\rorg.springframework.util.xml.SerializationUtils用于java的序列化与反序列化. serialize与deserialize方法\rorg.springframework.util.xml.StopWatch一个很好的用于记录执行时间的工具类, 且可以用于任务分阶段的测试时间. 最后支持一个很好看的打印格式. 这个类应该经常用\rorg.springframework.util.xml.StringUtils\rorg.springframework.util.xml.SystemPropertyUtils\rorg.springframework.util.xml.TypeUtils用于类型相容的判断. isAssignable\rorg.springframework.util.xml.WeakReferenceMonitor弱引用的监控 和web相关的工具 org.springframework.web.util.CookieGenerator\rorg.springframework.web.util.HtmlCharacterEntityDecoder\rorg.springframework.web.util.HtmlCharacterEntityReferences\rorg.springframework.web.util.HtmlUtils\rorg.springframework.web.util.HttpUrlTemplate\r这个类用于用字符串模板构建url, 它会自动处理url里的汉字及其它相关的编码. 在读取别人提供的url资源时, 应该经常用 String url = \u0026amp;quot;http://localhost/myapp/{name}/{id}\u0026amp;quot;\rorg.springframework.web.util.JavaScriptUtils\rorg.springframework.web.util.Log4jConfigListener\r用listener的方式来配制log4j在web环境下的初始化\rorg.springframework.web.util.UriTemplate\rorg.springframework.web.util.UriUtils处理uri里特殊字符的编码\rorg.springframework.web.util.WebUtils\rorg.springframework.web.util.\r","pubDate":"2021-02-15","title":"spring常用的工具类"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_study_study.web/","plain":"自己整理的日常开发参考网址    在线工具 链接     web工具 web工具   在线超级转换工具 在线超级转换工具   程序员在线工具 在线超级转换工具       算法 链接     算法网址 leetcode 国内 算法网址 leetcode 国内   算法网址 牛课网 国内 算法网址 牛课网 国内   算法网址 codility 国外 算法网址 codility 国外       bootstrap 链接     bootstrap 重要参考例子 bootstrap 重要参考例子   bootstrap table api(csdn) bootstrap table api(csdn)   bootstrap table api(官方) bootstrap table api(官方)       图标 链接     阿里巴巴icon 阿里巴巴icon   easy icon easy icon        Java学习 链接     ibm java example ibm java example   Java并发参考 Java并发参考   csdn csdn   Java分享网 Java分享网   java fx api java fx api       教程 链接     www.w3cschoo 国内 www.w3cschoo 国内   www.w3cschoo 国外 www.w3cschoo 国内   菜鸟教程 菜鸟教程   nginx api nginx api   vue 学习 vue 学习   幕课网 幕课网   我要自学网 我要自学网       网站 链接     站长之家 站长之家   脚本之家 脚本之家   源码之家 源码之家       考试网 链接     中国人事考试网 中国人事考试网   计算机技术与软件专业技术资格 计算机技术与软件专业技术资格   中国计算机职业资格网 中国计算机职业资格网       例子 链接     淘宝如何处理分布式请求的 博客网 淘宝如何处理分布式请求的 博客网   [淘宝如何处理分布式请求的 微信公众号 [淘宝如何处理分布式请求的 微信公众号   Java程序员必学知识点整理 Java程序员必学知识点整理   程序员必须掌握哪些算法？ 程序员必须掌握哪些算法？   12个模块 150 道 java 必考面试题 12个模块 150 道 java 必考面试题   优化代码中大量的if/else，你有什么方案? 优化代码中大量的if/else，你有什么方案?   短时间如何过java面试？ 短时间如何过java面试？   如何学习Java的NIO？ 如何学习Java的NIO？   16个小众却很实用的网站（程序员方向） 16个小众却很实用的网站（程序员方向）   如何判断 Java 工程师的基础知识是否扎实？ 如何判断 Java 工程师的基础知识是否扎实？   JAVA的多态用几句话能直观的解释一下吗？ JAVA的多态用几句话能直观的解释一下吗？    计算机在职研究生招生学校    学校 层次     西南交通大学 211   中国人民大学 教育部直属   自考参考网站 教育部直属    收集的杂七杂八得网址    学校     Java程序员掉发系列——程序员的成长之路   史上最全的程序员常用英语词汇   Java程序员掉发系列——程序员必须认识的英文单词（汇总）   每个程序员必须掌握的常用英语词汇   程序员必知1700英语单词   这70个Java必背英语单词不会，就别说你是Java程序员！   java代理机制   国内有哪些质量高的JAVA社区？   hutool-all 介绍 ==\u0026gt; Hutool是一个小而全的Java工具类库   GitHub Pages 绑定来自阿里云的域名   Spring Boot 学习    ","pubDate":"2021-02-15","title":"study.web"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_method_studyinfo/","plain":"学习方法 ","pubDate":"2021-02-15","title":"studyInfo"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_swing_swing_introduction/","plain":"Swing 类库结构 \rSwing 是新一代的图形界面工具。使用 Swing 来开发图形界面比 AWT 更加优秀，因为 Swing 是一种轻量级组件，它采用纯 Java 实现，不再依赖于本地平台的图形界面，所以可以在所有平台上保持相同的运行效果，对跨平台支持比较出色。除此之外，Swing 提供了比 AWT 更多的图形界面组件，因此可以开发出美观的图形界面程序。\r  Swing 组件都采用 MVC（Model-View-Controller，即模型-视图-控制器）的设计，实现 GUI 组件的显示逻辑和数据逻辑的分离，从而允许程序员自定义 Render 来改变 GUI 组件的显示外观，以提供更多的灵活性。\n  Swing 围绕 JComponent 组件构建，JComponent 则由 AWT 的容器类扩展而来。Swing 组织结构如图 1 所示。\n  Swing包   从图 1 可以看出，Swing 组件除了 AbstmctButton 类之外都以 J 开头。Swing 容器组件直接继承 AWT 类库中的容器组件类，其他大部分组件都是继承 JComponet 组件。组件可以划分为容器组件和非容器组件，容器组件包括 JFmme 和 JDialog。其中 JComponent 定义了非容器类的轻量级组件（JBntton、JPanel、JMenu 等）。\n  表1 Swing常用包\n     包名称 描述     javax.swing 提供一组“轻量级”组件，尽量让这些组件在所有平台上的工作方式都相同   javax.swing.border 提供围绕 Swing 组件绘制特殊边框的类和接口   javax.swing.event 提供 Swing 组件触发的事件   javax.swing.filechooser 提供 JFileChooser 组件使用的类和接口   javax.swing.table 提供用于处理 javax.swing.JTable 的类和接口   javax.swing.text 提供类 HTMLEditorKit 和创建 HTML 文本编辑器的支持类   javax.swing.tree 提供处理 javax.swingJTree 的类和接口     javax.swing.event 包中定义了事件和事件监听器类，javax.swing.event 包与 AWT 的 event 包类似。Java.awt.event 和 javax.swing.event 都包含事件类和监听器接口，它们分别响应由 AWT 组件和 Swing 组件触发的事件。    例如，当在树组件中需要节点扩展（或折叠）的通知时，则要实现 Swing 的 TreeExpansionListener 接口，并把一个 TreeExpansionEvent 实例传送给 TreeExpansionListener 接口中定义的方法，而 TreeExpansionListener 和 TreeExpansionEvent 都是在 swing.event 包中定义的。\n  虽然 Swing 的表格组件（JTable）在 javax.swing 包中，但它的支持类却在 javax.swing.table 包中。表格模型、图形绘制类和编辑器等也都在 javax.swing.table 包中。\n  与 JTable 类一样，Swing 中的树 JTree（用于按层次组织数据的结构组件）也在 javax.swing 包中，而它的支持类却在 javax.swing.tree 包中。javax.swing.tree 包提供树模型、树节点、树单元编辑类和树绘制类等支持类。\n  Swing 容器   创建图形用户界面程序的第一步是创建一个容器类以容纳其他组件，常见的窗口就是一种容器。容器本身也是一种组件，它的作用就是用来组织、管理和显示其他组件。\n  Swing 中容器可以分为两类：顶层容器和中间容器。\n  顶层容器是进行图形编程的基础，一切图形化的东西都必须包括在顶层容器中。顶层容器是任何图形界面程序都要涉及的主窗口，是显示并承载组件的容器组件。在 Swing 中有三种可以使用的顶层容器，分别是 JFrame、JDialog 和 JApplet。\n  JFrame：用于框架窗口的类，此窗口带有边框、标题、关闭和最小化窗口的图标。带 GUI 的应用程序至少使用一个框架窗口。\n  JDialog：用于对话框的类。\n  JApplet：用于使用 Swing 组件的 Java Applet 类。\n  中间容器是容器组件的一种，也可以承载其他组件，但中间容器不能独立显示，必须依附于其他的顶层容器。常见的中间容器有 JPanel、JScrollPane、JTabbedPane 和 JToolBar。\n  JPanel：表示一个普通面板，是最灵活、最常用的中间容器。\n  JScrollPane：与 JPanel 类似，但它可在大的组件或可扩展组件周围提供滚动条。\n  JTabbedPane：表示选项卡面板，可以包含多个组件，但一次只显示一个组件，用户可在组件之间方便地切换。\n  JToolBar：表示工具栏，按行或列排列一组组件（通常是按钮）。\n  在 Java 程序中容器类都是继承自 Container 类。中间容器和顶层容器在，AWT 包和 Swing 包中继承 Container 类的继承关系，如图 2 所示。\n  ","pubDate":"2021-02-15","title":"swing \u003e Introduction"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_linux_ubuntu-16.04%E4%BF%AE%E6%94%B9hosts/","plain":"IntelliJ IDE运行Tomcat报错解决办法的相关资料,出现“Unable to ping server at localhost:1099”错误解决方法，需要的朋友可以参考下\nsudo gedit /etc/hosts\n","pubDate":"2021-02-15","title":"Ubuntu 16.04修改hosts"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_linux_ubuntu%E5%AE%89%E8%A3%85chmsee/","plain":"垃圾的ubuntu 14.04 又一次去掉一些特别好用的软件, 官方给的解释是怕破坏他们系统. 只想说一句 我去年买了个本.\n14.04 之前的版本,如13.10, 12.04 继续能够使用 sudo apt-get install chmsee 来安装.\n14.04 需要下载安装包来安装:\nsudo apt-get install libc6 libchm1 libgcrypt11 libgdk-pixbuf2.0-0 libglib2.0-0 libgtk2.0-0 libpango1.0-0 libwebkitgtk-1.0-0 libxml2 安装依赖包\n(64位) sudo dpkg -i chmsee_1.3.0-2ubuntu2_amd64.deb 安装软件包,下载地址: http://kr.archive.ubuntu.com/ubuntu/pool/universe/c/chmsee/chmsee_1.3.0-2ubuntu2_amd64.deb Ubuntu的官方软件库放心下载.\n(32位) sudo dpkg -i chmsee_1.3.0-2ubuntu2_i386.deb 安装软件包,下载地址: http://kr.archive.ubuntu.com/ubuntu/pool/universe/c/chmsee/chmsee_1.3.0-2ubuntu2_i386.deb Ubuntu的官方软件库放心下载.\n","pubDate":"2021-02-15","title":"ubuntu安装chmsee"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_linux_ubuntu%E6%B8%85%E7%90%86%E7%B3%BB%E7%BB%9F%E5%9E%83%E5%9C%BE/","plain":"1，非常有用的清理命令： sudo apt-get autoclean \u0026ndash;清理旧版本的软件缓存 www.2cto.com\nsudo apt-get clean\u0026ndash;清理所有软件缓存\nsudo apt-get autoremove\u0026ndash;删除系统不再使用的孤立软件\n这三个命令主要清理升级缓存以及无用包的。\n2，清理opera firefox的缓存文件： ls ~/.opera/cache4 ls ~/.mozilla/firefox/*.default/Cache\n3，清理Linux下孤立的包： 图形界面下我们可以用：gtkorphan sudo apt-get install gtkorphan -y 终端命令下我们可以用：deborphan sudo apt-get install deborphan -y\n4，卸载：tracker 这个东西一般我只要安装Ubuntu就会第一删掉tracker 他不仅会产生大量的cache文件而且还会影响开机速度。所以在新得利里面删掉就行。 www.2cto.com\n5，删除多余的内核：一定不要删错哦，切记！！ 打开终端敲命令：dpkg \u0026ndash;get-selections|grep linux 有image的就是内核文件 删除老的内核文件： sudo apt-get remove 内核文件名（例如：linux-image-2.6.27-2-generic） 内核删除，释放空间了，应该能释放130－140M空间。\n最后不要忘了看看当前内核：uname -a 附录： 包管理的临时文件目录: 包在 /var/cache/apt/archives 没有下载完的在 /var/cache/apt/archives/partial\n","pubDate":"2021-02-15","title":"Ubuntu清理系统垃圾"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_linux_ubuntu%E8%BD%AF%E4%BB%B6%E5%8D%B8%E8%BD%BD/","plain":"ubuntu软件卸载\n安装Synaptic\nsudo apt-get install synaptic\n","pubDate":"2021-02-15","title":"ubuntu软件卸载"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_java_usemath/","plain":"计算机用到的数学公式 二进制十进制如何互相转换 https://jingyan.baidu.com/article/ac6a9a5e2cb17b2b653eac98.html\n","pubDate":"2021-02-15","title":"useMath"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_visual_studio_code_visualstudiocode%E8%BF%87%E6%BB%A4%E6%96%87%E4%BB%B6%E4%B8%8D%E6%98%BE%E7%A4%BA%E6%9F%90%E4%BA%9B%E6%96%87%E4%BB%B6/","plain":"Visual Studio Code 过滤文件 不显示某些文件 效果  过滤工程中显示的文件 不显示某些类型的文件或文件夹  菜单  File/Preferences/ 搜索file exclude 选中workspack页签 添加一个过滤规则 如图:   ","pubDate":"2021-02-15","title":"VisualStudioCode过滤文件不显示某些文件"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_vue_vue_index/","plain":"vue学习 vue学习 vue学习2   vue 官网 https://cn.vuejs.org/\n  vue 是什么?\n  Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。\r另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。\r v-text 文本指令  \r\u0026lt;span v-text=\u0026quot;msg\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\r\u0026lt;!-- 和下面的一样 --\u0026gt;\r\u0026lt;span\u0026gt;{{msg}}\u0026lt;/span\u0026gt;\rvar vm = new Vue({\rel: \u0026quot;#frmApp\u0026quot;,\rdata: {\rnameTo: Math.random().toString(36).slice(-8) ,\r}\r});\r//获取绑定的实例 再次更新\rvm.$data.nameTo = Math.random().toString(36).slice(-8);\r v-html 网页指令  内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译 。如果试图使用 v-html 组合模板，可以重新考虑是否通过使用组件来替代。\r\u0026lt;div v-html=\u0026quot;html\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;p v-html=\u0026quot;htmlContent\u0026quot;\u0026gt;\r\u0026lt;/p\u0026gt;\r v-model 这个指令用于在表单上创建双向数据绑定。   v-model会忽略所有表单元素的value、checked、selected特性的初始值。因为它选择Vue实例数据做为具体的值。\n \u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;input v-model=\u0026quot;somebody\u0026quot;\u0026gt;\r\u0026lt;p\u0026gt;hello {{somebody}}\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rvar app = new Vue({\rel: '#app',\rdata: {\rsomebody:'小明'\r}\r})\r\u0026lt;/script\u0026gt;\r这个例子中直接在浏览器input中输入别的名字，下面的p的内容会直接跟着变。这就是双向数据绑定。\rv-model修饰符\r\u0026lt;1\u0026gt; .lazy\r默认情况下，v-model同步输入框的值和数据。可以通过这个修饰符，转变为在change事件再同步。\r\u0026lt;input v-model.lazy=\u0026quot;msg\u0026quot;\u0026gt;\r\u0026lt;2\u0026gt; .number\r自动将用户的输入值转化为数值类型\r\u0026lt;input v-model.number=\u0026quot;msg\u0026quot;\u0026gt;\r\u0026lt;3\u0026gt; .trim\r自动过滤用户输入的首尾空格\r\u0026lt;input v-model.trim=\u0026quot;msg\u0026quot;\u0026gt;\r v-bind html中特性或者属性绑定  \r","pubDate":"2021-02-15","title":"vue \u003e index"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_windows_windows_question/","plain":" 磁盘变为了动态磁盘解决办法 最好是找软件解决 如DiskGenius 或者 傲梅分区助手 暴力解决办法  \r1、diskpart\r2、list disk\r3、select disk n\r4、convert basic\rSTEP 1：打开命令提示符窗口，在其中键入：“diskpart”命令并按下回车键。 STEP 2：在DISKPART命令提示符下，键入“list disk”命令并按下回车键后，能够查看到电脑中的磁盘情况。 STEP 3：在DISKPART命令提示符下，继续键入“select disk n”命令并按下回车键，其中n代表磁盘的序号。 STEP 4：在DISKPART命令提示符下，键入“convert dynamic”命令并按下回车键后，开始转换的工作。\r","pubDate":"2021-02-15","title":"windows \u003e question"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98edismemcached%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/","plain":"{width=\u0026ldquo;6.461388888888889in\u0026rdquo; height=\u0026ldquo;0.5419991251093613in\u0026rdquo;}\n(1) memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为丰富的数据类型\n(2) redis 的速度比 memcached 快很多\n(3) redis 可以持久化其数据\n{width=\u0026ldquo;6.461388888888889in\u0026rdquo; height=\u0026ldquo;0.5419991251093613in\u0026rdquo;}\n String、List、Set、Sorted Set、hashes\n {width=\u0026ldquo;6.461388888888889in\u0026rdquo; height=\u0026ldquo;0.5416655730533684in\u0026rdquo;}\n 1.twemproxy，大概概念是，它类似于一个代理方式，使用方法和普通 redis 无任何区别，设置好它下属的多个 redis 实例后，使用时在本需要连接 redis 的地方改为连接 twemproxy，它会以一个代理的身份接收请求并使用一致性 hash 算法，将请求转接到具体 redis，将结果再返回 twemproxy。使用方式简便(相对 redis只需修改连接端口)，对旧项目扩展的首选。 问题：twemproxy 自身单端口实例的压力，使用一致性 hash 后，对 redis 节点数量改变时候的计算值的改变，数据无法自动移动到新的节点。\n {width=\u0026ldquo;6.461388888888889in\u0026rdquo; height=\u0026ldquo;0.5416666666666666in\u0026rdquo;}\n LRU 算法\n {width=\u0026ldquo;6.461388888888889in\u0026rdquo; height=\u0026ldquo;0.5403324584426946in\u0026rdquo;}\n 分区可以让 Redis 管理更大的内存，Redis 将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使 Redis 的计算能力通过简单地增加计算机得到成倍提升,Redis 的网络带宽也会随着计算机和网卡的增加而成倍增长。\n {width=\u0026ldquo;6.461388888888889in\u0026rdquo; height=\u0026ldquo;0.5416666666666666in\u0026rdquo;}\n 给你举个例子： 100 万个键值对（键是 0 到 999999 值是字符串\u0026quot;hello world\u0026quot;）在我的 32 位的 Mac 笔记本上 用了 100MB。同样的数据放到一个 key 里只需要 16MB， 这是因为键值有一个很大的开销。 在 Memcached 上执行也是类似的结果，但是相对 Redis 的开销要小一点点，因为 Redis 会记录类型信息引用计数等等。\n {width=\u0026ldquo;6.461388888888889in\u0026rdquo; height=\u0026ldquo;0.5416666666666666in\u0026rdquo;}\n a、完全基于内存缓存的b、节点之间相互独立\nc、C/S 模式架构，C 语言编写，总共 2000 行代码。 d、异步Ｉ/O 模型，使用 libevent 作为事件通知机制。e、被缓存的数据以 key/value 键值对形式存在的。\nf、全部数据存放于内存中，无持久性存储的设计，重启服务器，内存里的数据会丢失。\ng、当内存中缓存的数据容量达到启动时设定的内存值时，就自动使用 LRU 算法删除过期的缓存数据。\nh、可以对存储的数据设置过期时间，这样过期后的数据自动被清除，服务本身不会监控过期，而是在访问的时候查看 key 的时间戳,判断是否过期。\nj、memcache 会对设定的内存进行分块，再把块分组，然后再提供服务。\n {width=\u0026ldquo;6.461388888888889in\u0026rdquo; height=\u0026ldquo;0.5419991251093613in\u0026rdquo;}\n Session 是运行在一台服务器上的，所有的访问都会到达我们的唯一服务器上， 这样我们可以根据客户端传来的 sessionID，来获取 session，或在对应 Session 不存在的情况下（session 生命周期到了/用户第一次登录），创建一个新的Session；但是，如果我们在集群环境下，假设我们有两台服务器 A，B，用户的请求会由 Nginx 服务器进行转发（别的方案也是同理），用户登录时，Nginx 将请求转发至服务器 A 上，A 创建了新的 session，并将 SessionID 返回给客户端，用户在浏览其他页面时，客户端验证登录状态，Nginx 将请求转发至服务器B，由于 B 上并没有对应客户端发来 sessionId 的 session，所以会重新创建一个新的 session，并且再将这个新的 sessionID 返回给客户端，这样，我们可以想象一下，用户每一次操作都有 1/2 的概率进行再次的登录，这样不仅对用户体验特别差，还会让服务器上的 session 激增，加大服务器的运行压力。\n为了解决集群环境下的 seesion 共享问题，共有 4 种解决方案：\n将 session 存储至数据库中，像操作数据一样才做 session。\n {width=\u0026ldquo;6.461388888888889in\u0026rdquo; height=\u0026ldquo;0.5416666666666666in\u0026rdquo;}\n 1、Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。而 memcache 只支持简单数据类型，需要客户端自己处理复杂对象\n2、Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用（PS：持久化在 rdb、aof）。\n3、由于 Memcache 没有持久化机制，因此宕机所有缓存数据失效。Redis 配置为持久化，宕机重启后，将自动加载宕机时刻的数据到缓存系统中。具有更好的灾备机制。\n4、Memcache 可以使用 Magent 在客户端进行一致性 hash 做分布式。Redis 支持在服务器端做分布式（PS:Twemproxy/Codis/Redis-cluster 多种分布式实现方式）\n5、Memcached 的简单限制就是键（key）和 Value 的限制。最大键长为 250\n个字符。可以接受的储存数据不能超过 1MB（可修改配置文件变大），因为这 是典型 slab 的最大值，不适合虚拟机使用。而 Redis 的 Key 长度支持到 512k。\n6、Redis 使用的是单线程模型，保证了数据按顺序提交。Memcache 需要使用cas 保证数据一致性。CAS（Check and Set）是一个确保并发一致性的机制， 属于\u0026quot;乐观锁\u0026quot;范畴；原理很简单：拿版本号，操作，对比版本号，如果一致就操作，不一致就放弃任何操作\ncpu 利用。由于 Redis 只使用单核，而 Memcached 可以使用多核，所以平均每一个核上 Redis 在存储小数据时比 Memcached 性能更 高。而在 100k 以上的数据中，Memcached 性能要高于 Redis 。\n7、memcache 内存管理：使用 Slab Allocation。原理相当简单，预先分配一系列大小固定的组，然后根据数据大小选择最合适的块存储。避免了内存碎片。（缺点：不能变长，浪费了一定空间）memcached 默认情况下下一个 slab 的最大值为前一个的 1.25 倍。\n8、redis 内存管理：Redis 通过定义一个数组来记录所有的内存分配情况，Redis 采用的是包装的 malloc/free，相较于 Memcached 的内存 管理方法来说，要简单很多。由于 malloc 首先以链表的方式搜索已管理的内存中可用的空间分配， 导致内存碎片比较多\n {width=\u0026ldquo;5.768055555555556in\u0026rdquo; height=\u0026ldquo;4.1666666666666664e-2in\u0026rdquo;}\n 更多请关注微信公众号：Java 技术栈，回复：资料\n{width=\u0026ldquo;2.31in\u0026rdquo; height=\u0026ldquo;2.3409372265966755in\u0026rdquo;}\n ","pubDate":"2021-02-15","title":"分布式缓存edisMemcached典面试题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_algorithm_%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/","plain":"﻿## 压缩算法\n//https://baijiahao.baidu.com/s?id=1649449620464606133\u0026amp;wfr=spider\u0026amp;for=pc\n哈夫曼算法\n","pubDate":"2021-02-15","title":"压缩算法"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A840%E9%81%93dubbo%E9%9D%A2%E8%AF%95%E9%A2%98/","plain":" 想往高处走，怎么能不懂 Dubbo？\nDubbo 是国内最出名的分布式服务框架，也是 Java 程序员必备的必会的框架之一。Dubbo 更是中高级面试过程中经常会问的技术，无论你是否用过，你都必须熟悉。\n下面我为大家准备了一些 Dubbo 常见的的面试题，一些是我经常问别人的，一些是我过去面试遇到的一些问题，总结给大家，希望对大家能有所帮助。\n {width=\u0026ldquo;5.768055555555556in\u0026rdquo; height=\u0026ldquo;4.1666666666666664e-2in\u0026rdquo;}\n1、Dubbo 是什么？  Dubbo 是阿里巴巴开源的基于 Java 的高性能 RPC 分布式服务框架，现已成为 Apache 基金会孵化项目。\n面试官问你如果这个都不清楚，那下面的就没必要问了。\n官网：http://dubbo.apache.org\n 2、为什么要用Dubbo？  因为是阿里开源项目，国内很多互联网公司都在用，已经经过很多线上考验。内部使用了Netty、Zookeeper，保证了高性能高可用性。\n使用 Dubbo 可以将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，可用于提高业务复用灵活扩展，使前端应用能更快速的响应多变的市场需求。\n{width=\u0026ldquo;7.018332239720035in\u0026rdquo; height=\u0026ldquo;2.165978783902012in\u0026rdquo;}下面这张图可以很清楚的诠释，最重要的一点是，分布式架构可以承受更大规模的并发流量。\n{width=\u0026ldquo;7.018332239720035in\u0026rdquo; height=\u0026ldquo;4.163888888888889in\u0026rdquo;}下面是 Dubbo 的服务治理图。\n3、Dubbo 和 Spring Cloud 有什么区别？ 两个没关联，如果硬要说区别，有以下几点。1）通信方式不同\nDubbo 使用的是 RPC 通信，而 Spring Cloud 使用的是 HTTP RESTFul 方式。\n 组成部分不同  +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | \u0026gt; 组件 | \u0026gt; Dubbo | \u0026gt; Spring Cloud | +==============+=================+================================+ | 服务注册中心 | \u0026gt; Zookeeper | \u0026gt; Spring Cloud Netflix Eureka | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 服务监控 | \u0026gt; Dubbo-monitor | \u0026gt; Spring Boot Admin | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 断路器 | \u0026gt; 不完善 | \u0026gt; Spring Cloud Netflix Hystrix | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 服务网关 | \u0026gt; 无 | \u0026gt; Spring Cloud Netflix Gateway | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 分布式配置 | \u0026gt; 无 | \u0026gt; Spring Cloud Config | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 服务跟踪 | \u0026gt; 无 | \u0026gt; Spring Cloud Sleuth | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\n+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | \u0026gt; 组件 | \u0026gt; Dubbo | \u0026gt; Spring Cloud | +============+=============+=======================+ | 消息总线 | \u0026gt; 无 | \u0026gt; Spring Cloud Bus | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 数据流 | \u0026gt; 无 | \u0026gt; Spring Cloud Stream | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 批量任务 | \u0026gt; 无 | \u0026gt; Spring Cloud Task | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | ... | \u0026gt; ... | \u0026gt; ... | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\n4、dubbo 都支持什么协议，推荐用哪种？   dubbo://（推荐）\n  rmi://\n  hessian://\n  http://\n  webservice://\n  thrift://\n  memcached://\n  redis://\n  rest://\n  5、Dubbo 需要 Web 容器吗？  不需要，如果硬要用 Web 容器，只会增加复杂性，也浪费资源。\n 6、Dubbo 内置了哪几种服务容器？   Spring Container\n  Jetty Container\n  Log4j Container\n   Dubbo 的服务容器只是一个简单的 Main 方法，并加载一个简单的 Spring 容器，用于暴露服务。\n 7、Dubbo 里面有哪几种节点角色？ +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | \u0026gt; 节点 | \u0026gt; 角色说明 | +============+==========================+ | Provider | 暴露服务的服务提供方 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | Consumer | 调用远程服务的服务消费方 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\n+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | \u0026gt; 节点 | \u0026gt; 角色说明 | +============+========================================+ | Registry | 服务注册与发现的注册中心 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | Monitor | 统计服务的调用次数和调用时间的监控中心 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | Container | 服务运行容器 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\n 8、画一画服务注册与发现的流程图\n{width=\u0026ldquo;7.0002132545931754in\u0026rdquo; height=\u0026ldquo;9.722916666666666in\u0026rdquo;}\n该图来自 Dubbo 官网，供你参考，如果你说你熟悉 Dubbo, 面试官经常会让你画这个图， 记好了。\n 9、Dubbo 默认使用什么注册中心，还有别的选择吗？  推荐使用 Zookeeper 作为注册中心，还有 Redis、Multicast、Simple 注册中心，但不推荐。\n10、Dubbo 有哪几种配置方式？ 1）Spring 配置方式 2）Java API 配置方式11、Dubbo 核心的配置有哪些？\n我曾经面试就遇到过面试官让你写这些配置，我也是蒙逼。。\n +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | \u0026gt; 配置 | \u0026gt; 配置说明 | +=================+================+ | dubbo:service | \u0026gt; 服务配置 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | dubbo:reference | \u0026gt; 引用配置 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | dubbo:protocol | \u0026gt; 协议配置 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\n+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | \u0026gt; 配置 | \u0026gt; 配置说明 | +===================+================+ | dubbo:application | \u0026gt; 应用配置 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | dubbo:module | \u0026gt; 模块配置 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | dubbo:registry | \u0026gt; 注册中心配置 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | dubbo:monitor | \u0026gt; 监控中心配置 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | dubbo:provider | \u0026gt; 提供方配置 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | dubbo:consumer | \u0026gt; 消费方配置 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | dubbo:method | \u0026gt; 方法配置 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | dubbo:argument | \u0026gt; 参数配置 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\n 配置之间的关系见下图。\n{width=\u0026ldquo;5.528207567804024in\u0026rdquo; height=\u0026ldquo;4.520833333333333in\u0026rdquo;}\n 12、在 Provider 上可以配置的 Consumer 端的属性有哪些？  1）timeout：方法调用超时 2）retries：失败重试次数，默认重试 2 次 3）loadbalance： 负载均衡算法，默认随机 4）actives 消费者端，最大并发调用限制\n 13、Dubbo 启动时如果依赖的服务不可用会怎样？  Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，默认 check=\u0026quot;true\u0026quot;，可以通过 check=\u0026quot;false\u0026quot; 关闭检查。\n 14、Dubbo 推荐使用什么序列化框架，你知道的还有哪些？  推荐使用 Hessian 序列化，还有 Duddo、FastJson、Java 自带序列化。\n 15、Dubbo 默认使用的是什么通信框架，还有别的选择吗？  Dubbo 默认使用 Netty 框架，也是推荐的选择，另外内容还集成有 Mina、Grizzly。\n 16、Dubbo 有哪几种集群容错方案，默认是哪种？ +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | \u0026gt; 集群容错方案 | \u0026gt; 说明 | +====================+============================================+ | Failover Cluster | 失败自动切换，自动重试其它服务器（默认） | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | Failfast Cluster | 快速失败，立即报错，只发起一次调用 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | Failsafe Cluster | 失败安全，出现异常时，直接忽略 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | Failback Cluster | 失败自动恢复，记录失败请求，定时重发 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | Forking Cluster | 并行调用多个服务器，只要一个成功即返回 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | Broadcast Cluster | 广播逐个调用所有提供者，任意一个报错则报错 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\n 17、Dubbo 有哪几种负载均衡策略，默认是哪种？\n +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | \u0026gt; 负载均衡策略 | \u0026gt; 说明 | +===================================+===================================+ | Random LoadBalance | \u0026gt; 随机，按权重设置随机概率（默认） | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | RoundRobin LoadBalance | \u0026gt; 轮询，按公约后的权重设置轮询比率 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | LeastActive LoadBalance | \u0026gt; 最少活跃调用数，相同活跃数的随机 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | ConsistentHash LoadBalance | \u0026gt; 一致性 | | | \u0026gt; Hash，相同参数的请求总是发到同一提供者 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\n18、注册了多个同一样的服务，如果测试指定的某一个服务呢？  可以配置环境点对点直连，绕过注册中心，将以服务接口为单位，忽略注册中心的提供者列表。\n 19、Dubbo 支持服务多协议吗？  Dubbo 允许配置多协议，在不同服务上支持不同协议或者同一服务上同时支持多种协议。\n 20、当一个服务接口有多种实现时怎么做？  当一个接口有多种实现时，可以用 group 属性来分组，服务提供方和消费方都指定同一个group 即可。\n 21、服务上线怎么兼容旧版本？  可以用版本号（version）过渡，多个不同版本的服务注册到注册中心，版本号不同的服务相互间不引用。这个和服务分组的概念有一点类似。\n 22、Dubbo 可以对结果进行缓存吗？  可以，Dubbo 提供了声明式缓存，用于加速热门数据的访问速度，以减少用户加缓存的工作量。\n 23、Dubbo 服务之间的调用是阻塞的吗？  默认是同步等待结果阻塞的，支持异步调用。\nDubbo 是基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小，异步调用会返回一个 Future 对象。\n异步调用流程图如下。\n{width=\u0026ldquo;6.258384733158355in\u0026rdquo; height=\u0026ldquo;1.9791666666666667in\u0026rdquo;}\n 24、Dubbo 支持分布式事务吗？  目前暂时不支持，后续可能采用基于 JTA/XA 规范实现，如以图所示。\n{width=\u0026ldquo;3.8471817585301835in\u0026rdquo; height=\u0026ldquo;5.020833333333333in\u0026rdquo;}\n 25、Dubbo telnet 命令能做什么？  dubbo 通过 telnet 命令来进行服务治理，具体使用看这篇文章《dubbo 服务调试管理实用命令》。\ntelnet localhost 8090\n 26、Dubbo 支持服务降级吗？  Dubbo 2.2.0 以上版本支持。\n 27、Dubbo 如何优雅停机？  Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果使用 kill -9 PID 等强制关闭指令，是不会执行优雅停机的，只有通过 kill PID 时，才会执行。\n 28、服务提供者能实现失效踢出是什么原理？  服务失效踢出基于 Zookeeper 的临时节点原理。\n 29、如何解决服务调用链过长的问题？  Dubbo 可以使用 Pinpoint 和 Apache Skywalking(Incubator) 实现分布式服务追踪， 当然还有其他很多方案。\n 30、服务读写推荐的容错策略是怎样的？  读操作建议使用 Failover 失败自动切换，默认重试两次其他服务器。写操作建议使用 Failfast 快速失败，发一次调用失败就立即报错。 31、Dubbo 必须依赖的包有哪些？\nDubbo 必须依赖 JDK，其他为可选。\n 32、Dubbo 的管理控制台能做什么？  管理控制台主要包含：路由规则，动态配置，服务降级，访问控制，权重调整，负载均衡， 等管理功能。\n 33、说说 Dubbo 服务暴露的过程。  Dubbo 会在 Spring 实例化完 bean 之后，在刷新容器最后一步发布ContextRefreshEvent 事件的时候，通知实现了 ApplicationListener 的 ServiceBean 类进行回调 onApplicationEvent 事件方法，Dubbo 会在这个方法中调用 ServiceBean 父类 ServiceConfig 的 export 方法，而该方法真正实现了服务的（异步或者非异步）发布。\n 34、Dubbo 停止维护了吗？  2014 年开始停止维护过几年，17 年开始重新维护，并进入了 Apache 项目。\n 35、Dubbo 和 Dubbox 有什么区别？  Dubbox 是继 Dubbo 停止维护后，当当网基于 Dubbo 做的一个扩展项目，如加了服务可 Restful 调用，更新了开源组件等。\n 36、你还了解别的分布式框架吗？  别的还有 Spring cloud、Facebook 的 Thrift、Twitter 的 Finagle 等。\n 37、Dubbo 能集成 Spring Boot 吗？  可以的，项目地址如下。\nhttps://github.com/apache/incubator-dubbo-spring-boot-project\n 38、在使用过程中都遇到了些什么问题？  Dubbo 的设计目的是为了满足高并发小数据量的 rpc 调用，在大数据量下的性能表现并不好，建议使用 rmi 或 http 协议。\n 39、你读过 Dubbo 的源码吗？  要了解 Dubbo 就必须看其源码，了解其原理，花点时间看下吧，网上也有很多教程，后续有时间我也会在公众号上分享 Dubbo 的源码。\n 40、你觉得用 Dubbo 好还是 Spring Cloud 好？  扩展性的问题，没有好坏，只有适合不适合，不过我好像更倾向于使用 Dubbo, Spring Cloud 版本升级太快，组件更新替换太频繁，配置太繁琐，还有很多我觉得是没有 Dubbo 顺手的地方\u0026hellip;\u0026hellip;\n更多请关注微信公众号：Java 技术栈，回复：资料\n{width=\u0026ldquo;2.31in\u0026rdquo; height=\u0026ldquo;2.3409372265966755in\u0026rdquo;}\n ","pubDate":"2021-02-15","title":"史上最全40道Dubbo面试题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A850%E9%81%93redis%E9%9D%A2%E8%AF%95%E9%A2%98/","plain":"{width=\u0026ldquo;5.773611111111111in\u0026rdquo; height=\u0026ldquo;9.990972222222222in\u0026rdquo;}\n 更多关注 Java 大后端公众号\n{width=\u0026ldquo;2.3333333333333335in\u0026rdquo; height=\u0026ldquo;2.3645833333333335in\u0026rdquo;}\n关注公众号，获取更多面试题及答案。\n1、什么是Redis？\nRedis 本质上是一个 Key-Value 类型的内存数据库，很像 memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value DB。 Redis 的出色之处不仅仅是性能，Redis 最大的魅力是支持保存多种数据结构，此外单个 value 的最大限制是 1GB，不像 memcached 只能保存 1MB 的数据，因此 Redis 可以用来实现很多有用的功能，比方说用他的 List 来做 FIFO 双向链表，实现一个轻量级的高性 能消息队列服务，用他的 Set 可以做高性能的 tag 系统等等。另外 Redis 也可以对存入的Key-Value 设置expire 时间，因此也可以被当作一 个功能加强版的memcached 来用。Redis 的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。\n2、Redis 相比 memcached 有哪些优势？\n (1) memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为丰富的数据类型\n(2) redis 的速度比 memcached 快很多\n(3) redis 可以持久化其数据\n 3、Redis 支持哪几种数据类型？ String、List、Set、Sorted Set、hashes 4、Redis 主要消耗什么物理资源？ 内存。\n5、Redis 的全称是什么？\nRemote Dictionary Server。\n6、Redis 有哪几种数据淘汰策略？\nnoeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL 和几个例外）\nallkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。\nvolatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。\nallkeys-random: 回收随机的键使得新添加的数据有空间存放。\nvolatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。\nvolatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。\n7、Redis 官方为什么不提供 Windows 版本？\n因为目前 Linux 版本已经相当稳定，而且用户量很大，无需开发windows 版本，反而会带来兼容性等问题。\n8、一个字符串类型的值能存储最大容量是多少？\n512M\n9、为什么Redis 需要把所有数据放到内存中？\nRedis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以 redis 具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘 I/O 速度为严重影响 redis 的性能。在内存越来越便宜的今天，redis 将会越来越受欢迎。 如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。\n10、Redis 集群方案应该怎么做？都有哪些方案？\n   twemproxy，大概概念是，它类似于一个代理方式，使用方法和普通 redis 无任何区别，设置好它下属的多个redis 实例后，使用时在本需要连接 redis 的地方改为连接twemproxy，它会以一个代理的身份接收请求并使用一致性 hash 算法，将请求转接到具体redis，将结果再返回 twemproxy。使用方式简便(相对 redis 只需修改连接端口)，对旧项目扩展的首选。 问题：twemproxy 自身单端口实例的压力，使用一致性 hash 后，对 redis 节点数量改变时候的计算值的改变，数据无法自动移动到新的节点。\n  codis，目前用的最多的集群方案，基本和 twemproxy 一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新 hash 节点。\n  redis cluster3.0 自带的集群，特点在于他的分布式算法不是一致性 hash，而是 hash 槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。\n  在业务代码层实现，起几个毫无关联的 redis 实例，在代码层，对 key 进行 hash 计算，然后去对应的 redis 实例操作数据。 这种方式对 hash 层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。\n   11、Redis 集群方案什么情况下会导致整个集群不可用？\n有 A，B，C 三个节点的集群,在没有复制模型的情况下,如果节点 B 失败了，那么整个集群就会以为缺少 5501-11000 这个范围的槽而不可用。\n12、MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据？\nredis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。\n13、Redis 有哪些适合的场景？\n  、会话缓存（Session Cache）   最常用的一种使用Redis 的情景是会话缓存（session cache）。用 Redis 缓存会话比其他存储\n（如 Memcached）的优势在于：Redis 提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？\n幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文档。甚至广为人知的商业平台Magento 也提供 Redis 的插件。\n  、全页缓存（FPC）   除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FPC。\n再次以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。\n此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。\n  、队列   Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis 能作为一个很好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如 Python） 对 list 的 push/pop 操作。\n如果你快速的在 Google 中搜索\u0026quot;Redis queues\u0026quot;，你马上就能找到大量的开源项目，这些项目的目的就是利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery 有一个后台就是使用Redis 作为 broker，你可以从这里去查看。\n  ，排行榜/计数器   Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的 10 个用户\u0026ndash;我们称之为\u0026quot;user_scores\u0026quot;，我们只需要像下面一样执行即可：\n当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：\nZRANGE user_scores 0 10 WITHSCORES\nAgora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据的，你可以在这里看到。\n  、发布/订阅   最后（但肯定不是最不重要的）是 Redis 的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis 的发布/订阅功能来建立聊天系统！（不，这是真的，你可以去核实）。\n14、Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？ Redisson、Jedis、lettuce 等等，官方推荐使用Redisson。 15、Redis 和 Redisson 有什么关系？\nRedisson 是一个高级的分布式协调Redis 客服端，能帮助用户在分布式环境中轻松实现一些Java 的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。\n16、Jedis 与 Redisson 对比有什么优缺点？\nJedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持；Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单，不支持字符串操作， 不支持排序、事务、管道、分区等 Redis 特性。Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。\n17、Redis 如何设置密码及验证密码？ 设置密码：config set requirepass 123456 授权密码：auth 123456\n18、说说 Redis 哈希槽的概念？\nRedis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有 16384 个哈希槽， 每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分hash 槽。\n19、Redis 集群的主从复制模型是怎样的？\n为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有 N-1 个复制品.\n20、Redis 集群会有写操作丢失吗？为什么？\nRedis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。\n21、Redis 集群之间是如何复制的？ 异步复制\n22、Redis 集群最大节点个数是多少？\n16384 个。\n23、Redis 集群如何选择数据库？\nRedis 集群目前无法做数据库选择，默认在 0 数据库。\n24、怎么测试 Redis 的连通性？\nping\n25、Redis 中的管道有什么用？\n一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。\n这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多 POP3 协议已经实现\n支持这个功能，大大加快了从服务器下载新邮件的过程。\n26、怎么理解 Redis 事务？\n事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。\n事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。\n27、Redis 事务相关的命令有哪几个？\nMULTI、EXEC、DISCARD、WATCH\n28、Redis key 的过期时间和永久有效分别怎么设置？\nEXPIRE 和 PERSIST 命令。\n29、Redis 如何做内存优化？\n尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的 web 系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的 key,而是应该把这个用户的所有信息存储到一张散列表里面.\n30、Redis 回收进程如何工作的？\n一个客户端运行了新的命令，添加了新的数据。\nRedi 检查内存使用情况，如果大于 maxmemory 的限制, 则根据设定好的策略进行回收。一个新的命令被执行，等等。\n所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。\n31、Redis 回收使用的是什么算法？\nLRU 算法\n32、Redis 如何做大量数据插入？\nRedis2.6 开始 redis-cli 支持一种新的被称之为 pipe mode 的新模式用于执行大量数据插入工作。\n33、为什么要做 Redis 分区？\n分区可以让 Redis 管理更大的内存，Redis 将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使 Redis 的计算能力通过简单地增加计算机得到成倍提升,Redis 的网络带宽也会随着计算机和网卡的增加而成倍增长。\n34、你知道有哪些Redis 分区实现方案？\n客户端分区就是在客户端就已经决定数据会被存储到哪个redis 节点或者从哪个redis 节点读取。大多数客户端已经实现了客户端分区。\n代理分区 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些 Redis 实例，然后根据 Redis 的响应结果返回给客户端。redis 和 memcached 的一种代理实现就是 Twemproxy\n查询路由(Query routing) 的意思是客户端随机地请求任意一个 redis 实例，然后由 Redis 将请求转发给正确的 Redis 节点。Redis Cluster 实现了一种混合形式的查询路由，但并不是直接将请求从一个redis 节点转发到另一个 redis 节点，而是在客户端的帮助下直接 redirected 到正确的 redis 节点。\n35、Redis 分区有什么缺点？\n涉及多个 key 的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的 Redis 实例（实际上这种情况也有办法，但是不能直接使用交集指令）。\n同时操作多个key,则不能使用 Redis 事务.\n分区使用的粒度是 key，不能使用一个非常长的排序 key 存储一个数据集（The partitioning granularity is the key, so it is not possible to shard a dataset with a single huge key like a very big sorted set）.\n当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的 Redis 实例和主机同时收集RDB / AOF 文件。\n分区时动态扩容或缩容可能非常复杂。Redis 集群在运行时增加或者删除 Redis 节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。\n36、Redis 持久化数据和缓存怎么做扩容？\n如果 Redis 被当做缓存使用，使用一致性哈希实现动态扩容缩容。\n如果 Redis 被当做一个持久化存储使用，必须使用固定的 keys-to-nodes 映射关系，节点的数量一旦确定不能变化。否则的话(即 Redis 节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有 Redis 集群可以做到这样。\n37、分布式 Redis 是前期做还是后期规模上来了再做好？为什么？\n既然 Redis 是如此的轻量（单实例只使用 1M 内存）,为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让 Redis 以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。\n一开始就多设置几个Redis 实例，例如 32 或者 64 个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。\n这样的话，当你的数据不断增长，需要更多的 Redis 服务器时，你需要做的就是仅仅将 Redis 实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的 Redis 实例从第一台机器迁移到第二台机器。\n38、Twemproxy 是什么？\nTwemproxy 是 Twitter 维护的（缓存）代理系统，代理 Memcached 的 ASCII 协议和 Redis 协议。它是单线程程序，使用 c 语言编写，运行起来非常快。它是采用 Apache 2.0 license 的开源软件。 Twemproxy 支持自动分区，如果其代理的其中一个 Redis 节点不可用时，会自动将该节点排除（这将改变原来的 keys-instances 的映射关系，所以你应该仅在把 Redis 当缓存时使用 Twemproxy)。 Twemproxy 本身不存在单点问题，因为你可以启动多个 Twemproxy 实例，然后让你的客户端去连接任意一个 Twemproxy 实例。 Twemproxy 是 Redis 客户端和服务器端的一个中间层，由它来处理分区功能应该不算复杂，并且应该算比较可靠的。\n39、支持一致性哈希的客户端有哪些？ Redis-rb、Predis 等。\n40、Redis 与其他 key-value 存储有什么不同？\nRedis 有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis 的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。\nRedis 运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡\n内存，应为数据量不能大于硬件内存。在内存数据库方面的另一个优点是， 相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样 Redis 可以做很多内部复杂性很强的事情。 同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。\n41、Redis 的内存占用情况怎么样？\n给你举个例子： 100 万个键值对（键是 0 到 999999 值是字符串\u0026quot;hello world\u0026quot;）在我的 32位的 Mac 笔记本上 用了 100MB。同样的数据放到一个 key 里只需要 16MB， 这是因为键值有一个很大的开销。 在 Memcached 上执行也是类似的结果，但是相对 Redis 的开销要小一点点，因为Redis 会记录类型信息引用计数等等。\n当然，大键值对时两者的比例要好很多。\n64 位的系统比 32 位的需要更多的内存开销，尤其是键值对都较小时，这是因为 64 位的系统里指针占用了 8 个字节。 但是，当然，64 位系统支持更大的内存，所以为了运行大型的Redis 服务器或多或少的需要使用 64 位的系统。\n42、都有哪些办法可以降低 Redis 的内存使用情况呢？\n如果你使用的是 32 位的 Redis 实例，可以好好利用 Hash,list,sorted set,set 等集合类型数据， 因为通常情况下很多小的Key-Value 可以用更紧凑的方式存放到一起。\n43、查看 Redis 使用情况及状态信息用什么命令？\ninfo\n44、Redis 的内存用完了会发生什么？\n如果达到设置的上限，Redis 的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以将 Redis 当缓存来使用配置淘汰机制，当 Redis 达到内存上限时会冲刷掉旧的内容。\n45、Redis 是单线程的，如何提高多核 CPU 的利用率？\n可以在同一个服务器部署多个 Redis 的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个 CPU，你可以考虑一下分片\n（shard）。\n46、一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素？\n理论上 Redis 可以处理多达 232 的 keys，并且在实际中进行了测试，每个实例至少存放了 2\n亿 5 千万的 keys。我们正在测试一些较大的值。 任何 list、set、和 sorted set 都可以放 232 个元素。\n换句话说，Redis 的存储极限是系统中的可用内存值。\n47、Redis 常见性能问题和解决方案？\n (1) Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件\n(2) 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次\n(3) 为了主从复制的速度和连接的稳定性，Master 和Slave 最好在同一个局域网内\n(4) 尽量避免在压力很大的主库上增加从库\n(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master \u0026lt;- Slave1 \u0026lt;- Slave2 \u0026lt;- Slave3...\n 这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了，可以立刻启用 Slave1 做 Master，其他不变。\n48、Redis 提供了哪几种持久化方式？\nRDB 持久化方式能够在指定的时间间隔能对你的数据进行快照存储.\nAOF 持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF 命令以redis 协议追加保存每次写的操作到文件末尾.Redis 还能对 AOF 文件进行后台重写,使得 AOF 文件的体积不至于过大.\n如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.\n你也可以同时开启两种持久化方式, 在这种情况下, 当 redis 重启的时候会优先载入 AOF 文件来恢复原始的数据,因为在通常情况下AOF 文件保存的数据集要比RDB 文件保存的数据集要完整.\n最重要的事情是了解RDB 和 AOF 持久化方式的不同,让我们以RDB 持久化方式开始。\n49、如何选择合适的持久化方式？\n一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化\n功能。如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB 持久化。\n有很多用户都只使用AOF 持久化，但并不推荐这种方式：因为定时生成 RDB 快照（snapshot） 非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，除此之外， 使用RDB 还可以避免之前提到的 AOF 程序的 bug。\n50、修改配置不重启Redis 会实时生效吗？\n针对运行实例，有许多配置选项可以通过 CONFIG SET 命令进行修改，而无需执行任何形式的重启。 从 Redis 2.2 开始，可以从 AOF 切换到 RDB 的快照持久性或其他方式而不需要重启 Redis。检索 \u0026lsquo;CONFIG GET *\u0026rsquo; 命令获取更多信息。\n但偶尔重新启动是必须的，如为升级 Redis 程序到新的版本，或者当你需要修改某些目前\nCONFIG 命令还不支持的配置参数的时候。\n ","pubDate":"2021-02-15","title":"史上最全50道Redis面试题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A870%E9%81%93spring%E9%9D%A2%E8%AF%95%E9%A2%98/","plain":"70 道 Spring 面试题  **什么是 spring? **   Spring 是个 java 企业级应用的开源开发框架。Spring 主要用来开发 Java 应用，但是有些扩展是针对构建 J2EE 平台的 web 应用。Spring 框架目标是简化 Java 企业级应用开发，并通过 POJO 为基础的编程模型促进良好的编程习惯。\n 使用 Spring 框架的好处是什么？   **轻量：**Spring 是轻量的，基本的版本大约 2MB。\n  **控制反转：**Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。\n  **面向切面的编程(AOP)：**Spring 支持面向切面的编程，并且把应用业务逻辑和系统服务分开。\n  **容器：**Spring 包含并管理应用中对象的生命周期和配置。\n  MVC 框架：Spring 的 WEB 框架是个精心设计的框架，是 Web 框架的一个很好的替代品。\n  **事务管理：**Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。\n  **异常处理：**Spring 提供方便的 API 把具体技术相关的异常（比如由 JDBC，HibernateorJDO抛出的）转化为一致的 unchecked 异常。\n  Spring 由哪些模块组成?  以下是 Spring 框架的基本模块：\n   Coremodule\n  Beanmodule\n  Contextmodule\n  ExpressionLanguagemodule\n  JDBCmodule\n  ORMmodule\n  OXMmodule\n  JavaMessagingService(JMS)module\n  Transactionmodule\n  Webmodule\n  Web-Servletmodule\n  Web-Strutsmodule\n  Web-Portletmodule\n  核心容器（应用上下文)模块。  这是基本的 Spring 模块，提供 spring 框架的基础功能，BeanFactory 是任何以 spring 为基础的应用的核心。Spring 框架建立在此模块之上，它使 Spring 成为一个容器。\n BeanFactory\u0026ndash;BeanFactory 实现举例。  Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖从正真的应用代码中分离。\n最常用的 BeanFactory 实现是 XmlBeanFactory 类。**6.XMLBeanFactory **\n最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory，它根据 XML 文件中的定义加载 beans。该容器从 XML 文件读取配置元数据并用它去创建一个完全配置的系统或应用。\n 解释 AOP 模块  AOP 模块用于发给我们的Spring 应用做面向切面的开发，很多支持由 AOP 联盟提供，这样就确保了 Spring 和其他AOP 框架的共通性。这个模块将元数据编程引入 Spring。\n 解释 JDBC 抽象和 DAO 模块。  通过使用 JDBC 抽象和 DAO 模块，保证数据库代码的简洁，并能避免数据库资源错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常访问层。它还利用 Spring 的 AOP 模块给Spring 应用中的对象提供事务管理服务。\n 解释对象/关系映射集成模块。  Spring 通过提供 ORM 模块，支持我们在直接 JDBC 之上使用一个对象/关系映射映射(ORM)工具，Spring 支持集成主流的 ORM 框架，如 Hiberate,JDO 和 iBATISSQLMaps。Spring 的事务管理同样支持以上所有 ORM 框架及 JDBC。\n 解释 WEB 模块。  Spring 的 WEB 模块是构建在 applicationcontext 模块基础之上，提供一个适合 web 应用的上下文。这个模块也包括支持多种面向 web 的任务，如透明地处理多个文件上传请求和程序级请求参数的绑定到你的业务对象。它也有对 JakartaStruts 的支持。\n 为什么说 Spring 是一个容器？  因为用来形容它用来存储单例的 bean 对象这个特性。**12.Spring 配置文件 **\nSpring 配置文件是个 XML 文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。\n 什么是 SpringIOC 容器？  SpringIOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。\n IOC 的优点是什么？  IOC 或依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI 查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC 容器支持加载服务时的饿汉式初始化和懒加载。\n ApplicationContext 通常的实现是什么?   **FileSystemXmlApplicationContext：**此容器从一个 XML 文件中加载 beans 的定义， XMLBean 配置文件的全路径名必须提供给它的构造函数。\n  **ClassPathXmlApplicationContext：**此容器也从一个 XML 文件中加载 beans 的定义，这里，你需要正确设置 classpath 因为这个容器将在classpath 里找 bean 配置。\n  **WebXmlApplicationContext：**此容器加载一个 XML 文件，此文件定义了一个 WEB 应用的所有 bean。\n  Bean 工厂和 Applicationcontexts 有什么区别？  Applicationcontexts 提供一种方法处理文本消息，一个通常的做法是加载文件资源（比如镜像），它们可以向注册为监听器的 bean 发布事件。另外，在容器或容器内的对象上执行的那些不得不由 bean 工厂以程序化方式处理的操作，可以在Applicationcontexts 中以声明的方式处理。Applicationcontexts 实现了 MessageSource 接口，该接口的实现以可插拔的方式提供获取本地化消息的方法。\n 一个 Spring 的应用看起来象什么？   一个定义了一些功能的接口。\n  这实现包括属性，它的 Setter，getter 方法和函数等。\n  SpringAOP。\n  Spring 的 XML 配置文件。\n  使用以上功能的客户端程序。\n  依赖注入 **什么是 Spring 的依赖注入？ **   依赖注入，是 IOC 的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC 容器）负责把他们组装起来。\n 有哪些不同类型的 IOC（依赖注入）方式？   **构造器依赖注入：**构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。\n  **Setter 方法注入：**Setter 方法注入是容器通过调用无参构造器或无参static 工厂方法实例化 bean 之后，调用该 bean 的 setter 方法，即实现了基于 setter 的依赖注入。\n  哪种依赖注入方式你建议使用，构造器注入，还是 Setter 方法注入？  你两种依赖方式都可以使用，构造器注入和 Setter 方法注入。最好的解决方案是用构造器参数实现强制依赖，setter 方法实现可选依赖。\n SpringBeans **什么是 Springbeans? **   Springbeans 是那些形成Spring 应用的主干的 java 对象。它们被 SpringIOC 容器初始化， 装配，和管理。这些 beans 通过容器中配置的元数据创建。比如，以XML 文件中\u0026lt;bean/\u0026gt;的形式定义。\nSpring 框架定义的 beans 都是单件 beans。在 beantag 中有个属性\u0026quot;singleton\u0026quot;，如果它被赋为TRUE，bean 就是单件，否则就是一个 prototypebean。默认是 TRUE，所以所有在 Spring框架中的 beans 缺省都是单件。\n 一个 SpringBean 定义包含什么？  一个 SpringBean 的定义包含容器必知的所有配置元数据，包括如何创建一个 bean，它的生命周期详情及它的依赖。\n 如何给 Spring 容器提供配置元数据?  这里有三种重要的方法给 Spring 容器提供配置元数据。XML 配置文件。\n基于注解的配置。 基于 java 的配置。\n 你怎样定义类的作用域?  当定义一个\u0026lt;bean\u0026gt;在 Spring 里，我们还能给这个 bean 声明一个作用域。它可以通过 bean 定义中的 scope 属性来定义。如，当 Spring 要在需要的时候每次生产一个新的 bean 实例， bean 的 scope 属性被指定为 prototype。另一方面，一个 bean 每次使用的时候必须返回同一个实例，这个 bean 的scope 属性必须设为 singleton。\n **解释 Spring 支持的几种 bean 的作用域。**Spring 框架支持以下五种 bean 的作用域：    **singleton:**bean 在每个 Springioc 容器中只有一个实例。\n  prototype：一个 bean 的定义可以有多个实例。\n  request：每次 http 请求都会创建一个bean，该作用域仅在基于 web 的SpringApplicationContext 情形下有效。\n  session：在一个 HTTPSession 中，一个 bean 定义对应一个实例。该作用域仅在基于 web 的 SpringApplicationContext 情形下有效。\n  global-session：在一个全局的 HTTPSession 中，一个 bean 定义对应一个实例。该作用域仅在基于 web 的 SpringApplicationContext 情形下有效。\n   缺省的 Springbean 的作用域是 Singleton. 26.Spring 框架中的单例 bean 是线程安全的吗? 不，Spring 框架中的单例 bean 不是线程安全的。**27.解释 Spring 框架中 bean 的生命周期。 **\n   Spring 容器从 XML 文件中读取 bean 的定义，并实例化 bean。\n  Spring 根据 bean 的定义填充所有的属性。\n  如果 bean 实现了 BeanNameAware 接口，Spring 传递 bean 的 ID 到 setBeanName 方法。\n  如果 Bean 实现了 BeanFactoryAware 接口，Spring 传递 beanfactory 给 setBeanFactory 方法。\n  如果有任何与 bean 相关联的 BeanPostProcessors，Spring 会在postProcesserBeforeInitialization()方法内调用它们。\n  如果 bean 实现 IntializingBean 了，调用它的 afterPropertySet 方法，如果 bean 声明了初始化方法，调用此初始化方法。\n  如果有 BeanPostProcessors 和 bean 关联，这些 bean 的postProcessAfterInitialization()方法将被调用。\n  如果 bean 实现了 DisposableBean，它将调用 destroy()方法。\n  哪些是重要的 bean 生命周期方法？你能重载它们吗？  有两个重要的bean 生命周期方法，第一个是 setup，它是在容器加载 bean 的时候被调用。第二个方法是teardown 它是在容器卸载类的时候被调用。\nThebean 标签有两个重要的属性（init-method 和 destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct 和@PreDestroy）。\n 什么是 Spring 的内部 bean？  当一个 bean 仅被用作另一个 bean 的属性时，它能被声明为一个内部 bean，为了定义innerbean，在Spring 的基于XML 的配置元数据中，可以在\u0026lt;property/\u0026gt;或\u0026lt;constructor-arg/\u0026gt;元素内使用\u0026lt;bean/\u0026gt;元素，内部 bean 通常是匿名的，它们的 Scope 一般是 prototype。\n 在 Spring 中如何注入一个 java 集合？ Spring 提供以下几种集合的配置元素：    \u0026lt;list\u0026gt;类型用于注入一列值，允许有相同的值。\n  \u0026lt;set\u0026gt;类型用于注入一组值，不允许有相同的值。\n  \u0026lt;map\u0026gt;类型用于注入一组键值对，键和值都可以为任意类型。\n  \u0026lt;props\u0026gt;类型用于注入一组键值对，键和值都只能为 String 类型。\n  什么是 bean 装配?  装配，或 bean 装配是指在 Spring 容器中把 bean 组装到一起，前提是容器需要知道 bean 的依赖关系，如何通过依赖注入来把它们装配到一起。\n 什么是 bean 的自动装配？  Spring 容器能够自动装配相互合作的 bean，这意味着容器不需要\u0026lt;constructor-arg\u0026gt;和\n\u0026lt;property\u0026gt;配置，能通过 Bean 工厂自动处理 bean 之间的协作。**33.解释不同方式的自动装配。 **\n有五种自动装配的方式，可以用来指导 Spring 容器用自动装配方式来进行依赖注入。\n   no：默认的方式是不进行自动装配，通过显式设置 ref 属性来进行装配。\n  **byName：**通过参数名自动装配，Spring 容器在配置文件中发现 bean 的 autowire 属性被设置成 byname，之后容器试图匹配、装配和该 bean 的属性具有相同名字的 bean。\n  **byType:：**通过参数类型自动装配，Spring 容器在配置文件中发现 bean 的 autowire 属性被设置成 byType，之后容器试图匹配、装配和该 bean 的属性具有相同类型的 bean。如果有多个 bean 符合条件，则抛出错误。\n  constructor：这个方式类似于 byType，但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。\n  **autodetect：**首先尝试使用 constructor 来自动装配，如果无法工作，则使用 byType 方式。\n  自动装配有哪些局限性? 自动装配的局限性是：    重写：你仍需用\u0026lt;constructor-arg\u0026gt;和\u0026lt;property\u0026gt;配置来定义依赖，意味着总要重写自动装配。\n  基本数据类型：你不能自动装配简单的属性，如基本数据类型，String 字符串，和类。\n  **模糊特性：**自动装配不如显式装配精确，如果有可能，建议使用显式装配。\n  你可以在 Spring 中注入一个 null 和一个空字符串吗？ 可以。  **Spring 注解 **\n 什么是基于 Java 的 Spring 注解配置?给一些注解的例子.  基于 Java 的配置，允许你在少量的 Java 注解的帮助下，进行你的大部分 Spring 配置而非通过 XML 文件。\n以@Configuration 注解为例，它用来标记类可以当做一个 bean 的定义，被 SpringIOC 容器使用。另一个例子是@Bean 注解，它表示此方法将要返回一个对象，作为一个 bean 注册进Spring 应用上下文。\n 什么是基于注解的容器配置?  相对于 XML 文件，注解型的配置依赖于通过字节码元数据装配组件，而非尖括号的声明。\n开发者通过在相应的类，方法或属性上使用注解的方式，直接组件类中进行配置，而不是使用 xml 表述 bean 的装配关系。\n 怎样开启注解装配？  注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在 Spring 配置文件中配置\u0026lt;context:annotation-config/\u0026gt;元素。\n @Required 注解  这个注解表明bean 的属性必须在配置的时候设置，通过一个 bean 定义的显式的属性值或通过自动装配，若@Required 注解的 bean 属性未被设置，容器将抛出BeanInitializationException。\n @Autowired 注解  @Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required 一样，修饰 setter 方法、构造器、属性或者具有任意名称和/或多个参数的 PN 方法。\n @Qualifier 注解  当有多个相同类型的 bean 却只有一个需要自动装配时，将@Qualifier 注解和@Autowire 注解结合使用以消除这种混淆，指定需要装配的确切的 bean。\n Spring 数据访问 **在 Spring 框架中如何更有效地使用 JDBC? **   使用 SpringJDBC 框架，资源管理和错误处理的代价都会被减轻。所以开发者只需写statements 和 queries 从数据存取数据，JDBC 也可以在 Spring 框架提供的模板类的帮助下更有效地被使用，这个模板叫 JdbcTemplate（例子见这里 [here]{.underline}）\n JdbcTemplate  JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象， 执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。\n Spring 对 DAO 的支持  Spring 对数据访问对象（DAO）的支持旨在简化它和数据访问技术如 JDBC，HibernateorJDO 结合使用。这使我们可以方便切换持久层。编码时也不用担心会捕获每种技术特有的异常。\n 使用 Spring 通过什么方式访问 Hibernate? 在 Spring 中有两种方式访问 Hibernate：    控制反转 HibernateTemplate 和 Callback。\n  继承 HibernateDAOSupport 提供一个 AOP 拦截器。\n  Spring 支持的 ORM Spring 支持以下 ORM：    Hibernate\n  iBatis\n  JPA(JavaPersistenceAPI)\n  TopLink\n  JDO(JavaDataObjects)\n  OJB\n  如何通过 HibernateDaoSupport 将 Spring 和 Hibernate 结合起来？  用 Spring 的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：\n   配置 theHibernateSessionFactory。\n  继承 HibernateDaoSupport 实现一个 DAO。\n  在 AOP 支持的事务中装配。\n  Spring 支持的事务管理类型Spring 支持两种类型的事务管理：    编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。\n  **声明式事务管理：**这意味着你可以将业务代码和事务管理分离，你只需用注解和 XML 配置来管理事务。\n  Spring 框架的事务管理有哪些优点？   它为不同的事务 API 如 JTA，JDBC，Hibernate，JPA 和 JDO，提供一个不变的编程模式。\n  它为编程式事务管理提供了一套简单的 API 而不是一些复杂的事务 API 如\n  它支持声明式事务管理。\n  它和 Spring 各种数据访问抽象层很好得集成。\n  你更倾向用那种事务管理类型？  大多数 Spring 框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。\n Spring 面向切面编程（AOP） 51.解释 AOP  面向切面的编程，或 AOP，是一种编程技术，允许程序模块化横向切割关注点，或横切典型的责任划分，如日志和事务管理。\n 52.Aspect 切面  AOP 核心就是切面，它将多个类的通用行为封装成可重用的模块，该模块含有一组 API 提供横切功能。比如，一个日志模块可以被称作日志的 AOP 切面。根据需求的不同，一个应用程序可以有若干切面。在 SpringAOP 中，切面通过带有@Aspect 注解的类实现。\n 52.在 SpringAOP 中，关注点和横切关注的区别是什么？  关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。\n 连接点  连接点代表一个应用程序的某个位置，在这个位置我们可以插入一个 AOP 切面，它实际上是个应用程序执行 SpringAOP 的位置。\n 通知  通知是个在方法执行前或执行后要做的动作，实际上是程序执行时要通过 SpringAOP 框架触发的代码段。\nSpring 切面可以应用五种类型的通知：\n   before：前置通知，在一个方法执行前被调用。\n  **after:**在方法执行之后调用的通知，无论方法执行是否成功。\n  **after-returning:**仅当方法成功完成后执行的通知。\n  **after-throwing:**在方法抛出异常退出时执行的通知。\n  **around:**在方法执行之前和之后调用的通知。\n  切点  切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。\n 什么是引入?  引入允许我们在已存在的类中增加新的方法和属性。**58.什么是目标对象? **\n被一个或者多个切面所通知的对象。它通常是一个代理对象。也指被通知（advised）对象。**59.什么是代理? **\n代理是通知目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。**60.有几种不同类型的自动代理？ **\nBeanNameAutoProxyCreator DefaultAdvisorAutoProxyCreator Metadataautoproxying\n 什么是织入。什么是织入应用的不同点？  织入是将切面和到其他应用类型或对象连接或创建一个被通知对象的过程。织入可以在编译时，加载时，或运行时完成。\n 解释基于 XMLSchema 方式的切面实现。  在这种情况下，切面由常规类以及基于 XML 的配置实现。**63.解释基于注解的切面实现 **\n在这种情况下(基于@AspectJ 的实现)，涉及到的切面声明的风格与带有 java5 标注的普通java 类一致。\n Spring 的 MVC **什么是 Spring 的 MVC 框架？ **   Spring 配备构建 Web 应用的全功能 MVC 框架。Spring 可以很便捷地和其他 MVC 框架集成， 如 Struts，Spring 的 MVC 框架用控制反转把业务对象和控制逻辑清晰地隔离。它也允许以声明的方式把请求参数和业务对象绑定。\n DispatcherServlet  Spring 的 MVC 框架是围绕 DispatcherServlet 来设计的，它用来处理所有的 HTTP 请求和响应。\n WebApplicationContext  WebApplicationContext 继承了 ApplicationContext 并增加了一些 WEB 应用必备的特有功能，它不同于一般的 ApplicationContext，因为它能处理主题，并找到被关联的 servlet。\n 什么是 SpringMVC 框架的控制器？  控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用户输入并将其转换为一个由视图呈现给用户的模型。Spring 用一个非常抽象的方式实现了一个控制层，允许用户创建多种用途的控制器。\n @Controller 注解  该注解表明该类扮演控制器的角色，Spring 不需要你继承任何其他控制器基类或引用ServletAPI。\n @RequestMapping 注解  该注解是用来映射一个 URL 到一个类或一个特定的方处理法上。**70.返回 Json 用什么注解？ **\n@ResponseBody\n ","pubDate":"2021-02-15","title":"史上最全70道Spring面试题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_windows%E5%8F%8A%E5%BA%94%E7%94%A8_%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/","plain":"微型计算机系统 微型计算机系统的基本组成 微型计算机系统的硬件组成 微型计算机的软件系统 微型计算机的分类与主要性能指标 1:微型计算机系统的基本组成   CPU ==\u0026gt; 中央处理器\n  内存储器 {ROM,RAM}\n  存储器 = {内存储器和外存储器以及类型的cache,寄存器} 存取速度:寄存器 \u0026gt; Cache \u0026gt; 内存 \u0026gt; 硬盘 \u0026gt; 光盘 \u0026gt; 软盘\n  总线 ==\u0026gt; 通信导线\n  没有安装任何软件叫做裸机\n  \t运算器(算术运算和逻辑运算)\r中央处理器(CPU)\r控制器(分析指令并执行)\r主机\r内存储器 【RAM,ROM】\r硬件\t外存储器\r外设\t输入设备【键盘，鼠标】\r输出设备【显示器】\r微计算机系统\r操作系统\r系统软件 服务软件\r编译与解释系统\r软件\r信息管理软件\r辅助设计软件\r应用软件\r文字处理软件\r图形软件\r各种程序包\r2:微型计算机系统的硬件组成   内存储器(主存储器) ROM,RAM\nROM 只读存储器 只能读出，不能写入,因此ROM常用来存放那些固定不变的程序和数据。ROM中数据再掉电后不会丢失比如说BIOS\nRAM 随机存储器 既可以读出，又可以写入，RAM中数据在掉电后会立即丢失。\n  输入设备:用于向计算机输入程序和原始数据的设备 键盘，图像扫描仪 鼠标，摄像头，手写笔 输出设备：输出设备是用于输出计算机结果的设备 显示器 打印机 绘图仪\n  中央处理器CPU   控制器:用来指挥电信号\n  运算器:执行算术运算和逻辑运算\n  寄存器:特殊的高速存储区域 寄存器是存储器中最快的一种 然后是缓存，内存，硬盘，各种外存U盘之类的，读写速度越来越慢，价格相对也比较便宜\n  总线:数据线路。总线是在CPU内部以及在CPU和主板的其他部件之间传输数据的电子数据线路.总线就像多车道的高速公路，通道越多，位的传输越快\n  性能: 主频越高，CPU的运算速度就越快；字长是指CPU可以同时处理的二进制数据的位数\n  内存储器  1kb=1024byte 1Mb=1024kb 1GB=1024Mb ,1TB = 1024GB   内存又称主存。CPU与内存合在一起一般称为主机\n   主要的内存芯片有RAM,ROM,CMOS和flash\n  RAM随机存取存储器：可以临时存储软件指令以及CPU处理前后的数据。RAM的内容是临时性的，当计算机断电或关闭时里面的内容就会丢失\n  ROM存储器:用来存储固定启动指令。只能读取数据.例子如BIOS\n  CMOS存储器:用来存储可变的启动指令,这个最重要的是即使断电后也必须对其供电,主要为BIOS供电\n  闪存 :容量小31-128M 主要给手机，寻呼机，MP3，打印机这些提供\n  cache 缓存\n  外存储器   1:软盘\n  2:U盘\n  3:硬盘\n  4:光盘\n  5:磁带\n  输入设备  1:键盘 2:鼠标器  输出设备   1:显示器\n  2:打印机\n  3:微型计算机的软件系统 软件概念  软件是指能指挥计算机工作的程序与程序运行时所需要的数据以及这些程序和数据有关的文字说明和图表资料又称为文档。其中文字说明和图表资料又称为文档  系统软件 操作系统，程序设计语言与语言处理程序，工具软件(诊断程序、调式程序、编辑程序) 应用软件 各种信息管理软件、办公自动化系统、各种文字处理软件、各种辅助设计软件以及辅助教学软件、各种软件包如图形软件包 程序设计语言及其处理程序 机器语言、汇编语言、高级语言 ","pubDate":"2021-02-15","title":"微型计算机系统"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_%E6%90%9E%E5%AE%9Ar%E8%AF%95%E7%9A%840%E5%BF%85%E5%A4%87%E9%97%AE%E9%A2%98/","plain":"1、请你自我介绍一下你自己？ **回答提示：**一般人回答这个问题过于平常，只说姓名、年龄、爱好、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，这些都可以和学习无关，也可以和学习有关，但要突出积极的个性和做事的能力，说得合情合理企业才会相信。企业很重视一个人的礼貌，求职者要尊重考官，在回答每个问题之后都说一句\u0026quot;谢谢\u0026quot;，企业喜欢有礼貌的求职者。\n2、你觉得你个性上最大的优点是什么？ **回答提示：**沉着冷静、条理清楚、立场坚定、顽强向上、乐于助人和关心他人、适应能力和幽默感、乐观和友爱。\n3、说说你最大的缺点？ **回答提示：**这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、爱忌妒人、非常懒、脾气大、工作效率低，企业肯定不会录用你。绝对不要自作聪明地回答\u0026quot;我最大的缺点是过于追求完美\u0026quot;，有的人以为这样回答会显得自己比较出色，但事实上，他已经岌岌可危了。业喜欢求职者从自己的优点说起，中间加一些小缺点，最后再把问题转回到优点上，突出优点的部分，企业喜欢聪明的求职者。\n4、你对加班的看法？ **回答提示：**实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公司奉献。\n**回答样本：**如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。\n5、你对薪资的要求？ **回答提示：**如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高， 那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算， 因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。如果你自己必须说出具体数目，请不要说一个宽泛的范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当今的人才市场作了调查，知道像自己这样学历的雇员有什么样的价值。\n**回答样本一：**我对工资没有硬性要求，我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我则不会计较太多。\n**回答样本二：**我受过系统的软件编程的训练，不需要进行大量的培训，而且我本人也对编程特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。\n6、你的职业规划？ **回答提示：**这是每一个应聘者都不希望被问到的问题，但是几乎每个人都会被问到，比较多的答案是\u0026quot;管理者\u0026quot;。但是近几年来，许多公司都已经建立了专门的技术途径。这些工作地位往往被称作\u0026quot;顾问\u0026quot;、\u0026ldquo;参议技师\u0026quot;或\u0026quot;高级软件工程师\u0026quot;等等。当然，说出其他一些你感兴趣的职位也是可以的，比如产品销售部经理，生产部经理等一些与你的专业有相关背景的工作。要知道，考官总是喜欢有进取心的应聘者，此时如果说\u0026quot;不知道\u0026rdquo;，或许就会使你丧失一个好机会。最普通的回答应该是\u0026quot;我准备在技术领域有所作为\u0026quot;或\u0026quot;我希望能按照公司的管理思路发展\u0026quot;。\n7、你还有什么问题要问吗？ **回答提示：**企业的这个问题看上去可有可无，其实很关键，企业不喜欢说\u0026quot;没问题\u0026quot;的人， 因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。\n8、如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位， 你怎么办？ **回答提示：**一段时间发现工作不适合我，有两种情况：①如果你确实热爱这个职业，那你就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；②你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的， 你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。\n9、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？ **回答提示：**①.原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻， 婉转地表达自己的想法，看看领导是否能改变想法。②如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作。③.还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。\n10、如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？ **回答提示：**①我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决。②分清责任，各负其责， 如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸， 作为一个团队，需要互相提携共同完成工作，安慰同事并且帮助同事查找原因总结经验。\n③总结经验教训，一个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，并在今后的工作中避免发生同类的错误。检讨自己的工作方法、分析问题的深度和力度是否不够，以致出现了本可以避免的错误。\n11、谈谈你对跳槽的看法？ **回答提示：**①正常的\u0026quot;跳槽\u0026quot;能促进人才合理流动，应该支持。②频繁的跳槽对单位和个人双方都不利，应该反对。\n12、工作中你难以和同事、上司相处，你该怎么办？ **回答提示：**①我会服从领导的指挥，配合同事的工作。②我会从自身找原因，仔细分析是不是自己工作做得不好让领导不满意，同事看不惯。还要看看是不是为人处世方面做得不好， 如果是这样的话 我会努力改正。③如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足，有问题就及时改正。④作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我在努力，总有一天会对我微笑的。\n13、你对于我们公司了解多少？ **回答提示：**在去公司面试前上网查一下该公司主营业务。如回答：贵公司有意改变策略，加强与国外大厂的OEM 合作，自有品牌的部分则透过海外经销商。\n14、请说出你选择这份工作的动机？ **回答提示：**这是想知道面试者对这份工作的热忱及理解度，并筛选因一时兴起而来应试的人， 如果是无经验者，可以强调\u0026quot;就算职种不同，也希望有机会发挥之前的经验\u0026quot;。\n15、你最擅长的技术方向是什么？ **回答提示：**说和你要应聘的职位相关的课程，表现一下自己的热诚没有什么坏处。\n16、你能为我们公司带来什么呢？ **回答提示：**企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后说：\u0026ldquo;就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益\u0026rdquo;。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：\u0026ldquo;我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。\u0026ldquo;等等。\n17、最能概括你自己的三个词是什么？ **回答提示：**我经常用的三个词是：适应能力强，有责任心和做事有始终，结合具体例子向主考官解释，\n18、为什么要离职? **回答提示：**回答这个问题时一定要小心，就算在前一个工作受到再大的委屈，对公司有多少的怨言，都千万不要表现出来，尤其要避免对公司本身主管的批评，避免面试官的负面情绪及印象。建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的\n空间，自己想在面试工作的相关产业中多加学习，或是前一份工作与自己的生涯规划不合等等，回答的答案最好是积极正面的。\n**回答样本：**我希望能获得一份更好的工作，如果机会来临，我会抓住。我觉得目前的工作， 已经达到顶峰，即沒有升迁机会。\n19、对工作的期望与目标何在？ **回答提示：**这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解的问题。对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：\u0026ldquo;我的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为了达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目标。\u0026ldquo;其他类的工作也可以比照这个方式来回答，只要在目标方面稍微修改一下就可以了。\n20、就你申请的这个职位，你认为你还欠缺什么？ **回答提示：**企业喜欢问求职者弱点，但精明的求职者一般不直接回答。他们希望看到这样的求职者：继续重复自己的优势，然后说：\u0026ldquo;对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题我想我可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。\u0026ldquo;企业喜欢能够巧妙地躲过难题的求职者。\n21、你通常如何处理別人的批评？ **回答提示：**①沈默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。②我会等大家冷靜下来再讨论。\n22、怎样对待自己的失敗？ **回答提示：**我们大家生来都不是十全十美的，我相信我有第二个机会改正我的错误。\n23、什么会让你有成就感？ **回答提示：**为贵公司竭力效劳，尽我所能，完成一个项目。\n24、你为什么愿意到我们公司来工作？ **回答提示：**对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因，像\u0026quot;公司本身的高技术开发环境很吸引我。\u0026quot;、\u0026ldquo;我同公司出生在同样的时代， 我希望能够进入一家与我共同成长的公司。\u0026quot;、\u0026ldquo;你们公司一直都稳定发展，在近几年来在市场上很有竞争力。\u0026quot;、\u0026ldquo;我认为贵公司能够给我提供一个与众不同的发展道路。\u0026ldquo;这都显示出你已经做了一些调查，也说明你对自己的未来有了较为具体的远景规划。\n25、你和别人发生过争执吗？你是怎样解决的？ **回答提示：**这是面试中最险恶的问题，其实是考官布下的一个陷阱，千万不要说任何人的过错，应知成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业， 这个问题简直成了最重要的一个环节。你是否能获得这份工作，将取决于这个问题的回答。考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。在没有外界干涉的情况下，通过妥协的方式来解决才是正确答案。\n26、对这项工作，你有哪些可预见的困难？ **回答提示：**①不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。②可以尝试迂回战术，说出应聘者对困难所持有的态度\u0026mdash;\u0026mdash;工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服。\n**分析：**一般问这个问题，面试者的希望就比较大了，因为已经在谈工作细节，但常规思路中的回答，又被面试官\u0026quot;骗\u0026quot;了。当面试官询问这个问题的时候，有两个目的。第一，看看应聘者是不是在行，说出的困难是不是在这个职位中一般都不可避免的问题。第二，是想看一下应聘者解决困难的手法对不对，及公司能否提供这样的资源。而不是想了解应聘者对困难的态度。\n27、如果我录用你，你将怎样开展工作？ 回答提示： ①如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工作的具体办法。②可以尝试采用迂回战术来回答，如\u0026quot;首先听取领导的指示和要求，然后就有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开展工作。\u0026quot;。\n**分析：**这个问题的主要目的也是了解应聘者的工作能力和计划性、条理性，而且重点想要知道细节。如果向思路中所讲的迂回战术，面试官会认为回避问题，如果引导了几次仍然是回避的话，此人绝对不会录用了。\n28、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？与上级意见不一是，你将怎么办？ **回答提示：**①.原则上我会尊重和服从领导的工作安排；同时私底下找机会以请教的口吻， 婉转地表达自己的想法，看看领导是否能改变想法。②如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作。③.还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。\n29、你工作经验欠缺，如何能胜任这项工作？ **常规思路：**①如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎\u0026quot;经验\u0026rdquo;，关键看应聘者怎样回答。②对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业。③如\u0026quot;作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。\n但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。\u0026rdquo;\n**点评：**这个问题思路中的答案尚可，突出自己的吃苦能力和适应性以及学习能力（不是学习成绩）为好。\n30、您在前一家公司的离职原因是什么？ **回答提示：**①最重要的是：应聘者要使找招聘单位相信，应聘者在过往的单位的\u0026quot;离职原因\u0026rdquo; 在此家招聘单位里不存在。②避免把\u0026quot;离职原因\u0026quot;说得太详细、太具体。③不能掺杂主观的负面感受，如\u0026quot;太辛苦\u0026rdquo;、\u0026ldquo;人际关系复杂\u0026rdquo;、\u0026ldquo;管理太混乱\u0026rdquo;、\u0026ldquo;公司不重视人才\u0026rdquo;、\u0026ldquo;公司排斥我们某某的员工\u0026quot;等。④但也不能躲闪、回避，如\u0026quot;想换换环境\u0026rdquo;、\u0026ldquo;个人原因\u0026quot;等。⑤不能涉及自己负面的人格特征，如不诚实、懒惰、缺乏责任感、不随和等。⑥尽量使解释的理由为应聘者个人形象添彩。⑦相关例子：如\u0026quot;我离职是因为这家公司倒闭；我在公司工作了三年多，有较深的感情；从去年始，由于市场形势突变，公司的局面急转直下；到眼下这一步我觉得很遗憾，但还要面对显示，重新寻找能发挥我能力的舞台。\u0026ldquo;同一个面试问题并非只有一个答案，而同一个答案并不是在任何面试场合都有效，关键在应聘者掌握了规律后，对面试的具体情况进行把握，有意识地揣摩面试官提出问题的心理背景，然后投其所好。\n分析：除非是薪资太低，或者是最初的工作，否则不要用薪资作为理由。\u0026ldquo;求发展\u0026quot;也被考官听得太多，离职理由要根据每个人的真实离职理由来设计，但是在回答时一定要表现得真诚。实在想不出来的时候，家在外地可以说是因为家中有事，须请假几个月，公司又不可能准假，所以辞职，这个答案一般面试官还能接受。\n31、为了做好你工作份外之事，你该怎样获得他人的支持和帮助？ **回答提示：**每个公司都在不断变化发展的过程中，你当然希望你的员工也是这样。你希望得到那些希望并欢迎变化的人，因为这些人明白，为了公司的发展，变化是公司日常生活中重要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。\n32、果你在这次面试中没有被录用，你怎么打算？ **回答提示：**现在的社会是一个竞争的社会，从这次面试中也可看出这一点，有竞争就必然有优劣，有成功必定就会有失败。往往成功的背后有许多的困难和挫折，如果这次失败了也仅仅是一次而已，只有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下几个方面来正确看待这次失败：①要敢于面对，面对这次失败不气馁，接受已经失去了这次机会就不会回头这个现实，从心理意志和精神上体现出对这次失败的抵抗力。要有自信，相信自己经历了这次之后经过努力一定能行，能够超越自我。②善于反思，对于这次面试经验要认真总结，思考剖析，能够从自身的角度找差距。正确对待自己，实事求是地评价自己，辩证的看待自己的长短得失，做一个明白人。③走出阴影，要克服这一次失败带给自己的心理压力， 时刻牢记自己弱点，防患于未然，加强学习，提高自身素质。④认真工作，回到原单位岗位上后，要实实在在、踏踏实实地工作，三十六行、行行出状元，争取在本岗位上做出一定的\n成绩。⑤再接再厉，成为国家公务员一直是我的梦想，以后如果有机会我仍然后再次参加竞争。\n33、谈谈你过去做过的成功案例？(工作中遇到什么问题) **回答提示：**举一个你最有把握的例子，把来龙去脉说清楚，而不要说了很多却没有重点。切忌夸大其词，把别人的功劳到说成自己的，很多主管为了确保要用的人是最适合的，会打电话向你的前一个主管征询对你的看法及意见，所以如果说谎，是很容易穿梆的。\n34、如何安排自己的时间？会不会排斥加班？ **回答提示：**基本上，如果上班工作有效率，工作量合理的话，应该不太需要加班。可是我也知道有时候很难避免加班，加上现在工作都采用责任制，所以我会调配自己的时间，全力配合。\n**分析：**虽然不会有人心甘情愿的加班，但依旧要表现出高配合度的诚意。\n35、这个职务的期许？ **回答提示：**希望能借此发挥我的所学及专长，同时也吸收贵公司在这方面的经验，就公司、我个人而言，缔造\u0026quot;双赢\u0026quot;的局面。\n**分析：**回答前不妨先询问该公司对这项职务的责任认定及归属，因为每一家公司的状况不尽相同，以免说了一堆理想抱负却发现牛头不对马嘴。\n36、什么选择我们这家公司？ **回答提示：**曾经在报章杂志看过关于贵公司的报道，与自己所追求的理念有志一同。而贵公司在业界的成绩也是有目共睹的，而且对员工的教育训练、升迁等也都很有制度。\n**分析：**去面试前先做功课，了解一下该公司的背景，让对方觉得你真的很有心想得到这份工作，而不只是探探路。\n37、谈谈如何适应办公室工作的新环境？ **回答提示：**①办公室里每个人有各自的岗位与职责，不得擅离岗位。②根据领导指示和工作安排，制定工作计划，提前预备，并按计划完成。③多请示并及时汇报，遇到不明白的要虚心请教。④抓间隙时间，多学习，努力提高自己的政治素质和业务水平。\n38、工作中学习到了些什么？ **回答提示：**这是针对转职者提出的问题，建议此时可以配合面试工作的特点作为主要依据来回答，如业务工作需要与人沟通，便可举出之前工作与人沟通的例子，经历了哪些困难，学习到哪些经验，把握这些要点做陈述，就可以轻易过关了。\n39、除了本公司外，还应聘了哪些公司？ **回答提示：**很奇怪，这是相当多公司会问的问题，其用意是要概略知道应徵者的求职志向，\n所以这并非绝对是负面答案，就算不便说出公司名称，也应回答\u0026quot;销售同种产品的公司\u0026rdquo;，如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉。\n40、何时可以到职？ **回答提示：**大多数企业会关心就职时间，最好是回答\u0026quot;如果被录用的话，到职日可按公司规定上班\u0026rdquo;，但如果还未辞去上一个工作、上班时间又太近，似乎有些强人所难，因为交接至少要一个月的时间，应进一步说明原因，录取公司应该会通融的。\n更多请关注微信公众号：Java 技术栈，回复：面试\n","pubDate":"2021-02-15","title":"搞定R试的0必备问题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_%E7%B2%BE%E9%80%8917%E9%81%93%E6%B5%B7%E9%87%8F%E6%95%B0%E9%87%8F%E5%A4%84%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/","plain":" 给定 a、b 两个文件，各存放 50 亿个 url，每个 url 各占 64 字节，内存限制是 4G，让你找出 a、b 文件共同的 url？   方案 1：可以估计每个文件安的大小为 50G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。\n{width=\u0026ldquo;1.0729166666666667in\u0026rdquo; height=\u0026ldquo;0.1358464566929134in\u0026rdquo;}{width=\u0026ldquo;0.8659722222222223in\u0026rdquo; height=\u0026ldquo;0.10449693788276465in\u0026rdquo;}s 遍历文件 a，对每个 url 求取 ，然后根据所取得的值将 url 分别存储到 1000 个小文件（记为 ）中。这样每个小文件的大约为300M。\ns 遍历文件 b，采取和 a 相同的方式将 url 分别存储到 1000 各小文件（记为\n{width=\u0026ldquo;0.8416655730533683in\u0026rdquo; height=\u0026ldquo;0.1358464566929134in\u0026rdquo;}）。这样处理后，所有可能相同的 url 都在对应的小文件\n{width=\u0026ldquo;1.8659722222222221in\u0026rdquo; height=\u0026ldquo;0.1358464566929134in\u0026rdquo;}（ ）中，不对应的小文件不可能有相同的 url。然后我们只要求出 1000 对小文件中相同的 url 即可。\ns 求每对小文件中相同的 url 时，可以把其中一个小文件的 url 存储到hash_set 中。然后遍历另一个小文件的每个 url，看其是否在刚才构建的hash_set 中，如果是，那么就是共同的 url，存到文件里面就可以了。\n方案 2：如果允许有一定的错误率，可以使用 Bloom filter，4G 内存大概可以表示 340 亿 bit。将其中一个文件中的 url 使用 Bloom filter 映射为这 340 亿\nbit，然后挨个读取另外一个文件的 url，检查是否与 Bloom filter，如果是，那么该 url 应该是共同的 url（注意会有一定的错误率）。\n  有 10 个文件，每个文件 1G，每个文件的每一行存放的都是用户的 query，每个文件的 query 都可能重复。要求你按照 query 的频度排序。   方案 1：\n{width=\u0026ldquo;0.75625in\u0026rdquo; height=\u0026ldquo;0.10449693788276465in\u0026rdquo;}s 顺序读取 10 个文件，按照 hash(query)%10 的结果将 query 写入到另外 10 个文件（记为 ）中。这样新生成的文件每个的大小大约也 1G（假设 hash 函数是随机的）。\n{width=\u0026ldquo;0.7562489063867016in\u0026rdquo; height=\u0026ldquo;0.10449693788276465in\u0026rdquo;}{width=\u0026ldquo;0.7805544619422572in\u0026rdquo; height=\u0026ldquo;0.1358464566929134in\u0026rdquo;}s 找一台内存在 2G 左右的机器，依次对 用 hash_map(query, query_count)来统计每个 query 出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的 query 和对应的 query_cout 输出到文件中。这样得到了 10 个排好序的文件（记为 ）。\n{width=\u0026ldquo;0.7805544619422572in\u0026rdquo; height=\u0026ldquo;0.1358464566929134in\u0026rdquo;}s 对 这 10 个文件进行归并排序（内排序与外排序相结合）。方案 2：\n一般 query 的总量是有限的，只是重复的次数比较多而已，可能对于所有的\nquery，一次性就可以加入到内存了。这样，我们就可以采用 trie 树/hash_map\n等直接来统计每个 query 出现的次数，然后按出现次数做快速/堆/归并排序就可以了。\n方案 3：\n与方案 1 类似，但在做完 hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如 MapReduce），最后再进行合并。\n  有一个 1G 大小的一个文件，里面每一行是一个词，词的大小不超过 16   字节，内存限制大小是 1M。返回频数最高的 100 个词。\n{width=\u0026ldquo;0.9513888888888888in\u0026rdquo; height=\u0026ldquo;0.1358464566929134in\u0026rdquo;}{width=\u0026ldquo;0.9027777777777778in\u0026rdquo; height=\u0026ldquo;0.10449693788276465in\u0026rdquo;}方案 1：顺序读文件中，对于每个词 x，取 ，然后按照该值存到5000 个小文件（记为 ）中。这样每个文件大概是 200k 左右。如果其中的有的文件超过了 1M 大小，还可以按照类似的方法继续往下分，知道分解得到的小文件的大小都不超过 1M。对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用 trie 树/hash_map 等），并取出出现频率最大的 100 个词（可以用含 100 个结点的最小堆），并把 100 词及相应的频\n率存入文件，这样又得到了 5000 个文件。下一步就是把这 5000 个文件进行归并（类似与归并排序）的过程了。\n  海量日志数据，提取出某日访问百度次数最多的那个 IP。   {width=\u0026ldquo;0.20763779527559056in\u0026rdquo; height=\u0026ldquo;0.11494641294838145in\u0026rdquo;}方案 1：首先是这一天，并且是访问百度的日志中的 IP 取出来，逐个写入到一个大文件中。注意到 IP 是 32 位的，最多有 个 IP。同样可以采用映射的方法，比如模 1000，把整个大文件映射为 1000 个小文件，再找出每个小文中出现频率最大的 IP（可以采用 hash_map 进行频率统计，然后再找出频率最大的几个）及相应的频率。然后再在这 1000 个最大的 IP 中，找出那个频率最大的 IP，即为所求。\n  在 2.5 亿个整数中找出不重复的整数，内存不足以容纳这 2.5 亿个整数。   {width=\u0026ldquo;1.1097222222222223in\u0026rdquo; height=\u0026ldquo;0.11494641294838145in\u0026rdquo;}方案 1：采用 2-Bitmap（每个数分配 2bit，00 表示不存在，01 表示出现一次， 10 表示多次，11 无意义）进行，共需内存 内存，还可以接受。然后扫描这 2.5 亿个整数，查看 Bitmap 中相对应位，如果是 00 变 01，01 变 10，10 保持不变。所描完事后，查看 bitmap，把对应位是 01 的整数输出即可。\n方案 2：也可采用上题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。\n  海量数据分布在 100 台电脑中，想个办法高校统计出这批数据的 TOP10。方案 1：   s 在每台电脑上求出TOP10，可以采用包含 10 个元素的堆完成（TOP10 小，用最大堆，TOP10 大，用最小堆）。比如求 TOP10 大，我们首先取前 10 个元素调整成最小堆，如果发现，然后扫描后面的数据，并与堆顶元素比较， 如果比堆顶元素大，那么用该元素替换堆顶，然后再调整为最小堆。最后堆中的元素就是 TOP10 大。\ns 求出每台电脑上的TOP10 后，然后把这 100 台电脑上的TOP10 组合起来， 共 1000 个数据，再利用上面类似的方法求出 TOP10 就可以了。\n  怎么在海量数据中找出重复次数最多的一个？   方案 1：先做 hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。\n  上千万或上亿数据（有重复），统计其中出现次数最多的钱 N 个数据。   方案 1：上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用 hash_map/搜索二叉树/红黑树等来进行统计次数。然后就是取出前 N 个出现次数最多的数据了，可以用第 6 题提到的堆机制完成。\n  1000 万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？   方案 1：这题用 trie 树比较合适，hash_map 也应该能行。\n  一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前 10 个词，请给出思想，给出时间复杂度分析。   方案 1：这题是考虑时间效率。用 trie 树统计每个词出现的次数，时间复杂度是 O(n*le)（le 表示单词的平准长度）。然后是找出出现最频繁的前 10 个词， 可以用堆来实现，前面的题中已经讲到了，时间复杂度是 O(n*lg10)。所以总的时间复杂度，是 O(n*le)与 O(n*lg10)中较大的哪一个。\n  一个文本文件，找出前 10 个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。   方案 1：首先根据用 hash 并求模，将文件分解为多个小文件，对于单个文件利用上题的方法求出每个文件件中 10 个最常出现的词。然后再进行归并处理，\n找出最终的 10 个最常出现的词。\n  100w 个数中找出最大的 100 个数。   方案 1：在前面的题中，我们已经提到了，用一个含 100 个元素的最小堆完成。复杂度为 O(100w*lg100)。\n方案 2：采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比 100 多的时候，采用传统排序算法排序，取前 100 个。复杂度为 O(100w*100)。\n方案 3：采用局部淘汰法。选取前 100 个元素，并排序，记为序列 L。然后一次扫描剩余的元素 x，与排好序的 100 个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除，并把 x 利用插入排序的思想， 插入到序列 L 中。依次循环，知道扫描了所有的元素。复杂度为 O(100w*100)。\n  寻找热门查询：   搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为 1-255 字节。假设目前有一千万个记录，这些查询串的重\n复读比较高，虽然总数是 1 千万，但是如果去除重复和，不超过 3 百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的 10 个查询串，要求使用的内存不能超过 1G。\n (1) 请描述你解决这个问题的思路；\n(2) 请给出主要的处理流程，算法，以及算法的复杂度。\n 方案 1：采用 trie 树，关键字域存该查询串出现的次数，没有出现为 0。最后用 10 个元素的最小推来对出现频率进行排序。\n  {width=\u0026ldquo;0.17083333333333334in\u0026rdquo; height=\u0026ldquo;0.11494641294838145in\u0026rdquo;}一共有 N 个机器，每个机器上有 N 个数。每个机器最多存 O(N)个数并对它们操作。如何找到 个数中的中数？   {width=\u0026ldquo;0.20763779527559056in\u0026rdquo; height=\u0026ldquo;0.11494641294838145in\u0026rdquo;}{width=\u0026ldquo;0.46319444444444446in\u0026rdquo; height=\u0026ldquo;0.11494641294838145in\u0026rdquo;}{width=\u0026ldquo;0.17083333333333334in\u0026rdquo; height=\u0026ldquo;0.2507928696412948in\u0026rdquo;}{width=\u0026ldquo;0.40421806649168857in\u0026rdquo; height=\u0026ldquo;0.2507928696412948in\u0026rdquo;}{width=\u0026ldquo;0.17083333333333334in\u0026rdquo; height=\u0026ldquo;0.2507928696412948in\u0026rdquo;}{width=\u0026ldquo;0.40421806649168857in\u0026rdquo; height=\u0026ldquo;0.2507928696412948in\u0026rdquo;}方案 1：先大体估计一下这些数的范围，比如这里假设这些数都是 32 位无符号整数（共有 个）。我们把 0 到 的整数划分为 N 个范围段，每个段\n包含 个整数。比如，第一个段位 0 到 ，第二段为 到 ，\u0026hellip;，第\n{width=\u0026ldquo;0.4631933508311461in\u0026rdquo; height=\u0026ldquo;0.2507928696412948in\u0026rdquo;}{width=\u0026ldquo;0.4631933508311461in\u0026rdquo; height=\u0026ldquo;0.11494641294838145in\u0026rdquo;}{width=\u0026ldquo;0.1340255905511811in\u0026rdquo; height=\u0026ldquo;0.2507928696412948in\u0026rdquo;}N 个段为 到 。然后，扫描每个机器上的 N 个数，把属于第一个区段的数放到第一个机器上，属于第二个区段的数放到第二个机器上，\u0026hellip;， 属于第 N 个区段的数放到第 N 个机器上。注意这个过程每个机器上存储的数应该是 O(N)的。下面我们依次统计每个机器上数的个数，一次累加，直到找\n到第 k 个机器，在该机器上累加的数大于或等于 ，而在第 k-1 个机器上的累加数小于 {width=\u0026ldquo;0.1340255905511811in\u0026rdquo; height=\u0026ldquo;0.4388888888888889in\u0026rdquo;}，并把这个数记为 x。那么我们要找的中位数在第 k 个机器中，\n{width=\u0026ldquo;0.37777668416447946in\u0026rdquo; height=\u0026ldquo;0.2507928696412948in\u0026rdquo;}{width=\u0026ldquo;0.37777668416447946in\u0026rdquo; height=\u0026ldquo;0.2507928696412948in\u0026rdquo;}{width=\u0026ldquo;0.3902777777777778in\u0026rdquo; height=\u0026ldquo;0.1358464566929134in\u0026rdquo;}排在第 位。然后我们对第 k 个机器的数排序，并找出第 个数，即为所求的中位数。复杂度是 的。\n方案 2：先对每台机器上的数进行排序。排好序后，我们采用归并排序的思\n{width=\u0026ldquo;0.1340255905511811in\u0026rdquo; height=\u0026ldquo;0.2507928696412948in\u0026rdquo;}{width=\u0026ldquo;0.7194444444444444in\u0026rdquo; height=\u0026ldquo;0.14629593175853017in\u0026rdquo;}想，将这 N 个机器上的数归并起来得到最终的排序。找到第 个便是所求。复杂度是 的。\n  最大间隙问题   {width=\u0026ldquo;0.9388877952755905in\u0026rdquo; height=\u0026ldquo;0.10449693788276465in\u0026rdquo;}给定 n 个实数 ，求着 n 个实数在实轴上向量 2 个数之间的最大差值，要求线性的时间算法。\n方案 1：最先想到的方法就是先对这 n 个数据进行排序，然后一遍扫描即可确定相邻的最大间隙。但该方法不能满足线性时间的要求。故采取如下方法：\ns 找到 n 个数据中最大和最小数据 max 和 min。\n{width=\u0026ldquo;1.1847462817147856in\u0026rdquo; height=\u0026ldquo;0.11494641294838145in\u0026rdquo;}{width=\u0026ldquo;1.4513888888888888in\u0026rdquo; height=\u0026ldquo;0.4388877952755906in\u0026rdquo;}s 用 n-2 个点等分区间[min, max]，即将[min, max]等分为 n-1 个区间（前闭后开区间），将这些区间看作桶，编号为 ，且桶 {width=\u0026ldquo;8.541447944007e-2in\u0026rdquo; height=\u0026ldquo;0.25624890638670167in\u0026rdquo;}的上界和桶\ni+1 的下届相同，即每个桶的大小相同。每个桶的大小为： 。\n实际上，这些桶的边界构成了一个等差数列（首项为 min，公差为\n{width=\u0026ldquo;0.9270833333333334in\u0026rdquo; height=\u0026ldquo;0.1358464566929134in\u0026rdquo;}），且认为将 min 放入第一个桶，将 max 放入第 n-1 个桶。\n{width=\u0026ldquo;0.20763779527559056in\u0026rdquo; height=\u0026ldquo;0.1358464566929134in\u0026rdquo;}{width=\u0026ldquo;1.5749857830271217in\u0026rdquo; height=\u0026ldquo;0.26124234470691166in\u0026rdquo;}s 将 n 个数放入 n-1 个桶中：将每个元素 分配到某个桶（编号为 index）， 其中 ，并求出分到每个桶的最大最小数据。\ns 最大间隙：除最大最小数据max 和min 以外的n-2 个数据放入n-1 个桶中，\n{width=\u0026ldquo;0.5243055555555556in\u0026rdquo; height=\u0026ldquo;0.1358464566929134in\u0026rdquo;}由抽屉原理可知至少有一个桶是空的，又因为每个桶的大小相同，所以最大间隙不会在同一桶中出现，一定是某个桶的上界和气候某个桶的下界之间隙， 且该量筒之间的桶（即便好在该连个便好之间的桶）一定是空桶。也就是说， 最大间隙在桶 i 的上界和桶 j 的下界之间产生 。一遍扫描即可完成。\n  将多个集合合并成没有交集的集合：给定一个字符串的集合，格式如：   {width=\u0026ldquo;2.5in\u0026rdquo; height=\u0026ldquo;0.12666666666666668in\u0026rdquo;}。要求将其中交集不为空的集合合并，要求合并完成的集合之间无交集，例如上例应输出\n{width=\u0026ldquo;2.5in\u0026rdquo; height=\u0026ldquo;0.15572834645669292in\u0026rdquo;}。\n (1) 请描述你解决这个问题的思路；\n(2) 给出主要的处理流程，算法，以及算法的复杂度；\n(3) 请描述可能的改进。\n {width=\u0026ldquo;0.9041896325459318in\u0026rdquo; height=\u0026ldquo;0.1358464566929134in\u0026rdquo;}方案 1：采用并查集。首先所有的字符串都在单独的并查集中。然后依扫描每个集合，顺序合并将两个相邻元素合并。例如，对于 ，首先查看 aaa 和 bbb 是否在同一个并查集中，如果不在，那么把它们所在的并查集合并，然后再看 bbb 和 ccc 是否在同一个并查集中，如果不在，那么也把它们所在的并查集合并。接下来再扫描其他的集合，当所有的集合都扫描完了， 并查集代表的集合便是所求。复杂度应该是 O(NlgN)的。改进的话，首先可 以记录每个节点的根结点，改进查询。合并的时候，可以把大的和小的进行合，这样也减少复杂度。\n  最大子序列与最大子矩阵问题   数组的最大子序列问题：给定一个数组，其中元素有正，也有负，找出其中一个连续子序列，使和最大。\n{width=\u0026ldquo;0.21944444444444444in\u0026rdquo; height=\u0026ldquo;0.1358464566929134in\u0026rdquo;}{width=\u0026ldquo;0.2089938757655293in\u0026rdquo; height=\u0026ldquo;0.1358464566929134in\u0026rdquo;}方案 1：这个问题可以动态规划的思想解决。设 表示以第 i 个元素 结尾的最大子序列，那么显然 {width=\u0026ldquo;2.499998906386702in\u0026rdquo; height=\u0026ldquo;0.15572834645669292in\u0026rdquo;}。基于这一点可以很快用代码实现。\n最大子矩阵问题：给定一个矩阵（二维数组），其中数据有大有小，请找一个子矩阵，使得子矩阵的和最大，并输出这个和。\n方案 1：可以采用与最大子序列类似的思想来解决。如果我们确定了选择第 i 列和第 j 列之间的元素，那么在这个范围内，其实就是一个最大子序列问题。如何确定第 i 列和第 j 列可以词用暴搜的方法进行。\n更多请关注微信公众号：Java 技术栈，回复：面试\n ","pubDate":"2021-02-15","title":"精选17道海量数量处理面试题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_%E7%B2%BE%E9%80%897%E9%81%93elasticearch%E9%9D%A2%E8%AF%95%E9%A2%98/","plain":" 为什么要使用 ES？  虽然 lucene 是性能最先进的、功能完善的搜索引擎，但是它只能有一个库，而且使用它需要集成到 java 项目才能使用，配置还特别复杂,而 ES 语法简单、是基于Resultful api 风格的, 它在 lucene 所有功能基础上还能集成多台服务器进行搜索，也就是集群;\n ES 和 lucene 的区别是什么？  lucene 是现存功能最强大、最先进搜索库，直接基于 lucene 开发，api 非常复杂大量的 java\n代码、需要深入了解原理对比处:\n只有一个索引库、 传统的遍历搜索方式采用B+树索引;\nEs 是基于 lucene 的，隐藏了 lucene 复杂部分的一个分布式全文检索框架对比处:\n一个es 的集群包含多个索引库、分布式搜索\nEs 是采用倒排式索引\nes 没有事物概念,删除不能恢复\nes 开源免费\n正排索引：id ---\u0026gt; value\n倒排索引：value ---\u0026gt; id\n 你还了解哪些全文检索工具？ Lucene，Solr，HadoopContrib，Katta 4.Bulk 一次最大处理多少数据量？  bulk 会把将要处理的数据载入内存中，所以数据量是有限制的\n最佳的数据量不是一个确定的数值，它取决于你的硬件，你的文档大小以及复杂性，你的索\n引以及搜索的负载。\n一般建议是 1000-5000 个文档，如果你的文档很大，可以适当减少队列,大小建议是 5-15MB， 默认不能超过 100M，可以在 es 的配置文件中修改这个值 http.max_content_length: 100mb\n5.ES 在高并发的情况下如何保证数据线程安全问题？\n在读数据与写数据之间如果有其他线程进行写操作，就会出问题，es 使用版本控制才避免这种问题\n在修改数据的时候指定版本号，操作一次版本号加 1 6.ES 管理的工具有哪些？\n  BigDesk Plugin (作者 Luká? Vl?ek)：监控 es 状态的插件,推荐！主要提供的是节点的实时状态监控，包括 jvm 的情况，linux 的情况，elasticsearch 的情况\n  Elasticsearch Head Plugin (作者 Ben Birch)：很方便对es 进行各种操作的客户端。? 3）Kibana(ES 官方推荐)：Es 基于?RestAPI 调试、数据报表、数据搜索\n  7.ES 自动映射的规则？\nEs 映射是用于确定字段类型，将新增的每个字段数据类型映射后确定的字段类型，常见的映射类型有基本数据类型、复杂数据类型映射有数组对象(但对象映射扁平化后相关性会丢失，不能确定哪个是哪个属性)、\n全局映射的方式默认映射继承_default_的配置、动态模板映射：dynamic_templates，使用动态模板映射会覆盖默认模板，可设置关键字分词，默认模板是 string 类型的。\n 更多请关注微信公众号：Java 技术栈，回复：面试\n ","pubDate":"2021-02-15","title":"精选7道Elasticearch面试题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_%E9%9D%A2%E8%AF%95_%E7%B2%BE%E9%80%898%E9%81%93dubbo%E9%9D%A2%E8%AF%95%E9%A2%98/","plain":" Dubbo 是阿里巴巴 SOA 服务化治理方案的核心框架，每天为 2,000+个服务提供 3,000,000,000+次访问量支持，并被广泛应用于阿里巴巴集团的各成员站点。\nDubbo[]是一个分布式服务框架，致力于提供高性能和透明化的 RPC 远程服务调用方案，以及 SOA 服务治理方案。它最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。从服务模型的角度来看，Dubbo 采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这\n一点可以抽象出服务提供方（Provider）和服务消费方（Consumer）两个角色。关于注册中心、协议支持、服务监控\n等内容。\n  Dubbo 中 zookeeper 做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？   可以通信的，启动 dubbo 时，消费者会从 zk 拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用；\n注册中心对等集群，任意一台宕机后，将会切换到另一台；注册中心全部宕机后，服务的提供者和消费者仍能通过本地缓存通讯。服务提供者无状态，任一台 宕机后，不影响使用；服务提供者全部宕机，服务消费者会无法使用，并无限次重连等待服务者恢复；\n挂掉是不要紧的，但前提是你没有增加新的服务，如果你要调用新的服务，则是不能办到的。\n{width=\u0026ldquo;7.018332239720035in\u0026rdquo; height=\u0026ldquo;1.75in\u0026rdquo;}附文档截图：\n  dubbo 服务负载均衡策略？   l Random LoadBalance\n随机，按权重设置随机概率。在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。(权重可以在 dubbo 管控台配置)\nl RoundRobin LoadBalance\n轮循，按公约后的权重设置轮循比率。存在慢的提供者累积请求问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。\nl LeastActive LoadBalance\n最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。\nl ConsistentHash LoadBalance\n一致性Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点， 平摊到其它提供者，不会引起剧烈变动。缺省只对第一个参数Hash，如果要修改，请配置\n[AppleScript] 纯文本查看 复制代码\n +\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+ | 1 | \u0026lt;dubbo:parameter | | | | | | key=\u0026quot;hash.arguments\u0026quot; value=\u0026quot;0,1\u0026quot; /\u0026gt; | +\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\n 缺省用 160 份虚拟节点，如果要修改，请配置\n[AppleScript] 纯文本查看 复制代码\n +\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | 1 | \u0026lt;dubbo:parameter | | | | | | key=\u0026quot;hash.nodes\u0026quot; value=\u0026quot;320\u0026quot; /\u0026gt; | +\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\n Dubbo 在安全机制方面是如何解决的   Dubbo 通过 Token 令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。Dubbo 还提供服务黑白名单，来控制服务所允许的调用方。\n  dubbo 连接注册中心和直连的区别   在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，这时候可能需要点对点直连，\n点对点直联方式，将以服务接口为单位，忽略注册中心的提供者列表，\n服务注册中心，动态的注册和发现服务，使服务的位置透明，并通过在消费方获取服务提供方地址列表，实现软负载均\n衡和Failover， 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。\n服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，注册中心，服务提供者， 服务消费者三者之间均为长连接，监控中心除外，注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者\n注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表\n注册中心和监控中心都是可选的，服务消费者可以直连服务提供者。\n1. dubbo 服务集群配置（集群容错模式）\n在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。可以自行扩展集群容错策略l Failover Cluster(默认)\n 失败自动切换，当出现失败，重试其它服务器。(缺省)通常用于读操作， 但重试会带来更长延迟。可通过 retries=\u0026quot;2\u0026quot;来设置重试次数(不含第一次)。  [AppleScript] 纯文本查看 复制代码\n +\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | 1 | \u0026lt;dubbo:service retries=\u0026quot;2\u0026quot; | | | | | 2 | cluster=\u0026quot;failover\u0026quot;/\u0026gt; | | | | | 3 | \u0026gt; 或： | | | | | 4 | \u0026lt;dubbo:reference retries=\u0026quot;2\u0026quot; cluster=\u0026quot;failover\u0026quot;/\u0026gt; | | | | | | \u0026gt; cluster=\u0026quot;failover\u0026quot; | | | \u0026gt; | | | \u0026gt; 可以不用写,因为默认就是 | | | | | | failover | +\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\n l Failfast Cluster\n 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作， 比如新增记录。  [AppleScript] 纯文本查看 复制代码\n +\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+ | 1 | dubbo:service | | | | | 2 | cluster=\u0026quot;failfast\u0026quot; /\u0026gt; | | | | | 3 | \u0026gt; 或： | | | | | 4 | \u0026lt;dubbo:reference cluster=\u0026quot;failfast\u0026quot; /\u0026gt; | | | | | | cluster=\u0026quot;failfast\u0026quot;和把 cluster=\u0026quot;failover\u0026quot;、retries=\u0026quot;0\u0026quot;是一样的效 | | | | | | 果,retries=\u0026quot;0\u0026quot;就是不重试 | +\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\n l Failsafe Cluster\n 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。  [AppleScript] 纯文本查看 复制代码\n +\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | \u0026gt; 1 | \u0026lt;dubbo:service | | \u0026gt; | | | \u0026gt; 2 | cluster=\u0026quot;failsafe\u0026quot; /\u0026gt; | | \u0026gt; | | | \u0026gt; 3 | \u0026gt; 或： | +\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\n \u0026lt;dubbo:reference cluster=\u0026quot;failsafe\u0026quot; /\u0026gt;\nl Failback Cluster\n 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。  [AppleScript] 纯文本查看 复制代码\n +\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+ | \u0026gt; 1 | \u0026lt;dubbo:service | | \u0026gt; | | | \u0026gt; 2 | cluster=\u0026quot;failback\u0026quot; /\u0026gt; | | \u0026gt; | | | \u0026gt; 3 | \u0026gt; 或： | | | | | | \u0026lt;dubbo:reference cluster=\u0026quot;failback\u0026quot; /\u0026gt; | +\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\n l Forking Cluster\n 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=\u0026quot;2\u0026quot;来设置最大并行数。  [AppleScript] 纯文本查看 复制代码\n +\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | \u0026gt; 1 | \u0026lt;dubbo:service | | \u0026gt; | | | \u0026gt; 2 | cluster=\u0026ldquo;forking\u0026quot; forks=\u0026quot;2\u0026quot;/\u0026gt; | | \u0026gt; | | | \u0026gt; 3 | \u0026gt; 或： | | | | | | \u0026lt;dubbo:reference cluster=\u0026ldquo;forking\u0026quot; forks=\u0026quot;2\u0026quot;/\u0026gt; | +\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\n l 配置\n[AppleScript] 纯文本查看 复制代码\n +\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | 1 | 服务端服务级别 | | | | | 2 | \u0026lt;dubbo:service interface=\u0026quot;...\u0026quot; loadbalance=\u0026quot;roundrobin\u0026quot; /\u0026gt; | | | | | 3 | 客户端服务级别 | | | | | 4 | \u0026lt;dubbo:reference interface=\u0026quot;...\u0026quot; loadbalance=\u0026quot;roundrobin\u0026quot; /\u0026gt; | | | | | 5 | 服务端方法级别 | | | | | 6 | | +\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\n \u0026lt;dubbo:service interface=\u0026quot;...\u0026quot;\u0026gt;\n\u0026lt;dubbo:method name=\u0026quot;...\u0026quot; loadbalance=\u0026quot;roundrobin\u0026quot;/\u0026gt;\n\u0026lt;/dubbo:service\u0026gt;\n客户端方法级\n别 \u0026lt;dubbo:referenc e interface=\u0026quot;...\u0026quot;\u0026gt;\n\u0026lt;dubbo:method name=\u0026quot;...\u0026quot; loadbalance=\u0026quot;roundrobin\u0026quot;/\u0026gt;\n\u0026lt;/dubbo:reference\u0026gt;\n  dubbo 通信协议dubbo 协议为什么要消费者比提供者个数多：   因 dubbo 协议采用单一长连接，假设网络为千兆网卡(1024Mbit=128MByte)，\n根据测试经验数据每条连接最多只能压满 7MByte(不同的环境可能不一样，供参考)，理论上 1 个服务提供者需要 20 个服务消费者才能压满网卡。\n  dubbo 通信协议dubbo 协议为什么不能传大包：   因 dubbo 协议采用单一长连接，\n如果每次请求的数据包大小为 500KByte，假设网络为千兆网卡(1024Mbit=128MByte)，每条连接最大 7MByte(不同的环境可能不一样，供参考)，\n单个服务提供者的 TPS(每秒处理事务数)最大为：128MByte / 500KByte = 262。\n单个消费者调用单个服务提供者的TPS(每秒处理事务数)最大为：7MByte / 500KByte = 14。如果能接受，可以考虑使用，否则网络将成为瓶颈。\n  dubbo 通信协议dubbo 协议为什么采用异步单一长连接：   因为服务的现状大都是服务提供者少，通常只有几台机器， 而服务的消费者多，可能整个网站都在访问该服务，\n比如 Morgan 的提供者只有 6 台提供者，却有上百台消费者，每天有 1.5 亿次调用，\n如果采用常规的 hessian 服务，服务提供者很容易就被压跨， 通过单一连接，保证单一消费者不会压死提供者，\n长连接，减少连接握手验证等，\n并使用异步 IO，复用线程池，防止 C10K 问题。\n  dubbo 通信协议 dubbo 协议适用范围和适用场景  适用范围：传入传出参数数据包较小（建议小于 100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用 dubbo 协议传输大文件或超大字符串。  适用场景：常规远程服务方法调用dubbo 协议补充：\n连接个数：单连接连接方式：长连接\n传输协议：TCP\n传输方式：NIO 异步传输\n序列化：Hessian 二进制序列化\n  RMI 协议  RMI 协议采用 JDK 标准的 java.rmi.*实现，采用阻塞式短连接和 JDK 标准序列化方式，Java 标准的远程调用协议。  连接个数：多连接连接方式：短连接传输协议：TCP\n 传输方式：同步传输  序列化：Java 标准二进制序列化\n 适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。  适用场景：常规远程服务方法调用，与原生 RMI 服务互操作\n  Hessian 协议  Hessian 协议用于集成 Hessian 的服务，Hessian 底层采用 Http 通讯，采用Servlet 暴露服务，Dubbo 缺省内嵌 Jetty 作为服务器实现  基于 Hessian 的远程调用协议。连接个数：多连接\n 连接方式：短连接传输协议：HTTP  传输方式：同步传输\n 序列化：Hessian 二进制序列化  适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大， 可传文件。\n 适用场景：页面传输，文件传输，或与原生 hessian 服务互操作  http  采用 Spring 的 HttpInvoker 实现基于 http 表单的远程调用协议。连接个数：多连接  连接方式：短连接\n 传输协议：HTTP  传输方式：同步传输\n 序列化：表单序列化（JSON）  适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或 URL 传入参数，暂不支持传文件。\n 适用场景：需同时给应用程序和浏览器 JS 使用的服务。  Webservice  基于 CXF 的 frontend-simple 和 transports-http 实现基于 WebService 的远程调用协议。  连接个数：多连接连接方式：短连接传输协议：HTTP\n 传输方式：同步传输  序列化：SOAP 文本序列化\n 适用场景：系统集成，跨语言调用。  Thrif  Thrift 是Facebook 捐给Apache 的一个RPC 框架，当前 dubbo 支持的 thrift 协议是对 thrift 原生协议的扩展，在原生协议的基础上添加了一些额外的头信息，比如 service name，magic number 等  更多请关注微信公众号：Java 技术栈，回复：面试\n ","pubDate":"2021-02-15","title":"精选8道Dubbo面试题"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_mysql_163%E8%AF%BE%E5%A0%82_%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter1/","plain":"MySQL数据库基础 1.1-认识MySQL 什么是数据库  计算机处理和存储的一切信息都是数据。 计算机系统中一种用于存取数据的程序。 一种：  计算机系统中有很多种能够存取数据的程序 它们各有特征和长处，有自己的适用范围。   存取：  能够保存数据避免丢失。 能够按照需求找到符合条件的数据。    为什么要使用数据库 数据库帮助我们解决一下数据存取难题：\n 较大数据量 网络控制 并发访问 高性能要求 事务控制 持久化和数据安全 查询数据需求逻辑复杂  数据库分类   关系型数据库\n MySQL Oracle SQL Server PostgreSQL    非关系型数据库\n hadoop：存放大数据 mongoDB： 文档型数据库 redis：键值型数据库 Cassandra：分布式数据库    最显著的区别：是否使用结构化查询语句（SQL）\n为什么学习MySQL MySQL：The world\u0026rsquo;s most popular open source database\n  最流行\n  开源\n  并不是最先进\n  前三强中唯一的开源数据库。\n  在互联网企业中占据绝对主流地位。\n  基于GPL协议开放源代码\n  社区版完全免费\n  代码允许自由的进行修改\n  易于学习：\n MySQL具备关系型数据库核心功能但是特性并不繁多。 架构设计上趋于精简。 非常适合新手学习关系型数据库，入门后可向其他数据库发展。    谁需要学习MySQL  应用开发者 DBA  学习目标 - 应用开发者 有助于利用MySQL开发出性能优异的应用程序\n学习目标 - DBA 为企业提供可靠的数据库技术保障\n1.2-轻松安装MySQL 轻松部署MySQL  Windows下安装MySQL  图形化工具安装， MySQL Installer   Linux（Ubuntu）下安装MySQL  包管理安装，apt-get    Windows安装时在安装中间starting server时报错解决办法是手动进入服务管理把MySQL服务的登录方式改为用本地账户且允许与桌面交互\n在Ubuntu下可以用apt-cache search mysql-server查看可用的软件包\n使用sudo apt-get install mysql-server-5.6安装MySQL5.6\n启动与停止MySQL服务：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # 启动 sudo /etc/init.d/mysql start # 或者 sudo service mysql start # 停止 sudo /etc/init.d/mysql stop # 或者 sudo service mysql stop # 重启 sudo service mysql restart # 查看状态 sudo /etc/init.d/mysql status   1.3-MySQL数据库连接 工作中常用到的三种连接方式  Java App + JDBC client（其他语言也有，比如Python的MySQLdb） MySQL client \u0026ldquo;MySQL\u0026rdquo; utility  使用应用程序连接MySQL  应用程序使用驱动（connector/driver）客户端连接MySQL MySQL驱动程序涵盖各种主流语言  使用命令行连接MySQL  安装MySQL客户端软件包 设置环境变量（Linux）  如何安装MySQL-client  从软件源安装sudo apt-get install mysql-client  验证MySQL的安装 mysql -V\n命令行连接MySQL的两种方式  Socket连接（本地连接） TCP/IP连接（远程连接）  使用Socket连接 1 2  # 需要指定socket文件和用户名、密码 mysql -S/tmp/mysql.sock -uroot -p   远程连接 1 2  # 需要指定IP和端口 mysql -h127.0.0.1 -P3306 -uroot -p   本地连接VS远程连接  本地连接只能在MySQL服务器上创建，常用作为MySQL状态检查，或程序和MySQL部署在一台机器上。 远程连接在MySQL服务器内外都能生效，适合应用服务器和MySQL部署在不同机器上的场景。  在Windows下用命令行连接MySQL 1  mysql -hlocalhost -P3306 -uroot -p   连接进入之后可以做什么 1 2 3 4 5  #数据库状态status;#展示当前连接showprocesslist;  使用命令行连接MySQL的注意事项  socket一般存储路径为：/tmp/mysql.sock  1 2  #如果找不到文件可以通过tcp连接进来然后通过如下命令查找showglobalvariableslike\u0026#39;socket\u0026#39;;   socket文件的权限必须是777 不要将密码直接输入在命令行里，存在安全风险！  命令行连接MySQL的特点  MySQL命令行里有丰富的扩展参数 DBA运维管理工具大多使用命令行方式 多台机器可以同时操作，对于DBA来说非常有效率  使用图形客户端连接MySQL  常用的图形客户端工具  Navicat MySQLWorkBench    图形GUI工具的优势  操作简单易于上手 支持图形化的导入、导出 可视化界面输出，输出可视化  总结  应用程序需要使用API接口连接MySQL 开发工程师可以使用图形工具连接MySQL 命令行客户端才是DBA的最爱  1.4-SQL语言入门 关系型数据库  数据存放在表中 表的每一行被称为记录 表中所有记录都有相同的字段（列）  SQL是什么  Structured Query Language 是一种特殊目的的编程语言，用于关系型数据库中的标准数据存取操作 与数据库进行沟通的钥匙  SQL语言与数据库  用SQL创建表，定义表中的字段 用SQL向表中增加，删除，修改记录 用SQL从表中查询到想要的记录 用SQL操作数据库的一切  SQL语句的分类    SQL语句的分类 大致用途     DDL(Data Definition Language) 创建表，删除表，修改表……   DML(Data Manipulation Language) 向表中插入记录，修改或者删除表中的记录……   select 根据条件从表中查询出想要得到的记录   DCL(Data Control Language) 控制数据库的访问权限等设置   TCL(Transaction Control Language) 控制事务进展     DDL  CREATE TABLE DROP TABLE ALTER TABLE   DML  SELECT FROM TABLE INSERT INTO TABLE UPDATE TABLE SET DELETE FROM TABLE   DCL  GRANT REVOKE   TCL  COMMIT ROLLBACK    example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  #查看当前有哪些数据库showdatabases;#使用名为test的数据库usetest;#创建一张学生表createtablestu(idint(10),namevarchar(20),ageint(10),primarykey(id));#每一张表都需要包含一个主键，主键唯一标识一条记录，唯一的字段，不可重复不能为空，通过`primarykey`关键字来定义。#查看创建好的表showcreatetablestu;#新加一个字段altertablestuaddcolumngendervarchar(20);#修改一个字段altertablestumodifycolumngendervarchar(40);#删除一个字段altertablestudropcolumngender;#删除表droptablestu;#查看当前数据库中的表showtables;#向表中插入数据insertintostu(id,name,age)values(1,\u0026#39;pw\u0026#39;,28);#插入全部字段时可以只写表名insertintostuvalues(2,\u0026#39;nss\u0026#39;,29);#查看刚才添加的数据,\u0026#34;*\u0026#34;代表查询全部字段select*fromstu;#如果只想查询两个字段，则只写要查询的字段名selectname,agefromstu;#也可以根据某个条件进行查询，比如只查询id为1的记录selectnameagefromstuwhereid=1;#更新语句updatestusetage=29whereid=1;#删除表中的数据deletefromstuwhereid=1;  1.5-认识DBA 什么是DBA DBA是数据库管理员，就像是足球队的守门员，是业务最后一道屏障，是业务稳定运行的基石，可以提供更畅快的用户体验\n为什么需要DBA  小公司  没有专职DBA 但肯定有懂数据库的人   大公司  专职DBA 数据存储技术专家    互联网业务有以下严格要求：\n 高性能（数据库是重要的一环） 高可用（需要业务不中断的运行） 可扩展（支撑海量数据和业务，数据库拓展） 安全性（核心业务数据敏感）  没有DBA，就没有稳定的数据库，请求变慢，数据丢失，安全问题，用户投诉，无穷无尽\nDBA要做哪些工作  基础运维工作  安装部署 监控 故障处理   安全运维工作  数据备份与恢复 安全访问、安全漏洞 审计   性能调优  数据库优化 容量评估、软硬件升级   开发支持工作  存储方案制定 数据库设计 数据库变更、SQL Review   流程与培训  数据库开发规范 运维流程标准化 业务培训    DBA需要哪些技能  专业技能  数据库原理 Linux与Shell 计算机体系结构 网络原理 数据库系统与操作 服务器硬件 业务架构设计   软技能  责任心、执行力 坚韧、抗压 学习与沟通能力 正直、诚信 耐心，注重细节 分析能力 团队协作    DBA如何发展  小公司or大公司 发展通道：  DBA -\u0026gt; 业务架构师 DBA -\u0026gt; 运维专家 DBA -\u0026gt; 数据库研发    小结  认识DBA 管理好数据库 DBA工作很重要 专业技能与软技能并重 不错的发展前景 互联网公司很缺优秀的DBA  ","pubDate":"2021-02-15","title":"网易云课堂MySQL \u003e chapter1"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_mysql_163%E8%AF%BE%E5%A0%82_%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter2/","plain":"MySQL数据库对象与应用 2.1-MySQL数据类型 Number不止一种  整形 浮点型  整形  INT SMALLINT MEDIUMINT BIGINT     type Storage Minumun Value Maximum Value      (Bytes) (Signed/Unsigned) (Signed/Unsigned)   TINYINT 1 -128 127     0 255   SMALLINT 2 -32768 32767     0 65535   MEDIUMINT 3 -8388608 8388607     0 16777215   INT 4 -2147483648 2147483647     0 4294967295   BIGINT 8 -9223372036854775808 9223372036854775807     0 18446744073709551615    老生常谈的问题 int(11) VS int(21) 存储空间，还是存储范围有区别？\n答案是：两者完全一样，只是在显示的时候补全0的位数不一样。\n可以通过下面的例子来验证：\n1 2 3  createtablet(aint(11)zerofill,bint(21)zerofill);insertintotvalues(1,1);select*fromt;  MySQL默认是不带0补全的。\n只是在一些特殊情况下两者显示有区别，其本质完全一样。\n浮点型  FLOAT(M, D) DOUBLE(M, D)     属性 存储空间 精度 精确性     Float 4 bytes 单精度 非精确   Double 8 bytes 双精度 比Float精度高    精度丢失问题  精度丢失  一个例子：\n1 2 3  createtablet(aint(11),bfloat(7,4));insertintotvalues(2,123.12345);select*fromt;  定点数-更精确的数字类型  DECIMAL  高精度的数据类型，常用来存储交易相关的数据 DECIMAL(M,N).M代表总精度，N代表小数点右侧的位数（标度） 1 \u0026lt; M \u0026lt; 254, 0 \u0026lt; N \u0026lt; 60; 存储空间变长    性别、省份信息 一般使用tinyint、char(1)、enum类型。\n经验之谈  存储性别、省份、类型等分类信息时选择TINYINT或者ENUM BIGINT存储空间更大，INT和BIGINT之间通常选择BIGINT 交易等高精度数据选择使用DECIMAL  存储用户名的属性  CHAR VARCHAR TEXT  CAHR与VARCHAR  CHAR和VARCHAR存储的单位都是字符 CHAR存储定长，容易造成空间的浪费 VARCHAR存储变长，节省存储空间  字符与字节的区别    编码\\输入字符串 网易 netease     gbk(双字节) varchar(2)/4 bytes varchar(7)/7 bytes   utf8(三字节) varchar(2)/6 bytes varchar(7)/7 bytes   utf8mb4(四字节) varchar(2) ? varchar(7)/7 bytes    对于utf8mb4号称占用四字节但是并不绝对。如果在utf8可以覆盖到的范围则仍然占用3字节。\nutf8mb4最有优势的应用场景是用于存储emoji表情\nemoji表情  MySQL版本 \u0026gt; 5.5.3 JDBC驱动版本 \u0026gt; 5.1.13 库和表的编码设为utf8mb4  TEXT与CHAR和VARCHAR的区别  CHAR和VARCHAR存储单位为字符 TEXT存储单位为字节，总大小为65535字节，约为64KB CHAR数据类型最大为255字符 VARCHAR数据类型为变长存储，可以超过255个字符 TEXT在MySQL内部大多存储格式为溢出页，效率不如CHAR  一个例子：\n1 2  createtablet(achar(256));createtablet(avarchar(256));  存储头像  BLOB BINARY  性能太差，不推荐\n经验之谈  CHAR与VARCHAR定义的长度是字符长度不是字节长度 存储字符串推荐使用VARCHAR(N),N尽量小 虽然数据库可以存储二进制数据，但是性能低下，不要使用数据库存储文件音频等二进制数据  存储生日信息  DATE TIME DATETIME TIMESTAMP BIGINT  时间类型的区别在哪里   存储空间上的区别\n DATE三字节，如：2015-05-01 TIME三字节，如：11:12:00 TIMESTAMP，如：2015-05-01 11::12:00 DATETIME八字节，如：2015-05-01 11::12:00    存储精度的区别\n DATE精确到年月日 TIME精确到小时分钟和秒 TIMESTAMP、DATETIME都包含上述两者    TIMESTAMP VS DATETIME  存储范围的区别  TIMESTAMP存储范围：1970-01-01 00::00:01 to 2038-01-19 03:14:07 DATETIME的存储范围：1000-01-01 00:00:00 to 9999-12-31 23:59:59    MySQL在5.6.4版本之后，TimeStamp和DateTime支持到微妙\n 字段类型与市区的关联关系  TIMESTAMP会根据系统时区进行转换，DATETIME则不会    字段类型和时区的关系  国际化的系统  一个例子：\n1 2 3 4 5 6  createtabletest(adatetime,btimestamp);selectnow();insertintotestvalues(now(),now());select*fromtest;settime_zone=\u0026#39;+00:00\u0026#39;;select*fromtest;  BIGINT如何存储时间类型  应用程序将时间转换为数字类型  2.2-MySQL数据对象 MySQL常见的数据对象有哪些  DataBase/Schema Table Index View/Trigger/Function/Procedure  库、表、行层级关系  一个DataBase对应一个Schema 一个Schema包含一个或多个表 一个表里面包含一个或多个字段 一个表里包含一条或多条记录 一个表包含一个或多个索引  多DataBase用途  业务隔离 资源隔离  表上有哪些常用的数据对象  索引 约束 视图、触发器、函数、存储过程  什么是数据库索引  读书的时候如何快速定位某一章节  查找书籍目录 在自己喜欢的章节加书签，直接定位   索引就是数据库中的数据的目录（索引和数据是分开存储的）  索引和数据是两个对象 索引主要是用来提高数据库的查询效率 数据库中数据变更同样需要同步索引数据的变更    如何创建索引（一） 1 2 3 4 5 6 7 8 9 10 11  CREATE[UNIQUE|FULLTEXT|SPATIAL]INDEXindex_name[index_type]ONtbl_name(index_col_name,...)[index_option][algorithm_option|lock_option]...index_col_name:col_name[(length)][ASC|DESC]index_type:USING{BTREE|HASH}  如何创建索引（二） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  ALTER[IGNORE]TABLEtbl_name[alter_specification[,alter_specification]...][partition_options]alter_specification:table_options|ADD[COLUMN]col_namecolumn_definition[FIRST|AFTERcol_name]ADD[COLUMN](col_namecolumn_definition,...)ADD{INDEX|KEY}[index_name][index_type](index_col_name,...)[index_option]...|ADD[CONSTRAINT[symbol]]PRIMARYKEY[index_type](index_col_name,...)[index_option]...|ADD[CONSTRAINT[symbol]]UNIQUE[INDEX|KEY][index_name]  约束  生活中的约束有哪些  每个人的指纹信息必须唯一 每个人的身份证要求唯一 网上购物需要先登录才能下单   唯一约束  对一张表的某个字段或者某几个字段设置唯一键约束，保证在这个表里对应的数据必须唯一，如：用户ID、手机号、身份证等。    创建唯一约束  唯一约束是一种特殊的索引 唯一约束可以是一个或者多个字段 唯一约束可以在创建表的时候建好，也可以后面再补上 主键也是一种唯一约束  唯一约束 以如下这张表为例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  CREATETABLE`order`(`id`int(10)unsignedNOTNULLAUTO_INCREMENT,`orderid`int(10)unsignedNOTNULL,`bookid`int(10)unsignedNOTNULLDEFAULT\u0026#39;0\u0026#39;,`userid`int(10)unsignedNOTNULLDEFAULT\u0026#39;0\u0026#39;,`number`tinyint(3)unsignedNOTNULLDEFAULT\u0026#39;0\u0026#39;,`address`varchar(128)NOTNULLDEFAULT\u0026#39;\u0026#39;,`postcode`varchar(128)NOTNULLDEFAULT\u0026#39;\u0026#39;,`orderdate`datetimeNOTNULLDEFAULT\u0026#39;0000-00-00 00:00:00\u0026#39;,`status`tinyint(3)unsignedzerofillDEFAULT\u0026#39;000\u0026#39;,PRIMARYKEY(`id`),UNIQUEKEY`idx_orderid`(`orderid`),UNIQUEKEY`idx_uid_orderid`(`userid`,`orderid`),KEY`bookid`(`bookid`))ENGINE=InnoDBDEFAULTCHARSET=utf8   索引有哪些  主键索引 ID 单键索引 orderid 单键索引 bookid 组合索引 (userid + orderid)   唯一约束有哪些  主键约束 (ID) 单键唯一索引 (orderid) 组合唯一索引 (userid + orderid)    添加唯一约束  添加主键  alter table `order` add primary key (id);   添加唯一索引  alter table `order` add unique key idx_uk_orderid (orderid);    外键约束  外键指两张表的数据通过某种条件关联起来  创建外键约束  将用户表和订单表通过外键关联起来  alter table `order` add CONSTRAINT constraint_uid FOREIGN KEY (userid) REFERENCES user(userid);   使用外键的注意事项  必须是INNODB表，Myisam和其他引擎不支持外键 相互约束的字段类型必须要求一样 主表的约束字段要求有索引 约束名称必须要唯一，即使不在一张表上    View  产品需求  假如有其他部门的同事想查询我们数据库里的数据，但是我们并不想暴露表结构，并且只提供给他们部分数据    View的作用  视图将一组查询语句构成的结果集，是一种虚拟结构，并不是实际数据 视图能简化数据库的访问，能够将多个查询语句结构化为一个虚拟结构 视图可以隐藏数据库后端表结构，提高数据库安全性 视图也是一种权限管理，只对用户提供部分数据  创建View  创建已完成订单的视图  create view order_view as select * from `order` where status=1;    Trigger  产品需求  随着客户个人等级的提升， 系统需要自动更新用户的积分，其中一共有两张表，分别为：用户信息表和积分表   Trigger俗称触发器，指可以在数据写入表A之前或者之后可以做一些其他动作 使用Trigger在每次更新用户表的时候出发更新积分表  除此之外还有哪些  Function Procedure  2.3-MySQL权限管理 连接MySQL的必要条件  网络要通畅 用户名和密码要正确 数据库需要加IP白名单 更细粒度的验证（库、表、列权限类型等等）  数据有哪些权限 show privileges命令可以查看全部权限\n权限粒度  Data Privileges  DATA: SELECT, INSERT, UPDATE, DELETE   Definition Privileges  DataBase: CREATE, ALTER, DROP Table: CREATE, ALTER, DROP VIEW/FUNCTION/TRIGGER/PROCEDURE: CREATE, ALTER, DROP   Administrator Privileges  Shutdown DataBase Replication Slave Replication Client File Privilege    MySQL赋权操作 1 2 3 4 5 6 7 8 9 10  GRANTpriv_type[(column_list)][,priv_type[column_list]]...ON[object_type]priv_levelTOuser_specification[,user_specification]...[REQUIRE{NONE|ssl_option[[AND]ssl_option]...}][WITHwith_option...]GRANTPROXYONuser_specificationTOuser_specification[,user_specification]...[WITHGRANTOPTION]  如何新建一个用户并赋权  使用MySQL自带的命令  CREATE USER 'netease'@'localhost' IDENTIFIED BY 'netease163'; GRANT SELECT ON *.* TO 'netease'@'localhost' WITH GRANT OPTION;    其他方法  更改数据库记录  首先向User表里面插入一条记录，根据自己的需要选择是否向db和table_pirv表插入记录 执行flush privileges命令，让权限信息生效    更简单的办法  GRANT语句会判断是否存在该用户，如果不存在则新建  GRANT SELECT ON *.* TO 'NETEASE'@'localhost' IDENTIFIED BY 'netease163' WITH GRANT OPTION;    查看用户的权限信息  查看当前用户的权限  show grants;   查看其它用户的权限  show grants for netease@'localhost';    如何更改用户的权限  回收不需要的权限  revoke select on *.* from netease@'localhost';   重新赋权  grant insert on *.* to netease@'localhost';    如何更改用户密码  用新密码，grant语句重新授权 更改数据库记录，Update User表的Password字段  注意：用这种办法，更改完需要flush privileges刷新权限信息，不推荐    删除用户 1  DROPUSERuser[,user]...  With Grant Option  允许被授予权利的人把这个权利授予其他的人  MySQL权限信息存储结构  MySQL权限信息是存在数据库表中 MySQL账号对应的密码也加密存储在数据库表中 每一种权限类型在元数据里都是枚举类型，表明是否有该权限  有哪些权限相关的表  user db table_pirv columns_pirv host  权限验证流程 查询时从user-\u0026gt;db-\u0026gt;table_pirv-\u0026gt;columns_pirv依次验证，如果通过则执行查询。\n小结  MySQL权限信息都是以数据记录的形式存储在数据库的表中。 MySQL的权限验证相比网站登录多了白名单环节，并且粒度更细，可以精确到表和字段。  MySQL权限上有哪些问题  使用Binary二进制安装管理用户没有设置密码 MySQL默认的test库不受权限控制，存在安全风险  mysql_secure_installation  You can set a Password for root accounts. You can remove root accounts that are accessible from outside the localhost. You can remove anonymous-user accounts. You can remove the test database.  小结  权限相关的操作不要直接操作表，统一使用MySQL命令。 使用二进制安装MySQL安装后，需要重置管理用户(root)的密码。 线上数据库不要留test库  实践课：数据库对象 何为表结构设计  表结构设计需要在正式进行开发之前完成 根据产品需求将复杂的业务模型抽象出来  设计表的时候需要注意哪些  理解各个表的依赖关系 理解各个表的功能特点  字段之间的约束、索引 字段类型、字段长度    收集表属性  昵称 生日 性别 手机号码 住宅号码 邮编 住宅地址 注册地址 登录IP 上一次登录时间 邮件地址  理解表的功能特点——数据用途 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  createtabletb_account(account_idintnotnullauto_incrementprimarykey,nick_namevarchar(20),true_namevarchar(20),sexchar(1),mail_addressvarchar(50),phone1varchar(20)notnull,phone2varchar(20),passwordvarchar(30)notnull,create_timedatetime,account_statetinyint,last_login_timedatetime,last_login_ipvarchar(20))ENGINE=InnoDBDEFAULTCHARSET=utf8mb4createtabletb_goods(good_idbigintnotnullauto_incrementprimarykey,goods_namevarchar(100)notnull,pic_urlvarchar(500)notnull,store_quantityintnotnull,goods_notevarchar(4096),producervarchar(500),category_idintnotnull)ENGINE=InnoDBDEFAULTCHARSET=utf8mb4createtabletb_goods_category(category_idintnotnullauto_incrementprimarykey,category_levelsmallintnotnull,category_namevarchar(500),upper_category_idintnotnull)ENGINE=InnoDBDEFAULTCHARSET=utf8mb4createtabletb_order(order_idbigintnotnullauto_incrementprimarykey,account_idintnotnull,create_timedatetime,order_amountdecimal(12,2),order_statetinyint,update_timedatetime,order_ipvarchar(20),pay_methodvarchar(20),user_notesvarchar(500))ENGINE=InnoDBDEFAULTCHARSET=utf8mb4createtabletb_order_item(order_item_idbigintnotnullauto_incrementprimarykey,order_idbigintnotnull,goods_idbigintnotnull,goods_quantityintnotnull,goods_amountdecimal(12,2),uiquekeyuk_order_goods(order_id,goods_id))ENGINE=InnoDBDEFAULTCHARSET=utf8mb4  数据类型——命名规范  所有表名，字段名全部使用小写字母 不同业务，表名使用不同前缀区分。 生成环境表名字段名要有实际意义 单个字段尽量使用字段全名；多个字段之间用下划线分隔  字段设计规范  字段类型选择，尽量选择能满足应用要求的最小数据类型 尽量使用整形代替字符型。整形在字段长度、索引大小等方面开销小效率更高，如邮编字段，手机号码等 注释，每个字段必须以comment语句给出字段的作用 经常访问的大字段需要单独放到一张表中，避免降低sql效率，图片、电影等大文件数据禁止存数据库 新业务统一建议使用utf8mb4字符集  用户赋权  理解用户到底需要什么权限  普通用户只有数据读写权限 系统管理员具有super权限   权限粒度要做到尽可能的细  普通用户不要设置with grant option属性 权限粒度：系统层面\u0026gt;库层面\u0026gt;表层面\u0026gt;字段层面   禁止简单密码  线上密码要求随机    2.4-SQL语言进阶 本课程涉及建表SQL\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175  -- ---------------------------- -- Table structure for `play_fav` -- ---------------------------- DROPTABLEIFEXISTS`play_fav`;CREATETABLE`play_fav`(`userid`bigint(20)NOTNULLCOMMENT\u0026#39;收藏用户id\u0026#39;,`play_id`bigint(20)NOTNULLCOMMENT\u0026#39;歌单id\u0026#39;,`createtime`bigint(20)NOTNULLCOMMENT\u0026#39;收藏时间\u0026#39;,`status`int(11)DEFAULT\u0026#39;0\u0026#39;COMMENT\u0026#39;状态，是否删除\u0026#39;,PRIMARYKEY(`play_id`,`userid`),KEY`IDX_USERID`(`userid`))ENGINE=InnoDBDEFAULTCHARSET=utf8COMMENT=\u0026#39;歌单收藏表\u0026#39;;-- ---------------------------- -- Records of play_fav -- ---------------------------- INSERTINTOplay_favVALUES(\u0026#39;2\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;);INSERTINTOplay_favVALUES(\u0026#39;116\u0026#39;,\u0026#39;1\u0026#39;,\u0026#39;1430223383\u0026#39;,\u0026#39;0\u0026#39;);INSERTINTOplay_favVALUES(\u0026#39;143\u0026#39;,\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;);INSERTINTOplay_favVALUES(\u0026#39;165\u0026#39;,\u0026#39;2\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;);INSERTINTOplay_favVALUES(\u0026#39;170\u0026#39;,\u0026#39;3\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;);INSERTINTOplay_favVALUES(\u0026#39;185\u0026#39;,\u0026#39;3\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;);INSERTINTOplay_favVALUES(\u0026#39;170\u0026#39;,\u0026#39;4\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;);INSERTINTOplay_favVALUES(\u0026#39;170\u0026#39;,\u0026#39;5\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;);-- ---------------------------- -- Table structure for `play_list` -- ---------------------------- DROPTABLEIFEXISTS`play_list`;CREATETABLE`play_list`(`id`bigint(20)NOTNULLCOMMENT\u0026#39;主键\u0026#39;,`play_name`varchar(255)DEFAULTNULLCOMMENT\u0026#39;歌单名字\u0026#39;,`userid`bigint(20)NOTNULLCOMMENT\u0026#39;歌单作者账号id\u0026#39;,`createtime`bigint(20)DEFAULT\u0026#39;0\u0026#39;COMMENT\u0026#39;歌单创建时间\u0026#39;,`updatetime`bigint(20)DEFAULT\u0026#39;0\u0026#39;COMMENT\u0026#39;歌单更新时间\u0026#39;,`bookedcount`bigint(20)DEFAULT\u0026#39;0\u0026#39;COMMENT\u0026#39;歌单订阅人数\u0026#39;,`trackcount`int(11)DEFAULT\u0026#39;0\u0026#39;COMMENT\u0026#39;歌曲的数量\u0026#39;,`status`int(11)DEFAULT\u0026#39;0\u0026#39;COMMENT\u0026#39;状态,是否删除\u0026#39;,PRIMARYKEY(`id`),KEY`IDX_CreateTime`(`createtime`),KEY`IDX_UID_CTIME`(`userid`,`createtime`))ENGINE=InnoDBDEFAULTCHARSET=utf8COMMENT=\u0026#39;歌单\u0026#39;;-- ---------------------------- -- Records of play_list -- ---------------------------- INSERTINTOplay_listVALUES(\u0026#39;1\u0026#39;,\u0026#39;老男孩\u0026#39;,\u0026#39;1\u0026#39;,\u0026#39;1430223383\u0026#39;,\u0026#39;1430223383\u0026#39;,\u0026#39;5\u0026#39;,\u0026#39;6\u0026#39;,\u0026#39;0\u0026#39;);INSERTINTOplay_listVALUES(\u0026#39;2\u0026#39;,\u0026#39;情歌王子\u0026#39;,\u0026#39;3\u0026#39;,\u0026#39;1430223384\u0026#39;,\u0026#39;1430223384\u0026#39;,\u0026#39;7\u0026#39;,\u0026#39;3\u0026#39;,\u0026#39;0\u0026#39;);INSERTINTOplay_listVALUES(\u0026#39;3\u0026#39;,\u0026#39;每日歌曲推荐\u0026#39;,\u0026#39;5\u0026#39;,\u0026#39;1430223385\u0026#39;,\u0026#39;1430223385\u0026#39;,\u0026#39;2\u0026#39;,\u0026#39;4\u0026#39;,\u0026#39;0\u0026#39;);INSERTINTOplay_listVALUES(\u0026#39;4\u0026#39;,\u0026#39;山河水\u0026#39;,\u0026#39;2\u0026#39;,\u0026#39;1430223386\u0026#39;,\u0026#39;1430223386\u0026#39;,\u0026#39;5\u0026#39;,null,\u0026#39;0\u0026#39;);INSERTINTOplay_listVALUES(\u0026#39;5\u0026#39;,\u0026#39;李荣浩\u0026#39;,\u0026#39;1\u0026#39;,\u0026#39;1430223387\u0026#39;,\u0026#39;1430223387\u0026#39;,\u0026#39;1\u0026#39;,\u0026#39;10\u0026#39;,\u0026#39;0\u0026#39;);INSERTINTOplay_listVALUES(\u0026#39;6\u0026#39;,\u0026#39;情深深\u0026#39;,\u0026#39;5\u0026#39;,\u0026#39;1430223388\u0026#39;,\u0026#39;1430223389\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;1\u0026#39;);-- ---------------------------- -- Table structure for `song_list` -- ---------------------------- DROPTABLEIFEXISTS`song_list`;CREATETABLE`song_list`(`id`bigint(20)NOTNULLCOMMENT\u0026#39;主键\u0026#39;,`song_name`varchar(255)NOTNULLCOMMENT\u0026#39;歌曲名\u0026#39;,`artist`varchar(255)NOTNULLCOMMENT\u0026#39;艺术节\u0026#39;,`createtime`bigint(20)DEFAULT\u0026#39;0\u0026#39;COMMENT\u0026#39;歌曲创建时间\u0026#39;,`updatetime`bigint(20)DEFAULT\u0026#39;0\u0026#39;COMMENT\u0026#39;歌曲更新时间\u0026#39;,`album`varchar(255)DEFAULTNULLCOMMENT\u0026#39;专辑\u0026#39;,`playcount`int(11)DEFAULT\u0026#39;0\u0026#39;COMMENT\u0026#39;点播次数\u0026#39;,`status`int(11)DEFAULT\u0026#39;0\u0026#39;COMMENT\u0026#39;状态,是否删除\u0026#39;,PRIMARYKEY(`id`),KEY`IDX_artist`(`artist`),KEY`IDX_album`(`album`))ENGINE=InnoDBDEFAULTCHARSET=utf8COMMENT=\u0026#39;歌曲列表\u0026#39;;-- ---------------------------- -- Records of song_list -- ---------------------------- INSERTINTOsong_listVALUES(\u0026#39;1\u0026#39;,\u0026#39;Good Lovin\\\u0026#39;GoneBad\u0026#39;, \u0026#39;BadCompany\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;StraightShooter\u0026#39;, \u0026#39;453\u0026#39;, \u0026#39;0\u0026#39;); INSERT INTO song_list VALUES (\u0026#39;2\u0026#39;, \u0026#39;WeepNoMore\u0026#39;, \u0026#39;BadCompany\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;StraightShooter\u0026#39;, \u0026#39;280\u0026#39;, \u0026#39;0\u0026#39;); INSERT INTO song_list VALUES (\u0026#39;3\u0026#39;, \u0026#39;ShootingStar\u0026#39;, \u0026#39;BadCompany\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;StraightShooter\u0026#39;, \u0026#39;530\u0026#39;, \u0026#39;0\u0026#39;); INSERT INTO song_list VALUES (\u0026#39;4\u0026#39;, \u0026#39;大象\u0026#39;, \u0026#39;李志\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;1701\u0026#39;, \u0026#39;560\u0026#39;, \u0026#39;0\u0026#39;); INSERT INTO song_list VALUES (\u0026#39;5\u0026#39;, \u0026#39;定西\u0026#39;, \u0026#39;李志\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;1701\u0026#39;, \u0026#39;1023\u0026#39;, \u0026#39;0\u0026#39;); INSERT INTO song_list VALUES (\u0026#39;6\u0026#39;, \u0026#39;红雪莲\u0026#39;, \u0026#39;洪启\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;红雪莲\u0026#39;, \u0026#39;220\u0026#39;, \u0026#39;0\u0026#39;); INSERT INTO song_list VALUES (\u0026#39;7\u0026#39;, \u0026#39;风柜来的人\u0026#39;, \u0026#39;李宗盛\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;作品李宗盛\u0026#39;, \u0026#39;566\u0026#39;, \u0026#39;0\u0026#39;); -- ---------------------------- -- Table structure for `stu` -- ---------------------------- DROP TABLE IF EXISTS `stu`; CREATE TABLE `stu` ( `id` int(10) NOT NULL DEFAULT \u0026#39;0\u0026#39;, `name` varchar(20) DEFAULT NULL, `age` int(10) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=latin1; -- ---------------------------- -- Records of stu -- ---------------------------- -- ---------------------------- -- Table structure for `tbl_proc_test` -- ---------------------------- DROP TABLE IF EXISTS `tbl_proc_test`; CREATE TABLE `tbl_proc_test` ( `id` int(11) NOT NULL AUTO_INCREMENT, `num` int(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=30 DEFAULT CHARSET=utf8; -- ---------------------------- -- Records of tbl_proc_test -- ---------------------------- INSERT INTO tbl_proc_test VALUES (\u0026#39;11\u0026#39;, \u0026#39;1\u0026#39;); INSERT INTO tbl_proc_test VALUES (\u0026#39;12\u0026#39;, \u0026#39;2\u0026#39;); INSERT INTO tbl_proc_test VALUES (\u0026#39;13\u0026#39;, \u0026#39;6\u0026#39;); INSERT INTO tbl_proc_test VALUES (\u0026#39;14\u0026#39;, \u0026#39;24\u0026#39;); INSERT INTO tbl_proc_test VALUES (\u0026#39;15\u0026#39;, \u0026#39;120\u0026#39;); INSERT INTO tbl_proc_test VALUES (\u0026#39;16\u0026#39;, \u0026#39;720\u0026#39;); INSERT INTO tbl_proc_test VALUES (\u0026#39;17\u0026#39;, \u0026#39;5040\u0026#39;); INSERT INTO tbl_proc_test VALUES (\u0026#39;18\u0026#39;, \u0026#39;40320\u0026#39;); INSERT INTO tbl_proc_test VALUES (\u0026#39;19\u0026#39;, \u0026#39;362880\u0026#39;); INSERT INTO tbl_proc_test VALUES (\u0026#39;20\u0026#39;, \u0026#39;3628800\u0026#39;); INSERT INTO tbl_proc_test VALUES (\u0026#39;21\u0026#39;, \u0026#39;1\u0026#39;); INSERT INTO tbl_proc_test VALUES (\u0026#39;22\u0026#39;, \u0026#39;2\u0026#39;); INSERT INTO tbl_proc_test VALUES (\u0026#39;23\u0026#39;, \u0026#39;6\u0026#39;); INSERT INTO tbl_proc_test VALUES (\u0026#39;24\u0026#39;, \u0026#39;24\u0026#39;); INSERT INTO tbl_proc_test VALUES (\u0026#39;25\u0026#39;, \u0026#39;1\u0026#39;); INSERT INTO tbl_proc_test VALUES (\u0026#39;26\u0026#39;, \u0026#39;2\u0026#39;); INSERT INTO tbl_proc_test VALUES (\u0026#39;27\u0026#39;, \u0026#39;6\u0026#39;); INSERT INTO tbl_proc_test VALUES (\u0026#39;28\u0026#39;, \u0026#39;24\u0026#39;); INSERT INTO tbl_proc_test VALUES (\u0026#39;29\u0026#39;, \u0026#39;120\u0026#39;); -- ---------------------------- -- Table structure for `tbl_test1` -- ---------------------------- DROP TABLE IF EXISTS `tbl_test1`; CREATE TABLE `tbl_test1` ( `user` varchar(255) NOT NULL COMMENT \u0026#39;主键\u0026#39;, `key` varchar(255) NOT NULL, `value` varchar(255) NOT NULL, PRIMARY KEY (`user`,`key`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=\u0026#39;行列转换测试\u0026#39;; -- ---------------------------- -- Records of tbl_test1 -- ---------------------------- INSERT INTO tbl_test1 VALUES (\u0026#39;li\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;18\u0026#39;); INSERT INTO tbl_test1 VALUES (\u0026#39;li\u0026#39;, \u0026#39;dep\u0026#39;, \u0026#39;2\u0026#39;); INSERT INTO tbl_test1 VALUES (\u0026#39;li\u0026#39;, \u0026#39;sex\u0026#39;, \u0026#39;male\u0026#39;); INSERT INTO tbl_test1 VALUES (\u0026#39;sun\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;44\u0026#39;); INSERT INTO tbl_test1 VALUES (\u0026#39;sun\u0026#39;, \u0026#39;dep\u0026#39;, \u0026#39;3\u0026#39;); INSERT INTO tbl_test1 VALUES (\u0026#39;sun\u0026#39;, \u0026#39;sex\u0026#39;, \u0026#39;female\u0026#39;); INSERT INTO tbl_test1 VALUES (\u0026#39;wang\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;20\u0026#39;); INSERT INTO tbl_test1 VALUES (\u0026#39;wang\u0026#39;, \u0026#39;dep\u0026#39;, \u0026#39;3\u0026#39;); INSERT INTO tbl_test1 VALUES (\u0026#39;wang\u0026#39;, \u0026#39;sex\u0026#39;, \u0026#39;male\u0026#39;); -- ---------------------------- -- Procedure structure for `proc_test1` -- ---------------------------- DROP PROCEDURE IF EXISTS `proc_test1`; DELIMITER ;; CREATE DEFINER=`root` PROCEDURE `proc_test1`(IN total INT,OUT res INT) BEGIN DECLARE i INT; SET i = 1; SET res = 1; IF total \u0026lt;= 0 THEN SET total = 1; END IF; WHILE i \u0026lt;= total DO SET res = res * i; INSERT INTO tbl_proc_test(num) VALUES (res); SET i = i + 1; END WHILE; END ;; DELIMITER ;   说明  本课程介绍以MySQL SQL语法为基础，不同数据库SQL语法存在差异，并未完全遵照ANSI标准。 本课程结合一个实际项目（云音乐），介绍各种SQL语言在实际应用中如何实现业务功能。  SQL进阶语法——order by 场景1：歌单按时间排序\n1 2 3 4 5 6 7 8 9  -- 查看全部歌单 select*fromplay_list;-- 按创建时间排序 select*fromplay_listorderbycreatetime;-- MySQL默认升序，如果按降序排列，则使用如下语句。 select*fromplay_listorderbycreatetimedesc;-- 也可以按照多个字段来排序 select*fromplay_listorderbybookedcount,trackcount;  SQL进阶语法——distinct 场景2：统计云音乐创建歌单的用户\n1 2 3 4 5 6 7 8  -- 有重复 selectuseridfromplay_list;-- 去重 selectdistinctuseridfromplay_list;-- 多个字段 selectdistinctuserid,play_namefromplay_list;   distinct用于返回唯一不同的值 可以返回多列的唯一组合 底层实现使用排序，如果数据量大会消耗较多的IO和CPU  SQL进阶语法——group by 场景3-1：统计云音乐创建歌单的用户列表和每人创建歌单的数量。\n1 2 3 4 5  -- 每个用户歌单的最大订阅数 selectuserid,max(bookedcount)fromplay_listgroupbyuserid;-- 每个用户歌单的数量 selectuserid,count(*)fromplay_listgroupbyuserid;   group by 根据单列或多列对数据进行分组，通常结合聚合函数使用，如count(*).  SQL进阶语法——group by having 场景3-2：统计云音乐创建歌单的用户列表和每人创建歌单的数量，并且只显示歌单数量排序大于等于2的用户\n1  selectuserid,count(*)fromplay_listgroupbyuseridhavingcount(*)\u0026gt;=2;   having 是对结果进行过滤  SQL进阶语法-like\n1  select*fromplay_listwhereplay_namelike\u0026#39;%男孩%\u0026#39;;     通配符 描述     % 代替一个或多个字符   _ 代替单个字符   [charlist] 中括号中的任何一个字符   [^charlist] 或者 [!charlist] 不在中括号中的任何单一字符     除了百分号在最右面的情况以外，他会对这个表中所有的记录进行一次查询匹配，而没办法使用索引，效率较低。大表中需要慎用like。可以使用全文检索的手段。  SQL进阶语法-limit, offset 场景4：查询一个月内创建歌单（从第6行开始显示10条记录）\n1  select*fromplay_listwhere(createtimebetween1427791323and1430383307)limit10offset6;   offset后的值不建议太大，需要消耗的IO较大  case when  case when 实现类似编程语言的if else功能，可以对SQL的输出结果进行选择判断。  场景5：对于未录入歌曲的歌单(trackcount = null)，输出结果时歌曲数返回0.\n1  selectcasewhenplay_name,trackcountisnullthen0elsetrackcountendfromplay_list;  select相关进阶语法 1 2 3 4 5 6 7 8 9 10 11 12  SELECT[DISTINCT]select_expr[,select_expr...][FROMtable_references[WHEREwhere_condition][GROUPBY{col_name|expr|position}[ASC|DESC],...[WITHROLLUP]][HAVINGwhere_condition][ORDERBY{col_name|expr|position}[ASC|DESC],...][LIMIT{[offset,]row_count|row_countOFFSEToffset}][FORUPDATE|LOCKINSHAREMODE]]  连接-Join 连接的作用是用一个SQL语句把多个表中相互关联的数据查出来\n场景6：查询收藏“老男孩”歌单的用户列表\n1 2 3 4  select*fromplay_list,play_favwhereplay_list.id=play_fav.play_id;selectplay_fav.useridfromplay_list,play_favwhereplay_list.id=play_fav.play_idandplay_list.play_name=\u0026#39;老男孩\u0026#39;;-- 另一种写法 selectf.useridfromplay_listlstjoinplay_favfonlst.id=f.play_idwherelst.play_name=\u0026#39;老男孩\u0026#39;;  子查询  MySQL还有另一种写法，可以实现同样的功能。  1  selectuseridfromplay_favwhereplay_id=(selectidfromplay_listwhereplay_name=\u0026#39;老男孩\u0026#39;);  子查询：内层查询的结果作为外层的比较条件。一般子查询都可以转换成连接，推荐使用连接。\n 不利于MySQL的查询优化器进行优化，可能存在性能问题 连接的实现是嵌套循环，选择一个驱动表，遍历驱动表，查询内层表，依次循环。驱动表会至少查询一边，如果有索引等，内层表可以非常快，查询优化器会选择数据小的表作为驱动表。 子查询由人为规定驱动表和内层表  连接- left Join 1  selectlst.play_namefromplay_listlstleftjoinplay_favfonlst.id=f.play_idwheref.play_idisnull;   LEFT JOIN从左表(play_list)返回所有的行，即使在右表中(play_fav)中没有匹配的行。 与LEFT JOIN相对应的有RIGHT JOIN关键字，会从右表那里返回所有的行，即使在左表中没有匹配的行。  场景7：查询出没有用户收藏的歌单\nSQL进阶语法-union 场景8：老板想看创建和收藏歌单的所有用户，查询play_list和play_fav两表中所有的userid\n1 2  selectuseridfromplay_listunionselectuseridfromplay_fav;-- 默认会去重， 不想去重的话使用union all代替union。   DML进阶语法  多值插入： insert into table values(\u0026hellip;.),(\u0026hellip;.)  可以一次插入多行数据，减少与数据库的交互提高效率 eg： insert into A values(4, 33), (5, 33);   覆盖插入： replace into table values (\u0026hellip;.)  可以简化业务逻辑的判断   忽略插入： insert ignore into table value (\u0026hellip;.)  可以简化业务逻辑的判断   查询插入： insert into table_a select * from table_b  常用于导表操作   insert主键重复则update  INSERT INTO TABLE tbl VALUES (id, col1, col2) ON DUPLICATE KEY UPDATE col2=....; eg: insert into A values(2, 40) on duplicate key update age=40; 可以简化前端业务逻辑的判断   连表update  A表：id, age B表：id, name, age A表id与B表id关联，根据B表的age值更新A表的age。 eg: update A,B set A.age=B.age where A.id=B.id;   连表删除  A表：id, age B表：id, name, age A表id与B表id关联，根据B表的age值删除A表的数据。 eg: delete A from A,B where A.id=B.id and B.name='pw';    总结  select查询进阶语法  order by/distinct/group by having (聚合函数) /like (%前缀后缀)   连接语法  内连接、左连接、右连接、 Union [ALL]   DML进阶语法  insert/连表update/连表delete    2.5-内置函数 聚合函数  聚合函数面向一组数据，对数据进行聚合运算后返回单一的值。 MySQL聚合函数的基本语法：SELECT function(列) from 表 常用聚合函数：     函数 描述     AVG() 返回列的平均值   COUNT(DISTINCT) 返回列去重后的行数   COUNT() 返回列的行数   MAX() 返回列的最大值   MIN() 返回列的最小值   SUM() 返回列的总和   GROUP_CONCAT() 返回一组值的连接字符串(MySQL独有)    实例还是上节中的那些表\n场景1：查询每张专辑总的点播次数和每首歌的平均点播次数。\n1  selectalbum,sum(playcount),avg(playcount)fromsong_listgroupbyalbum;  场景2：查询全部歌曲中的最大的播放次数和最小的播放次数。\n1  selectmax(playcount),min(playcount)fromsong_list;  场景2续：查询播放次数最多的歌曲\n1 2 3 4  -- 错误查法 selectsong_name,max(playcount)fromsong_list;-- 正确查法 selectsong_name,playcountfromsong_listorderbyplaycountdesclimit1;   select count(*) from song_list; select count(1) from song_list; select count(song_name) from song_list;  count(*)和count(1)基本一样，没有明显的性能差异。 count(*)和count(song_name)差别在于count(song_name)会除去song_name is null的情况\n场景3：显示每张专辑的歌曲列表\n1 2  selectalbum,GROUP_CONCAT(song_name)fromsong_listgroupbyalbum;-- 默认最大只能连接1024个字符，但是可以通过改数据库参数来改变。   使用聚合函数做数据库行列转换 1 2 3 4 5 6  selectuser,max(casewhen\u0026#39;key\u0026#39;=\u0026#39;age\u0026#39;thenvalueend)age,max(casewhen\u0026#39;key\u0026#39;=\u0026#39;sex\u0026#39;thenvalueend)sex,max(casewhen\u0026#39;key\u0026#39;=\u0026#39;dep\u0026#39;thenvalueend)dep,fromtbl_test1groupbyuser;  预定义函数  预定义函数面向单值数据，返回一对一的处理结果(聚合函数可以理解成多对一)。 预定义函数基本语法： 1 2  selectfunction(列)from表;select*from表where列=function(value)...    预定义函数-字符串函数    函数 描述     LENGTH() 返回列的字节数   CHAR_LENGTH() 返回列的字符数   TRIM()/RTRIM()/LTRIM() 去除两边空格/去除右边空格/去除左边空格   SUBSTRING(str, pos, [len]) 从pos位置截取字符串str，截取len长度   LOCATE(substr, str, [pos]) 返回substr在str字符串中的位置   REPLACE(str, from_str, to_str) 将str字符串中的from_str替换成to_str   LOWER(), UPPER() 字符串转换为小写/大写     字符串函数 - 实例  1 2 3 4 5 6 7 8 9 10 11 12  SELECTSUBSTRING(\u0026#39;abcdef\u0026#39;,3);-- \u0026#39;cdef\u0026#39; SELECTSUBSTRING(\u0026#39;abcdef\u0026#39;,-3);-- \u0026#39;def\u0026#39; SELECTSUBSTRING(\u0026#39;abcdef\u0026#39;,3,2);-- \u0026#39;cd\u0026#39; SELECTLOCATE(\u0026#39;bar\u0026#39;,\u0026#39;foobarbar\u0026#39;);-- 4 SELECTLOCATE(\u0026#39;xbar\u0026#39;,\u0026#39;foobar\u0026#39;);-- 0 SELECTLOCATE(\u0026#39;bar\u0026#39;,\u0026#39;foobarbar\u0026#39;,5);-- 7   预定义函数-时间处理函数    函数 描述     CURDATE() 当前日期   CURTIME() 当前时间   NOW() 显示当前时间日期(常用)   UNIX_TIMESTAMP() 当前时间戳   DATE_FORMAT(date, format) 按指定格式显示时间   DATE_ADD(date, INTERVAL unit) 计算指定日期向后加一段时间的日期   DATE_SUB(date, INTERVAL unit) 计算指定日期向前减一段时间的日期     实例：  1 2  SELECTNOW()+INTERVAL1MONTH;SELECTNOW()-INTERVAL1WEEK;  预定义函数-数字处理函数    函数 描述     ABS() 返回数值的绝对值   CEIL() 对小数向上取整 CEIL(1.2)=2   ROUND() 四舍五入   POW(num, n) num的n次幂 POW(2, 2)=4   FLOOR() 对小数向下取整 CELL(1.2)=1   MOD(N, M) 取模(返回n除以m的余数)=N % M   RAND() 取0~1之间的一个随机数    算数、逻辑运算  比较运算     函数 描述     IS, IS NOT 判定布尔值 IS True, IS NOT False, IS NULL   \u0026gt;, \u0026gt;= 大于，大于等于   \u0026lt;, \u0026lt;= 小于，小于等于   = 等于   !=, \u0026lt;\u0026gt; 不等于   BETWEEN M AND N 取M和N之间的值   IN, NOT IN 检查是否在或不在一组值之中    实例：查询一个月内userid为1,3,5的用户创建的歌单\n1  select*fromplay_listwhere(createtimebetween1427791323and1430383307)anduseridin(1,3,5);   *,/,DIV,%,MOD,-,+ NOT, AND, \u0026amp;\u0026amp;, XOR, OR, ||  2.6-触发器与存储过程 触发器  是什么  触发器是加在表上的一个特殊程序，当表上出现特定的事件(INSERT/UPDATE/DELETE)时触发该程序执行。   做什么  数据订正；迁移表；实现特定的业务逻辑。    触发器-基本语法 1 2 3 4 5 6 7 8 9  CREATE[DEFINER={user|CURRENT_USER}]TRIGGERtrigger_nametrigger_timetrigger_eventONtbl_nameFOREACHROWtrigger_bodyttrigger_time:{BEFORE|AFTER}trigger_event:{INSERT|UPDATE|DELETE}  触发器-实例 学生表：\n1 2 3 4 5 6  CREATETABLE`stu`(`name`varchar(50),`course`varchar(50),`score`int(11),PRIMARYKEY(`name`))ENGINE=InnoDB;  用于更正成绩的触发器：\n1 2 3 4 5 6 7 8 9 10 11 12  DELIMITER//CREATETRIGGERtrg_upd_scoreBEFOREUPDATEON`stu`FOREACHROWBEGINIFNEW.score\u0026lt;0THENSETNEW.score=0;ELSEIFNEW.score\u0026gt;100THENSETNEW.score=100;ENDIF;END;//DELIMITER;  注意事项  触发器对性能有损耗，应慎重使用。 同一类事件在一个表中只能创建一次。 对于事务表，触发器执行失败则整个语句回滚。 Row格式的主从复制，触发器不会在从库上执行。 使用触发器时应防止递归执行。  存储过程  定义：存储过程是存储在数据库的一组SQL语句集，用户可以通过存储过程名和传参多次调用的程序模块。 特点：  使用灵活，可以使用流控制语句，自定义变量等完成复杂的业务逻辑。 提高数据安全性，屏蔽应用程序直接对表的操作，易于进行审计。 减少网络传输。 提高代码维护的复杂度，实际使用中要评估场景是否适合。    存储过程-基本语法 1 2 3 4 5 6 7 8 9 10 11 12 13 14  CREATE[DEFINER={user|CURRENT_USER}]PROCEDUREsp_name([proc_parameter[,...]])[characteristic...]routine_bodyproc_parameter:[IN|OUT|INOUT]param_nametypetype:AnyvalidMySQLdatatypecharacteristic:COMMENT\u0026#39;string\u0026#39;|[NOT]DETERMINISTICroutine_body:ValidSQLroutinestatement  存储过程-实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  CREATEPROCEDUREproc_test1(INtotalINT,OUTresINT)BEGINDECLAREiINT;SETi=1;SETres=1;IFtotal\u0026lt;=0THENSETtotal=1;ENDIF;WHILEi\u0026lt;=totalDOSETres=res*i;INSERTINTOtbl_proc_test(num)VALUES(res);SETi=i+1;ENDWHILE;END;  存储过程-流控制语句    流控制 描述     IF IF search_condition THEN statement_list [ELSEIF search_condition THEN statement_list][ELSE statement_list] END IF   CASE CASE case_value WHEN when_value THEN statement_list [ELSE statement_list] END CASE   WHILE WHILE search_condition DO statement_list END WHILE   REPEAT REPEAT statement_list UNTIL search_condition END REPEAT    存储过程-调用 1 2 3 4  set@total=10;set@res=1;callproc_test1(@total,@res);select@res;  自定义函数  自定义函数与存储过程类似，但是必须带有返回值(RETURN)。 自定义函数与sum(), max()等MySQL原生函数使用方法类似： 1 2  SELECTfunc(val);SELECT*fromtblwherecol=func(val);   由于自定义函数可能在遍历数据中使用，要注意性能损耗  自定义函数-基本语法 1 2 3 4 5 6 7 8 9 10 11 12 13 14  CREATE[DEFINER={user|CURRENT_USER}]FUNCTIONsp_name([func_parameter[,...]])RETURNStype[characteristic...]routine_bodyfunc_parameter:param_nametypetype:AnyvalidMySQLdatatypecharacteristic:COMMENT\u0026#39;string\u0026#39;|[NOT]DETERMINISTICroutine_body:ValidSQLroutinestatement  自定义函数-实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  CREATEFUNCTIONfunc_test1(totalINT)RETURNSINTBEGINDECLAREiINT;DECLAREresINT;SETi=1;SETres=1;IFtotal\u0026lt;=0THENSETtotal=1;ENDIF;WHILEi\u0026lt;totalDOSETres=res*i;SETi=i+1;ENDWHILE;RETURNres;END;  自定义函数-调用 1  selectfunc_test1(4);  小结  知识点：触发器、存储过程、自定义函数 互联网场景：触发器和存储过程不利于水平扩展，多用于统计和运维操作中。  2.7-MySQL字符集 字符集基础  字符集：数据库中的字符集包含两层含义  各种文字和符号的集合，包括各国家文字、标点符号、图形符号、数字等。 字符的编码方式，即二进制数据与字符的映射规则。    字符集-分类  ASCII：美国信息互换标准编码；英语和其他西欧语言；单字节编码，7位表示一个字符，共128字符。 GBK：汉字内码扩展规范；中日韩汉字、英文、数字；双字节编码；共收录了21003个汉字，GB2312的扩展。 UTF-8:Unicode标准的可变长度字符编码；Unicode标准（统一码），业界统一标准，包括世界上数十种文字的系统；UTF-8使用一至四个字节为每个字符编码。 其他常见字符集：UTF-32，UTF-16，Big5，latin1  MySQL字符集  查看字符集  1  SHOWCHARACTERSET;   新增字符集  1 2  # 编译时加入： --with-charset= ./configure --prefix=/usr/local/mysql3 --with-plugins=innobase --with-charset=gbk   字符集与字符序  charset和collation  collation：字符序，字符的排序与比较规则，每个字符集都有对应的多套字符序。 不同的字符序决定了字符串在比较排序中的精度和性能不同。    查看字符序\n1  showcollation;  mysql的字符序遵从命名惯例：以_ci(表示大小写不敏感)，以_CS(表示大小写敏感)，以_bin(表示用编码值进行比较)。\n字符集设置级别  charset和collation的设置级别：  服务器级 \u0026raquo; 数据库级 \u0026raquo; 表级 \u0026raquo; 列级   服务器级  系统变量(可动态设置)：  character_set_server：默认的内部操作字符集 character_set_system：系统元数据(各字段名等)字符集      字符集设置级别  服务器级  配置文件\r[mysqld]\rcharacter_set_server=utf8\rcollation_server=utf8_general_ci\r 数据库级  1  CREATEDATABASEdb_nameCHARACTERSETlatin1COLLATElatin1_swedish_ci;   character_set_database：当前选中数据库的默认字符集  主要影响load data等语句的默认字符集，CREATE DATABASE的字符集如果不设置，默认使用character_set_server的字符集。\n 表级  1  CREATETABLEtbl1(....)DEFAULTCHARSET=utf8DEFAULTCOLLATE=utf8_bin;   列级  1  CREATETABLEtbl1(col1VARCHAR(5)CHARACTERSETlatin1COLLATElatin1_german1_ci);  字符集设置级别  数据存储字符集使用规则：  使用列集的CHARACTER SET设定值； 若列级字符集不存在，则使用对应表级的DEFAULT CHARACTER SET设定值； 若表级字符集不存在，则使用数据库级的DEFAULT CHARACTER SET设定值； 若数据库级字符集不存在，则使用服务器级character_set_server设定值。    1 2 3 4 5 6 7  -- 查看字符集 show[global]variableslike\u0026#39;character%\u0026#39;;show[global]variableslike\u0026#39;collation%\u0026#39;;-- 修改字符集 setglobalcharacter_set_server=utf8;-- 全局 altertablexxxconverttocharactersetxxx;-- 表   客户端连接与字符集  连接与字符集  character_set_client：客户端来源数据使用的字符集。 character_set_connection：连接层字符集。 character_set_results：查询结果字符集。    mysql \u0026gt; set names utf8;\r配置文件设置：\r[mysql]\rdefault-character-set=utf8\r 字符转换过程  client \u0026gt; character_set_client \u0026gt; character_set_connection \u0026gt; Storage \u0026gt; character_set_results \u0026gt;client\n推荐使用统一的字符集\n  常见乱码原因：\n 数据存储字符集不能正确编码(不支持)client发来的数据：client(utf8)-\u0026gt;Storage(latin1) 程序连接使用的字符集与通知mysql的character_set_client等不一致或不兼容。    使用建议\n 创建数据库/表时显式的指定字符集，不使用默认。 连接字符集与存储字符集设置一致，推荐使用utf8。 驱动程序连接时显式指定字符集(set names XXX).    mysql CAPI:初始化数据库句柄后马上用mysql_options设定MYSQL_CHARSET_NAME属性为utf8.\n  mysql php API:连接到数据库以后显式用SET NAMES语句设置一次连接字符集。\n  mysql JDBC: url=\u0026ldquo;jdbc:mysql://localhost:3306/blog_dbo?user=xx\u0026amp;password=xx\u0026amp;userUnicode=true\u0026amp;characterEncoding=utf8\u0026rdquo;\n  小结  字符集：表示的字符集和/字符编码方式 字符的设置级别：服务器/数据库/表/列 客户端字符集：乱码产生的原因与解决方式  2.8程序连接MySQL 程序连接MySQL基本原理 JDBC客户端应用 -\u0026gt; java.sql.*或javax.sql.* -\u0026gt; 驱动程序 -\u0026gt; SQLserver/Oracle/MySQL\nJava代码示例 结构：\nDriverManager -\u0026gt; Driver(是驱动程序对象的接口，指向具体数据库驱动程序对象)=DriverManager.getDriver(String URL) -\u0026gt; Connectinon(是连接对象接口，指向具体数据库连接对象)=DriverManager.getConnection(String URL) -\u0026gt; Statement(执行静态SQL语句接口)=Connection.CreateStatement() -\u0026gt; ResultSet(是指向结果集对象的接口)=Statement.excuteXXX()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138  import java.sql.*; /** * 使用JDBC连接MySQL */ public class DBTest { public static Connection getConnection() throws SQLException, java.lang.ClassNotFoundException { //第一步：加载MySQL的JDBC的驱动  Class.forName(\u0026#34;com.mysql.jdbc.Driver\u0026#34;); //设置MySQL连接字符串,要访问的MySQL数据库 ip,端口,用户名,密码  String url = \u0026#34;jdbc:mysql://localhost:3306/blog\u0026#34;; String username = \u0026#34;blog_user\u0026#34;; String password = \u0026#34;blog_pwd\u0026#34;; //第二步：创建与MySQL数据库的连接类的实例  Connection con = DriverManager.getConnection(url, username, password); return con; } public static void main(String args[]) { Connection con = null; try { //第三步：获取连接类实例con，用con创建Statement对象类实例 sql_statement  con = getConnection(); Statement sql_statement = con.createStatement(); /************ 对数据库进行相关操作 ************/ //如果同名数据库存在，删除  sql_statement.executeUpdate(\u0026#34;drop table if exists user;\u0026#34;); //执行了一个sql语句生成了一个名为user的表  sql_statement.executeUpdate(\u0026#34;create table user (id int not null auto_increment,\u0026#34; + \u0026#34; name varchar(20) not null default \u0026#39;name\u0026#39;, age int not null default 0, primary key (id) ); \u0026#34;); //向表中插入数据  System.out.println(\u0026#34;JDBC 插入操作:\u0026#34;); String sql = \u0026#34;insert into user(name,age) values(\u0026#39;liming\u0026#39;, 18)\u0026#34;; int num = sql_statement.executeUpdate(\u0026#34;insert into user(name,age) values(\u0026#39;liming\u0026#39;, 18)\u0026#34;); System.out.println(\u0026#34;execute sql : \u0026#34; + sql); System.out.println(num + \u0026#34; rows has changed!\u0026#34;); System.out.println(\u0026#34;\u0026#34;); //第四步：执行查询，用ResultSet类的对象，返回查询的结果  String query = \u0026#34;select * from user\u0026#34;; ResultSet result = sql_statement.executeQuery(query); /************ 对数据库进行相关操作 ************/ System.out.println(\u0026#34;JDBC 查询操作:\u0026#34;); System.out.println(\u0026#34;------------------------\u0026#34;); System.out.println(\u0026#34;userid\u0026#34; + \u0026#34; \u0026#34; + \u0026#34;name\u0026#34; + \u0026#34; \u0026#34; + \u0026#34;age \u0026#34;); System.out.println(\u0026#34;------------------------\u0026#34;); //对获得的查询结果进行处理，对Result类的对象进行操作  while (result.next()) { int userid = result.getInt(\u0026#34;id\u0026#34;); String name = result.getString(\u0026#34;name\u0026#34;); int age = result.getInt(\u0026#34;age\u0026#34;); //取得数据库中的数据  System.out.println(\u0026#34; \u0026#34; + userid + \u0026#34; \u0026#34; + name + \u0026#34; \u0026#34; + age); } //关闭 result,sql_statement  result.close(); sql_statement.close(); //使用PreparedStatement更新记录  sql = \u0026#34;update user set age=? where name=?;\u0026#34;; PreparedStatement pstmt = con.prepareStatement(sql); //设置绑定变量的值  pstmt.setInt(1, 15); pstmt.setString(2, \u0026#34;liming\u0026#34;); //执行操作  num = pstmt.executeUpdate(); System.out.println(\u0026#34;\u0026#34;); System.out.println(\u0026#34;JDBC 更新操作:\u0026#34;); System.out.println(\u0026#34;execute sql : \u0026#34; + sql); System.out.println(num + \u0026#34; rows has changed!\u0026#34;); //关闭PreparedStatement  pstmt.close(); //流式读取result，row-by-row  query = \u0026#34;select * from user\u0026#34;; PreparedStatement ps = (PreparedStatement) con.prepareStatement (query,ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY); ps.setFetchSize(Integer.MIN_VALUE); result = ps.executeQuery(); /************ 对数据库进行相关操作 ************/ System.out.println(\u0026#34;JDBC 查询操作:\u0026#34;); System.out.println(\u0026#34;------------------------\u0026#34;); System.out.println(\u0026#34;userid\u0026#34; + \u0026#34; \u0026#34; + \u0026#34;name\u0026#34; + \u0026#34; \u0026#34; + \u0026#34;age \u0026#34;); System.out.println(\u0026#34;------------------------\u0026#34;); //对获得的查询结果进行处理，对Result类的对象进行操作  while (result.next()) { int userid = result.getInt(\u0026#34;id\u0026#34;); String name = result.getString(\u0026#34;name\u0026#34;); int age = result.getInt(\u0026#34;age\u0026#34;); //取得数据库中的数据  System.out.println(\u0026#34; \u0026#34; + userid + \u0026#34; \u0026#34; + name + \u0026#34; \u0026#34; + age); } //关闭 result,ps  result.close(); ps.close(); con.close(); } catch(java.lang.ClassNotFoundException e) { //加载JDBC错误,所要用的驱动没有找到  System.err.print(\u0026#34;ClassNotFoundException\u0026#34;); //其他错误  System.err.println(e.getMessage()); } catch (SQLException ex) { //显示数据库连接错误或查询错误  System.err.println(\u0026#34;SQLException: \u0026#34; + ex.getMessage()); } } }   JDBC使用技巧  Statement与PreparedStatement的区别 connection, Statement与ResultSet关闭的意义 jdbc连接参数的使用 ResultSet游标的使用(setFetchSize)  Statement与PreparedStatement的区别  PreparedStatement在数据库端预编译，效率高，可以防止SQL注入。 对数据库执行一次性存取的时候，用Statement对象进行处理。 线上业务推荐使用PreparedStatement.  PreparedStatement背后的故事 PREPARE -\u0026gt; EXECUTE -\u0026gt; DEALLOCATE PREPARE\n1 2 3 4 5 6 7  PREPAREstmt1FROM\u0026#39;SELECT productCode, productName From products WHERE productCode = ?\u0026#39;;SET@pc=\u0026#39;S10_1678\u0026#39;;EXECUTEstmt1USING@pc;DEALLOCATEPREPAREstmt1;  connection, Statement与ResultSet关闭的意义  MySQL数据库端为connection与ResultSet维护内存状态，一直不关闭会占用服务端资源。 MySQL最大连接数受max_connections限制，不能无限创建连接，所以用完要及时关闭。 JDBC connection关闭后ResultSet, Statement会自动关闭。但是如果使用连接池将不会关闭，因此推荐主动关闭。  jdbc连接参数的使用  字符集设置：  url=\u0026ldquo;jdbc:mysql://localhost:3306/blog_dbo?userUnicode=true\u0026amp;characterEncoding=utf8\u0026rdquo;;\n 超时设置：  url=\u0026ldquo;jdbc:mysql://localhost:3306/blog_dbo?connectionTimeout=1000\u0026amp;socketTimeout=30000\u0026rdquo;;\nResultSet游标的使用  默认的ResultSet对象不可更新，仅有一个向前移动的指针。因此，只能迭代它一次，并且只能按从第一行到最后一行的顺序进行。可以生成可滚动和/或可更新的ResultSet对象。 setFetchSize()是设置ResultSet每次向数据库取的行数，防止数据返回量过大将内存爆掉。  Python连接MySQL  Python：脚本语言，无需编译、易开发 DBA使用Python的一般场景是编写自动化运维工具、报表、数据迁移 Python MySQL驱动：python-mysqldb  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  import MySQLdb # 建立和mysql数据库的连接 conn = MySQLdb.connect(host=\u0026#39;localhost\u0026#39;, port=3306,user=\u0026#39;bloguser\u0026#39;,passwd=\u0026#39;xxxx\u0026#39;) # 获取游标 curs = conn.cursor() # 选择数据库 conn.select_db(\u0026#39;blog\u0026#39;) # 执行SQL，创建一个表 curs.execute(\u0026#34;create table blog (id int, name varchar(200))\u0026#34;) # 插入一条记录 value = [1, \u0026#39;user1\u0026#39;] curs.execute(\u0026#34;insert into blog values(%s, %s)\u0026#34;, value) # 插入多条记录 values = [(2, \u0026#34;user2\u0026#34;), (3, \u0026#34;user3\u0026#34;)] curs.executemany(\u0026#34;insert into blog values(%s, %s)\u0026#34;, values) # 提交 conn.commit() # 关闭游标 curs.close() # 关闭连接 conn.close()   2.9-DAO框架的使用 DAO框架  在应用程序中使用数据访问对象(DAO),使我们可以将底层数据访问逻辑与业务逻辑分离开来。DAO框架构建了为每一个数据源提供CRUD(创建、读取、更新、删除)操作的类。 DAO模式是标准J2EE设计模式之一。开发人员用这种模式将底层数据访问操作与高层业务逻辑分离开。一个典型的DAO框架实现有以下组操作：  一个DAO工厂类 一个DAO接口(select/insert/delete/update) 一个实现了DAO接口的具体类 数据传输对象    DAO框架的特点  屏蔽底层数据访问细节，实现业务逻辑和数据访问逻辑的分离。 简化代码开发，提高代码复用率。 相较于原生的SQL可能会带来额外的 性能损耗(利用反射机制封装对象，SQL转换等)  MyBatis简介  MyBatis是一个主流的DAO框架，是apache的一个开源项目iBatis的升级版。 MyBatis支持普通SQL查询，存储过程和高级映射，消除就几乎所有JDBC代码和参数的手工设置以及结果集的检索。 接口丰富、使用简单 相较于hibernate更加轻量级，支持原生的sql语句。 支持查询缓存  MyBatis代码示例  环境搭建，数据源于映射配置文件的编写 单值、多值查询 增删改数据 连表查询  示例代码在sorence/DAO框架代码示例.rar\nMyBatis工作流程  加载配置并初始化，内部生成MappedStatement对象。 调用MyBatis提供的API(SqlSession.select/insert\u0026hellip;.)，将SQL ID与数据对象传递给处理层。 处理层解析MappedStatement对象，获取MySQL的连接，执行相应的SQL语句，接收返回结果。 MyBatis将接收到的返回结果封装成对应的数据对象返回。  MyBatis使用技巧  区分#{}和${}的不同应用场景： #{}会生成预编译SQL，会正确的处理数据的类型，而${}仅仅是文本替换。 注意MyBatis封装数据时的性能损耗： 只返回需要的行数和字段。 使用MyBatis自带的连接池功能： \u0026lt;dataSource type=\u0026quot;POOLED\u0026quot;\u0026gt;  ","pubDate":"2021-02-15","title":"网易云课堂MySQL \u003e chapter2"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_mysql_163%E8%AF%BE%E5%A0%82_%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter3/","plain":"MySQL事务与存储引擎 3.1-数据库事务 什么是事务  一系列有序的数据库操作：  要么全部成功 要么全部回退到操作前的状态 中间状态对其他连接不可见   事务的基本操作：    基本操作 说明     start transaction 开始事务   commit 提交(全部完成)   rollback 回滚(回到初始状态)      1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  -- 开启一个事务 starttransaction;-- 或者使用(非标准sql) begin;insertintotvalues(1,1,1);-- 事务结束，插入成功 commit;begin;insertintotvalues(2,1,1);insertintotvalues(3,1,1);insertintotvalues(4,1,1);-- 事务结束，没有插入数据 rollback;begin;insertintotvalues(1,1,1);savepointa1;insertintotvalues(2,1,1);-- 回滚到指定的保存点 rollbacktoa1;commit;  自动提交  autocommit可以在session级别设置 每个DML操作都自动提交 DDL永远都是自动提交，无法通过rollback回滚  事务的四个基本属性(ACID)  原子性(Atomicity) 一致性(Consistency) 隔离性(Isolation) 持久性(Durability)  事务的原子性  包含在事务中的操作要么全部被执行，要么都不执行 中途数据库或应用发生异常，未提交的事务都应该被回滚  事务的一致性  数据的正确性，合理性，完整性 数据一致性应该符合应用需要规则：  余额不能是负数 交易对象必须先有账号 用户账号不能重复   事务的结果需要满足数据的一致性约束  事物的持久性  提交完成的事务对数据库的影响必须是永久性的  数据库异常不会丢失事务更新 通常认为成功写入磁盘的数据即为持久化成功    事务的持久化的实现  数据文件持久化  随机同步刷新(慢)   事务日志持久化与实例恢复  顺序同步刷新(快) -\u0026gt; 事务日志 随机异步刷新 -\u0026gt; 磁盘 事务日志 -\u0026gt; 磁盘(实例恢复)    事务的隔离性  数据库事务在提交完成前，中间的任何数据变化对其他的事务都是不可见的。  数据库隔离现象    隔离现象 描述     脏读(Dirty Read) 事务B读到事务A尚未提交的数据变更   不可重复读(NonRepeatable Read) 事务B读取前后两次读取一条记录之间该记录被事务A修改并提交，于是事务B读到了不一样的结果   幻读(Phantom Read) 事务B按条件匹配到了若干行记录并修改。但是由于修改过程中事务A新插入了符合条件记录，导致B更新完成后发现仍有符合条件却未被更新的记录。    数据库隔离等级    隔离等级 脏读 不可重复读 幻读     未提交读 可能 可能 可能   已提交读 不可能 可能 可能   可重复读 不可能 不可能 可能   可串行化读 不可能 不可能 不可能    MySQL的事务隔离级别  InnoDB默认标记为可重复读 InnoDB并不是标准定义上的课重复读 InnoDB默认在可重复读的基础上避免幻读  MySQL事务隔离级别设置  可在global/session/下个事务，级别分别进行设置 建议使用Read committed(同Oracle) 或者建议使用默认的Repeatable read  1 2  settx_isolation=\u0026#39;\u0026#39;-- 设置隔离级别   事务与并发写  某个正在更新的记录再提交或回滚前不能被其他事务同时更新  事务回滚的实现  回滚段(rollback segment)与数据前像  3.2-存储引擎概述 MySQL程序层次架构 MySQL存储引擎  有多种可选方案，可插拔，可修改存储引擎 基于表选择使用何种存储引擎  主要存储引擎    存储引擎 常用度 支持事务     InnoDB 主要，推荐 是   MyISAM 古老，偶尔有用，系统表 否   MEMORY 偶尔临时表有用，纯内存 否   BLACKHOLE 不用来存放数据，个别特殊用处 否   TokuDB 新颖，个别特殊场景有奇效 是   Cluster 新颖，分布式，内存，线上不要用 是    InnoDB存储引擎  索引组织表 支持事务 支持行级锁 数据块缓存 日志持久化 稳定可靠，性能好，线上尽量使用InnoDB  MyISAM存储引擎  堆表 不支持事务 只维护索引缓存池，表数据缓存交给操作系统 锁粒度较大 数据文件可以直接拷贝，偶尔可能会用上 不建议线上业务数据使用  MWMORY存储引擎  数据全内存存放，无法持久化 性能较高 不支持事务 适合偶尔作为临时表使用 create temporary table tmp (id int) engine = memory ;  BLACKHOLE存储引擎  数据不作任何存储 利用MySQL Replicate，充当日志服务器 在MySQL Replicate环境中充当代理主  TokuDB  分形树存储结构 支持事务 行锁 压缩效率较高 适合大批量insert的场景  MySQL Cluster  多主分布式集群 数据节点间冗余，高可用 支持事务 设计上易于扩展 面向未来，线上慎用  改变表的存储引擎 alter table m ENGINE=innodb;\n3.3-InnoDB存储引擎 InnoDB存储引擎体系架构 InnoDB相关的磁盘文件    文件 名称 数量 位置     系统表空间 ibdata1 一个实例一个 innodb_data_home_dir   日志文件 ib_logfile0/1 一个实例两个(可配置) innodb_log_group_home_dir   表定义文件 表名.frm 每张表一个 Schema目录下   表数据文件 表名.ibd 如果innodb_file_per_table = 1, 则每张表一个 Schema目录下    InnoDB系统表空间文件  ibdata1里存放了什么:  回滚段 所有InnoDB表元数据信息 Double Write, Insert buffer dump等等\u0026hellip;.   自动扩展机制  InnoDB与磁盘文件有关的参数    参数 样例值 备注     innodb_data_home_dir /data/mysql/node_1 数据主目录   innodb_log_group_home_dir /data/mysql/node_1 一般同上   innodb_data_file_path ibdata1:512M:autoextned 请开启autoextned   innodb_autoextend_increment 128 MB,勿太大或太小   innodb_file_per_table 1 强烈建议开启   innodb_log_file_size 100MB 性能相关   innodb_log_files_in_group 2 性能相关    InnoDB数据文件存储结构  索引组织表(聚簇表) 根据表逻辑主键排序 数据节点每页16K 根据主键寻址速度很快 主键值递增的insert插入效率较好 主键值随机insert插入效率差 因此，InnoDB表必须指定主键，建议使用自增数字  InnoDB数据块缓存池  数据的读写需要经过缓存 数据以整页(16K)为单位读取到缓存中 缓存中的数据以LRU策略换出 IO效率高，性能好  InnoDB Buffer Pool相关参数    参数 样例值 备注     innodb_buffer_pool_size 10G 根据总物理内存设置    InnoDB数据持久化与事务日志  事务日志实时持久化 内存变化数据(脏数据)增量异步刷出到磁盘 实例故障靠重放日志恢复 性能好，可靠，恢复快  InnoDB日志持久化相关参数    参数 样例值 备注     innodb_flush_log_at_trx_commit 1 可选：0：每隔1s写入并持久化一次日志。1：每次commit都写入并持久化日志。2：每次提交日志写到内存，每1s持久化一次    InnoDB行级锁  写不阻塞读 不同行间的写互相不阻塞 并发性能好  InnoDB与事务ACID  事务ACID特性完整支持  回滚段失败回滚 支持主外键约束 事务版本+回滚段=MVCC 事务日志持久化   默认可重复读隔离级别，可以调整  3.4-InnoDB事务锁 什么是计算机程序锁  计算机程序锁  控制对共享资源进行并发访问 保护数据的完整性和一致性    数据库中的锁  分为两个大类      lock latch/mutex     对象 事务 线程   保护 数据库逻辑内容 内存数据结构   持续时间 事务过程中 临界资源争抢     我们主要关心的是事务锁  数据库事务并发  对同一行记录的修改必须串行化  事务锁粒度  行锁  InnoDB, Oracle   页锁  SQL Server   表锁  MyISAM, Memory   锁升级  InnoDB存储引擎中的锁模式与粒度  四种基本锁模式  共享锁(S) - 读锁 - 行锁 排他锁(X) - 写锁 - 行锁 意向共享锁(IS) - 表级 意向排他锁(IX) - 表级   意向锁  意向锁总是自动先加，并且意向锁自动加自动释放 意向锁提示数据库这个session将要在接下来施加何种锁 意向锁和X/S锁级别不同，除了阻塞全表级别的X/S锁外其他任何锁    InnoDB锁模式互斥 数据库加锁操作  一般的select语句不加任何锁，也不会被任何事物锁阻塞  读的隔离性由MVCC确保   S锁  手动：select * from tb_test lock in share mode; 自动：insert前   X锁  手动：select * from tb_test lock for update; 自动：update，delete前    InnoDB行锁的实现  通过索引项加锁实现  只有条件走索引才能实现行级锁 索引上有重复值，可能锁住多个记录 查询有多个索引可以走，可以对不同索引加锁 是否对索引加锁实际上取决于MySQL执行计划   自增主键做条件更新，性能最好  没有索引的话会对整张表加锁。\nInnoDB的gap lock  什么是幻读 gap lock消灭幻读  InnoDB消灭幻读仅仅为了确保statement模式replicate的主从一致性   小心gap lock 自增主键做条件更新，性能最好  死锁   什么是死锁\n A、B两个事务，A先更新t1，同时B更新t2，A再更新t2，B再更新t1就发生了死锁。    死锁数据库自动解决\n 数据库挑选冲突事务中回滚代价较小的事务回滚    死锁预防\n 单表死锁可以根据批量更新里的更新条件排序 可能冲突的跨表事务尽量避免并发 尽量缩短事务长度    业务逻辑加锁   业务流程中的悲观锁\n 任何的并发修改都有可能造成我们的业务逻辑最终的错误，在事务流程中一开始就加锁，最后释放    如何缩短锁的时间\n  ","pubDate":"2021-02-15","title":"网易云课堂MySQL \u003e chapter3"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_mysql_163%E8%AF%BE%E5%A0%82_%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter4/","plain":"MySQL应用优化 4.1-MySQL索引优化与设计 什么是索引  索引的意义 —— 快速定位要查找的数据  数据库索引查找  全表扫描 VS 索引查找  如何根据首字母找到所在行  二分查找 B+tree  InnoDB表聚簇索引 索引中只放着排序字段和ID\n创建索引  单列索引  1  createindexidx_test1ontb_student(name);   联合索引  1  createindexidx_test2ontb_student(name,age);   索引中先根据name排序，name相同的情况下，根据age排序  索引维护  索引维护由数据库自动完成 插入/修改/删除每一个索引行都会变成一个内部封装的事务 索引越多，事务越长，代价越高 索引越多对表的插入和索引字段修改就越慢 控制表上索引的数量，切忌胡乱添加无用索引  如何使用索引  依据WHERE查询条件建立索引  1 2 3 4  selecta,bfromtab_awherec=?;idx_c(c)selecta,bfromtab_awherec=?andd=?;idx_cd(c,d)   排序order by, group by, distinct字段添加索引  1 2 3 4 5 6 7 8 9  select*fromtb_aorderbya;selecta,count(*)fromtb_agroupbya;idx_a(a)select*fromtb_aorderbya,b;idx_a_b(a,b)select*fromtb_aorderwherec=?bya;idx_c_a(c,a)  索引与字段选择性   某个字段其值的重复程度\n  选择性很差的字段通常不适合创建单列索引\n 男女比例相仿的列表中性别不适合创建单列索引 如果男女比例极不平衡，要查询的又是少数方(理工院校查女生)可以考虑使用索引    联合索引中选择性好的字段应该排在前面\n  1 2  select*fromtab_awheregender=?andname=?;idx_a1(name,gender)  联合索引与前缀查询  联合索引能为前缀单列，复列查询提供帮助  1 2 3 4  idx_smp(a,b,c)wherea=?;wherea=?andb=?;wherea=?andc=?;(部分ok)   合理创建联合索引，避免冗余 (a) , (a, b) , (a, b, c) X (a, b, c) ok  长字段上的索引  在非常长的字段上建立索引影响性能 InnoDB索引单字段(utf8)只能取前767 bytes 对长字段处理的方法  Email类，建立前缀索引  1 2  Mail_addrvarchar(2048)idx_mailadd(Mail_addr(30))ok   住址类，拆分字段  1 2 3  Home_addressvarchar(2048)idx_mailadd(Mail_addr(30))?-- 很可能前半段都是相同的省市区街道名称 Provincevarchar(1024),Cityvarchar(1024),Districtvarchar(1024),Local_addressvarchar(1024)...-- 建立联合索引或单列索引     索引覆盖扫  最核心SQL考虑索引覆盖 1 2  selectNamefromtb_userwhereUserID=?Keyidx_uid_name(UserID,Name)   不需要回表获取name字段，IO最小，效率最高  无法使用索引的情况  索引列进行数学运算或函数运算 1 2 3 4  whereid+1=10;Xwhereid=(10-1);okyear(col)\u0026lt;2007;Xcol\u0026lt;\u0026#39;2007-01-01\u0026#39;;ok   未含符合索引的前缀字段 1 2 3  Idx_abc(a,b,c):whereb=?andc=?;X(b,c)ok   前缀通配,'_\u0026lsquo;和\u0026rsquo;%\u0026lsquo;通配符 1 2  Like\u0026#39;%xxx%\u0026#39;;XLike\u0026#39;xxx%\u0026#39;;ok   where 条件使用NOT, \u0026lt;\u0026gt;, != 字段类型匹配  并不绝对，但是无法预测地会造成问题，不要使用  1 2 3  aint(11),idx_a(a)wherea=\u0026#39;123\u0026#39;;Xwherea=123;ok    利用索引排序 idx_a_b (a, b)\n 能够使用索引帮助排序的查询：  1 2 3 4 5  orderbyaa=3orderbyborderbya,borderbyadesc,bdesca\u0026gt;5orderbya   不能使用索引帮助排序的查询：  1 2 3 4  orderbyba\u0026gt;5orderbybain(1,3)orderbyborderbyaasc,bdesc  如何确定一个查询走没走索引，走了哪个索引  explain是确定一个查询如何走索引最简便有效的方法 explain select * from tb_test ; 关注的项目  type:查询access的方式 key:本次查询最终选择使用哪个索引，NULL为未使用索引 key_len:选择的索引使用的前缀长度或者整个长度 rows:可以理解为查询逻辑读，需要扫描过的记录行数 extra:额外信息，主要指的fetch data的具体方式    4.2-MySQL数据库设计 什么是Schema设计  设计数据库的表，索引，以及表和表的关系  在数据模型的基础上将关系模型转化为数据库表 满足业务模型需要基础上根据数据库和应用特点优化表结构    为什么Schema需要设计  Schema关系到应用程序功能与性能  满足业务功能需要 同性能密切相关 数据库扩展性 满足周边需求(统计，迁移等)   关系型数据库修改Schema经常是高危操作  Schema设计要体现一定的前瞻性    完全由开发者主导的Schema设计  着眼于实现当前功能 完全基于功能的设计可能存在一些隐患  不合理的表结构或索引设计造成性能问题 没有合理评估到数据量的增长造成空间紧张而且难以维护 需求频繁修改造成表结构经常变更 业务重大调整导致数据经常需要重构订正    基于性能的表设计  根据查询需要设计好索引 根据核心查询需求，适当调整表结构 基于一些特殊业务需求，调整实现方式  索引  正确使用索引 更新尽可能使用主键或唯一索引 主键尽可能使用自增ID字段 核心查询覆盖扫描  用户登录需要根据用户名返回密码用于验证create index idx_uname_passwd on tb_user (username, password); 建立联合索引避免回表取数据    反范式，冗余必要字段  针对核心SQL保留查询结果所必须的冗余字段，避免频繁join  例：消息表中冗余了每次读消息必须返回的nickname字段，避免每次读消息都变成join操作。代价是用户修改nickname成本变高。    拆分大字段  拆分大字段到单独表中，避免范围扫描代价大  例：博文表拆分两份，标题表只保留标题和内容缩略部分，用于快速批量返回标题列表，正文表保存大段博文内容，用于点开文章单个读取    避免过多字段或过长行  根据SQL必要返回设计字段，有必要就拆表，避免过多字段 一次没有必要获取那么多列数据 行过长导致表数据页记录变少，范围扫描性能降低 更新数据也代价增加 16K也最少放2行，可能出现行迁移  分页查询  避免limit + offset过大 应该使用自增主键ID模拟分页  第一页，直接查 得到第一页的max(id)=123(一般是最后一条记录) 第二页，带上id\u0026gt;123查询：where id\u0026gt;123 limit 100 这样每次只需要扫描100条数据   要求业务上禁止查询XX页之后的数据  热点读数据特殊处理  根据数据获取的频率或数量不同对热点数据做特殊处理  例1：论坛系统中置顶帖、公告贴，可以单独拆分存储，由于每次访问都要全部读出来，单独放在一起，避免每次都到普通表中随机找出来    热点写数据特殊处理  根据数据获取的频率或数量不同对热点数据做特殊处理  例2：微博系统中对于大量关注的热点账号消息从\u0026quot;推\u0026quot;改为\u0026quot;拉\u0026quot;，避免过量insert操作。    准实时统计  对不需要精确结果的计数等统计要求，建立定期更新结果表  例：首页要求展示动态成交总金额，维护一个计数表，每分钟根据原表注册时间获取增量sum值更新计数表，避免每次用户刷新都要扫描交易全记录表    实时统计改进1 - 触发器实时统计  对需要精确统计的计数利用数据库触发器维护计数表  例：用户量冲亿活动要求实时统计，用户表上加触发器，每次有新用户插入就同时在计数表+1    实时统计改进2 - 缓存实时统计  对需要精确统计的计数利用前端缓存实时维护计数  例：用户量冲亿活动要求实时统计，注册数量在缓存中实时维护，每注册一个就+1，完全避免数据库读写操作。缓存万一故障失效，可从数据库整体count重新获取。    实时统计改进2 - 最大自增ID获取总数  很多逻辑可以利用自增ID主键最大值直接作为总数  例：用户量冲亿活动要求实时统计，用户表加上自增ID作为主键，只要取当时max(ID)就可以得到用户总数    课拓展性设计  可拓展性  硬件资源增长有极限的情况下处理尽可能久的线上业务   数据分级，冷数据归档与淘汰  可以不断释放空间供新数据使用   为数据分布式做准备  分库分表 水平拆分 牺牲一定的关系模型支持    分区表与数据淘汰  range分区 适合数据需要定期过期的大表 单个分区扫描迁移数据到历史库避免全表扫描IO开销 删除单个分区非常高效  分区表与垂直分区  list分区 适合将来可能要基于地区，类目等方式垂直拆分数据的方式 清理节点上不要的数据非常高效  分区表与水平分区  hash分区 适合将来需要做水平拆分的表 清理节点上不要的数据非常高效  MySQL分区表的局限  主键或唯一键必须包含在分区字段内 分区字段必须是整数类型，或者加上返回整数的函数  满足周边需求  为周边需求额外增加表设计  为后台统计任务增加特殊索引 为数据迁移或统计需求增加时间戳    统计和后台需求  统计运行SQL往往和线上有很大不同  利用MySQL——主多从，主从可以建不同索引的特性将统计分流到特定从库 包括一些特殊用户批量查询等，所有对线上有IO压力的查询都要读写分离    自动更新时间戳  统计需求经常要求从线上读走增量数据 表的第一个timestamp类型字段再写入时如果不填值，会自动写入系统时间戳 表的第一个timestamp类型字段每次记录发生更新后都会自动更新 在update_time字段上建索引用于定时导出增量数据  Schema设计与前瞻性  基于历史经验教训，预防和解决同类问题 把折腾DBA够呛的所有Schema改造的原因记录并分析总结 例： 业务为例用户信息加密做了大改造  数据库结果大量改动，增加了加密字段，验证策略表，所有表重新订正数据等等 是否所有用到用户信息管理的应用都要去上线就用密文？   程序bug误删数据，线上风险大  改造业务流程，不再删除数据，加入is_deleted标记位，经常给各种表加 今后的类似表是否一上线就都用标记位的方式，并加上修改原因字段？   支付类应用后期做了风控改造  对线上订单大表改造，加了限额，终端类型等字段 遇到支付类应用，是否一上线就提示业务是否需要考虑风控并留好相关字段？    4.3-MySQL容量评估 性能容量评估  分析线上业务场景 评估数据库服务器所需性能指标 预估可能成为瓶颈的服务器资源 帮助数据库性能调优  数据库服务器硬件性能指标  磁盘IO性能 内存容量 CPU 网络吞吐量 磁盘容量  数据库业务特点关键词  OLTP/OLAP类型 并发请求 读写比例 数据量 冷热数据比 数据分级存储  OLTP/OLAP  T = Transaction 面向广大用户，高并发，较短事务操作 互联网应用绝大部分属于OLTP OLTP看重服务器CPU，内存，写事务较多或内存不够则依赖磁盘IO A = Analytical 通常面向内部人员，大规模复查询 OLAP看重磁盘扫描的IO能力，部分依赖内存排序  并发请求 - 衡量线上业务繁忙程度  业务高峰时数据库的每秒并发访问量是多少 通过应用服务器数量，连接池配置判断 通过产品估算初上线用户规模和用户增长速度判断 通过实际业务业务类型判断 并发量相关资源：CPU  读写比例 - 描述应用程序如何使用数据库  线上业务select只读与update/delete/insert写操作比例 delete/update通常都是先读再写 insert需要区分数据写入时持续insert还是大量导入数据 根据业务实际场景分析 多读场景相关资源：内存 多写场景相关资源：磁盘IO  数据量 - 总量  数据库服务器存储设备可扩容能力的上限 根据估算的业务量，写入模式，分析数据增长量 预估一个硬件升级周期内数据库可存放数据的总量，上线时要留好余量 数据总量相关资源：磁盘容量  冷数据与热数据 - 有用数据的实时集合  热数据，线上最新一定周期内将被反复访问的数据 冷数据，线上保存着的，最近不会被在线用户用到的数据 估算活跃用户量，数据增长量等预估热数据量 内存大小尽可能足够存放线上实时热数据 热数据相关资源：内存  线上数据分层存储 - 缓解线上磁盘空间压力  最新热数据确保放在内存中 还可能访问到的较早数据存放在线上库磁盘中 更早的不会常规访问的数据定期迁移至历史库中 区分哪些数据时效性强可以迁移  服务器资源选型 - 将可选方案列出来    资源指标 可选方案     磁盘IO性能 单盘 -\u0026gt; 盘阵; SATA -\u0026gt; SAS; HDD -\u0026gt; SSD   内存容量 较小内存 -\u0026gt; 较大内存   CPU 普通 -\u0026gt; 多核，超线程   网络吞吐量 千兆 -\u0026gt; 万兆; 单网卡 -\u0026gt; 多路;   磁盘容量 单盘 -\u0026gt; 盘阵; 单盘 -\u0026gt; LVM    案例一，网易云音乐曲库数据库服务器评估  用于存放线上数千万歌曲信息 确定属于OLTP线上类型数据库 并发请求量  50台应用服务器，每台最大连接数100 可能峰值5000qps，并发请求量较大   CPU需求高 读写比例  访问模式以用户列出歌单和播放歌曲时查询歌曲信息为主，用户只有只读查询 写数据发生在录入新歌或修改歌曲信息时后台操作，写比例小，且为批量导入 读写比100:1   数据总量  估算每首歌信息8K，总计5000万，总量400G 数据总量增长相对缓慢   冷热数据  5000万歌曲中大约40%可能被访问，10%属于热点歌曲 热数据大约\u0026lt;=40G   数据分级存储需求  由于没有用户产生的数据，歌曲信息无法分级存储   内存需求一般，\u0026gt;=40G 磁盘IO能力需求一般 网络流量要求，8k*2500/1024 ≈ 20MB/S，一般     资源指标 可选方案     磁盘IO性能 两块SAS做RAID1   内存容量 96G内存   CPU 2c8core超线程 相当于32核   网络吞吐量 千兆双网卡bunding   磁盘容量 900G    案例二，网易理财销售数据库服务器评估  用于存放理财用户线上订单 确定属于OLTP线上类型数据库 业务场景有明显特征  特定高息产品秒杀销售时间窗有大量并发订单写入 平时只有少量订单查询和请求，和较低的常规产品购买请求   评估应以满足最关键的业务高峰为基准 并发请求量  秒杀期间持续时间短，但是并发量预估30台应用服务器约2000tps   读写比例  高峰时写订单是主要开销操作   CPU要求高 磁盘IO要求很高 数据总量  根据业务分析，订单属于写入瞬时量大，总量较小，单笔金额较高 总量预估一年成交百万级别，增长较稳定 判断数据存储需求小于200G   冷热数据  峰值写入为主，内存要求存放热点期间产生的脏数据即可   数据分级存储需求  用户订单业务约定页面展示最近半年订单，半年前的需要到历史查询页面专门查询 因此可以做分级存储，迁移所有半年前的订单至历史库   内存需求一般， \u0026gt;= 30G 磁盘空间需求一般， \u0026gt;=200G 磁盘IO能力需求很高 网络要求较高  并发流量较高 响应速度要求高       资源指标 可选方案     磁盘IO性能 两块SSD做RAID1   内存容量 64G内存   CPU 2c8core超线程 相当于32核   网络吞吐量 万兆双网卡bunding   磁盘容量 600G    4.4-MySQL性能测试 为什么需要性能测试  对线上产品缺乏心理预估 重现线上异常 规划未来的业务增长 测试不同硬件软件配置  性能测试的分类  设备层的测试 业务层的测试 数据库层的测试  设备层的测试  关注的指标  服务器、磁盘性能 磁盘坏块率 服务器寿命    业务层测试  针对业务进行测试  数据库层测试  什么情况下要做MySQL的测试  测试不同的MySQL分支版本 测试不同的MySQL版本 测试不同的MySQL参数搭配    MySQL测试分类  CPU Bound IO Bound  写入测试 更新测试 纯读测试 混合模式\n常用的测试工具  开源的MySQL性能测试工具  sysbench tpcc-mysql mysqlslap   针对业务编写性能测试工具  blogbench    性能测试衡量指标  服务吞吐量(TPS, QPS) 服务响应时间 服务并发性  Sysbench  业界较为出名的性能测试工具 可以测试磁盘、CPU、数据库 支持多种数据库：Oracle, DB2, MySQL 需要自己下载编译安装 建议版本：sysbench0.5  编译安装Sysbench  下载sysbench  git clone https://github.com/akopytov/sysbench.git   编译\u0026amp;安装  ./autogen.sh ./configure make \u0026amp;\u0026amp; make install    Sysbench流程  常见的做法  初始化数据 -\u0026gt; 运行测试 -\u0026gt; 清理数据\nPrepare语法 1  sysbench --test=parallel_prepare.lua --oltp_tables_count=1 --rand-init=on --oltp-table-size=500000000 --mysql-host=127.0.0.1 --mysql-port=3306 --mysql-user=sys --mysql-password=netease --mysql-db=sbtest --max-requests=0 prepare      参数 含义     \u0026ndash;test=parallel_prepare.lua 运行导数据的脚本   \u0026ndash;oltp_tables_count 测试需要几张表   \u0026ndash;oltp-table-size 每张表的大小   \u0026ndash;mysql-host MySQL Host   \u0026ndash;mysql-port MySQL Port   \u0026ndash;mysql-db MySQL DB   \u0026ndash;mysql-user MySQL User   \u0026ndash;mysql-password MySQL Password   \u0026ndash;rand-init 是否随机初始化数据   \u0026ndash;max-requests 执行多少个请求之后停止   prepare 执行导数据    Sysbench表结构 1 2 3 4 5 6 7 8  createtable\u0026#39;sbtest1\u0026#39;(\u0026#39;id\u0026#39;int(10)unsignednotnullAUTO_INCREMENT,\u0026#39;k\u0026#39;int(10)unsignednotnullDEFAULT\u0026#39;0\u0026#39;,\u0026#39;c\u0026#39;char(120)notnullDEFAULT\u0026#39;\u0026#39;,\u0026#39;pad\u0026#39;char(60)notnullDEFAULT\u0026#39;\u0026#39;,PRIMARYKEY(\u0026#39;id\u0026#39;),KEY\u0026#39;k_1\u0026#39;(\u0026#39;k\u0026#39;))ENGINE=InnoDBAUTO_INCREMENT=3000000001DEFAULTCHARSET=utf8MAX_ROWS=1000000  Run语法 1  sysbench --test=oltp.lua --oltp_tables_count=1 --num-threads=100 --oltp-table-size=500000000 --oltp-read-only=off --report-interval=10 --rand-type=uniform --mysql-host=127.0.0.1 --mysql-port=3306 --mysql-user=sys --mysql-password=netease --mysql-db=sbtest --max-time=1000 --max-requests=0 run      参数 含义     \u0026ndash;test=oltp.lua 需要运行的lua脚本   \u0026ndash;oltp_tables_count 测试需要几张表   \u0026ndash;oltp-table-size 每张表的大小   \u0026ndash;num-threads 测试并发线程数   \u0026ndash;oltp-read-only 是否为只读测试   \u0026ndash;report-interval 结果输出间隔   \u0026ndash;rand-type 数据分布模式，热点数据或者随机数据   \u0026ndash;max-time 最大运行时间   \u0026ndash;max-requests 执行多少个请求之后停止   prepare 开始测试    特殊情况  写入测试  写入数据进行测试 -\u0026gt; 清理数据\ncleanup  手动drop掉表和database 使用sysbench提供的cleanup命令  1  sysbench --test=parallel_prepare.lua --oltp_tables_count=1 --rand-init=on --oltp-table-size=500000000 --mysql-host=127.0.0.1 --mysql-port=3306 --mysql-user=sys --mysql-password=netease --mysql-db=sbtest --max-requests=0 cleanup   Tpcc-mysql   TPC-C是专门针对联机交易处理系统(OLTP系统)的规范\n  Tpcc-mysql由percona根据规范实现\n  下载Tpcc-mysql\n bzr branch lp:~percona-dev/perconatools/tpcc-mysql    编译安装\n  使用Tpcc-mysql的步骤 创建表结构和索引 -\u0026gt; 导数据 -\u0026gt; 运行测试 -\u0026gt; 数据清理\n创建表结构  create_table.sql add_fkey_idx.sql  Tpcc-load tpcc_load [server] [DB] [user] [pass] [warehouse]\n   函数 含义     server 数据库IP   DB DB名称   user 用户名   pass 密码   warehouse 仓库数量    Tpcc-start 1  tpcc_start -h server_host -P port -d database_name -u mysql_user -p mysql_password -w warehouse -c connections -r warmup_time -I running_time -i report-interval -f report-file      函数 含义     warehouse 仓库数量   connections 并发线程数   warmup_time 预热时间   running_time 运行时间   report_interval 输出时间间隔   report_file 输出文件    总结  IO Bound测试数据量要远大于内存、CPU Bound测试数据量要小于内存 测试时间建议大于60分钟，减小误差 Sysbench更倾向于测试MySQL性能、TPCC更接近于业务 运行测试程序需要同时监控机器负载，MySQL各项监控指标  ","pubDate":"2021-02-15","title":"网易云课堂MySQL \u003e chapter4"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_mysql_163%E8%AF%BE%E5%A0%82_%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter5/","plain":"MySQL运维实践 5.1-MySQL日志系统 什么是日志  日志(log)是一种顺序记录事件流水的文件 记录计算机程序运行过程中发生了什么 多种多样的用途  帮助分析程序问题 分析服务请求的特征、流量等 判断工作是否成功执行 等等……    MySQL日志的分类  服务器日志  记录进程启动运行过程中的特殊事件，帮助分析MySQL服务遇到的问题 根据需求抓取特定的SQL语句，追踪性能可能存在的问题的业务SQL   事务日志  记录应用程序对数据的所有更改 可用于数据恢复 可用于实例间数据同步       分类 日志名称     服务器日志 服务错误日志   服务器日志 慢查询日志   服务器日志 综合查询日志   事务日志 存储引擎事务日志   事务日志 二进制日志    服务错误日志  记录实例启动运行过程中重要消息 配置参数  log_error = /data/mysql_data/node-1/mysql.log   内容并非全是错误消息 如果mysqld进程无法正常启动首先查看错误日志  慢查询日志  记录执行时间超过一定阈值的SQL语句 配置参数  1 2 3  slow_query_log=1slow_query_log_file=/data/mysql_data/node-1/mysql-slow.loglong_query_time=5   用于分析系统中可能存在性能问题的SQL  综合查询日志  如果开启将会记录系统中所有SQL语句 配置参数  1 2  general_log=1general_log_file=/data/mysql_data/node-1/mysql-slow.log   偶尔用于帮助分析系统问题，对性能有影响  查询日志的输出与文件切换  日志输出参数  log_output={file|table|none}\n 如果日志文件过大，可以定期截断并切换新文件  flush log;\n存储引擎事务日志  部分存储引擎拥有重做日志(redo log) 如InnoDB, TokuDB等WAL(Write Ahead Log)机制存储引擎 日志随着事务commit优先持久化，确保异常恢复不丢数据 日志顺序写性能较好  InnoDB事务日志重用机制  InnoDB事务日志采用两组文件交替重用  二进制日志binlog  binlog (binary log) 记录数据引起数据变化的SQL语句或数据逻辑变化的内容 MySQL服务层记录，无关存储引擎 binlog的主要作用：  基于备份恢复数据 数据库主从同步 挖掘分析SQL语句    开启binlog  主要参数  log_bin = c:/tmp/mylog/mysql-bin\rsql_log_bin = 1\rsync_binlog = 1\r 查看binlog  show binary logs;\nbinlog管理  主要参数  max_binlog_size = 100MB\rexpire_logs_days = 7\r  binlog始终生成新文件，不会重用\n  手工清理binlog\n  purge binary logs to 'mysql-bin.000009';\rpurge binary logs before '2016-4-2 21:00:40'\r查看binlog内容  日志  show binlog events in 'mysql-bin.000011';\rshow binlog events in 'mysql-bin.000011' from 60 limit 3;\r mysqlbinlog工具  mysqlbinlog c:/tmp/mylog/mysql-bin.000001\r--start-datetime | --stop-datetime\r--start-position | --stop-position\rbinlog格式  主要参数  binlog_format = {ROW|STATEMENT|MIXED}\n 查看row模式的binlog内容  mysqlbinlog --base64-output=decode-rows -v c:/tmp/mylpg/mysql-bin.000001\n5.2-MySQL数据备份 基本指数 - 备份用途  数据备灾  应对硬件故障数据丢失 应对人为或程序bug导致数据删除   制作镜像库以供服务  需要将数据迁移、统计分析等用处 需要为线上数据建立一个镜像    基本知识 - 备份内容  数据  数据文件或文本格式数据   操作日志(binlog)  数据库变更日志    基本知识 - 冷备份与热备份  冷备份  关闭数据库服务，完整拷贝数据文件   热备份  在不影响数据库读写服务的情况下备份数据库    基本知识 - 物理备份与逻辑备份  物理备份  以数据页的形式拷贝数据   逻辑备份  导出为裸数据或者SQL(insert)语句    基本知识 - 本地备份与远程备份  本地备份  在数据库服务器本地进行备份   远程备份  远程连接数据库进行备份    基本知识 - 全量备份与增量备份  全量备份  备份完整的数据库   增量备份  只备份上一次备份以来发生修改的数据    基本知识 - 备份周期 考虑因素：\n 数据库大小(决定备份时间) 恢复速度要求(快速or慢速) 备份方式(全量or增量)  常用工具及用法  mysqldump - 逻辑备份，热备 xtrabackup - 物理备份， 热备 Lvm/zfs snapshot - 物理备份 mydumper - 逻辑备份，热备 cp - 物理备份，冷备  常用工具及用法 - mysqldump MySQL官方自带的命令行工具\n主要示例：\n 演示使用mysqldump备份表、库、实例  1 2 3 4 5 6 7 8  # 备份所有数据库 mysqldump -uroot -p123456 --socket=/var/run/mysqld/mysqld.sock --all-databases \u0026gt; /dbbackup/all_db.sql # 备份指定的数据库 mysqldump -uroot -p123456 --socket=/var/run/mysqld/mysqld.sock --databases db2 \u0026gt; /dbbackup/db2.sql # 备份单个表 mysqldump -uroot -p123456 --socket=/var/run/mysqld/mysqld.sock db2 t1 \u0026gt;/dbbackup/db2_t1.sql # 还原表 mysql \u0026gt; source /dbbackup/db2_t1.sql    演示使用mysqldump制作一致性备份  1  mysqldump --single-transaction -uroot -p123456 --all-databases \u0026gt; /dbbackup/add_db_2.sql    演示使用mysqldump远程备份一个数据库  1  mysqldump -utest -ptest -h192.168.0.68 -P3306 --all-databases \u0026gt; /dbbackup/remote_bakall.sql    演示使用mysqldump导出数据为csv格式  1  mysqldump -uroot -p123456 --single-transaction --fields-terminated-by=, db1 -T /tmp   常用工具及用法 - xtrabackup 特点：\n 开源，在线备份InnoDB表 支持限速备份，避免对业务造成影响 支持流备 支持增量备份 支持备份文件压缩与加密 支持并行备份与恢复，速度快  xtrabackup备份原理  基于InnoDB的crash-recovery功能 备份期间允许用户读写，写请求产生redo日志 从磁盘上拷贝数据文件 从InnoDB redo log file实时拷贝走备份期间产生的所有redo日志 恢复的时候 数据文件 + redo日志 = 一致性数据  实用脚本innobackupex  开源Perl脚本，封装调用xtrabackup及一系列相关工具与OS操作，最终完成备份过程 支持备份InnoDB和其他引擎的表 备份一致性保证  innobackupex备份基本流程 start xtrabackup_log -\u0026gt; copy .ibd; ibdata1 -\u0026gt; FLUSH TABLE WITH READ LOCK -\u0026gt; copy .FRM; MYD; MYI; misc files -\u0026gt; Get binary log position -\u0026gt; UNLOCK TABLES -\u0026gt; stop and copy xtrabackup_log\ninnobackupex使用 主要示例：\n 全量备份  1  innobackupex --user=root --password=123456 --defaults-file=/etc/mysql/my.cnf /dbbackup    增量备份  1  innobackupex --user=root --password=123456 --defaults-file=/etc/mysql/my.cnf --incremental --incremental-dir /dbbackup/2016-4-3_13:24:32 /dbbackup    流方式备份  1  innobackupex --user=root --password=123456 --defaults-file=/etc/mysql/my.cnf --stream=xbstream /dbbackup/ \u0026gt; /dbbackup/stream.bak    并行备份  1  innobackupex --user=root --password=123456 --defaults-file=/etc/mysql/my.cnf --parallel=4 /dbbackup/    限流备份  1  innobackupex --user=root --password=123456 --defaults-file=/etc/mysql/my.cnf --throttle=10 /dbbackup/    压缩备份  1  innobackupex --user=root --password=123456 --defaults-file=/etc/mysql/my.cnf --compress --compress-thread 4 /dbbackup/   如何制定备份策略 需要考虑的因素\n 数据库是不是都是innodb引擎表 -\u0026gt; 备份方式，热备or冷备 数据量大小 -\u0026gt; 逻辑备份or物理备份，全量or增量 数据库本地磁盘空间十分充足 -\u0026gt; 备份到本地or远程 需要多块恢复 -\u0026gt; 备份频率 小时or天  5.3-MySQL数据恢复 什么时候需要恢复数据  硬件故障(如磁盘损坏) 人为删除(如误删除数据、被黑) 业务回滚(如游戏bug需要回档) 正常需求(如部署镜像库、查看历史某时刻数据)  数据恢复的必要条件  有效备份 完整的数据库操作日志(binlog)  数据恢复思路  最新一次备份 + binlog恢复到故障时间点(适用于各种数据丢失场景) 挖掘最后一次备份到故障点之间的binlog获取相关SQL语句，构造反转SQL语句并应用到数据库(只是用于记录丢失，且binlog必须是row格式)  反转SQL语句 例：\nt1(id primary key, a int)\n反转SQL语句：\ninsert into t(id, a) values(1, 1) -\u0026gt; delete t1 where id=1 and a=1 update t1 set a=5 where id=1 -\u0026gt; update t1 set a=1 where id=1 delete from t1 where id=1 -\u0026gt; insert into t(id, a) values(1, 1)\n数据库恢复工具与命令  mysqldump备份 -\u0026gt; source恢复 xtrabackup备份 -\u0026gt; xtrabackup恢复 binlog备份 -\u0026gt; mysqlbinlog恢复  详细示例讲解  恢复某几条误删数据 恢复误删表、库 将数据库恢复到指定时间点  恢复误删除数据 case：误操作，删除数据忘记带完整条件，执行delete from user where age \u0026gt; 30 [and sex=male]\n需求：将被删除的数据还原\n恢复前提：完整的数据库操作日志(binlog)\n1  deletefromuserwheresex=\u0026#39;female\u0026#39;;  1 2 3  # 首先需要找到binlog里的信息 mysqlbinlog -vv mysql-bin.000001 # 找出sql语句，然后写出反转sql语句   恢复误删表、库 case：业务被黑，表被删除了(drop teble user)\n需求：将表恢复\n前提：备份 + 备份以来完整binlog\n1 2 3 4 5 6 7 8  innobackupex --apply-log /dbbackup/filename # 查看binlog的位置点 cat xtrabackup_binlog_info # 查看结束点 mysqlbinlog -vv filename mysqlbinlog -vv --start-position=2556990 -- stop-position=2776338 mysqlbinlog -vv --start-position=2556990 -- stop-position=2776338 | mysql -uroot -p123456 --sock=/dbbackup/mysql_3309/mysqld.sock   课程小结  恢复是已经非常苦逼的差事，尽量避免做。我们要做数据卫士而不是救火队员。(线上应该严格把控权限，数据变更操作应事先测试，操作时做好备份) 有效备份(+binlog)是重中之重，对数据库定期备份是必须的 备份是一切数据恢复的基础  5.4-MySQL线上部署 MySQL线上部署 考虑因素：\n 版本选择， 5.1、5.5还是5.6？ 分支选择，官方社区版？ percona server？ Mariadb？ 安装方式，包安装？二进制包安装？源码安装？ 路径配置，参数配置(尽量模板化、标准化) 一个实例多个库 or 多个实例单个库？  二进制安装MySQL  下载软件包 解压放到指定目录(比如/usr/local) 将MySQL目录放到PATH中 初始化实例，编辑配置文件并启动 账户安全设置  编译安装MySQL  下载MySQL源码安装包 安装必要包(make cmake bison-devel ncurses-devel build-essential) Cmake配置MySQL编译选项，可以定制需要安装的功能 make \u0026amp;\u0026amp; make install 初始化实例，编辑配置文件并启动 账户安全设置  MySQL升级  下载MySQL5.6安装包并配置MySQL5.6安装包安装路径 关闭MySQL5.5实例，修改部分参数，使用MySQL5.6软件启动 执行MySQL5.6路径下mysql_upgrade脚本 验证是否成功升级  MySQL多实例安装  部署好mysql软件 编辑多个配置文件，初始化多个实例 启动MySQL实例  MySQL多实例部署 为啥多实例部署？\n 充分利用系统资源 资源隔离 业务、模块隔离  MySQL线上安装小结  根据需求选择合适的版本以及分支，建议使用或升级到较高版本5.5或5.6 如果需要定制MySQL功能的话，可以考虑编译安装，否则的话建议使用二进制包安装，比较省事 根据机器配置选择部署多个MySQL实例还是单个实例，机器配置非常好的话，建议部署多实例  5.5-MySQL主从复制 MySQL主从复制  一主一从 主主复制 一主多从 多主一从 联级复制  MySQL主从复制用途  实时灾备，用于故障切换 读写分离，提供查询服务 备份，避免影响业务  MySQL主从复制部署 主从部署必要条件\n 主库开启binlog日志(设置log-bin参数) 主从server-id不同 从库服务器能连通主库  主从部署步骤：\n 备份还原(mysqldump或xtrabackup) 授权(grant replication slave on .) 配置复制，并启动(change master to) 查看主从复制信息(show slave status\\G)  MySQL复制存在的问题 存在的问题\n 主机宕机后，数据可能丢失 从库只有一个sql thread，主库写压力大，复制很可能延时  解决方法：\n 半同步复制 并行复制  MySQL semi-sync(半同步复制) 半同步复制\n 5.5集成到MySQL，以插件形式存在，需要单独安装 确保事务提交后binlog至少传输到一个从库 不保证从库应用完这个事务的binlog 性能有一定的降低，响应时间更长 网络异常或从库宕机，卡住主库，直到超时或从库恢复  MySQL异步复制 MySQL semi-sync(半同步复制) 配置MySQL半同步复制 只需一次：\n主库：\nINSTALL PLUGIN rpl_semi_sync_master SONAME 'semisync_master.so';\n从库：\nINSTALL PLUGIN rpl_semi_sync_slave SONAME 'semisync_slave.so';\n动态设置：\n主库：\nSET GLOBAL rpl_semi_sync_master_enabled=1; SET GLOBAL rpl_semi_sync_master_timeout=N; master 延迟切异步\n从库：\nSET GLOBAL rpl_semi_sync_slave_enabled=1;\n配置MySQL并行复制 并行复制\n 社区版5.6中新增 并行是指从库多线程apply binlog 库级别并行应用binlog，同一个数据库更改还是串行的(5.7版并行复制基于事务组)  设置\nset global slave_parallel_workers=10; 设置sql线程数为10\n联级复制 A -\u0026gt; B -\u0026gt; C\nB中添加参数： log_slave_updates B将把A的binlog记录到自己的binlog日志中\n复制监控 查询从库状态：\nshow slave status\\G\n复制出错处理 常见：1062(主键冲突) 1032(记录不存在) 解决：手动处理 或： 跳过复制出错 set global sql_slave_skip_counter=1\n总结  MySQL主从复制是MySQL高可用性、高性能(负载均衡)的基础 简单、灵活，部署方式多样，可以根据不同业务场景部署不同复制结构 MySQL主从复制目前也存在一些问题，可以根据需要部署复制增强功能来解决问题 复制过程中应该时刻监控复制状态，复制出错或延时可能给系统造成影响 MySQL复制是MySQL数据库工程师必知必会的一项基本技能  5.6-MySQL日常运维 DBA运维工作 日常\n 导数据、数据修改、表结构变更 加权限、问题处理 其他 数据库选型部署、设计、监控、备份、优化等  导数据及注意事项  数据最终形式(csv、sql文本 还是直接导入某库中) 导数据方法(mysqldump、select into outfile) 导数据注意事项  导出为csv格式需要file权限，而且只能数据库本地导 避免锁库锁表(mysqldump使用——single-transaction选项不锁表) 避免对业务造成影响，尽量在镜像库做    数据修改及注意事项  修改前切记做好备份 开事务做，修改完检查好了再提交 避免一次 修改大量数据，可以分批修改 避免业务高峰期做  表结构变更注意事项  在低峰期做 表结构变更是否会有锁？(5.6包含online ddl功能) 使用pt-online-schema-change完成表结构变更  可以避免主从延时 可以避免负载过高，可以限速    加权限及注意事项  只给符合需求的最低权限 避免授权时修改密码 避免给应用账号super权限  问题处理(数据库慢？)  数据库慢在哪？ show processlist查看mysql连接信息 查看系统状态(iostat, top, vmstat)  小结  日常工作比较简单，但是任何一个操作都可能影响线上服务 结合不同环境，不同要求选择最合适的方法处理 日常工作应该求稳不求快，保障线上稳定是DBA的最大责任  5.7-MySQL参数调优 为什么要调整参数  不同服务器之间的配置、性能不一样 不同业务场景对数据的需求不一样 MySQL的默认参数只是个参考值，并不适合所有的应用场合  优化之前我们需要知道什么  服务器相关的配置 业务相关的情况 MySQL相关的配置  服务器上需要关注哪些  硬件情况 操作系统版本 CPU、网卡节电模式 服务器numa设置 RAID卡缓存  磁盘调度策略-write back  数据写入cache既返回，数据异步的从cache刷入存储介质  磁盘调度策略-write through  数据同时写入cache和存储介质才返回写入成功  Write Back VS Write Through  write Back 性能优于 Write Through Write Through 比 Write Back安全性高  RAID  RAID Redundant Array of Independent Disks  生产环境里一般不太会用裸设备，通常会使用RAID卡对一块盘或多块盘做RAID RAID卡会预留一块内存，来保证数据高效存储与读取 常见的RAID类型有:RAID1、RAID0、RAID10和RAID5    RAID0 VS RAID1  RAID 0 - Block Striped. No Mirror. No Parity. RAID 1 - Block Mirrored. No Stripe. No Parity.  RAID5 VS RAID10  RAID 5 - Block Striped. Distributed Parity.(至少三块盘，每块里有两个数据块和一个校验块) RAID 10 - Block Mirrored.(每两块盘做RAID1，然后再按组做RAID0，至少四块盘)  RAID如何保证数据安全  BBU(Backup Battery Unit)  BBU保证在WB策略下，即使服务器发生掉电或者宕机，也能够将缓存数据写入到磁盘，从而保证数据的安全    MySQL有哪些注意事项  MySQL的部署安装 MySQL的监控 MySQL参数调优  部署MySQL的要求  推荐的MySQL版本: \u0026gt;= MySQL5.5 推荐的MySQL存储引擎: InnoDB  系统调优的依据：监控  实时监控MySQL的slow log 实时监控数据库服务器的负载情况 实时监控MySQL内部状态值  通常关注哪些MySQL Status  Com_Select/Update/Delete/Insert Bytes_received/Bytes_sent Buffer Pool Hit Rate Threads_connected/Threads_created/Threads_running  MySQL参数调优  为什么要调整MySQL的参数  MySQL是通用数据库，但业务是多变的，默认参数无法满足所有业务需求 MySQL内部一些参数是在MySQL一些很老的版本时候做的，可能之前是做限流和保护用的，但随着机器性能的提高，这些保护类的参数可能会成为性能瓶颈    读优化  合理利用索引对MySQL查询性能至关重要 适当的调整参数也能提升查询性能  innodb_buffer_pool_size  InnoDB存储引擎自己维护一块内存区域完成新老数据的替换 内存越大越能缓存更多的数据  innodb_thread_concurrency  innoDB内部并发控制参数，设置为0代表不做控制 如果并发请求较多，参数设置较小，后进来的请求将会排队  写优化  表结构设计上使用自增字段作为表的主键 只对合适的字段加索引，索引太多影响写入性能 监控服务器磁盘IO情况，如果写延迟较大则需要扩容 选择正确的MySQL版本，合理设置参数  哪些参数有助于提高写入性能  innoDB_flush_log_at_trx_commit \u0026amp;\u0026amp; sync_binlog innodb log file size innodb_io_capacity innodb insert buffer  主要影响MySQL写性能的两个参数  innoDB_flush_log_at_trx_commit sync_binlog  innoDB_flush_log_at_trx_commit  控制InnoDB事务的刷新方式，一共有三个值：0,1,2  N=0 - 每隔一秒，把事务日志缓存区的数据写到日志文件中，以及把日志文件的数据刷新到磁盘上(高效，但不安全) N=1 - 每个事务提交时候，把事务日志从缓存区写到日志文件中，并且刷新日志文件的数据到磁盘上，优先使用此模式保障数据安全性(低效，非常安全) N=2 - 每事务提交的时候，把事务日志数据从缓存区写到日志文件中；每隔一秒，但不一定刷新到磁盘上，而是取决于操作系统的调度(高效，但不安全)    sync_binlog  控制每次写入Binlog，是否都需要进行一次持久化  如何保证事务的安全  innoDB_flush_log_at_trx_commit 和 sync_binlog都设为1 事务要和Binlog保证一致性  (加锁)-\u0026gt; xa_prepare, Fsync -\u0026gt; Write And Fsync Binlog -\u0026gt; InnoDB Commit, Fsync -\u0026gt;(释放锁)\n串行有哪些问题  SAS盘一般每秒只能有150~200个Fsync。 换算到数据库每秒只能执行50~60个事务  社区和官方的改进  MariaDB提出改进，即使这两个参数都是1也能做到合并效果，性能得到了大幅提高。 官方吸收了MariaDB的思想，并在此基础上进行了改进，性能再次得到了提高  Tips:\n 官方在MySQL5.6版本之后才做了这个优化 Percona和MariaDB版本在MySQL5.5已经包含了这个优化  InnoDB Redo log  Write ahead Log  Redo log的作用  Redo log用在数据库崩溃会的故障恢复  Redo log有哪些问题  如果写入频繁导致Redo log里对应的最老的数据脏页还没有刷新到磁盘，此时数据库将卡住，强制刷新脏页到磁盘 MySQL默认配置两个文件才10M，非常容易写满，生产环境中应适当调整大小。  innodb_io_capacity  InnoDB每次刷多少个脏页，决定InnoDB存储引擎的吞吐能力。 在SSD等高性能存储介质下，应该提高该参数以提高数据库的性能。  Insert Buffer  顺序读写 VS 随机读写 随机请求性能远小于顺序请求  尽可能多的随机请求合并为顺序请求才是提高数据库性能的关键\n MySQL从5.1版本开始支持Insert Buffer MySQL5.5版本之后同时支持update和delete的merge Insert Buffer只对二级索引且非唯一索引有效  总结  服务器配置要合理(内核版本、磁盘调度策略、RAID卡缓存) 完善的监控系统，提前发现问题 数据库版本要跟上，不要太新，也不要太老 数据库性能优化：  查询优化：索引优化为主，参数优化为辅 写入优化：业务优化为主，参数优化为辅    ","pubDate":"2021-02-15","title":"网易云课堂MySQL \u003e chapter5"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_mysql_163%E8%AF%BE%E5%A0%82_%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql%E5%BE%AE%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","plain":"NTES_MySQL_notes 网易云课堂MySQL微专业学习笔记\n但愿可以不弃坑。\n目录  数据库基础  1.1-认识MySQL 1.2-轻松安装MySQL 1.3-MySQL数据库连接 1.4-SQL语言入门 1.5-认识DBA   MySQL数据库对象与应用  2.1-MySQL数据类型 2.2-MySQL数据对象 2.3-MySQL权限管理 2.4-SQL语言进阶 2.5-内置函数 2.6-触发器与存储过程 2.7-MySQL字符集 2.8程序连接MySQL 2.9-DAO框架的使用   MySQL事务与存储引擎  3.1-数据库事务 3.2-存储引擎概述 3.3-InnoDB存储引擎 3.4-InnoDB事务锁   MySQL应用优化  4.1-MySQL索引优化与设计 4.2-MySQL数据库设计 4.3-MySQL容量评估 4.4-MySQL性能测试   MySQL运维实践   5.1-MySQL日志系统\n  5.2-MySQL数据备份\n  5.3-MySQL数据恢复\n  5.4-MySQL线上部署\n  5.5-MySQL主从复制\n  5.6-MySQL日常运维\n  5.7-MySQL参数调优\n  5.7-MySQL参数调优\n    ","pubDate":"2021-02-15","title":"网易云课堂MySQL微专业学习笔记"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_windows%E5%8F%8A%E5%BA%94%E7%94%A8_%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA/","plain":"计算机中信息使用二进制表示    易于实现   2)运算简单 3)逻辑性强   进位计数制的概念,就是按照进位方式计数的数制  记数制的基本概念    基数    进计数制中使用不同基本符号的个数称为基数。如十进制中有十种符号(0-9),所以基数为10\n 2)数码  进制中所使用的符号。如十进制中有10个数码，分别是:0,1,2,3,4,5,6,7,8,9\n 3)位权  位权是个乘方值，底数为进位计数制的基数,而指数由个数字所在数中的位置决定。\n如:十进制数548.25可以表示为\r(548.25)⑩ = ","pubDate":"2021-02-15","title":"计算机中信息的表示"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_windows%E5%8F%8A%E5%BA%94%E7%94%A8_%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","plain":"计算机操作系统   操作系统的基本概念\n  行命令操作系统\n  汉字操作系统\n  windows操作系统\n  一:操作系统的基本概念  操作系统主要模块（作用）     管理系统资源。包括对CPU、内存储器、输入输出设备、数据文件和其他软件资源的管理    为用户提供资源共享的条件和环境，并对资源的使用进行合理调度    提供输入输出的方便环境，简化用户的输入输出工作，提供良好的用户界面    规定用户的接口，发现、处理或报告计算机操作过程中发生的各种错误     操作系统的功能和任务     处理机管理:处理机(CPU)是整个计算机硬件的核心。处理机管理的主要任务是:充分发挥处理机的作用，提高它的使用效率。    存储器管理:计算机内存储器是计算机硬件系统中的重要资源，它的容量总是有效的。存储器管理的主要任务是:对有限的内存储器进行合理分配，以满足多个用户程序运行的需要    设备管理:有效地管理各种外部设备，使这些设备充分发挥效率；给用户提供简单而易于使用地接口，以便在用户不了解设备性能地情况下，也能很方便地使用它们。    文件管理:唯一地标识计算机系统地每一组信息，以便能够合理地访问和控制它们；有条理地组织这些信息，使用户能够方便且安全地使用它们。    作业管理:对所有的用户作业进行分类，并且根据某种原则，源源不断地选取一些作业交给计算机去处理    ","pubDate":"2021-02-15","title":"计算机操作系统"},{"link":"https://huachengzhou.github.io/life/posts/uuid_t_windows%E5%8F%8A%E5%BA%94%E7%94%A8_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%8F%91%E5%B1%95%E4%B8%8E%E5%BA%94%E7%94%A8/","plain":"计算机的发展与应用  一:计算机的主要特点     计算机具有自动进行各种操作的能力    计算机具有高速处理的能力    计算机具有超强的记忆能力    计算机具有很高的计算精度与可靠的判断能力     二:计算机的应用     科学计算    过程检测与控制    信息管理    计算机辅助系统    ①计算机辅助设计(CAD) ②计算机辅助制造(CAM) ③计算机辅助测试(CAT) ④计算机辅助教学(CAI)\n 三:计算机的分类     巨型计算机    大型机    工作站    微型计算机    微控制器    服务器     四:计算机在三个方面得到了发展     小型化    速度    可购性      真正作为世界上第一台计算机的是电子管\n  计算机性能\n     CPU的主频 越高越好    CPU的字长 越大越好 32位，64位    存储容量 内部存储和外部存储 简称内存和外存 都是存储数据的东西   4)存取周期 越快越好  配置及扩展能力   6)可靠性  ","pubDate":"2021-02-15","title":"计算机的发展与应用"},{"link":"https://huachengzhou.github.io/life/posts/%E6%95%B0%E5%AD%A6%E9%A2%84%E8%A7%88/","plain":"KaTeX and MathJax Comparison Demo, currently processed as KaTex\nRepeating fractions \\[ \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} \\equiv 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}} {1+\\frac{e^{-8\\pi}} {1+\\cdots} } } } \\]\nSummation notation \\[ \\left( \\sum_{k=1}^n a_k b_k \\right)^2 \\leq \\left( \\sum_{k=1}^n a_k^2 \\right) \\left( \\sum_{k=1}^n b_k^2 \\right) \\]\nSum of a Series I broke up the next two examples into separate lines so it behaves better on a mobile phone. That's why they include \\displaystyle.\n\\[ \\displaystyle\\sum_{i=1}^{k+1}i \\]\n\\[ \\displaystyle= \\left(\\sum_{i=1}^{k}i\\right) +(k+1) \\]\n\\[ \\displaystyle= \\frac{k(k+1)}{2}+k+1 \\]\n\\[ \\displaystyle= \\frac{k(k+1)+2(k+1)}{2} \\]\n\\[ \\displaystyle= \\frac{(k+1)(k+2)}{2} \\]\n\\[ \\displaystyle= \\frac{(k+1)((k+1)+1)}{2} \\]\nProduct notation \\[ \\displaystyle 1 + \\frac{q^2}{(1-q)}+\\frac{q^6}{(1-q)(1-q^2)}+\\cdots = \\displaystyle \\prod_{j=0}^{\\infty}\\frac{1}{(1-q^{5j+2})(1-q^{5j+3})}, \\displaystyle\\text{ for }\\lvert q\\rvert Inline math And here is some in-line math: \\( k_{n+1} = n^2 + k_n^2 - k_{n-1} \\) , followed by some more text.\nGreek Letters \\[ \\Gamma\\ \\Delta\\ \\Theta\\ \\Lambda\\ \\Xi\\ \\Pi\\ \\Sigma\\ \\Upsilon\\ \\Phi\\ \\Psi\\ \\Omega \\alpha\\ \\beta\\ \\gamma\\ \\delta\\ \\epsilon\\ \\zeta\\ \\eta\\ \\theta\\ \\iota\\ \\kappa\\ \\lambda\\ \\mu\\ \\nu\\ \\xi \\ \\omicron\\ \\pi\\ \\rho\\ \\sigma\\ \\tau\\ \\upsilon\\ \\phi\\ \\chi\\ \\psi\\ \\omega\\ \\varepsilon\\ \\vartheta\\ \\varpi\\ \\varrho\\ \\varsigma\\ \\varphi \\]\nArrows \\[ \\gets\\ \\to\\ \\leftarrow\\ \\rightarrow\\ \\uparrow\\ \\Uparrow\\ \\downarrow\\ \\Downarrow\\ \\updownarrow\\ \\Updownarrow \\]\n\\[ \\Leftarrow\\ \\Rightarrow\\ \\leftrightarrow\\ \\Leftrightarrow\\ \\mapsto\\ \\hookleftarrow \\leftharpoonup\\ \\leftharpoondown\\ \\rightleftharpoons\\ \\longleftarrow\\ \\Longleftarrow\\ \\longrightarrow \\]\n\\[ \\Longrightarrow\\ \\longleftrightarrow\\ \\Longleftrightarrow\\ \\longmapsto\\ \\hookrightarrow\\ \\rightharpoonup \\]\n\\[ \\rightharpoondown\\ \\leadsto\\ \\nearrow\\ \\searrow\\ \\swarrow\\ \\nwarrow \\]\nSymbols \\[ \\surd\\ \\barwedge\\ \\veebar\\ \\odot\\ \\oplus\\ \\otimes\\ \\oslash\\ \\circledcirc\\ \\boxdot\\ \\bigtriangleup \\]\n\\[ \\bigtriangledown\\ \\dagger\\ \\diamond\\ \\star\\ \\triangleleft\\ \\triangleright\\ \\angle\\ \\infty\\ \\prime\\ \\triangle \\]\nCalculus \\[ \\int u \\frac{dv}{dx}\\,dx=uv-\\int \\frac{du}{dx}v\\,dx \\]\n\\[ f(x) = \\int_{-\\infty}^\\infty \\hat f(\\xi)\\,e^{2 \\pi i \\xi x} \\]\n\\[ \\oint \\vec{F} \\cdot d\\vec{s}=0 \\]\nLorenz Equations \\[ \\begin{aligned} \\dot{x} \u0026 = \\sigma(y-x) \\\\ \\dot{y} \u0026 = \\rho x - y - xz \\\\ \\dot{z} \u0026 = -\\beta z + xy \\end{aligned} \\]\nCross Product This works in KaTeX, but the separation of fractions in this environment is not so good.\n\\[ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} \u0026 \\mathbf{j} \u0026 \\mathbf{k} \\\\ \\frac{\\partial X}{\\partial u} \u0026 \\frac{\\partial Y}{\\partial u} \u0026 0 \\\\ \\frac{\\partial X}{\\partial v} \u0026 \\frac{\\partial Y}{\\partial v} \u0026 0 \\end{vmatrix} \\]\nHere's a workaround: make the fractions smaller with an extra class that targets the spans with \u0026quot;mfrac\u0026quot; class (makes no difference in the MathJax case):\n\\[ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} \u0026 \\mathbf{j} \u0026 \\mathbf{k} \\\\ \\frac{\\partial X}{\\partial u} \u0026 \\frac{\\partial Y}{\\partial u} \u0026 0 \\\\ \\frac{\\partial X}{\\partial v} \u0026 \\frac{\\partial Y}{\\partial v} \u0026 0 \\end{vmatrix} \\]\nAccents \\[ \\hat{x}\\ \\vec{x}\\ \\ddot{x} \\]\nStretchy brackets \\[ \\left(\\frac{x^2}{y^3}\\right) \\]\nEvaluation at limits \\[ \\left.\\frac{x^3}{3}\\right|_0^1 \\]\nCase definitions \\[ f(n) = \\begin{cases} \\frac{n}{2}, \u0026 \\text{if } n\\text{ is even} \\\\ 3n+1, \u0026 \\text{if } n\\text{ is odd} \\end{cases} \\]\nMaxwell's Equations \\[ \\begin{aligned} \\nabla \\times \\vec{\\mathbf{B}} -\\, \\frac1c\\, \\frac{\\partial\\vec{\\mathbf{E}}}{\\partial t} \u0026 = \\frac{4\\pi}{c}\\vec{\\mathbf{j}} \\\\ \\nabla \\cdot \\vec{\\mathbf{E}} \u0026 = 4 \\pi \\rho \\\\ \\nabla \\times \\vec{\\mathbf{E}}\\, +\\, \\frac1c\\, \\frac{\\partial\\vec{\\mathbf{B}}}{\\partial t} \u0026 = \\vec{\\mathbf{0}} \\\\ \\nabla \\cdot \\vec{\\mathbf{B}} \u0026 = 0 \\end{aligned} \\]\nThese equations are quite cramped. We can add vertical spacing using (for example) [1em] after each line break (\\). as you can see here:\n\\[ \\begin{aligned} \\nabla \\times \\vec{\\mathbf{B}} -\\, \\frac1c\\, \\frac{\\partial\\vec{\\mathbf{E}}}{\\partial t} \u0026 = \\frac{4\\pi}{c}\\vec{\\mathbf{j}} \\\\[1em] \\nabla \\cdot \\vec{\\mathbf{E}} \u0026 = 4 \\pi \\rho \\\\[0.5em] \\nabla \\times \\vec{\\mathbf{E}}\\, +\\, \\frac1c\\, \\frac{\\partial\\vec{\\mathbf{B}}}{\\partial t} \u0026 = \\vec{\\mathbf{0}} \\\\[1em] \\nabla \\cdot \\vec{\\mathbf{B}} \u0026 = 0 \\end{aligned} \\]\nStatistics Definition of combination:\n\\[ \\frac{n!}{k!(n-k)!} = {^n}C_k {n \\choose k} \\]\nFractions on fractions \\[ \\frac{\\frac{1}{x}+\\frac{1}{y}}{y-z} \\]\nn-th root \\[ \\sqrt[n]{1+x+x^2+x^3+\\ldots} \\]\nMatrices \\[ \\begin{pmatrix} a_{11} \u0026 a_{12} \u0026 a_{13}\\\\ a_{21} \u0026 a_{22} \u0026 a_{23}\\\\ a_{31} \u0026 a_{32} \u0026 a_{33} \\end{pmatrix} \\begin{bmatrix} 0 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 \\cdots \u0026 0 \\end{bmatrix} \\]\nPunctuation \\[ f(x) = \\sqrt{1+x} \\quad (x \\ge -1) f(x) \\sim x^2 \\quad (x\\to\\infty) \\]\nNow with punctuation:\n\\[ f(x) = \\sqrt{1+x}, \\quad x \\ge -1 f(x) \\sim x^2, \\quad x\\to\\infty \\]\n","pubDate":"2019-03-04","title":"数学预览"},{"link":"https://huachengzhou.github.io/life/posts/%E5%9B%BE%E7%89%87%E9%A2%84%E8%A7%88/","plain":"Thanks for liwenyip/hugo-easy-gallery \u0026amp; Zebradil · Pull Request #48 .\nNow, we could use {{\u0026lt; gallery \u0026gt;}} shortcode in hugo-theme-jane.\nNormal Image This is an image in static/image folder.\n1  ![This is an image in `static/image` folder.](/image/example.jpg)   {{\u0026lt; figure \u0026gt;}} shortcode figure image with title {{\u0026lt; figure src=\u0026quot;/image/example.jpg\u0026quot; title=\u0026quot;figure image with title\u0026quot; \u0026gt;}}\rfigure image with caption {{\u0026lt; figure src=\u0026quot;/image/example.jpg\u0026quot; caption=\u0026quot;figure image with caption figure image with caption figure image with caption figure image with caption figure image with caption\u0026quot; \u0026gt;}}\rmore {{\u0026lt; figure \u0026gt;}} shortcode usage Specifying your image files:\n {{\u0026lt; figure src=\u0026quot;thumb.jpg\u0026quot; link=\u0026quot;image.jpg\u0026quot; \u0026gt;}} will use thumb.jpg for thumbnail and image.jpg for lightbox {{\u0026lt; figure src=\u0026quot;image.jpg\u0026quot; \u0026gt;}} or {{\u0026lt; figure link=\u0026quot;image.jpg\u0026quot; \u0026gt;}} will use image.jpg for both thumbnail and lightbox {{\u0026lt; figure link=\u0026quot;image.jpg\u0026quot; thumb=\u0026quot;-small\u0026quot; \u0026gt;}} will use image-small.jpg for thumbnail and image.jpg for lightbox  Optional parameters:\n All the features/parameters of Hugo\u0026rsquo;s built-in figure shortcode work as normal, i.e. src, link, title, caption, class, attr (attribution), attrlink, alt size (e.g. size=\u0026quot;1024x768\u0026quot;) pre-defines the image size for PhotoSwipe. Use this option if you don\u0026rsquo;t want to pre-load the linked image to determine its size. class allows you to set any custom classes you want on the \u0026lt;figure\u0026gt; tag.  Optional parameters for standalone {{\u0026lt; figure \u0026gt;}} shortcodes only (i.e. don\u0026rsquo;t use on {{\u0026lt; figure \u0026gt;}} inside {{\u0026lt; gallery \u0026gt;}} - strange things may happen if you do):\n caption-position and caption-effect work the same as for the {{\u0026lt; gallery \u0026gt;}} shortcode (see below). width defines the max-width of the image displayed on the page. If using a thumbnail for a standalone figure, set this equal to your thumbnail\u0026rsquo;s native width to make the captions behave properly (or feel free to come up with a better solution and submit a pull request :-)). Also use this option if you don\u0026rsquo;t have a thumbnail and you don\u0026rsquo;t want the hi-res image to take up the entire width of the screen/container. class=\u0026quot;no-photoswipe\u0026quot; prevents a \u0026lt;figure\u0026gt; from being loaded into PhotoSwipe. If you click on the figure you\u0026rsquo;ll instead a good ol' fashioned hyperlink to a bigger image (or - if you haven\u0026rsquo;t specified a bigger image - the same one).  {{\u0026lt; gallery \u0026gt;}} shortcode simple gallery To specify a directory of image files:\n{{\u0026lt; gallery dir=\u0026quot;/img/your-directory-of-images/\u0026quot; \u0026gt;}}\r The images are automatically captioned with the file name. [image].jpg is used for the hi-res image, and [image]-thumb.jpg is used for the thumbnails. If [image]-thumb.jpg doesn\u0026rsquo;t exist, then [image].jpg will be used for both hi-res and thumbnail images. The default thumbnail suffix is -thumb, but you can specify a different one e.g. thumb=\u0026quot;-small\u0026quot; or thumb=\u0026quot;_150x150\u0026quot;.  To specify individual image files {{\u0026lt; gallery \u0026gt;}}\r{{\u0026lt; figure src=\u0026quot;image1.jpg\u0026quot; \u0026gt;}}\r{{\u0026lt; figure src=\u0026quot;image2.jpg\u0026quot; \u0026gt;}}\r{{\u0026lt; figure src=\u0026quot;image3.jpg\u0026quot; \u0026gt;}}\r{{\u0026lt; /gallery \u0026gt;}}\rOptional parameters:\n caption-position - determines the captions' position over the image. Options:  bottom (default) center none hides captions on the page (they will only show in PhotoSwipe)   caption-effect - determines if/how captions appear upon hover. Options:  slide (default) fade none (captions always visible)   hover-effect - determines if/how images change upon hover. Options:  zoom (default) grow shrink slideup slidedown none   hover-transition - determines if/how images change upon hover. Options:  not set - smooth transition (default) none - hard transition   ","pubDate":"2018-03-03","title":"图片预览"},{"link":"https://huachengzhou.github.io/life/posts/%E6%96%87%E6%A1%A3%E8%84%9A%E6%9C%AC%E5%BC%95%E7%94%A8/","plain":"Hugo-theme-jane optimized for footnote. When you mouse hover the footnote1 , footnote content will be displayed.\nFootnote-1 1 2 3  You can create footnotes like this[^footnote]. [^footnote]: Here is the *text* of the **footnote**.   will produce:\nYou can create footnotes like this2.\nMouse on the ‘footnote’ superscript to see content of the footnote.\nFootnote-2 1 2 3  You can create footnotes like this[^footnote2]. [^footnote2]: Here is the *text* of the **footnote**.   will produce:\nYou can create footnotes like this3.\nMouse on the ‘footnote’ superscript to see content of the footnote.\nFootnote-3 1 2 3  You can create footnotes like this[^footnote]. [^footnote]: Here is the *text* of the **footnote**.   will produce:\nYou can create footnotes like this4.\nMouse on the ‘footnote’ superscript to see content of the footnote.\nFootnote-4 1 2 3  You can create footnotes like this[^footnote]. [^footnote]: Here is the *text* of the **footnote**.   will produce:\nYou can create footnotes like this5.\nMouse on the ‘footnote’ superscript to see content of the footnote.\nFootnote-5 1 2 3  You can create footnotes like this[^footnote]. [^footnote]: Here is the *text* of the **footnote**.   will produce dddddddddddddddddddddddddddddddddddddddddddddd:\nYou can create footnotes like this6.\nMouse on the ‘footnote’ superscript to see content of the footnote.\n  example footnote show.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Here is the text of the footnote-1.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Here is the text of the footnote-2. Here is the text of the footnote-2. Here is the text of the footnote-2. Here is the text of the footnote-2. Here is the text of the footnote-2. The world’s fastest framework for building websites | Hugo\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Here is the text of the footnote-3.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Here is the text of the footnote-4.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Here is the text of the footnote-5.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","pubDate":"2018-03-01","title":"文档脚本引用"},{"link":"https://huachengzhou.github.io/life/posts/%E8%8B%B1%E8%AF%AD%E9%A2%84%E8%A7%88/","plain":"Introduction This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I\u0026rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won\u0026rsquo;t cover using CSS to style your theme.\nWe\u0026rsquo;ll start with creating a new site with a very basic template. Then we\u0026rsquo;ll add in a few pages and posts. With small variations on that, you will be able to create many different types of web sites.\nIn this tutorial, commands that you enter will start with the \u0026ldquo;$\u0026rdquo; prompt. The output will follow. Lines that start with \u0026ldquo;#\u0026rdquo; are comments that I\u0026rsquo;ve added to explain a point. When I show updates to a file, the \u0026ldquo;:wq\u0026rdquo; on the last line means to save the file.\nHere\u0026rsquo;s an example:\n## this is a comment\r$ echo this is a command\rthis is a command\r## edit the file\r$vi foo.md\r+++\rdate = \u0026quot;2014-09-28\u0026quot;\rtitle = \u0026quot;creating a new theme\u0026quot;\r+++\rbah and humbug\r:wq\r## show it\r$ cat foo.md\r+++\rdate = \u0026quot;2014-09-28\u0026quot;\rtitle = \u0026quot;creating a new theme\u0026quot;\r+++\rbah and humbug\r$\rSome Definitions There are a few concepts that you need to understand before creating a theme.\nSkins Skins are the files responsible for the look and feel of your site. It’s the CSS that controls colors and fonts, it’s the Javascript that determines actions and reactions. It’s also the rules that Hugo uses to transform your content into the HTML that the site will serve to visitors.\nYou have two ways to create a skin. The simplest way is to create it in the layouts/ directory. If you do, then you don’t have to worry about configuring Hugo to recognize it. The first place that Hugo will look for rules and files is in the layouts/ directory so it will always find the skin.\nYour second choice is to create it in a sub-directory of the themes/ directory. If you do, then you must always tell Hugo where to search for the skin. It’s extra work, though, so why bother with it?\nThe difference between creating a skin in layouts/ and creating it in themes/ is very subtle. A skin in layouts/ can’t be customized without updating the templates and static files that it is built from. A skin created in themes/, on the other hand, can be and that makes it easier for other people to use it.\nThe rest of this tutorial will call a skin created in the themes/ directory a theme.\nNote that you can use this tutorial to create a skin in the layouts/ directory if you wish to. The main difference will be that you won’t need to update the site’s configuration file to use a theme.\nThe Home Page The home page, or landing page, is the first page that many visitors to a site see. It is the index.html file in the root directory of the web site. Since Hugo writes files to the public/ directory, our home page is public/index.html.\nSite Configuration File When Hugo runs, it looks for a configuration file that contains settings that override default values for the entire site. The file can use TOML, YAML, or JSON. I prefer to use TOML for my configuration files. If you prefer to use JSON or YAML, you’ll need to translate my examples. You’ll also need to change the name of the file since Hugo uses the extension to determine how to process it.\nHugo translates Markdown files into HTML. By default, Hugo expects to find Markdown files in your content/ directory and template files in your themes/ directory. It will create HTML files in your public/ directory. You can change this by specifying alternate locations in the configuration file.\nContent Content is stored in text files that contain two sections. The first section is the “front matter,” which is the meta-information on the content. The second section contains Markdown that will be converted to HTML.\nFront Matter The front matter is information about the content. Like the configuration file, it can be written in TOML, YAML, or JSON. Unlike the configuration file, Hugo doesn’t use the file’s extension to know the format. It looks for markers to signal the type. TOML is surrounded by “+++”, YAML by “---”, and JSON is enclosed in curly braces. I prefer to use TOML, so you’ll need to translate my examples if you prefer YAML or JSON.\nThe information in the front matter is passed into the template before the content is rendered into HTML.\nMarkdown Content is written in Markdown which makes it easier to create the content. Hugo runs the content through a Markdown engine to create the HTML which will be written to the output file.\nTemplate Files Hugo uses template files to render content into HTML. Template files are a bridge between the content and presentation. Rules in the template define what content is published, where it\u0026rsquo;s published to, and how it will rendered to the HTML file. The template guides the presentation by specifying the style to use.\nThere are three types of templates: single, list, and partial. Each type takes a bit of content as input and transforms it based on the commands in the template.\nHugo uses its knowledge of the content to find the template file used to render the content. If it can’t find a template that is an exact match for the content, it will shift up a level and search from there. It will continue to do so until it finds a matching template or runs out of templates to try. If it can’t find a template, it will use the default template for the site.\nPlease note that you can use the front matter to influence Hugo’s choice of templates.\nSingle Template A single template is used to render a single piece of content. For example, an article or post would be a single piece of content and use a single template.\nList Template A list template renders a group of related content. That could be a summary of recent postings or all articles in a category. List templates can contain multiple groups.\nThe homepage template is a special type of list template. Hugo assumes that the home page of your site will act as the portal for the rest of the content in the site.\nPartial Template A partial template is a template that can be included in other templates. Partial templates must be called using the “partial” template command. They are very handy for rolling up common behavior. For example, your site may have a banner that all pages use. Instead of copying the text of the banner into every single and list template, you could create a partial with the banner in it. That way if you decide to change the banner, you only have to change the partial template.\nCreate a New Site Let\u0026rsquo;s use Hugo to create a new web site. I\u0026rsquo;m a Mac user, so I\u0026rsquo;ll create mine in my home directory, in the Sites folder. If you\u0026rsquo;re using Linux, you might have to create the folder first.\nThe \u0026ldquo;new site\u0026rdquo; command will create a skeleton of a site. It will give you the basic directory structure and a useable configuration file.\n$ hugo new site ~/Sites/zafta\r$ cd ~/Sites/zafta\r$ ls -l\rtotal 8\rdrwxr-xr-x 7 quoha staff 238 Sep 29 16:49 .\rdrwxr-xr-x 3 quoha staff 102 Sep 29 16:49 ..\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 archetypes\r-rw-r--r-- 1 quoha staff 82 Sep 29 16:49 config.toml\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 content\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 layouts\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 static\r$\rTake a look in the content/ directory to confirm that it is empty.\nThe other directories (archetypes/, layouts/, and static/) are used when customizing a theme. That\u0026rsquo;s a topic for a different tutorial, so please ignore them for now.\nGenerate the HTML For the New Site Running the hugo command with no options will read all the available content and generate the HTML files. It will also copy all static files (that\u0026rsquo;s everything that\u0026rsquo;s not content). Since we have an empty site, it won\u0026rsquo;t do much, but it will do it very quickly.\n$ hugo --verbose\rINFO: 2014/09/29 Using config file: config.toml\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\rWARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html]\rWARN: 2014/09/29 Unable to locate layout: [404.html]\r0 draft content\r0 future content\r0 pages created\r0 tags created\r0 categories created\rin 2 ms\r$\rThe \u0026ldquo;--verbose\u0026rdquo; flag gives extra information that will be helpful when we build the template. Every line of the output that starts with \u0026ldquo;INFO:\u0026rdquo; or \u0026ldquo;WARN:\u0026rdquo; is present because we used that flag. The lines that start with \u0026ldquo;WARN:\u0026rdquo; are warning messages. We\u0026rsquo;ll go over them later.\nWe can verify that the command worked by looking at the directory again.\n$ ls -l\rtotal 8\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 archetypes\r-rw-r--r-- 1 quoha staff 82 Sep 29 16:49 config.toml\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 content\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 layouts\rdrwxr-xr-x 4 quoha staff 136 Sep 29 17:02 public\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 static\r$\rSee that new public/ directory? Hugo placed all generated content there. When you\u0026rsquo;re ready to publish your web site, that\u0026rsquo;s the place to start. For now, though, let\u0026rsquo;s just confirm that we have what we\u0026rsquo;d expect from a site with no content.\n$ ls -l public\rtotal 16\r-rw-r--r-- 1 quoha staff 416 Sep 29 17:02 index.xml\r-rw-r--r-- 1 quoha staff 262 Sep 29 17:02 sitemap.xml\r$\rHugo created two XML files, which is standard, but there are no HTML files.\nTest the New Site Verify that you can run the built-in web server. It will dramatically shorten your development cycle if you do. Start it by running the \u0026ldquo;server\u0026rdquo; command. If it is successful, you will see output similar to the following:\n$ hugo server --verbose\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\rWARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html]\rWARN: 2014/09/29 Unable to locate layout: [404.html]\r0 draft content\r0 future content\r0 pages created\r0 tags created\r0 categories created\rin 2 ms\rServing pages from /Users/quoha/Sites/zafta/public\rWeb Server is available at http://localhost:1313\rPress Ctrl+C to stop\rConnect to the listed URL (it\u0026rsquo;s on the line that starts with \u0026ldquo;Web Server\u0026rdquo;). If everything is working correctly, you should get a page that shows the following:\nindex.xml\rsitemap.xml\rThat\u0026rsquo;s a listing of your public/ directory. Hugo didn\u0026rsquo;t create a home page because our site has no content. When there\u0026rsquo;s no index.html file in a directory, the server lists the files in the directory, which is what you should see in your browser.\nLet’s go back and look at those warnings again.\nWARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html]\rWARN: 2014/09/29 Unable to locate layout: [404.html]\rThat second warning is easier to explain. We haven’t created a template to be used to generate “page not found errors.” The 404 message is a topic for a separate tutorial.\nNow for the first warning. It is for the home page. You can tell because the first layout that it looked for was “index.html.” That’s only used by the home page.\nI like that the verbose flag causes Hugo to list the files that it\u0026rsquo;s searching for. For the home page, they are index.html, _default/list.html, and _default/single.html. There are some rules that we\u0026rsquo;ll cover later that explain the names and paths. For now, just remember that Hugo couldn\u0026rsquo;t find a template for the home page and it told you so.\nAt this point, you\u0026rsquo;ve got a working installation and site that we can build upon. All that’s left is to add some content and a theme to display it.\nCreate a New Theme Hugo doesn\u0026rsquo;t ship with a default theme. There are a few available (I counted a dozen when I first installed Hugo) and Hugo comes with a command to create new themes.\nWe\u0026rsquo;re going to create a new theme called \u0026ldquo;zafta.\u0026rdquo; Since the goal of this tutorial is to show you how to fill out the files to pull in your content, the theme will not contain any CSS. In other words, ugly but functional.\nAll themes have opinions on content and layout. For example, Zafta uses \u0026ldquo;post\u0026rdquo; over \u0026ldquo;blog\u0026rdquo;. Strong opinions make for simpler templates but differing opinions make it tougher to use themes. When you build a theme, consider using the terms that other themes do.\nCreate a Skeleton Use the hugo \u0026ldquo;new\u0026rdquo; command to create the skeleton of a theme. This creates the directory structure and places empty files for you to fill out.\n$ hugo new theme zafta\r$ ls -l\rtotal 8\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 archetypes\r-rw-r--r-- 1 quoha staff 82 Sep 29 16:49 config.toml\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 content\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 layouts\rdrwxr-xr-x 4 quoha staff 136 Sep 29 17:02 public\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 static\rdrwxr-xr-x 3 quoha staff 102 Sep 29 17:31 themes\r$ find themes -type f | xargs ls -l\r-rw-r--r-- 1 quoha staff 1081 Sep 29 17:31 themes/zafta/LICENSE.md\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/archetypes/default.md\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/list.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/single.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/footer.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/header.html\r-rw-r--r-- 1 quoha staff 93 Sep 29 17:31 themes/zafta/theme.toml\r$\rThe skeleton includes templates (the files ending in .html), license file, a description of your theme (the theme.toml file), and an empty archetype.\nPlease take a minute to fill out the theme.toml and LICENSE.md files. They\u0026rsquo;re optional, but if you\u0026rsquo;re going to be distributing your theme, it tells the world who to praise (or blame). It\u0026rsquo;s also nice to declare the license so that people will know how they can use the theme.\n$ vi themes/zafta/theme.toml\rauthor = \u0026quot;michael d henderson\u0026quot;\rdescription = \u0026quot;a minimal working template\u0026quot;\rlicense = \u0026quot;MIT\u0026quot;\rname = \u0026quot;zafta\u0026quot;\rsource_repo = \u0026quot;\u0026quot;\rtags = [\u0026quot;tags\u0026quot;, \u0026quot;categories\u0026quot;]\r:wq\r## also edit themes/zafta/LICENSE.md and change\r## the bit that says \u0026quot;YOUR_NAME_HERE\u0026quot;\rNote that the the skeleton\u0026rsquo;s template files are empty. Don\u0026rsquo;t worry, we\u0026rsquo;ll be changing that shortly.\n$ find themes/zafta -name '*.html' | xargs ls -l\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/list.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/single.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/footer.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/header.html\r$\rUpdate the Configuration File to Use the Theme Now that we\u0026rsquo;ve got a theme to work with, it\u0026rsquo;s a good idea to add the theme name to the configuration file. This is optional, because you can always add \u0026ldquo;-t zafta\u0026rdquo; on all your commands. I like to put it the configuration file because I like shorter command lines. If you don\u0026rsquo;t put it in the configuration file or specify it on the command line, you won\u0026rsquo;t use the template that you\u0026rsquo;re expecting to.\nEdit the file to add the theme, add a title for the site, and specify that all of our content will use the TOML format.\n$ vi config.toml\rtheme = \u0026quot;zafta\u0026quot;\rbaseurl = \u0026quot;\u0026quot;\rlanguageCode = \u0026quot;en-us\u0026quot;\rtitle = \u0026quot;zafta - totally refreshing\u0026quot;\rMetaDataFormat = \u0026quot;toml\u0026quot;\r:wq\r$\rGenerate the Site Now that we have an empty theme, let\u0026rsquo;s generate the site again.\n$ hugo --verbose\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\rWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\r0 draft content\r0 future content\r0 pages created\r0 tags created\r0 categories created\rin 2 ms\r$\rDid you notice that the output is different? The warning message for the home page has disappeared and we have an additional information line saying that Hugo is syncing from the theme\u0026rsquo;s directory.\nLet\u0026rsquo;s check the public/ directory to see what Hugo\u0026rsquo;s created.\n$ ls -l public\rtotal 16\rdrwxr-xr-x 2 quoha staff 68 Sep 29 17:56 css\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:56 index.html\r-rw-r--r-- 1 quoha staff 407 Sep 29 17:56 index.xml\rdrwxr-xr-x 2 quoha staff 68 Sep 29 17:56 js\r-rw-r--r-- 1 quoha staff 243 Sep 29 17:56 sitemap.xml\r$\rNotice four things:\n Hugo created a home page. This is the file public/index.html. Hugo created a css/ directory. Hugo created a js/ directory. Hugo claimed that it created 0 pages. It created a file and copied over static files, but didn\u0026rsquo;t create any pages. That\u0026rsquo;s because it considers a \u0026ldquo;page\u0026rdquo; to be a file created directly from a content file. It doesn\u0026rsquo;t count things like the index.html files that it creates automatically.  The Home Page Hugo supports many different types of templates. The home page is special because it gets its own type of template and its own template file. The file, layouts/index.html, is used to generate the HTML for the home page. The Hugo documentation says that this is the only required template, but that depends. Hugo\u0026rsquo;s warning message shows that it looks for three different templates:\nWARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html]\rIf it can\u0026rsquo;t find any of these, it completely skips creating the home page. We noticed that when we built the site without having a theme installed.\nWhen Hugo created our theme, it created an empty home page template. Now, when we build the site, Hugo finds the template and uses it to generate the HTML for the home page. Since the template file is empty, the HTML file is empty, too. If the template had any rules in it, then Hugo would have used them to generate the home page.\n$ find . -name index.html | xargs ls -l\r-rw-r--r-- 1 quoha staff 0 Sep 29 20:21 ./public/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 ./themes/zafta/layouts/index.html\r$\rThe Magic of Static Hugo does two things when generating the site. It uses templates to transform content into HTML and it copies static files into the site. Unlike content, static files are not transformed. They are copied exactly as they are.\nHugo assumes that your site will use both CSS and JavaScript, so it creates directories in your theme to hold them. Remember opinions? Well, Hugo\u0026rsquo;s opinion is that you\u0026rsquo;ll store your CSS in a directory named css/ and your JavaScript in a directory named js/. If you don\u0026rsquo;t like that, you can change the directory names in your theme directory or jane delete them completely. Hugo\u0026rsquo;s nice enough to offer its opinion, then behave nicely if you disagree.\n$ find themes/zafta -type d | xargs ls -ld\rdrwxr-xr-x 7 quoha staff 238 Sep 29 17:38 themes/zafta\rdrwxr-xr-x 3 quoha staff 102 Sep 29 17:31 themes/zafta/archetypes\rdrwxr-xr-x 5 quoha staff 170 Sep 29 17:31 themes/zafta/layouts\rdrwxr-xr-x 4 quoha staff 136 Sep 29 17:31 themes/zafta/layouts/_default\rdrwxr-xr-x 4 quoha staff 136 Sep 29 17:31 themes/zafta/layouts/partials\rdrwxr-xr-x 4 quoha staff 136 Sep 29 17:31 themes/zafta/static\rdrwxr-xr-x 2 quoha staff 68 Sep 29 17:31 themes/zafta/static/css\rdrwxr-xr-x 2 quoha staff 68 Sep 29 17:31 themes/zafta/static/js\r$\rThe Theme Development Cycle When you\u0026rsquo;re working on a theme, you will make changes in the theme\u0026rsquo;s directory, rebuild the site, and check your changes in the browser. Hugo makes this very easy:\n Purge the public/ directory. Run the built in web server in watch mode. Open your site in a browser. Update the theme. Glance at your browser window to see changes. Return to step 4.  I’ll throw in one more opinion: never work on a theme on a live site. Always work on a copy of your site. Make changes to your theme, test them, then copy them up to your site. For added safety, use a tool like Git to keep a revision history of your content and your theme. Believe me when I say that it is too easy to lose both your mind and your changes.\nCheck the main Hugo site for information on using Git with Hugo.\nPurge the public/ Directory When generating the site, Hugo will create new files and update existing ones in the public/ directory. It will not delete files that are no longer used. For example, files that were created in the wrong directory or with the wrong title will remain. If you leave them, you might get confused by them later. I recommend cleaning out your site prior to generating it.\nNote: If you\u0026rsquo;re building on an SSD, you should ignore this. Churning on a SSD can be costly.\nHugo\u0026rsquo;s Watch Option Hugo\u0026rsquo;s \u0026ldquo;--watch\u0026rdquo; option will monitor the content/ and your theme directories for changes and rebuild the site automatically.\nLive Reload Hugo\u0026rsquo;s built in web server supports live reload. As pages are saved on the server, the browser is told to refresh the page. Usually, this happens faster than you can say, \u0026ldquo;Wow, that\u0026rsquo;s totally amazing.\u0026rdquo;\nDevelopment Commands Use the following commands as the basis for your workflow.\n## purge old files. hugo will recreate the public directory.\r##\r$ rm -rf public\r##\r## run hugo in watch mode\r##\r$ hugo server --watch --verbose\rHere\u0026rsquo;s sample output showing Hugo detecting a change to the template for the home page. Once generated, the web browser automatically reloaded the page. I\u0026rsquo;ve said this before, it\u0026rsquo;s amazing.\n$ rm -rf public\r$ hugo server --watch --verbose\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\rWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\r0 draft content\r0 future content\r0 pages created\r0 tags created\r0 categories created\rin 2 ms\rWatching for changes in /Users/quoha/Sites/zafta/content\rServing pages from /Users/quoha/Sites/zafta/public\rWeb Server is available at http://localhost:1313\rPress Ctrl+C to stop\rINFO: 2014/09/29 File System Event: [\u0026quot;/Users/quoha/Sites/zafta/themes/zafta/layouts/index.html\u0026quot;: MODIFY|ATTRIB]\rChange detected, rebuilding site\rWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\r0 draft content\r0 future content\r0 pages created\r0 tags created\r0 categories created\rin 1 ms\rUpdate the Home Page Template The home page is one of a few special pages that Hugo creates automatically. As mentioned earlier, it looks for one of three files in the theme\u0026rsquo;s layout/ directory:\n index.html _default/list.html _default/single.html  We could update one of the default templates, but a good design decision is to update the most specific template available. That\u0026rsquo;s not a hard and fast rule (in fact, we\u0026rsquo;ll break it a few times in this tutorial), but it is a good generalization.\nMake a Static Home Page Right now, that page is empty because we don\u0026rsquo;t have any content and we don\u0026rsquo;t have any logic in the template. Let\u0026rsquo;s change that by adding some text to the template.\n$ vi themes/zafta/layouts/index.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;hugo says hello!\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r:wq\r$\rBuild the web site and then verify the results.\n$ hugo --verbose\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\rWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\r0 draft content\r0 future content\r0 pages created\r0 tags created\r0 categories created\rin 2 ms\r$ find public -type f -name '*.html' | xargs ls -l\r-rw-r--r-- 1 quoha staff 78 Sep 29 21:26 public/index.html\r$ cat public/index.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;hugo says hello!\u0026lt;/p\u0026gt;\r\u0026lt;/html\u0026gt;\rLive Reload Note: If you\u0026rsquo;re running the server with the --watch option, you\u0026rsquo;ll see different content in the file:\n$ cat public/index.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;hugo says hello!\u0026lt;/p\u0026gt;\r\u0026lt;script\u0026gt;document.write('\u0026lt;script src=\u0026quot;http://'\r+ (location.host || 'localhost').split(':')[0]\r+ ':1313/livereload.js?mindelay=10\u0026quot;\u0026gt;\u0026lt;/'\r+ 'script\u0026gt;')\u0026lt;/script\u0026gt;\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rWhen you use --watch, the Live Reload script is added by Hugo. Look for live reload in the documentation to see what it does and how to disable it.\nBuild a \u0026ldquo;Dynamic\u0026rdquo; Home Page \u0026ldquo;Dynamic home page?\u0026rdquo; Hugo\u0026rsquo;s a static web site generator, so this seems an odd thing to say. I mean let\u0026rsquo;s have the home page automatically reflect the content in the site every time Hugo builds it. We\u0026rsquo;ll use iteration in the template to do that.\nCreate New Posts Now that we have the home page generating static content, let\u0026rsquo;s add some content to the site. We\u0026rsquo;ll display these posts as a list on the home page and on their own page, too.\nHugo has a command to generate a skeleton post, just like it does for sites and themes.\n$ hugo --verbose new post/first.md\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 attempting to create post/first.md of post\rINFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/default.md\rERROR: 2014/09/29 Unable to Cast \u0026lt;nil\u0026gt; to map[string]interface{}\r$\rThat wasn\u0026rsquo;t very nice, was it?\nThe \u0026ldquo;new\u0026rdquo; command uses an archetype to create the post file. Hugo created an empty default archetype file, but that causes an error when there\u0026rsquo;s a theme. For me, the workaround was to create an archetypes file specifically for the post type.\n$ vi themes/zafta/archetypes/post.md\r+++\rDescription = \u0026quot;\u0026quot;\rTags = []\rCategories = []\r+++\r:wq\r$ find themes/zafta/archetypes -type f | xargs ls -l\r-rw-r--r-- 1 quoha staff 0 Sep 29 21:53 themes/zafta/archetypes/default.md\r-rw-r--r-- 1 quoha staff 51 Sep 29 21:54 themes/zafta/archetypes/post.md\r$ hugo --verbose new post/first.md\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 attempting to create post/first.md of post\rINFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/post.md\rINFO: 2014/09/29 creating /Users/quoha/Sites/zafta/content/post/first.md\r/Users/quoha/Sites/zafta/content/post/first.md created\r$ hugo --verbose new post/second.md\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 attempting to create post/second.md of post\rINFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/post.md\rINFO: 2014/09/29 creating /Users/quoha/Sites/zafta/content/post/second.md\r/Users/quoha/Sites/zafta/content/post/second.md created\r$ ls -l content/post\rtotal 16\r-rw-r--r-- 1 quoha staff 104 Sep 29 21:54 first.md\r-rw-r--r-- 1 quoha staff 105 Sep 29 21:57 second.md\r$ cat content/post/first.md\r+++\rCategories = []\rDescription = \u0026quot;\u0026quot;\rTags = []\rdate = \u0026quot;2014-09-29T21:54:53-05:00\u0026quot;\rtitle = \u0026quot;first\u0026quot;\r+++\rmy first post\r$ cat content/post/second.md\r+++\rCategories = []\rDescription = \u0026quot;\u0026quot;\rTags = []\rdate = \u0026quot;2014-09-29T21:57:09-05:00\u0026quot;\rtitle = \u0026quot;second\u0026quot;\r+++\rmy second post\r$\rBuild the web site and then verify the results.\n$ rm -rf public\r$ hugo --verbose\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 found taxonomies: map[string]string{\u0026quot;category\u0026quot;:\u0026quot;categories\u0026quot;, \u0026quot;tag\u0026quot;:\u0026quot;tags\u0026quot;}\rWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\r0 draft content\r0 future content\r2 pages created\r0 tags created\r0 categories created\rin 4 ms\r$\rThe output says that it created 2 pages. Those are our new posts:\n$ find public -type f -name '*.html' | xargs ls -l\r-rw-r--r-- 1 quoha staff 78 Sep 29 22:13 public/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 22:13 public/post/first/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 22:13 public/post/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 22:13 public/post/second/index.html\r$\rThe new files are empty because because the templates used to generate the content are empty. The homepage doesn\u0026rsquo;t show the new content, either. We have to update the templates to add the posts.\nList and Single Templates In Hugo, we have three major kinds of templates. There\u0026rsquo;s the home page template that we updated previously. It is used only by the home page. We also have \u0026ldquo;single\u0026rdquo; templates which are used to generate output for a single content file. We also have \u0026ldquo;list\u0026rdquo; templates that are used to group multiple pieces of content before generating output.\nGenerally speaking, list templates are named \u0026ldquo;list.html\u0026rdquo; and single templates are named \u0026ldquo;single.html.\u0026rdquo;\nThere are three other types of templates: partials, content views, and terms. We will not go into much detail on these.\nAdd Content to the Homepage The home page will contain a list of posts. Let\u0026rsquo;s update its template to add the posts that we just created. The logic in the template will run every time we build the site.\n$ vi themes/zafta/layouts/index.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r{{ range first 10 .Data.Pages }}\r\u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt;\r{{ end }}\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r:wq\r$\rHugo uses the Go template engine. That engine scans the template files for commands which are enclosed between \u0026ldquo;{{\u0026rdquo; and \u0026ldquo;}}\u0026rdquo;. In our template, the commands are:\n range .Title end  The \u0026ldquo;range\u0026rdquo; command is an iterator. We\u0026rsquo;re going to use it to go through the first ten pages. Every HTML file that Hugo creates is treated as a page, so looping through the list of pages will look at every file that will be created.\nThe \u0026ldquo;.Title\u0026rdquo; command prints the value of the \u0026ldquo;title\u0026rdquo; variable. Hugo pulls it from the front matter in the Markdown file.\nThe \u0026ldquo;end\u0026rdquo; command signals the end of the range iterator. The engine loops back to the top of the iteration when it finds \u0026ldquo;end.\u0026rdquo; Everything between the \u0026ldquo;range\u0026rdquo; and \u0026ldquo;end\u0026rdquo; is evaluated every time the engine goes through the iteration. In this file, that would cause the title from the first ten pages to be output as heading level one.\nIt\u0026rsquo;s helpful to remember that some variables, like .Data, are created before any output files. Hugo loads every content file into the variable and then gives the template a chance to process before creating the HTML files.\nBuild the web site and then verify the results.\n$ rm -rf public\r$ hugo --verbose\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 found taxonomies: map[string]string{\u0026quot;tag\u0026quot;:\u0026quot;tags\u0026quot;, \u0026quot;category\u0026quot;:\u0026quot;categories\u0026quot;}\rWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\r0 draft content\r0 future content\r2 pages created\r0 tags created\r0 categories created\rin 4 ms\r$ find public -type f -name '*.html' | xargs ls -l\r-rw-r--r-- 1 quoha staff 94 Sep 29 22:23 public/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 22:23 public/post/first/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 22:23 public/post/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 22:23 public/post/second/index.html\r$ cat public/index.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;second\u0026lt;/h1\u0026gt;\r\u0026lt;h1\u0026gt;first\u0026lt;/h1\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r$\rCongratulations, the home page shows the title of the two posts. The posts themselves are still empty, but let\u0026rsquo;s take a moment to appreciate what we\u0026rsquo;ve done. Your template now generates output dynamically. Believe it or not, by inserting the range command inside of those curly braces, you\u0026rsquo;ve learned everything you need to know to build a theme. All that\u0026rsquo;s really left is understanding which template will be used to generate each content file and becoming familiar with the commands for the template engine.\nAnd, if that were entirely true, this tutorial would be much shorter. There are a few things to know that will make creating a new template much easier. Don\u0026rsquo;t worry, though, that\u0026rsquo;s all to come.\nAdd Content to the Posts We\u0026rsquo;re working with posts, which are in the content/post/ directory. That means that their section is \u0026ldquo;post\u0026rdquo; (and if we don\u0026rsquo;t do something weird, their type is also \u0026ldquo;post\u0026rdquo;).\nHugo uses the section and type to find the template file for every piece of content. Hugo will first look for a template file that matches the section or type name. If it can\u0026rsquo;t find one, then it will look in the _default/ directory. There are some twists that we\u0026rsquo;ll cover when we get to categories and tags, but for now we can assume that Hugo will try post/single.html, then _default/single.html.\nNow that we know the search rule, let\u0026rsquo;s see what we actually have available:\n$ find themes/zafta -name single.html | xargs ls -l\r-rw-r--r-- 1 quoha staff 132 Sep 29 17:31 themes/zafta/layouts/_default/single.html\rWe could create a new template, post/single.html, or change the default. Since we don\u0026rsquo;t know of any other content types, let\u0026rsquo;s start with updating the default.\nRemember, any content that we haven\u0026rsquo;t created a template for will end up using this template. That can be good or bad. Bad because I know that we\u0026rsquo;re going to be adding different types of content and we\u0026rsquo;re going to end up undoing some of the changes we\u0026rsquo;ve made. It\u0026rsquo;s good because we\u0026rsquo;ll be able to see immediate results. It\u0026rsquo;s also good to start here because we can start to build the basic layout for the site. As we add more content types, we\u0026rsquo;ll refactor this file and move logic around. Hugo makes that fairly painless, so we\u0026rsquo;ll accept the cost and proceed.\nPlease see the Hugo documentation on template rendering for all the details on determining which template to use. And, as the docs mention, if you\u0026rsquo;re building a single page application (SPA) web site, you can delete all of the other templates and work with just the default single page. That\u0026rsquo;s a refreshing amount of joy right there.\nUpdate the Template File $ vi themes/zafta/layouts/_default/single.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;title\u0026gt;{{ .Title }}\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt;\r{{ .Content }}\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r:wq\r$\rBuild the web site and verify the results.\n$ rm -rf public\r$ hugo --verbose\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 found taxonomies: map[string]string{\u0026quot;tag\u0026quot;:\u0026quot;tags\u0026quot;, \u0026quot;category\u0026quot;:\u0026quot;categories\u0026quot;}\rWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\r0 draft content\r0 future content\r2 pages created\r0 tags created\r0 categories created\rin 4 ms\r$ find public -type f -name '*.html' | xargs ls -l\r-rw-r--r-- 1 quoha staff 94 Sep 29 22:40 public/index.html\r-rw-r--r-- 1 quoha staff 125 Sep 29 22:40 public/post/first/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 22:40 public/post/index.html\r-rw-r--r-- 1 quoha staff 128 Sep 29 22:40 public/post/second/index.html\r$ cat public/post/first/index.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;title\u0026gt;first\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;first\u0026lt;/h1\u0026gt;\r\u0026lt;p\u0026gt;my first post\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r$ cat public/post/second/index.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;title\u0026gt;second\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;second\u0026lt;/h1\u0026gt;\r\u0026lt;p\u0026gt;my second post\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r$\rNotice that the posts now have content. You can go to localhost:1313/post/first to verify.\nLinking to Content The posts are on the home page. Let\u0026rsquo;s add a link from there to the post. Since this is the home page, we\u0026rsquo;ll update its template.\n$ vi themes/zafta/layouts/index.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r{{ range first 10 .Data.Pages }}\r\u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;{{ .Permalink }}\u0026quot;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt;\r{{ end }}\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rBuild the web site and verify the results.\n$ rm -rf public\r$ hugo --verbose\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 found taxonomies: map[string]string{\u0026quot;tag\u0026quot;:\u0026quot;tags\u0026quot;, \u0026quot;category\u0026quot;:\u0026quot;categories\u0026quot;}\rWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\r0 draft content\r0 future content\r2 pages created\r0 tags created\r0 categories created\rin 4 ms\r$ find public -type f -name '*.html' | xargs ls -l\r-rw-r--r-- 1 quoha staff 149 Sep 29 22:44 public/index.html\r-rw-r--r-- 1 quoha staff 125 Sep 29 22:44 public/post/first/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 22:44 public/post/index.html\r-rw-r--r-- 1 quoha staff 128 Sep 29 22:44 public/post/second/index.html\r$ cat public/index.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;/post/second/\u0026quot;\u0026gt;second\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt;\r\u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;/post/first/\u0026quot;\u0026gt;first\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r$\rCreate a Post Listing We have the posts displaying on the home page and on their own page. We also have a file public/post/index.html that is empty. Let\u0026rsquo;s make it show a list of all posts (not just the first ten).\nWe need to decide which template to update. This will be a listing, so it should be a list template. Let\u0026rsquo;s take a quick look and see which list templates are available.\n$ find themes/zafta -name list.html | xargs ls -l\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/list.html\rAs with the single post, we have to decide to update _default/list.html or create post/list.html. We still don\u0026rsquo;t have multiple content types, so let\u0026rsquo;s stay consistent and update the default list template.\nCreating Top Level Pages Let\u0026rsquo;s add an \u0026ldquo;about\u0026rdquo; page and display it at the top level (as opposed to a sub-level like we did with posts).\nThe default in Hugo is to use the directory structure of the content/ directory to guide the location of the generated html in the public/ directory. Let\u0026rsquo;s verify that by creating an \u0026ldquo;about\u0026rdquo; page at the top level:\n$ vi content/about.md\r+++\rtitle = \u0026quot;about\u0026quot;\rdescription = \u0026quot;about this site\u0026quot;\rdate = \u0026quot;2014-09-27\u0026quot;\rslug = \u0026quot;about time\u0026quot;\r+++\r## about us\ri'm speechless\r:wq\rGenerate the web site and verify the results.\n$ find public -name '*.html' | xargs ls -l\r-rw-rw-r-- 1 mdhender staff 334 Sep 27 15:08 public/about-time/index.html\r-rw-rw-r-- 1 mdhender staff 527 Sep 27 15:08 public/index.html\r-rw-rw-r-- 1 mdhender staff 358 Sep 27 15:08 public/post/first-post/index.html\r-rw-rw-r-- 1 mdhender staff 0 Sep 27 15:08 public/post/index.html\r-rw-rw-r-- 1 mdhender staff 342 Sep 27 15:08 public/post/second-post/index.html\rNotice that the page wasn\u0026rsquo;t created at the top level. It was created in a sub-directory named \u0026lsquo;about-time/\u0026rsquo;. That name came from our slug. Hugo will use the slug to name the generated content. It\u0026rsquo;s a reasonable default, by the way, but we can learn a few things by fighting it for this file.\nOne other thing. Take a look at the home page.\n$ cat public/index.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;http://localhost:1313/post/theme/\u0026quot;\u0026gt;creating a new theme\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt;\r\u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;http://localhost:1313/about-time/\u0026quot;\u0026gt;about\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt;\r\u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;http://localhost:1313/post/second-post/\u0026quot;\u0026gt;second\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt;\r\u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;http://localhost:1313/post/first-post/\u0026quot;\u0026gt;first\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt;\r\u0026lt;script\u0026gt;document.write('\u0026lt;script src=\u0026quot;http://'\r+ (location.host || 'localhost').split(':')[0]\r+ ':1313/livereload.js?mindelay=10\u0026quot;\u0026gt;\u0026lt;/'\r+ 'script\u0026gt;')\u0026lt;/script\u0026gt;\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rNotice that the \u0026ldquo;about\u0026rdquo; link is listed with the posts? That\u0026rsquo;s not desirable, so let\u0026rsquo;s change that first.\n$ vi themes/zafta/layouts/index.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;posts\u0026lt;/h1\u0026gt;\r{{ range first 10 .Data.Pages }}\r{{ if eq .Type \u0026quot;post\u0026quot;}}\r\u0026lt;h2\u0026gt;\u0026lt;a href=\u0026quot;{{ .Permalink }}\u0026quot;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt;\r{{ end }}\r{{ end }}\r\u0026lt;h1\u0026gt;pages\u0026lt;/h1\u0026gt;\r{{ range .Data.Pages }}\r{{ if eq .Type \u0026quot;page\u0026quot; }}\r\u0026lt;h2\u0026gt;\u0026lt;a href=\u0026quot;{{ .Permalink }}\u0026quot;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt;\r{{ end }}\r{{ end }}\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r:wq\rGenerate the web site and verify the results. The home page has two sections, posts and pages, and each section has the right set of headings and links in it.\nBut, that about page still renders to about-time/index.html.\n$ find public -name '*.html' | xargs ls -l\r-rw-rw-r-- 1 mdhender staff 334 Sep 27 15:33 public/about-time/index.html\r-rw-rw-r-- 1 mdhender staff 645 Sep 27 15:33 public/index.html\r-rw-rw-r-- 1 mdhender staff 358 Sep 27 15:33 public/post/first-post/index.html\r-rw-rw-r-- 1 mdhender staff 0 Sep 27 15:33 public/post/index.html\r-rw-rw-r-- 1 mdhender staff 342 Sep 27 15:33 public/post/second-post/index.html\rKnowing that hugo is using the slug to generate the file name, the simplest solution is to change the slug. Let\u0026rsquo;s do it the hard way and change the permalink in the configuration file.\n$ vi config.toml\r[permalinks]\rpage = \u0026quot;/:title/\u0026quot;\rabout = \u0026quot;/:filename/\u0026quot;\rGenerate the web site and verify that this didn\u0026rsquo;t work. Hugo lets \u0026ldquo;slug\u0026rdquo; or \u0026ldquo;URL\u0026rdquo; override the permalinks setting in the configuration file. Go ahead and comment out the slug in content/about.md, then generate the web site to get it to be created in the right place.\nSharing Templates If you\u0026rsquo;ve been following along, you probably noticed that posts have titles in the browser and the home page doesn\u0026rsquo;t. That\u0026rsquo;s because we didn\u0026rsquo;t put the title in the home page\u0026rsquo;s template (layouts/index.html). That\u0026rsquo;s an easy thing to do, but let\u0026rsquo;s look at a different option.\nWe can put the common bits into a shared template that\u0026rsquo;s stored in the themes/zafta/layouts/partials/ directory.\nCreate the Header and Footer Partials In Hugo, a partial is a sugar-coated template. Normally a template reference has a path specified. Partials are different. Hugo searches for them along a TODO defined search path. This makes it easier for end-users to override the theme\u0026rsquo;s presentation.\n$ vi themes/zafta/layouts/partials/header.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;title\u0026gt;{{ .Title }}\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r:wq\r$ vi themes/zafta/layouts/partials/footer.html\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r:wq\rUpdate the Home Page Template to Use the Partials The most noticeable difference between a template call and a partials call is the lack of path:\n{{ template \u0026quot;theme/partials/header.html\u0026quot; . }}\rversus\n{{ partial \u0026quot;header.html\u0026quot; . }}\rBoth pass in the context.\nLet\u0026rsquo;s change the home page template to use these new partials.\n$ vi themes/zafta/layouts/index.html\r{{ partial \u0026quot;header.html\u0026quot; . }}\r\u0026lt;h1\u0026gt;posts\u0026lt;/h1\u0026gt;\r{{ range first 10 .Data.Pages }}\r{{ if eq .Type \u0026quot;post\u0026quot;}}\r\u0026lt;h2\u0026gt;\u0026lt;a href=\u0026quot;{{ .Permalink }}\u0026quot;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt;\r{{ end }}\r{{ end }}\r\u0026lt;h1\u0026gt;pages\u0026lt;/h1\u0026gt;\r{{ range .Data.Pages }}\r{{ if or (eq .Type \u0026quot;page\u0026quot;) (eq .Type \u0026quot;about\u0026quot;) }}\r\u0026lt;h2\u0026gt;\u0026lt;a href=\u0026quot;{{ .Permalink }}\u0026quot;\u0026gt;{{ .Type }} - {{ .Title }} - {{ .RelPermalink }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt;\r{{ end }}\r{{ end }}\r{{ partial \u0026quot;footer.html\u0026quot; . }}\r:wq\rGenerate the web site and verify the results. The title on the home page is now \u0026ldquo;your title here\u0026rdquo;, which comes from the \u0026ldquo;title\u0026rdquo; variable in the config.toml file.\nUpdate the Default Single Template to Use the Partials $ vi themes/zafta/layouts/_default/single.html\r{{ partial \u0026quot;header.html\u0026quot; . }}\r\u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt;\r{{ .Content }}\r{{ partial \u0026quot;footer.html\u0026quot; . }}\r:wq\rGenerate the web site and verify the results. The title on the posts and the about page should both reflect the value in the markdown file.\nAdd “Date Published” to Posts It\u0026rsquo;s common to have posts display the date that they were written or published, so let\u0026rsquo;s add that. The front matter of our posts has a variable named \u0026ldquo;date.\u0026rdquo; It\u0026rsquo;s usually the date the content was created, but let\u0026rsquo;s pretend that\u0026rsquo;s the value we want to display.\nAdd “Date Published” to the Template We\u0026rsquo;ll start by updating the template used to render the posts. The template code will look like:\n{{ .Date.Format \u0026quot;Mon, Jan 2, 2006\u0026quot; }}\rPosts use the default single template, so we\u0026rsquo;ll change that file.\n$ vi themes/zafta/layouts/_default/single.html\r{{ partial \u0026quot;header.html\u0026quot; . }}\r\u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt;\r\u0026lt;h2\u0026gt;{{ .Date.Format \u0026quot;Mon, Jan 2, 2006\u0026quot; }}\u0026lt;/h2\u0026gt;\r{{ .Content }}\r{{ partial \u0026quot;footer.html\u0026quot; . }}\r:wq\rGenerate the web site and verify the results. The posts now have the date displayed in them. There\u0026rsquo;s a problem, though. The \u0026ldquo;about\u0026rdquo; page also has the date displayed.\nAs usual, there are a couple of ways to make the date display only on posts. We could do an \u0026ldquo;if\u0026rdquo; statement like we did on the home page. Another way would be to create a separate template for posts.\nThe \u0026ldquo;if\u0026rdquo; solution works for sites that have just a couple of content types. It aligns with the principle of \u0026ldquo;code for today,\u0026rdquo; too.\nLet\u0026rsquo;s assume, though, that we\u0026rsquo;ve made our site so complex that we feel we have to create a new template type. In Hugo-speak, we\u0026rsquo;re going to create a section template.\nLet\u0026rsquo;s restore the default single template before we forget.\n$ mkdir themes/zafta/layouts/post\r$ vi themes/zafta/layouts/_default/single.html\r{{ partial \u0026quot;header.html\u0026quot; . }}\r\u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt;\r{{ .Content }}\r{{ partial \u0026quot;footer.html\u0026quot; . }}\r:wq\rNow we\u0026rsquo;ll update the post\u0026rsquo;s version of the single template. If you remember Hugo\u0026rsquo;s rules, the template engine will use this version over the default.\n$ vi themes/zafta/layouts/post/single.html\r{{ partial \u0026quot;header.html\u0026quot; . }}\r\u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt;\r\u0026lt;h2\u0026gt;{{ .Date.Format \u0026quot;Mon, Jan 2, 2006\u0026quot; }}\u0026lt;/h2\u0026gt;\r{{ .Content }}\r{{ partial \u0026quot;footer.html\u0026quot; . }}\r:wq\rNote that we removed the date logic from the default template and put it in the post template. Generate the web site and verify the results. Posts have dates and the about page doesn\u0026rsquo;t.\nDon\u0026rsquo;t Repeat Yourself DRY is a good design goal and Hugo does a great job supporting it. Part of the art of a good template is knowing when to add a new template and when to update an existing one. While you\u0026rsquo;re figuring that out, accept that you\u0026rsquo;ll be doing some refactoring. Hugo makes that easy and fast, so it\u0026rsquo;s okay to delay splitting up a template.\n","pubDate":"2017-08-31","title":"英语创建一个新的主题"},{"link":"https://huachengzhou.github.io/life/posts/%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E5%BE%88%E9%95%BF%E7%9A%84%E6%A0%87%E9%A2%98/","plain":"This is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long titleThis is a very long title\n","pubDate":"2017-08-30","title":"这是一个很长的标题"},{"link":"https://huachengzhou.github.io/life/posts/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E4%B8%BB%E9%A2%98/","plain":"Introduction This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I\u0026rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won\u0026rsquo;t cover using CSS to style your theme.\nWe\u0026rsquo;ll start with creating a new site with a very basic template. Then we\u0026rsquo;ll add in a few pages and posts. With small variations on that, you will be able to create many different types of web sites.\nIn this tutorial, commands that you enter will start with the \u0026ldquo;$\u0026rdquo; prompt. The output will follow. Lines that start with \u0026ldquo;#\u0026rdquo; are comments that I\u0026rsquo;ve added to explain a point. When I show updates to a file, the \u0026ldquo;:wq\u0026rdquo; on the last line means to save the file.\nHere\u0026rsquo;s an example:\n## this is a comment\r$ echo this is a command\rthis is a command\r## edit the file\r$vi foo.md\r+++\rdate = \u0026quot;2014-09-28\u0026quot;\rtitle = \u0026quot;creating a new theme\u0026quot;\r+++\rbah and humbug\r:wq\r## show it\r$ cat foo.md\r+++\rdate = \u0026quot;2014-09-28\u0026quot;\rtitle = \u0026quot;creating a new theme\u0026quot;\r+++\rbah and humbug\r$\rSome Definitions There are a few concepts that you need to understand before creating a theme.\nSkins Skins are the files responsible for the look and feel of your site. It’s the CSS that controls colors and fonts, it’s the Javascript that determines actions and reactions. It’s also the rules that Hugo uses to transform your content into the HTML that the site will serve to visitors.\nYou have two ways to create a skin. The simplest way is to create it in the layouts/ directory. If you do, then you don’t have to worry about configuring Hugo to recognize it. The first place that Hugo will look for rules and files is in the layouts/ directory so it will always find the skin.\nYour second choice is to create it in a sub-directory of the themes/ directory. If you do, then you must always tell Hugo where to search for the skin. It’s extra work, though, so why bother with it?\nThe difference between creating a skin in layouts/ and creating it in themes/ is very subtle. A skin in layouts/ can’t be customized without updating the templates and static files that it is built from. A skin created in themes/, on the other hand, can be and that makes it easier for other people to use it.\nThe rest of this tutorial will call a skin created in the themes/ directory a theme.\nNote that you can use this tutorial to create a skin in the layouts/ directory if you wish to. The main difference will be that you won’t need to update the site’s configuration file to use a theme.\nThe Home Page The home page, or landing page, is the first page that many visitors to a site see. It is the index.html file in the root directory of the web site. Since Hugo writes files to the public/ directory, our home page is public/index.html.\nSite Configuration File When Hugo runs, it looks for a configuration file that contains settings that override default values for the entire site. The file can use TOML, YAML, or JSON. I prefer to use TOML for my configuration files. If you prefer to use JSON or YAML, you’ll need to translate my examples. You’ll also need to change the name of the file since Hugo uses the extension to determine how to process it.\nHugo translates Markdown files into HTML. By default, Hugo expects to find Markdown files in your content/ directory and template files in your themes/ directory. It will create HTML files in your public/ directory. You can change this by specifying alternate locations in the configuration file.\nContent Content is stored in text files that contain two sections. The first section is the “front matter,” which is the meta-information on the content. The second section contains Markdown that will be converted to HTML.\nFront Matter The front matter is information about the content. Like the configuration file, it can be written in TOML, YAML, or JSON. Unlike the configuration file, Hugo doesn’t use the file’s extension to know the format. It looks for markers to signal the type. TOML is surrounded by “+++”, YAML by “---”, and JSON is enclosed in curly braces. I prefer to use TOML, so you’ll need to translate my examples if you prefer YAML or JSON.\nThe information in the front matter is passed into the template before the content is rendered into HTML.\nMarkdown Content is written in Markdown which makes it easier to create the content. Hugo runs the content through a Markdown engine to create the HTML which will be written to the output file.\nTemplate Files Hugo uses template files to render content into HTML. Template files are a bridge between the content and presentation. Rules in the template define what content is published, where it\u0026rsquo;s published to, and how it will rendered to the HTML file. The template guides the presentation by specifying the style to use.\nThere are three types of templates: single, list, and partial. Each type takes a bit of content as input and transforms it based on the commands in the template.\nHugo uses its knowledge of the content to find the template file used to render the content. If it can’t find a template that is an exact match for the content, it will shift up a level and search from there. It will continue to do so until it finds a matching template or runs out of templates to try. If it can’t find a template, it will use the default template for the site.\nPlease note that you can use the front matter to influence Hugo’s choice of templates.\nSingle Template A single template is used to render a single piece of content. For example, an article or post would be a single piece of content and use a single template.\nList Template A list template renders a group of related content. That could be a summary of recent postings or all articles in a category. List templates can contain multiple groups.\nThe homepage template is a special type of list template. Hugo assumes that the home page of your site will act as the portal for the rest of the content in the site.\nPartial Template A partial template is a template that can be included in other templates. Partial templates must be called using the “partial” template command. They are very handy for rolling up common behavior. For example, your site may have a banner that all pages use. Instead of copying the text of the banner into every single and list template, you could create a partial with the banner in it. That way if you decide to change the banner, you only have to change the partial template.\nCreate a New Site Let\u0026rsquo;s use Hugo to create a new web site. I\u0026rsquo;m a Mac user, so I\u0026rsquo;ll create mine in my home directory, in the Sites folder. If you\u0026rsquo;re using Linux, you might have to create the folder first.\nThe \u0026ldquo;new site\u0026rdquo; command will create a skeleton of a site. It will give you the basic directory structure and a useable configuration file.\n$ hugo new site ~/Sites/zafta\r$ cd ~/Sites/zafta\r$ ls -l\rtotal 8\rdrwxr-xr-x 7 quoha staff 238 Sep 29 16:49 .\rdrwxr-xr-x 3 quoha staff 102 Sep 29 16:49 ..\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 archetypes\r-rw-r--r-- 1 quoha staff 82 Sep 29 16:49 config.toml\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 content\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 layouts\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 static\r$\rTake a look in the content/ directory to confirm that it is empty.\nThe other directories (archetypes/, layouts/, and static/) are used when customizing a theme. That\u0026rsquo;s a topic for a different tutorial, so please ignore them for now.\nGenerate the HTML For the New Site Running the hugo command with no options will read all the available content and generate the HTML files. It will also copy all static files (that\u0026rsquo;s everything that\u0026rsquo;s not content). Since we have an empty site, it won\u0026rsquo;t do much, but it will do it very quickly.\n$ hugo --verbose\rINFO: 2014/09/29 Using config file: config.toml\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\rWARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html]\rWARN: 2014/09/29 Unable to locate layout: [404.html]\r0 draft content\r0 future content\r0 pages created\r0 tags created\r0 categories created\rin 2 ms\r$\rThe \u0026ldquo;--verbose\u0026rdquo; flag gives extra information that will be helpful when we build the template. Every line of the output that starts with \u0026ldquo;INFO:\u0026rdquo; or \u0026ldquo;WARN:\u0026rdquo; is present because we used that flag. The lines that start with \u0026ldquo;WARN:\u0026rdquo; are warning messages. We\u0026rsquo;ll go over them later.\nWe can verify that the command worked by looking at the directory again.\n$ ls -l\rtotal 8\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 archetypes\r-rw-r--r-- 1 quoha staff 82 Sep 29 16:49 config.toml\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 content\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 layouts\rdrwxr-xr-x 4 quoha staff 136 Sep 29 17:02 public\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 static\r$\rSee that new public/ directory? Hugo placed all generated content there. When you\u0026rsquo;re ready to publish your web site, that\u0026rsquo;s the place to start. For now, though, let\u0026rsquo;s just confirm that we have what we\u0026rsquo;d expect from a site with no content.\n$ ls -l public\rtotal 16\r-rw-r--r-- 1 quoha staff 416 Sep 29 17:02 index.xml\r-rw-r--r-- 1 quoha staff 262 Sep 29 17:02 sitemap.xml\r$\rHugo created two XML files, which is standard, but there are no HTML files.\nTest the New Site Verify that you can run the built-in web server. It will dramatically shorten your development cycle if you do. Start it by running the \u0026ldquo;server\u0026rdquo; command. If it is successful, you will see output similar to the following:\n$ hugo server --verbose\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\rWARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html]\rWARN: 2014/09/29 Unable to locate layout: [404.html]\r0 draft content\r0 future content\r0 pages created\r0 tags created\r0 categories created\rin 2 ms\rServing pages from /Users/quoha/Sites/zafta/public\rWeb Server is available at http://localhost:1313\rPress Ctrl+C to stop\rConnect to the listed URL (it\u0026rsquo;s on the line that starts with \u0026ldquo;Web Server\u0026rdquo;). If everything is working correctly, you should get a page that shows the following:\nindex.xml\rsitemap.xml\rThat\u0026rsquo;s a listing of your public/ directory. Hugo didn\u0026rsquo;t create a home page because our site has no content. When there\u0026rsquo;s no index.html file in a directory, the server lists the files in the directory, which is what you should see in your browser.\nLet’s go back and look at those warnings again.\nWARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html]\rWARN: 2014/09/29 Unable to locate layout: [404.html]\rThat second warning is easier to explain. We haven’t created a template to be used to generate “page not found errors.” The 404 message is a topic for a separate tutorial.\nNow for the first warning. It is for the home page. You can tell because the first layout that it looked for was “index.html.” That’s only used by the home page.\nI like that the verbose flag causes Hugo to list the files that it\u0026rsquo;s searching for. For the home page, they are index.html, _default/list.html, and _default/single.html. There are some rules that we\u0026rsquo;ll cover later that explain the names and paths. For now, just remember that Hugo couldn\u0026rsquo;t find a template for the home page and it told you so.\nAt this point, you\u0026rsquo;ve got a working installation and site that we can build upon. All that’s left is to add some content and a theme to display it.\nCreate a New Theme Hugo doesn\u0026rsquo;t ship with a default theme. There are a few available (I counted a dozen when I first installed Hugo) and Hugo comes with a command to create new themes.\nWe\u0026rsquo;re going to create a new theme called \u0026ldquo;zafta.\u0026rdquo; Since the goal of this tutorial is to show you how to fill out the files to pull in your content, the theme will not contain any CSS. In other words, ugly but functional.\nAll themes have opinions on content and layout. For example, Zafta uses \u0026ldquo;post\u0026rdquo; over \u0026ldquo;blog\u0026rdquo;. Strong opinions make for simpler templates but differing opinions make it tougher to use themes. When you build a theme, consider using the terms that other themes do.\nCreate a Skeleton Use the hugo \u0026ldquo;new\u0026rdquo; command to create the skeleton of a theme. This creates the directory structure and places empty files for you to fill out.\n$ hugo new theme zafta\r$ ls -l\rtotal 8\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 archetypes\r-rw-r--r-- 1 quoha staff 82 Sep 29 16:49 config.toml\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 content\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 layouts\rdrwxr-xr-x 4 quoha staff 136 Sep 29 17:02 public\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 static\rdrwxr-xr-x 3 quoha staff 102 Sep 29 17:31 themes\r$ find themes -type f | xargs ls -l\r-rw-r--r-- 1 quoha staff 1081 Sep 29 17:31 themes/zafta/LICENSE.md\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/archetypes/default.md\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/list.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/single.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/footer.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/header.html\r-rw-r--r-- 1 quoha staff 93 Sep 29 17:31 themes/zafta/theme.toml\r$\rThe skeleton includes templates (the files ending in .html), license file, a description of your theme (the theme.toml file), and an empty archetype.\nPlease take a minute to fill out the theme.toml and LICENSE.md files. They\u0026rsquo;re optional, but if you\u0026rsquo;re going to be distributing your theme, it tells the world who to praise (or blame). It\u0026rsquo;s also nice to declare the license so that people will know how they can use the theme.\n$ vi themes/zafta/theme.toml\rauthor = \u0026quot;michael d henderson\u0026quot;\rdescription = \u0026quot;a minimal working template\u0026quot;\rlicense = \u0026quot;MIT\u0026quot;\rname = \u0026quot;zafta\u0026quot;\rsource_repo = \u0026quot;\u0026quot;\rtags = [\u0026quot;tags\u0026quot;, \u0026quot;categories\u0026quot;]\r:wq\r## also edit themes/zafta/LICENSE.md and change\r## the bit that says \u0026quot;YOUR_NAME_HERE\u0026quot;\rNote that the the skeleton\u0026rsquo;s template files are empty. Don\u0026rsquo;t worry, we\u0026rsquo;ll be changing that shortly.\n$ find themes/zafta -name '*.html' | xargs ls -l\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/list.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/single.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/footer.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/header.html\r$\rUpdate the Configuration File to Use the Theme Now that we\u0026rsquo;ve got a theme to work with, it\u0026rsquo;s a good idea to add the theme name to the configuration file. This is optional, because you can always add \u0026ldquo;-t zafta\u0026rdquo; on all your commands. I like to put it the configuration file because I like shorter command lines. If you don\u0026rsquo;t put it in the configuration file or specify it on the command line, you won\u0026rsquo;t use the template that you\u0026rsquo;re expecting to.\nEdit the file to add the theme, add a title for the site, and specify that all of our content will use the TOML format.\n$ vi config.toml\rtheme = \u0026quot;zafta\u0026quot;\rbaseurl = \u0026quot;\u0026quot;\rlanguageCode = \u0026quot;en-us\u0026quot;\rtitle = \u0026quot;zafta - totally refreshing\u0026quot;\rMetaDataFormat = \u0026quot;toml\u0026quot;\r:wq\r$\rGenerate the Site Now that we have an empty theme, let\u0026rsquo;s generate the site again.\n$ hugo --verbose\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\rWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\r0 draft content\r0 future content\r0 pages created\r0 tags created\r0 categories created\rin 2 ms\r$\rDid you notice that the output is different? The warning message for the home page has disappeared and we have an additional information line saying that Hugo is syncing from the theme\u0026rsquo;s directory.\nLet\u0026rsquo;s check the public/ directory to see what Hugo\u0026rsquo;s created.\n$ ls -l public\rtotal 16\rdrwxr-xr-x 2 quoha staff 68 Sep 29 17:56 css\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:56 index.html\r-rw-r--r-- 1 quoha staff 407 Sep 29 17:56 index.xml\rdrwxr-xr-x 2 quoha staff 68 Sep 29 17:56 js\r-rw-r--r-- 1 quoha staff 243 Sep 29 17:56 sitemap.xml\r$\rNotice four things:\n Hugo created a home page. This is the file public/index.html. Hugo created a css/ directory. Hugo created a js/ directory. Hugo claimed that it created 0 pages. It created a file and copied over static files, but didn\u0026rsquo;t create any pages. That\u0026rsquo;s because it considers a \u0026ldquo;page\u0026rdquo; to be a file created directly from a content file. It doesn\u0026rsquo;t count things like the index.html files that it creates automatically.  The Home Page Hugo supports many different types of templates. The home page is special because it gets its own type of template and its own template file. The file, layouts/index.html, is used to generate the HTML for the home page. The Hugo documentation says that this is the only required template, but that depends. Hugo\u0026rsquo;s warning message shows that it looks for three different templates:\nWARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html]\rIf it can\u0026rsquo;t find any of these, it completely skips creating the home page. We noticed that when we built the site without having a theme installed.\nWhen Hugo created our theme, it created an empty home page template. Now, when we build the site, Hugo finds the template and uses it to generate the HTML for the home page. Since the template file is empty, the HTML file is empty, too. If the template had any rules in it, then Hugo would have used them to generate the home page.\n$ find . -name index.html | xargs ls -l\r-rw-r--r-- 1 quoha staff 0 Sep 29 20:21 ./public/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 ./themes/zafta/layouts/index.html\r$\rThe Magic of Static Hugo does two things when generating the site. It uses templates to transform content into HTML and it copies static files into the site. Unlike content, static files are not transformed. They are copied exactly as they are.\nHugo assumes that your site will use both CSS and JavaScript, so it creates directories in your theme to hold them. Remember opinions? Well, Hugo\u0026rsquo;s opinion is that you\u0026rsquo;ll store your CSS in a directory named css/ and your JavaScript in a directory named js/. If you don\u0026rsquo;t like that, you can change the directory names in your theme directory or even delete them completely. Hugo\u0026rsquo;s nice enough to offer its opinion, then behave nicely if you disagree.\n$ find themes/zafta -type d | xargs ls -ld\rdrwxr-xr-x 7 quoha staff 238 Sep 29 17:38 themes/zafta\rdrwxr-xr-x 3 quoha staff 102 Sep 29 17:31 themes/zafta/archetypes\rdrwxr-xr-x 5 quoha staff 170 Sep 29 17:31 themes/zafta/layouts\rdrwxr-xr-x 4 quoha staff 136 Sep 29 17:31 themes/zafta/layouts/_default\rdrwxr-xr-x 4 quoha staff 136 Sep 29 17:31 themes/zafta/layouts/partials\rdrwxr-xr-x 4 quoha staff 136 Sep 29 17:31 themes/zafta/static\rdrwxr-xr-x 2 quoha staff 68 Sep 29 17:31 themes/zafta/static/css\rdrwxr-xr-x 2 quoha staff 68 Sep 29 17:31 themes/zafta/static/js\r$\rThe Theme Development Cycle When you\u0026rsquo;re working on a theme, you will make changes in the theme\u0026rsquo;s directory, rebuild the site, and check your changes in the browser. Hugo makes this very easy:\n Purge the public/ directory. Run the built in web server in watch mode. Open your site in a browser. Update the theme. Glance at your browser window to see changes. Return to step 4.  I’ll throw in one more opinion: never work on a theme on a live site. Always work on a copy of your site. Make changes to your theme, test them, then copy them up to your site. For added safety, use a tool like Git to keep a revision history of your content and your theme. Believe me when I say that it is too easy to lose both your mind and your changes.\nCheck the main Hugo site for information on using Git with Hugo.\nPurge the public/ Directory When generating the site, Hugo will create new files and update existing ones in the public/ directory. It will not delete files that are no longer used. For example, files that were created in the wrong directory or with the wrong title will remain. If you leave them, you might get confused by them later. I recommend cleaning out your site prior to generating it.\nNote: If you\u0026rsquo;re building on an SSD, you should ignore this. Churning on a SSD can be costly.\nHugo\u0026rsquo;s Watch Option Hugo\u0026rsquo;s \u0026ldquo;--watch\u0026rdquo; option will monitor the content/ and your theme directories for changes and rebuild the site automatically.\nLive Reload Hugo\u0026rsquo;s built in web server supports live reload. As pages are saved on the server, the browser is told to refresh the page. Usually, this happens faster than you can say, \u0026ldquo;Wow, that\u0026rsquo;s totally amazing.\u0026rdquo;\nDevelopment Commands Use the following commands as the basis for your workflow.\n## purge old files. hugo will recreate the public directory.\r##\r$ rm -rf public\r##\r## run hugo in watch mode\r##\r$ hugo server --watch --verbose\rHere\u0026rsquo;s sample output showing Hugo detecting a change to the template for the home page. Once generated, the web browser automatically reloaded the page. I\u0026rsquo;ve said this before, it\u0026rsquo;s amazing.\n$ rm -rf public\r$ hugo server --watch --verbose\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\rWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\r0 draft content\r0 future content\r0 pages created\r0 tags created\r0 categories created\rin 2 ms\rWatching for changes in /Users/quoha/Sites/zafta/content\rServing pages from /Users/quoha/Sites/zafta/public\rWeb Server is available at http://localhost:1313\rPress Ctrl+C to stop\rINFO: 2014/09/29 File System Event: [\u0026quot;/Users/quoha/Sites/zafta/themes/zafta/layouts/index.html\u0026quot;: MODIFY|ATTRIB]\rChange detected, rebuilding site\rWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\r0 draft content\r0 future content\r0 pages created\r0 tags created\r0 categories created\rin 1 ms\rUpdate the Home Page Template The home page is one of a few special pages that Hugo creates automatically. As mentioned earlier, it looks for one of three files in the theme\u0026rsquo;s layout/ directory:\n index.html _default/list.html _default/single.html  We could update one of the default templates, but a good design decision is to update the most specific template available. That\u0026rsquo;s not a hard and fast rule (in fact, we\u0026rsquo;ll break it a few times in this tutorial), but it is a good generalization.\nMake a Static Home Page Right now, that page is empty because we don\u0026rsquo;t have any content and we don\u0026rsquo;t have any logic in the template. Let\u0026rsquo;s change that by adding some text to the template.\n$ vi themes/zafta/layouts/index.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;hugo says hello!\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r:wq\r$\rBuild the web site and then verify the results.\n$ hugo --verbose\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\rWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\r0 draft content\r0 future content\r0 pages created\r0 tags created\r0 categories created\rin 2 ms\r$ find public -type f -name '*.html' | xargs ls -l\r-rw-r--r-- 1 quoha staff 78 Sep 29 21:26 public/index.html\r$ cat public/index.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;hugo says hello!\u0026lt;/p\u0026gt;\r\u0026lt;/html\u0026gt;\rLive Reload Note: If you\u0026rsquo;re running the server with the --watch option, you\u0026rsquo;ll see different content in the file:\n$ cat public/index.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;hugo says hello!\u0026lt;/p\u0026gt;\r\u0026lt;script\u0026gt;document.write('\u0026lt;script src=\u0026quot;http://'\r+ (location.host || 'localhost').split(':')[0]\r+ ':1313/livereload.js?mindelay=10\u0026quot;\u0026gt;\u0026lt;/'\r+ 'script\u0026gt;')\u0026lt;/script\u0026gt;\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rWhen you use --watch, the Live Reload script is added by Hugo. Look for live reload in the documentation to see what it does and how to disable it.\nBuild a \u0026ldquo;Dynamic\u0026rdquo; Home Page \u0026ldquo;Dynamic home page?\u0026rdquo; Hugo\u0026rsquo;s a static web site generator, so this seems an odd thing to say. I mean let\u0026rsquo;s have the home page automatically reflect the content in the site every time Hugo builds it. We\u0026rsquo;ll use iteration in the template to do that.\nCreate New Posts Now that we have the home page generating static content, let\u0026rsquo;s add some content to the site. We\u0026rsquo;ll display these posts as a list on the home page and on their own page, too.\nHugo has a command to generate a skeleton post, just like it does for sites and themes.\n$ hugo --verbose new post/first.md\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 attempting to create post/first.md of post\rINFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/default.md\rERROR: 2014/09/29 Unable to Cast \u0026lt;nil\u0026gt; to map[string]interface{}\r$\rThat wasn\u0026rsquo;t very nice, was it?\nThe \u0026ldquo;new\u0026rdquo; command uses an archetype to create the post file. Hugo created an empty default archetype file, but that causes an error when there\u0026rsquo;s a theme. For me, the workaround was to create an archetypes file specifically for the post type.\n$ vi themes/zafta/archetypes/post.md\r+++\rDescription = \u0026quot;\u0026quot;\rTags = []\rCategories = []\r+++\r:wq\r$ find themes/zafta/archetypes -type f | xargs ls -l\r-rw-r--r-- 1 quoha staff 0 Sep 29 21:53 themes/zafta/archetypes/default.md\r-rw-r--r-- 1 quoha staff 51 Sep 29 21:54 themes/zafta/archetypes/post.md\r$ hugo --verbose new post/first.md\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 attempting to create post/first.md of post\rINFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/post.md\rINFO: 2014/09/29 creating /Users/quoha/Sites/zafta/content/post/first.md\r/Users/quoha/Sites/zafta/content/post/first.md created\r$ hugo --verbose new post/second.md\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 attempting to create post/second.md of post\rINFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/post.md\rINFO: 2014/09/29 creating /Users/quoha/Sites/zafta/content/post/second.md\r/Users/quoha/Sites/zafta/content/post/second.md created\r$ ls -l content/post\rtotal 16\r-rw-r--r-- 1 quoha staff 104 Sep 29 21:54 first.md\r-rw-r--r-- 1 quoha staff 105 Sep 29 21:57 second.md\r$ cat content/post/first.md\r+++\rCategories = []\rDescription = \u0026quot;\u0026quot;\rTags = []\rdate = \u0026quot;2014-09-29T21:54:53-05:00\u0026quot;\rtitle = \u0026quot;first\u0026quot;\r+++\rmy first post\r$ cat content/post/second.md\r+++\rCategories = []\rDescription = \u0026quot;\u0026quot;\rTags = []\rdate = \u0026quot;2014-09-29T21:57:09-05:00\u0026quot;\rtitle = \u0026quot;second\u0026quot;\r+++\rmy second post\r$\rBuild the web site and then verify the results.\n$ rm -rf public\r$ hugo --verbose\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 found taxonomies: map[string]string{\u0026quot;category\u0026quot;:\u0026quot;categories\u0026quot;, \u0026quot;tag\u0026quot;:\u0026quot;tags\u0026quot;}\rWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\r0 draft content\r0 future content\r2 pages created\r0 tags created\r0 categories created\rin 4 ms\r$\rThe output says that it created 2 pages. Those are our new posts:\n$ find public -type f -name '*.html' | xargs ls -l\r-rw-r--r-- 1 quoha staff 78 Sep 29 22:13 public/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 22:13 public/post/first/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 22:13 public/post/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 22:13 public/post/second/index.html\r$\rThe new files are empty because because the templates used to generate the content are empty. The homepage doesn\u0026rsquo;t show the new content, either. We have to update the templates to add the posts.\nList and Single Templates In Hugo, we have three major kinds of templates. There\u0026rsquo;s the home page template that we updated previously. It is used only by the home page. We also have \u0026ldquo;single\u0026rdquo; templates which are used to generate output for a single content file. We also have \u0026ldquo;list\u0026rdquo; templates that are used to group multiple pieces of content before generating output.\nGenerally speaking, list templates are named \u0026ldquo;list.html\u0026rdquo; and single templates are named \u0026ldquo;single.html.\u0026rdquo;\nThere are three other types of templates: partials, content views, and terms. We will not go into much detail on these.\nAdd Content to the Homepage The home page will contain a list of posts. Let\u0026rsquo;s update its template to add the posts that we just created. The logic in the template will run every time we build the site.\n$ vi themes/zafta/layouts/index.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r{{ range first 10 .Data.Pages }}\r\u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt;\r{{ end }}\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r:wq\r$\rHugo uses the Go template engine. That engine scans the template files for commands which are enclosed between \u0026ldquo;{{\u0026rdquo; and \u0026ldquo;}}\u0026rdquo;. In our template, the commands are:\n range .Title end  The \u0026ldquo;range\u0026rdquo; command is an iterator. We\u0026rsquo;re going to use it to go through the first ten pages. Every HTML file that Hugo creates is treated as a page, so looping through the list of pages will look at every file that will be created.\nThe \u0026ldquo;.Title\u0026rdquo; command prints the value of the \u0026ldquo;title\u0026rdquo; variable. Hugo pulls it from the front matter in the Markdown file.\nThe \u0026ldquo;end\u0026rdquo; command signals the end of the range iterator. The engine loops back to the top of the iteration when it finds \u0026ldquo;end.\u0026rdquo; Everything between the \u0026ldquo;range\u0026rdquo; and \u0026ldquo;end\u0026rdquo; is evaluated every time the engine goes through the iteration. In this file, that would cause the title from the first ten pages to be output as heading level one.\nIt\u0026rsquo;s helpful to remember that some variables, like .Data, are created before any output files. Hugo loads every content file into the variable and then gives the template a chance to process before creating the HTML files.\nBuild the web site and then verify the results.\n$ rm -rf public\r$ hugo --verbose\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 found taxonomies: map[string]string{\u0026quot;tag\u0026quot;:\u0026quot;tags\u0026quot;, \u0026quot;category\u0026quot;:\u0026quot;categories\u0026quot;}\rWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\r0 draft content\r0 future content\r2 pages created\r0 tags created\r0 categories created\rin 4 ms\r$ find public -type f -name '*.html' | xargs ls -l\r-rw-r--r-- 1 quoha staff 94 Sep 29 22:23 public/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 22:23 public/post/first/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 22:23 public/post/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 22:23 public/post/second/index.html\r$ cat public/index.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;second\u0026lt;/h1\u0026gt;\r\u0026lt;h1\u0026gt;first\u0026lt;/h1\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r$\rCongratulations, the home page shows the title of the two posts. The posts themselves are still empty, but let\u0026rsquo;s take a moment to appreciate what we\u0026rsquo;ve done. Your template now generates output dynamically. Believe it or not, by inserting the range command inside of those curly braces, you\u0026rsquo;ve learned everything you need to know to build a theme. All that\u0026rsquo;s really left is understanding which template will be used to generate each content file and becoming familiar with the commands for the template engine.\nAnd, if that were entirely true, this tutorial would be much shorter. There are a few things to know that will make creating a new template much easier. Don\u0026rsquo;t worry, though, that\u0026rsquo;s all to come.\nAdd Content to the Posts We\u0026rsquo;re working with posts, which are in the content/post/ directory. That means that their section is \u0026ldquo;post\u0026rdquo; (and if we don\u0026rsquo;t do something weird, their type is also \u0026ldquo;post\u0026rdquo;).\nHugo uses the section and type to find the template file for every piece of content. Hugo will first look for a template file that matches the section or type name. If it can\u0026rsquo;t find one, then it will look in the _default/ directory. There are some twists that we\u0026rsquo;ll cover when we get to categories and tags, but for now we can assume that Hugo will try post/single.html, then _default/single.html.\nNow that we know the search rule, let\u0026rsquo;s see what we actually have available:\n$ find themes/zafta -name single.html | xargs ls -l\r-rw-r--r-- 1 quoha staff 132 Sep 29 17:31 themes/zafta/layouts/_default/single.html\rWe could create a new template, post/single.html, or change the default. Since we don\u0026rsquo;t know of any other content types, let\u0026rsquo;s start with updating the default.\nRemember, any content that we haven\u0026rsquo;t created a template for will end up using this template. That can be good or bad. Bad because I know that we\u0026rsquo;re going to be adding different types of content and we\u0026rsquo;re going to end up undoing some of the changes we\u0026rsquo;ve made. It\u0026rsquo;s good because we\u0026rsquo;ll be able to see immediate results. It\u0026rsquo;s also good to start here because we can start to build the basic layout for the site. As we add more content types, we\u0026rsquo;ll refactor this file and move logic around. Hugo makes that fairly painless, so we\u0026rsquo;ll accept the cost and proceed.\nPlease see the Hugo documentation on template rendering for all the details on determining which template to use. And, as the docs mention, if you\u0026rsquo;re building a single page application (SPA) web site, you can delete all of the other templates and work with just the default single page. That\u0026rsquo;s a refreshing amount of joy right there.\nUpdate the Template File $ vi themes/zafta/layouts/_default/single.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;title\u0026gt;{{ .Title }}\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt;\r{{ .Content }}\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r:wq\r$\rBuild the web site and verify the results.\n$ rm -rf public\r$ hugo --verbose\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 found taxonomies: map[string]string{\u0026quot;tag\u0026quot;:\u0026quot;tags\u0026quot;, \u0026quot;category\u0026quot;:\u0026quot;categories\u0026quot;}\rWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\r0 draft content\r0 future content\r2 pages created\r0 tags created\r0 categories created\rin 4 ms\r$ find public -type f -name '*.html' | xargs ls -l\r-rw-r--r-- 1 quoha staff 94 Sep 29 22:40 public/index.html\r-rw-r--r-- 1 quoha staff 125 Sep 29 22:40 public/post/first/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 22:40 public/post/index.html\r-rw-r--r-- 1 quoha staff 128 Sep 29 22:40 public/post/second/index.html\r$ cat public/post/first/index.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;title\u0026gt;first\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;first\u0026lt;/h1\u0026gt;\r\u0026lt;p\u0026gt;my first post\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r$ cat public/post/second/index.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;title\u0026gt;second\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;second\u0026lt;/h1\u0026gt;\r\u0026lt;p\u0026gt;my second post\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r$\rNotice that the posts now have content. You can go to localhost:1313/post/first to verify.\nLinking to Content The posts are on the home page. Let\u0026rsquo;s add a link from there to the post. Since this is the home page, we\u0026rsquo;ll update its template.\n$ vi themes/zafta/layouts/index.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r{{ range first 10 .Data.Pages }}\r\u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;{{ .Permalink }}\u0026quot;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt;\r{{ end }}\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rBuild the web site and verify the results.\n$ rm -rf public\r$ hugo --verbose\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 found taxonomies: map[string]string{\u0026quot;tag\u0026quot;:\u0026quot;tags\u0026quot;, \u0026quot;category\u0026quot;:\u0026quot;categories\u0026quot;}\rWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\r0 draft content\r0 future content\r2 pages created\r0 tags created\r0 categories created\rin 4 ms\r$ find public -type f -name '*.html' | xargs ls -l\r-rw-r--r-- 1 quoha staff 149 Sep 29 22:44 public/index.html\r-rw-r--r-- 1 quoha staff 125 Sep 29 22:44 public/post/first/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 22:44 public/post/index.html\r-rw-r--r-- 1 quoha staff 128 Sep 29 22:44 public/post/second/index.html\r$ cat public/index.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;/post/second/\u0026quot;\u0026gt;second\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt;\r\u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;/post/first/\u0026quot;\u0026gt;first\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r$\rCreate a Post Listing We have the posts displaying on the home page and on their own page. We also have a file public/post/index.html that is empty. Let\u0026rsquo;s make it show a list of all posts (not just the first ten).\nWe need to decide which template to update. This will be a listing, so it should be a list template. Let\u0026rsquo;s take a quick look and see which list templates are available.\n$ find themes/zafta -name list.html | xargs ls -l\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/list.html\rAs with the single post, we have to decide to update _default/list.html or create post/list.html. We still don\u0026rsquo;t have multiple content types, so let\u0026rsquo;s stay consistent and update the default list template.\nCreating Top Level Pages Let\u0026rsquo;s add an \u0026ldquo;about\u0026rdquo; page and display it at the top level (as opposed to a sub-level like we did with posts).\nThe default in Hugo is to use the directory structure of the content/ directory to guide the location of the generated html in the public/ directory. Let\u0026rsquo;s verify that by creating an \u0026ldquo;about\u0026rdquo; page at the top level:\n$ vi content/about.md\r+++\rtitle = \u0026quot;about\u0026quot;\rdescription = \u0026quot;about this site\u0026quot;\rdate = \u0026quot;2014-09-27\u0026quot;\rslug = \u0026quot;about time\u0026quot;\r+++\r## about us\ri'm speechless\r:wq\rGenerate the web site and verify the results.\n$ find public -name '*.html' | xargs ls -l\r-rw-rw-r-- 1 mdhender staff 334 Sep 27 15:08 public/about-time/index.html\r-rw-rw-r-- 1 mdhender staff 527 Sep 27 15:08 public/index.html\r-rw-rw-r-- 1 mdhender staff 358 Sep 27 15:08 public/post/first-post/index.html\r-rw-rw-r-- 1 mdhender staff 0 Sep 27 15:08 public/post/index.html\r-rw-rw-r-- 1 mdhender staff 342 Sep 27 15:08 public/post/second-post/index.html\rNotice that the page wasn\u0026rsquo;t created at the top level. It was created in a sub-directory named \u0026lsquo;about-time/\u0026rsquo;. That name came from our slug. Hugo will use the slug to name the generated content. It\u0026rsquo;s a reasonable default, by the way, but we can learn a few things by fighting it for this file.\nOne other thing. Take a look at the home page.\n$ cat public/index.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;http://localhost:1313/post/theme/\u0026quot;\u0026gt;creating a new theme\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt;\r\u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;http://localhost:1313/about-time/\u0026quot;\u0026gt;about\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt;\r\u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;http://localhost:1313/post/second-post/\u0026quot;\u0026gt;second\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt;\r\u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;http://localhost:1313/post/first-post/\u0026quot;\u0026gt;first\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt;\r\u0026lt;script\u0026gt;document.write('\u0026lt;script src=\u0026quot;http://'\r+ (location.host || 'localhost').split(':')[0]\r+ ':1313/livereload.js?mindelay=10\u0026quot;\u0026gt;\u0026lt;/'\r+ 'script\u0026gt;')\u0026lt;/script\u0026gt;\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rNotice that the \u0026ldquo;about\u0026rdquo; link is listed with the posts? That\u0026rsquo;s not desirable, so let\u0026rsquo;s change that first.\n$ vi themes/zafta/layouts/index.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;posts\u0026lt;/h1\u0026gt;\r{{ range first 10 .Data.Pages }}\r{{ if eq .Type \u0026quot;post\u0026quot;}}\r\u0026lt;h2\u0026gt;\u0026lt;a href=\u0026quot;{{ .Permalink }}\u0026quot;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt;\r{{ end }}\r{{ end }}\r\u0026lt;h1\u0026gt;pages\u0026lt;/h1\u0026gt;\r{{ range .Data.Pages }}\r{{ if eq .Type \u0026quot;page\u0026quot; }}\r\u0026lt;h2\u0026gt;\u0026lt;a href=\u0026quot;{{ .Permalink }}\u0026quot;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt;\r{{ end }}\r{{ end }}\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r:wq\rGenerate the web site and verify the results. The home page has two sections, posts and pages, and each section has the right set of headings and links in it.\nBut, that about page still renders to about-time/index.html.\n$ find public -name '*.html' | xargs ls -l\r-rw-rw-r-- 1 mdhender staff 334 Sep 27 15:33 public/about-time/index.html\r-rw-rw-r-- 1 mdhender staff 645 Sep 27 15:33 public/index.html\r-rw-rw-r-- 1 mdhender staff 358 Sep 27 15:33 public/post/first-post/index.html\r-rw-rw-r-- 1 mdhender staff 0 Sep 27 15:33 public/post/index.html\r-rw-rw-r-- 1 mdhender staff 342 Sep 27 15:33 public/post/second-post/index.html\rKnowing that hugo is using the slug to generate the file name, the simplest solution is to change the slug. Let\u0026rsquo;s do it the hard way and change the permalink in the configuration file.\n$ vi config.toml\r[permalinks]\rpage = \u0026quot;/:title/\u0026quot;\rabout = \u0026quot;/:filename/\u0026quot;\rGenerate the web site and verify that this didn\u0026rsquo;t work. Hugo lets \u0026ldquo;slug\u0026rdquo; or \u0026ldquo;URL\u0026rdquo; override the permalinks setting in the configuration file. Go ahead and comment out the slug in content/about.md, then generate the web site to get it to be created in the right place.\nSharing Templates If you\u0026rsquo;ve been following along, you probably noticed that posts have titles in the browser and the home page doesn\u0026rsquo;t. That\u0026rsquo;s because we didn\u0026rsquo;t put the title in the home page\u0026rsquo;s template (layouts/index.html). That\u0026rsquo;s an easy thing to do, but let\u0026rsquo;s look at a different option.\nWe can put the common bits into a shared template that\u0026rsquo;s stored in the themes/zafta/layouts/partials/ directory.\nCreate the Header and Footer Partials In Hugo, a partial is a sugar-coated template. Normally a template reference has a path specified. Partials are different. Hugo searches for them along a TODO defined search path. This makes it easier for end-users to override the theme\u0026rsquo;s presentation.\n$ vi themes/zafta/layouts/partials/header.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;title\u0026gt;{{ .Title }}\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r:wq\r$ vi themes/zafta/layouts/partials/footer.html\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r:wq\rUpdate the Home Page Template to Use the Partials The most noticeable difference between a template call and a partials call is the lack of path:\n{{ template \u0026quot;theme/partials/header.html\u0026quot; . }}\rversus\n{{ partial \u0026quot;header.html\u0026quot; . }}\rBoth pass in the context.\nLet\u0026rsquo;s change the home page template to use these new partials.\n$ vi themes/zafta/layouts/index.html\r{{ partial \u0026quot;header.html\u0026quot; . }}\r\u0026lt;h1\u0026gt;posts\u0026lt;/h1\u0026gt;\r{{ range first 10 .Data.Pages }}\r{{ if eq .Type \u0026quot;post\u0026quot;}}\r\u0026lt;h2\u0026gt;\u0026lt;a href=\u0026quot;{{ .Permalink }}\u0026quot;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt;\r{{ end }}\r{{ end }}\r\u0026lt;h1\u0026gt;pages\u0026lt;/h1\u0026gt;\r{{ range .Data.Pages }}\r{{ if or (eq .Type \u0026quot;page\u0026quot;) (eq .Type \u0026quot;about\u0026quot;) }}\r\u0026lt;h2\u0026gt;\u0026lt;a href=\u0026quot;{{ .Permalink }}\u0026quot;\u0026gt;{{ .Type }} - {{ .Title }} - {{ .RelPermalink }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt;\r{{ end }}\r{{ end }}\r{{ partial \u0026quot;footer.html\u0026quot; . }}\r:wq\rGenerate the web site and verify the results. The title on the home page is now \u0026ldquo;your title here\u0026rdquo;, which comes from the \u0026ldquo;title\u0026rdquo; variable in the config.toml file.\nUpdate the Default Single Template to Use the Partials $ vi themes/zafta/layouts/_default/single.html\r{{ partial \u0026quot;header.html\u0026quot; . }}\r\u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt;\r{{ .Content }}\r{{ partial \u0026quot;footer.html\u0026quot; . }}\r:wq\rGenerate the web site and verify the results. The title on the posts and the about page should both reflect the value in the markdown file.\nAdd “Date Published” to Posts It\u0026rsquo;s common to have posts display the date that they were written or published, so let\u0026rsquo;s add that. The front matter of our posts has a variable named \u0026ldquo;date.\u0026rdquo; It\u0026rsquo;s usually the date the content was created, but let\u0026rsquo;s pretend that\u0026rsquo;s the value we want to display.\nAdd “Date Published” to the Template We\u0026rsquo;ll start by updating the template used to render the posts. The template code will look like:\n{{ .Date.Format \u0026quot;Mon, Jan 2, 2006\u0026quot; }}\rPosts use the default single template, so we\u0026rsquo;ll change that file.\n$ vi themes/zafta/layouts/_default/single.html\r{{ partial \u0026quot;header.html\u0026quot; . }}\r\u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt;\r\u0026lt;h2\u0026gt;{{ .Date.Format \u0026quot;Mon, Jan 2, 2006\u0026quot; }}\u0026lt;/h2\u0026gt;\r{{ .Content }}\r{{ partial \u0026quot;footer.html\u0026quot; . }}\r:wq\rGenerate the web site and verify the results. The posts now have the date displayed in them. There\u0026rsquo;s a problem, though. The \u0026ldquo;about\u0026rdquo; page also has the date displayed.\nAs usual, there are a couple of ways to make the date display only on posts. We could do an \u0026ldquo;if\u0026rdquo; statement like we did on the home page. Another way would be to create a separate template for posts.\nThe \u0026ldquo;if\u0026rdquo; solution works for sites that have just a couple of content types. It aligns with the principle of \u0026ldquo;code for today,\u0026rdquo; too.\nLet\u0026rsquo;s assume, though, that we\u0026rsquo;ve made our site so complex that we feel we have to create a new template type. In Hugo-speak, we\u0026rsquo;re going to create a section template.\nLet\u0026rsquo;s restore the default single template before we forget.\n$ mkdir themes/zafta/layouts/post\r$ vi themes/zafta/layouts/_default/single.html\r{{ partial \u0026quot;header.html\u0026quot; . }}\r\u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt;\r{{ .Content }}\r{{ partial \u0026quot;footer.html\u0026quot; . }}\r:wq\rNow we\u0026rsquo;ll update the post\u0026rsquo;s version of the single template. If you remember Hugo\u0026rsquo;s rules, the template engine will use this version over the default.\n$ vi themes/zafta/layouts/post/single.html\r{{ partial \u0026quot;header.html\u0026quot; . }}\r\u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt;\r\u0026lt;h2\u0026gt;{{ .Date.Format \u0026quot;Mon, Jan 2, 2006\u0026quot; }}\u0026lt;/h2\u0026gt;\r{{ .Content }}\r{{ partial \u0026quot;footer.html\u0026quot; . }}\r:wq\rNote that we removed the date logic from the default template and put it in the post template. Generate the web site and verify the results. Posts have dates and the about page doesn\u0026rsquo;t.\nDon\u0026rsquo;t Repeat Yourself DRY is a good design goal and Hugo does a great job supporting it. Part of the art of a good template is knowing when to add a new template and when to update an existing one. While you\u0026rsquo;re figuring that out, accept that you\u0026rsquo;ll be doing some refactoring. Hugo makes that easy and fast, so it\u0026rsquo;s okay to delay splitting up a template.\n","pubDate":"2014-09-28","title":"创建一个新主题"},{"link":"https://huachengzhou.github.io/life/posts/hugo%E6%A8%A1%E6%9D%BF%E5%BC%95%E7%94%A8/","plain":"Hugo uses the excellent go html/template library for its template engine. It is an extremely lightweight engine that provides a very small amount of logic. In our experience that it is just the right amount of logic to be able to create a good static website. If you have used other template systems from different languages or frameworks you will find a lot of similarities in go templates.\nThis document is a brief primer on using go templates. The go docs provide more details.\nIntroduction to Go Templates Go templates provide an extremely simple template language. It adheres to the belief that only the most basic of logic belongs in the template or view layer. One consequence of this simplicity is that go templates parse very quickly.\nA unique characteristic of go templates is they are content aware. Variables and content will be sanitized depending on the context of where they are used. More details can be found in the go docs.\nBasic Syntax Go lang templates are html files with the addition of variables and functions.\nGo variables and functions are accessible within {{ }}\nAccessing a predefined variable \u0026ldquo;foo\u0026rdquo;:\n{{ foo }}\r Parameters are separated using spaces\nCalling the add function with input of 1, 2:\n{{ add 1 2 }}\r Methods and fields are accessed via dot notation\nAccessing the Page Parameter \u0026ldquo;bar\u0026rdquo;\n{{ .Params.bar }}\r Parentheses can be used to group items together\n{{ if or (isset .Params \u0026quot;alt\u0026quot;) (isset .Params \u0026quot;caption\u0026quot;) }} Caption {{ end }}\r Variables Each go template has a struct (object) made available to it. In hugo each template is passed either a page or a node struct depending on which type of page you are rendering. More details are available on the variables page.\nA variable is accessed by referencing the variable name.\n\u0026lt;title\u0026gt;{{ .Title }}\u0026lt;/title\u0026gt;\r Variables can also be defined and referenced.\n{{ $address := \u0026quot;123 Main St.\u0026quot;}}\r{{ $address }}\r Functions Go template ship with a few functions which provide basic functionality. The go template system also provides a mechanism for applications to extend the available functions with their own. Hugo template functions provide some additional functionality we believe are useful for building websites. Functions are called by using their name followed by the required parameters separated by spaces. Template functions cannot be added without recompiling hugo.\nExample:\n{{ add 1 2 }}\r Includes When including another template you will pass to it the data it will be able to access. To pass along the current context please remember to include a trailing dot. The templates location will always be starting at the /layout/ directory within Hugo.\nExample:\n{{ template \u0026quot;chrome/header.html\u0026quot; . }}\r Logic Go templates provide the most basic iteration and conditional logic.\nIteration Just like in go, the go templates make heavy use of range to iterate over a map, array or slice. The following are different examples of how to use range.\nExample 1: Using Context\n{{ range array }}\r{{ . }}\r{{ end }}\r Example 2: Declaring value variable name\n{{range $element := array}}\r{{ $element }}\r{{ end }}\r Example 2: Declaring key and value variable name\n{{range $index, $element := array}}\r{{ $index }}\r{{ $element }}\r{{ end }}\r Conditionals If, else, with, or, \u0026amp; and provide the framework for handling conditional logic in Go Templates. Like range, each statement is closed with end.\nGo Templates treat the following values as false:\n false 0 any array, slice, map, or string of length zero  Example 1: If\n{{ if isset .Params \u0026quot;title\u0026quot; }}\u0026lt;h4\u0026gt;{{ index .Params \u0026quot;title\u0026quot; }}\u0026lt;/h4\u0026gt;{{ end }}\r Example 2: If -\u0026gt; Else\n{{ if isset .Params \u0026quot;alt\u0026quot; }}\r{{ index .Params \u0026quot;alt\u0026quot; }}\r{{else}}\r{{ index .Params \u0026quot;caption\u0026quot; }}\r{{ end }}\r Example 3: And \u0026amp; Or\n{{ if and (or (isset .Params \u0026quot;title\u0026quot;) (isset .Params \u0026quot;caption\u0026quot;)) (isset .Params \u0026quot;attr\u0026quot;)}}\r Example 4: With\nAn alternative way of writing \u0026ldquo;if\u0026rdquo; and then referencing the same value is to use \u0026ldquo;with\u0026rdquo; instead. With rebinds the context . within its scope, and skips the block if the variable is absent.\nThe first example above could be simplified as:\n{{ with .Params.title }}\u0026lt;h4\u0026gt;{{ . }}\u0026lt;/h4\u0026gt;{{ end }}\r Example 5: If -\u0026gt; Else If\n{{ if isset .Params \u0026quot;alt\u0026quot; }}\r{{ index .Params \u0026quot;alt\u0026quot; }}\r{{ else if isset .Params \u0026quot;caption\u0026quot; }}\r{{ index .Params \u0026quot;caption\u0026quot; }}\r{{ end }}\r Pipes One of the most powerful components of go templates is the ability to stack actions one after another. This is done by using pipes. Borrowed from unix pipes, the concept is simple, each pipeline\u0026rsquo;s output becomes the input of the following pipe.\nBecause of the very simple syntax of go templates, the pipe is essential to being able to chain together function calls. One limitation of the pipes is that they only can work with a single value and that value becomes the last parameter of the next pipeline.\nA few simple examples should help convey how to use the pipe.\nExample 1 :\n{{ if eq 1 1 }} Same {{ end }}\r is the same as\n{{ eq 1 1 | if }} Same {{ end }}\r It does look odd to place the if at the end, but it does provide a good illustration of how to use the pipes.\nExample 2 :\n{{ index .Params \u0026quot;disqus_url\u0026quot; | html }}\r Access the page parameter called \u0026ldquo;disqus_url\u0026rdquo; and escape the HTML.\nExample 3 :\n{{ if or (or (isset .Params \u0026quot;title\u0026quot;) (isset .Params \u0026quot;caption\u0026quot;)) (isset .Params \u0026quot;attr\u0026quot;)}}\rStuff Here\r{{ end }}\r Could be rewritten as\n{{ isset .Params \u0026quot;caption\u0026quot; | or isset .Params \u0026quot;title\u0026quot; | or isset .Params \u0026quot;attr\u0026quot; | if }}\rStuff Here\r{{ end }}\r Context (aka. the dot) The most easily overlooked concept to understand about go templates is that {{ . }} always refers to the current context. In the top level of your template this will be the data set made available to it. Inside of a iteration it will have the value of the current item. When inside of a loop the context has changed. . will no longer refer to the data available to the entire page. If you need to access this from within the loop you will likely want to set it to a variable instead of depending on the context.\nExample:\n {{ $title := .Site.Title }}\r{{ range .Params.tags }}\r\u0026lt;li\u0026gt; \u0026lt;a href=\u0026quot;{{ $baseurl }}/tags/{{ . | urlize }}\u0026quot;\u0026gt;{{ . }}\u0026lt;/a\u0026gt; - {{ $title }} \u0026lt;/li\u0026gt;\r{{ end }}\r Notice how once we have entered the loop the value of {{ . }} has changed. We have defined a variable outside of the loop so we have access to it from within the loop.\nHugo Parameters Hugo provides the option of passing values to the template language through the site configuration (for sitewide values), or through the meta data of each specific piece of content. You can define any values of any type (supported by your front matter/config format) and use them however you want to inside of your templates.\nUsing Content (page) Parameters In each piece of content you can provide variables to be used by the templates. This happens in the front matter.\nAn example of this is used in this documentation site. Most of the pages benefit from having the table of contents provided. Sometimes the TOC just doesn\u0026rsquo;t make a lot of sense. We\u0026rsquo;ve defined a variable in our front matter of some pages to turn off the TOC from being displayed.\nHere is the example front matter:\n---\rtitle: \u0026quot;Permalinks\u0026quot;\rdate: \u0026quot;2013-11-18\u0026quot;\raliases:\r- \u0026quot;/doc/permalinks/\u0026quot;\rgroups: [\u0026quot;extras\u0026quot;]\rgroups_weight: 30\rnotoc: true\r---\rHere is the corresponding code inside of the template:\n {{ if not .Params.notoc }}\r\u0026lt;div id=\u0026quot;toc\u0026quot; class=\u0026quot;well col-md-4 col-sm-6\u0026quot;\u0026gt;\r{{ .TableOfContents }}\r\u0026lt;/div\u0026gt;\r{{ end }}\r Using Site (config) Parameters In your top-level configuration file (eg, config.yaml) you can define site parameters, which are values which will be available to you in chrome.\nFor instance, you might declare:\n1 2 3 4  params:CopyrightHTML:\u0026#34;Copyright \u0026amp;#xA9; 2013 John Doe. All Rights Reserved.\u0026#34;TwitterUser:\u0026#34;spf13\u0026#34;SidebarRecentLimit:5  Within a footer layout, you might then declare a \u0026lt;footer\u0026gt; which is only provided if the CopyrightHTML parameter is provided, and if it is given, you would declare it to be HTML-safe, so that the HTML entity is not escaped again. This would let you easily update just your top-level config file each January 1st, instead of hunting through your templates.\n{{if .Site.Params.CopyrightHTML}}\u0026lt;footer\u0026gt;\r\u0026lt;div class=\u0026quot;text-center\u0026quot;\u0026gt;{{.Site.Params.CopyrightHTML | safeHtml}}\u0026lt;/div\u0026gt;\r\u0026lt;/footer\u0026gt;{{end}}\rAn alternative way of writing the \u0026ldquo;if\u0026rdquo; and then referencing the same value is to use \u0026ldquo;with\u0026rdquo; instead. With rebinds the context . within its scope, and skips the block if the variable is absent:\n{{with .Site.Params.TwitterUser}}\u0026lt;span class=\u0026quot;twitter\u0026quot;\u0026gt;\r\u0026lt;a href=\u0026quot;https://twitter.com/{{.}}\u0026quot; rel=\u0026quot;author\u0026quot;\u0026gt;\r\u0026lt;img src=\u0026quot;/images/twitter.png\u0026quot; width=\u0026quot;48\u0026quot; height=\u0026quot;48\u0026quot; title=\u0026quot;Twitter: {{.}}\u0026quot;\ralt=\u0026quot;Twitter\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\r\u0026lt;/span\u0026gt;{{end}}\rFinally, if you want to pull \u0026ldquo;magic constants\u0026rdquo; out of your layouts, you can do so, such as in this example:\n\u0026lt;nav class=\u0026quot;recent\u0026quot;\u0026gt;\r\u0026lt;h1\u0026gt;Recent Posts\u0026lt;/h1\u0026gt;\r\u0026lt;ul\u0026gt;{{range first .Site.Params.SidebarRecentLimit .Site.Recent}}\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;{{.RelPermalink}}\u0026quot;\u0026gt;{{.Title}}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r{{end}}\u0026lt;/ul\u0026gt;\r\u0026lt;/nav\u0026gt;\r","pubDate":"2014-04-02","title":"(Hu)go 模板引用"},{"link":"https://huachengzhou.github.io/life/posts/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8hugo/","plain":"Step 1. Install Hugo Goto hugo releases and download the appropriate version for your os and architecture.\nSave it somewhere specific as we will be using it in the next step.\nMore complete instructions are available at installing hugo\nStep 2. Build the Docs Hugo has its own example site which happens to also be the documentation site you are reading right now.\nFollow the following steps:\n Clone the hugo repository Go into the repo Run hugo in server mode and build the docs Open your browser to http://localhost:1313  Corresponding pseudo commands:\ngit clone https://github.com/spf13/hugo\rcd hugo\r/path/to/where/you/installed/hugo server --source=./docs\r\u0026gt; 29 pages created\r\u0026gt; 0 tags index created\r\u0026gt; in 27 ms\r\u0026gt; Web Server is available at http://localhost:1313\r\u0026gt; Press ctrl+c to stop\r Once you\u0026rsquo;ve gotten here, follow along the rest of this page on your local build.\nStep 3. Change the docs site Stop the Hugo process by hitting ctrl+c.\nNow we are going to run hugo again, but this time with hugo in watch mode.\n/path/to/hugo/from/step/1/hugo server --source=./docs --watch\r\u0026gt; 29 pages created\r\u0026gt; 0 tags index created\r\u0026gt; in 27 ms\r\u0026gt; Web Server is available at http://localhost:1313\r\u0026gt; Watching for changes in /Users/spf13/Code/hugo/docs/content\r\u0026gt; Press ctrl+c to stop\r Open your favorite editor and change one of the source content pages. How about changing this very file to fix the typo. How about changing this very file to fix the typo.\nContent files are found in docs/content/. Unless otherwise specified, files are located at the same relative location as the url, in our case docs/content/overview/quickstart.md.\nChange and save this file.. Notice what happened in your terminal.\n\u0026gt; Change detected, rebuilding site\r\u0026gt; 29 pages created\r\u0026gt; 0 tags index created\r\u0026gt; in 26 ms\r Refresh the browser and observe that the typo is now fixed.\nNotice how quick that was. Try to refresh the site before it\u0026rsquo;s finished building.. I double dare you. Having nearly instant feedback enables you to have your creativity flow without waiting for long builds.\nStep 4. Have fun The best way to learn something is to play with it.\n","pubDate":"2014-04-02","title":"开始使用Hugo"},{"link":"https://huachengzhou.github.io/life/posts/migrate-from-jekyll/","plain":"Move static content to static Jekyll has a rule that any directory not starting with _ will be copied as-is to the _site output. Hugo keeps all static content under static. You should therefore move it all there. With Jekyll, something that looked like\n▾ \u0026lt;root\u0026gt;/\r▾ images/\rlogo.png\r should become\n▾ \u0026lt;root\u0026gt;/\r▾ static/\r▾ images/\rlogo.png\r Additionally, you\u0026rsquo;ll want any files that should reside at the root (such as CNAME) to be moved to static.\nCreate your Hugo configuration file Hugo can read your configuration as JSON, YAML or TOML. Hugo supports parameters custom configuration too. Refer to the Hugo configuration documentation for details.\nSet your configuration publish folder to _site The default is for Jekyll to publish to _site and for Hugo to publish to public. If, like me, you have _site mapped to a git submodule on the gh-pages branch, you\u0026rsquo;ll want to do one of two alternatives:\n  Change your submodule to point to map gh-pages to public instead of _site (recommended).\n git submodule deinit _site\rgit rm _site\rgit submodule add -b gh-pages git@github.com:your-username/your-repo.git public\r   Or, change the Hugo configuration to use _site instead of public.\n {\r..\r\u0026quot;publishdir\u0026quot;: \u0026quot;_site\u0026quot;,\r..\r}\r   Convert Jekyll templates to Hugo templates That\u0026rsquo;s the bulk of the work right here. The documentation is your friend. You should refer to Jekyll\u0026rsquo;s template documentation if you need to refresh your memory on how you built your blog and Hugo\u0026rsquo;s template to learn Hugo\u0026rsquo;s way.\nAs a single reference data point, converting my templates for heyitsalex.net took me no more than a few hours.\nConvert Jekyll plugins to Hugo shortcodes Jekyll has plugins; Hugo has shortcodes. It\u0026rsquo;s fairly trivial to do a port.\nImplementation As an example, I was using a custom image_tag plugin to generate figures with caption when running Jekyll. As I read about shortcodes, I found Hugo had a nice built-in shortcode that does exactly the same thing.\nJekyll\u0026rsquo;s plugin:\nmodule Jekyll\rclass ImageTag \u0026lt; Liquid::Tag\r@url = nil\r@caption = nil\r@class = nil\r@link = nil\r// Patterns\rIMAGE_URL_WITH_CLASS_AND_CAPTION =\rIMAGE_URL_WITH_CLASS_AND_CAPTION_AND_LINK = /(\\w+)(\\s+)((https?:\\/\\/|\\/)(\\S+))(\\s+)\u0026quot;(.*?)\u0026quot;(\\s+)-\u0026gt;((https?:\\/\\/|\\/)(\\S+))(\\s*)/i\rIMAGE_URL_WITH_CAPTION = /((https?:\\/\\/|\\/)(\\S+))(\\s+)\u0026quot;(.*?)\u0026quot;/i\rIMAGE_URL_WITH_CLASS = /(\\w+)(\\s+)((https?:\\/\\/|\\/)(\\S+))/i\rIMAGE_URL = /((https?:\\/\\/|\\/)(\\S+))/i\rdef initialize(tag_name, markup, tokens)\rsuper\rif markup =~ IMAGE_URL_WITH_CLASS_AND_CAPTION_AND_LINK\r@class = $1\r@url = $3\r@caption = $7\r@link = $9\relsif markup =~ IMAGE_URL_WITH_CLASS_AND_CAPTION\r@class = $1\r@url = $3\r@caption = $7\relsif markup =~ IMAGE_URL_WITH_CAPTION\r@url = $1\r@caption = $5\relsif markup =~ IMAGE_URL_WITH_CLASS\r@class = $1\r@url = $3\relsif markup =~ IMAGE_URL\r@url = $1\rend\rend\rdef render(context)\rif @class\rsource = \u0026quot;\u0026lt;figure class='#{@class}'\u0026gt;\u0026quot;\relse\rsource = \u0026quot;\u0026lt;figure\u0026gt;\u0026quot;\rend\rif @link\rsource += \u0026quot;\u0026lt;a href=\\\u0026quot;#{@link}\\\u0026quot;\u0026gt;\u0026quot;\rend\rsource += \u0026quot;\u0026lt;img src=\\\u0026quot;#{@url}\\\u0026quot;\u0026gt;\u0026quot;\rif @link\rsource += \u0026quot;\u0026lt;/a\u0026gt;\u0026quot;\rend\rsource += \u0026quot;\u0026lt;figcaption\u0026gt;#{@caption}\u0026lt;/figcaption\u0026gt;\u0026quot; if @caption\rsource += \u0026quot;\u0026lt;/figure\u0026gt;\u0026quot;\rsource\rend\rend\rend\rLiquid::Template.register_tag('image', Jekyll::ImageTag)\r is written as this Hugo shortcode:\n\u0026lt;!-- image --\u0026gt;\r\u0026lt;figure {{ with .Get \u0026quot;class\u0026quot; }}class=\u0026quot;{{.}}\u0026quot;{{ end }}\u0026gt;\r{{ with .Get \u0026quot;link\u0026quot;}}\u0026lt;a href=\u0026quot;{{.}}\u0026quot;\u0026gt;{{ end }}\r\u0026lt;img src=\u0026quot;{{ .Get \u0026quot;src\u0026quot; }}\u0026quot; {{ if or (.Get \u0026quot;alt\u0026quot;) (.Get \u0026quot;caption\u0026quot;) }}alt=\u0026quot;{{ with .Get \u0026quot;alt\u0026quot;}}{{.}}{{else}}{{ .Get \u0026quot;caption\u0026quot; }}{{ end }}\u0026quot;{{ end }} /\u0026gt;\r{{ if .Get \u0026quot;link\u0026quot;}}\u0026lt;/a\u0026gt;{{ end }}\r{{ if or (or (.Get \u0026quot;title\u0026quot;) (.Get \u0026quot;caption\u0026quot;)) (.Get \u0026quot;attr\u0026quot;)}}\r\u0026lt;figcaption\u0026gt;{{ if isset .Params \u0026quot;title\u0026quot; }}\r{{ .Get \u0026quot;title\u0026quot; }}{{ end }}\r{{ if or (.Get \u0026quot;caption\u0026quot;) (.Get \u0026quot;attr\u0026quot;)}}\u0026lt;p\u0026gt;\r{{ .Get \u0026quot;caption\u0026quot; }}\r{{ with .Get \u0026quot;attrlink\u0026quot;}}\u0026lt;a href=\u0026quot;{{.}}\u0026quot;\u0026gt; {{ end }}\r{{ .Get \u0026quot;attr\u0026quot; }}\r{{ if .Get \u0026quot;attrlink\u0026quot;}}\u0026lt;/a\u0026gt; {{ end }}\r\u0026lt;/p\u0026gt; {{ end }}\r\u0026lt;/figcaption\u0026gt;\r{{ end }}\r\u0026lt;/figure\u0026gt;\r\u0026lt;!-- image --\u0026gt;\r Usage I simply changed:\n{% image full http://farm5.staticflickr.com/4136/4829260124_57712e570a_o_d.jpg \u0026quot;One of my favorite touristy-type photos. I secretly waited for the good light while we were \u0026quot;having fun\u0026quot; and took this. Only regret: a stupid pole in the top-left corner of the frame I had to clumsily get rid of at post-processing.\u0026quot; -\u0026gt;http://www.flickr.com/photos/alexnormand/4829260124/in/set-72157624547713078/ %}\r to this (this example uses a slightly extended version named fig, different than the built-in figure):\n{{% fig class=\u0026quot;full\u0026quot; src=\u0026quot;http://farm5.staticflickr.com/4136/4829260124_57712e570a_o_d.jpg\u0026quot; title=\u0026quot;One of my favorite touristy-type photos. I secretly waited for the good light while we were having fun and took this. Only regret: a stupid pole in the top-left corner of the frame I had to clumsily get rid of at post-processing.\u0026quot; link=\u0026quot;http://www.flickr.com/photos/alexnormand/4829260124/in/set-72157624547713078/\u0026quot; %}}\r As a bonus, the shortcode named parameters are, arguably, more readable.\nFinishing touches Fix content Depending on the amount of customization that was done with each post with Jekyll, this step will require more or less effort. There are no hard and fast rules here except that hugo server --watch is your friend. Test your changes and fix errors as needed.\nClean up You\u0026rsquo;ll want to remove the Jekyll configuration at this point. If you have anything else that isn\u0026rsquo;t used, delete it.\nA practical example in a diff Hey, it\u0026rsquo;s Alex was migrated in less than a father-with-kids day from Jekyll to Hugo. You can see all the changes (and screw-ups) by looking at this diff.\n","pubDate":"2014-03-10","title":"Migrate to Hugo from Jekyll"},{"link":"https://huachengzhou.github.io/life/posts/%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%E6%98%BE%E7%A4%BA/","plain":"More detail: Syntax Highlighting | Hugo\n1 2 3  function helloWorld () { alert(\u0026#34;Hello, World!\u0026#34;) }   1 2 3 4 5  public class HelloWorld { public static void main(String[] args) { System.out.println(\u0026#34;Hello, World!\u0026#34;); } }   1 2 3 4 5  package hello fun main(args: Array\u0026lt;String\u0026gt;) { println(\u0026#34;Hello World!\u0026#34;) }   1 2 3 4 5 6 7  #include \u0026lt;stdio.h\u0026gt; /* Hello */ int main(void){ printf(\u0026#34;Hello, World!\u0026#34;); return 0; }   1 2 3 4 5 6 7 8  // \u0026#39;Hello World!\u0026#39; program  #include \u0026lt;iostream\u0026gt; int main(){ std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; }   1 2 3 4 5 6  using System; class HelloWorld{ public static void Main(){ System.Console.WriteLine(\u0026#34;Hello, World!\u0026#34;); } }   1 2 3 4 5  \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; Hello, World! \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   1 2 3 4 5 6 7  package main import fmt \u0026#34;fmt\u0026#34; func main() { fmt.Printf(\u0026#34;Hello, World!\\n\u0026#34;); }   1 2 3  object HelloWorld with Application { Console.println(\u0026#34;Hello, World!\u0026#34;); }   1 2 3  \u0026lt;?php echo \u0026#39;Hello, World!\u0026#39;; ?\u0026gt;  1  print(\u0026#34;Hello, World!\u0026#34;)   no named code block ## this is a comment\r$ echo this is a command\rthis is a command\r## edit the file\r$vi foo.md\r+++\rdate = \u0026quot;2014-09-28\u0026quot;\rtitle = \u0026quot;creating a new theme\u0026quot;\r+++\rbah and humbug\r:wq\r## show it\r$ cat foo.md\r+++\rdate = \u0026quot;2014-09-28\u0026quot;\rtitle = \u0026quot;creating a new theme\u0026quot;\r+++\rbah and humbug\r$\rhighlight shortcode example:\n{{\u0026lt; highlight go \u0026quot;linenos=table,hl_lines=8 15-17,linenostart=199\u0026quot; \u0026gt;}}\r// ... code\r{{\u0026lt; /highlight \u0026gt;}}\rresult:\n199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220  // GetTitleFunc returns a func that can be used to transform a string to // title case. // // The supported styles are // // - \u0026#34;Go\u0026#34; (strings.Title) // - \u0026#34;AP\u0026#34; (see https://www.apstylebook.com/) // - \u0026#34;Chicago\u0026#34; (see http://www.chicagomanualofstyle.org/home.html) // // If an unknown or empty style is provided, AP style is what you get. func GetTitleFunc(style string) func(s string) string { switch strings.ToLower(style) { case \u0026#34;go\u0026#34;: return strings.Title case \u0026#34;chicago\u0026#34;: tc := transform.NewTitleConverter(transform.ChicagoStyle) return tc.Title  default: tc := transform.NewTitleConverter(transform.APStyle) return tc.Title } }  ","pubDate":"2011-08-30","title":"语法高亮显示"}];
    var search_theEnd = "The End";
    var search_nothing = "Nothing was found";
    var search_found = "Found";
    var search_result = "result";
    var search_results = "results";
</script>





    </body>
</html>

