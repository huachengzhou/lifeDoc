<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>并发工具  on 所悟所想</title>
    <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/</link>
    <description>Recent content in 并发工具  on 所悟所想</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 15 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://huachengzhou.github.io/life/docs/javadir/thread/tool/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ThreadLocal</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/thread_local/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/thread_local/</guid>
      <description>一:介绍 #   ThreadLocal直译为线程局部变量，或许将它命名为ThreadLocalVariable更为合适。其主要作用就是实现线程本地存储功能，通过线程本地资源隔离，解决多线程并发场景下线程安全问题
  类ThreadLocal 主要解决的就是每个线程绑定自己的值,可以将ThreadLocal类比喻成全局存放数据的盒子,盒子中可以存放每个线程 的私有数据
 二:用法举例 #  public class ToolsThreadLocal { public static ThreadLocal t1 = new ThreadLocal(); } public class ThreadLocalA extends Thread { @Override public void run() { for (int i = 0; i &amp;lt; 50; i++) { ToolsThreadLocal.t1.set(&amp;#34;thread a &amp;#34;+i); System.out.println(ToolsThreadLocal.t1.get()); } } } public class ThreadLocalB extends Thread { @Override public void run() { for (int i = 0; i &amp;lt; 50; i++) { ToolsThreadLocal.</description>
    </item>
    
    <item>
      <title>Semaphore和Exchanger</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/semaphore_exchanger/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/semaphore_exchanger/</guid>
      <description>Semaphore #  1、Semaphore 是什么 #   Semaphore 通常我们叫它信号量， 可以用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源
  可以把它简单的理解成我们停车场入口立着的那个显示屏，每有一辆车进入停车场显示屏就会显示剩余车位减1，每有一辆车从停车场出去，显示屏上显示的剩余车辆就会加1，当显示屏上的剩余车位为0时，停车场入口的栏杆就不会再打开，车辆就无法进入停车场了，直到有一辆车从停车场出去为止
 2、使用场景 #   通常用于那些资源有明确访问数量限制的场景，常用于限流
  比如：数据库连接池，同时进行连接的线程有数量限制，连接不能超过一定的数量，当连接达到了限制数量后，后面的线程只能排队等前面的线程释放了数据库连接才能获得数据库连接。
  比如：停车场场景，车位数量有限，同时只能容纳多少台车，车位满了之后只有等里面的车离开停车场外面的车才可以进入
  20辆小轿车 3个车位 当车停入车位算抢占成功到释放出车位完成一个完整动作 锁定的位数 必然使用车位才合理 餐厅能够容纳16个人同时吃饭 但是吃饭的人总数有200个人 同意锁定的位数 也必然是16个餐位
 3、Semaphore常用方法说明 #  acquire() 获取一个令牌，在获取到令牌、或者被其他线程调用中断之前线程一直处于阻塞状态。 ​ acquire(int permits) 从此信号量获取给定数目的令牌，在提供这些许可前一直将线程阻塞，或者线程已被中断。 acquireUninterruptibly() 获取一个令牌，在获取到令牌之前线程一直处于阻塞状态（忽略中断）。 tryAcquire() 尝试获得令牌，返回获取令牌成功或失败，不阻塞线程。 ​ tryAcquire(long timeout, TimeUnit unit) 尝试获得令牌，在超时时间内循环尝试获取，直到尝试获取成功或超时返回，不阻塞线程。 ​ release() 释放一个令牌，唤醒一个获取令牌不成功的阻塞线程。 ​release(int permits) 释放给定数目的令牌，将其返回到信号量。 hasQueuedThreads() 等待队列里是否还存在等待线程。 ​ getQueueLength() 获取等待队列里阻塞的线程数。 ​ drainPermits() 清空令牌把可用令牌数置为0，返回清空令牌的数量。 ​ availablePermits() 返回可用的令牌数量。 4、用semaphore 实现停车场提示牌功能 #   每个停车场入口都有一个提示牌，上面显示着停车场的剩余车位还有多少，当剩余车位为0时，不允许车辆进入停车场，直到停车场里面有车离开停车场，这时提示牌上会显示新的剩余车位数</description>
    </item>
    
    <item>
      <title>CountDownLatch 和 CyclicBarrier</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/countdownlatch_cyclicbarrier/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/countdownlatch_cyclicbarrier/</guid>
      <description>CountDownLatch #    CountDownLatch中count down是倒数的意思，latch则是门闩的含义。整体含义可以理解为倒数的门栓，似乎有一点“三二一，芝麻开门”的感觉。CountDownLatch的作用也是如此，在构造CountDownLatch的时候需要传入一个整数n，在这个整数“倒数”到0之前，主线程需要等待在门口，而这个“倒数”过程则是由各个执行线程驱动的，每个线程执行完一个任务“倒数”一次。总结来说，CountDownLatch的作用就是等待其他的线程都执行完任务，必要时可以对各个任务的执行结果进行汇总，然后主线程才继续往下执行
   CountDownLatch主要有两个方法：countDown()和await()。countDown()方法用于使计数器减一，其一般是执行任务的线程调用，await()方法则使调用该方法的线程处于等待状态，其一般是主线程调用。这里需要注意的是，countDown()方法并没有规定一个线程只能调用一次，当同一个线程调用多次countDown()方法时，每次都会使计数器减一；另外，await()方法也并没有规定只能有一个线程执行该方法，如果多个线程同时执行await()方法，那么这几个线程都将处于等待状态，并且以共享模式享有同一个锁。
 public class CountDownLatchExample { public static void main(String[] args) throws InterruptedException { CountDownLatch latch = new CountDownLatch(5); Service service = new Service(latch); Runnable task = () -&amp;gt; service.exec(); for (int i = 0; i &amp;lt; 5; i++) { Thread thread = new Thread(task); thread.start(); } System.out.println(&amp;#34;main thread await. &amp;#34;); latch.await(); System.out.println(&amp;#34;main thread finishes await. &amp;#34;); } } class Service { private CountDownLatch latch; public Service(CountDownLatch latch) { this.</description>
    </item>
    
    <item>
      <title>Phaser</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/phaser/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/phaser/</guid>
      <description>Phaser #  </description>
    </item>
    
    <item>
      <title>Executor</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/executor/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/executor/</guid>
      <description>Executor #  </description>
    </item>
    
    <item>
      <title>Future 和 callable</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/future_callable/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/future_callable/</guid>
      <description>Future #  callable #  </description>
    </item>
    
    <item>
      <title>CompletionService</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/completionservice/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/completionservice/</guid>
      <description>CompletionService #  </description>
    </item>
    
    <item>
      <title>ExecutorService</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/executorservice/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/executorservice/</guid>
      <description>ExecutorService #  </description>
    </item>
    
    <item>
      <title>Fork-Join</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/fork_join/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/fork_join/</guid>
      <description>Fork-Join #  </description>
    </item>
    
    <item>
      <title>并发集合框架</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/collection/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/collection/</guid>
      <description>collection #  </description>
    </item>
    
  </channel>
</rss>
