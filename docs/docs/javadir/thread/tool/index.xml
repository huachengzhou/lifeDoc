<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>并发工具  on 所悟所想</title>
    <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/</link>
    <description>Recent content in 并发工具  on 所悟所想</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 15 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://huachengzhou.github.io/life/docs/javadir/thread/tool/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ThreadLocal</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/thread_local/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/thread_local/</guid>
      <description>一:介绍# ThreadLocal直译为线程局部变量，或许将它命名为ThreadLocalVariable更为合适。其主要作用就是实现线程本地存储功能，通过线程本地资源隔离，解决多线程并发场景下线程安全问题
  类ThreadLocal 主要解决的就是每个线程绑定自己的值,可以将ThreadLocal类比喻成全局存放数据的盒子,盒子中可以存放每个线程 的私有数据
 二:用法举例#public class ToolsThreadLocal { public static ThreadLocal t1 = new ThreadLocal(); } public class ThreadLocalA extends Thread { @Override public void run() { for (int i = 0; i &amp;lt; 50; i++) { ToolsThreadLocal.t1.set(&amp;#34;thread a &amp;#34;+i); System.out.println(ToolsThreadLocal.t1.get()); } } } public class ThreadLocalB extends Thread { @Override public void run() { for (int i = 0; i &amp;lt; 50; i++) { ToolsThreadLocal.</description>
    </item>
    
    <item>
      <title>Semaphore和Exchanger</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/semaphore_exchanger/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/semaphore_exchanger/</guid>
      <description>Semaphore#1、Semaphore 是什么# Semaphore 通常我们叫它信号量， 可以用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源
  可以把它简单的理解成我们停车场入口立着的那个显示屏，每有一辆车进入停车场显示屏就会显示剩余车位减1，每有一辆车从停车场出去，显示屏上显示的剩余车辆就会加1，当显示屏上的剩余车位为0时，停车场入口的栏杆就不会再打开，车辆就无法进入停车场了，直到有一辆车从停车场出去为止
 2、使用场景# 通常用于那些资源有明确访问数量限制的场景，常用于限流
  比如：数据库连接池，同时进行连接的线程有数量限制，连接不能超过一定的数量，当连接达到了限制数量后，后面的线程只能排队等前面的线程释放了数据库连接才能获得数据库连接。
  比如：停车场场景，车位数量有限，同时只能容纳多少台车，车位满了之后只有等里面的车离开停车场外面的车才可以进入
  20辆小轿车 3个车位 当车停入车位算抢占成功到释放出车位完成一个完整动作 锁定的位数 必然使用车位才合理 餐厅能够容纳16个人同时吃饭 但是吃饭的人总数有200个人 同意锁定的位数 也必然是16个餐位
 3、Semaphore常用方法说明#acquire() 获取一个令牌，在获取到令牌、或者被其他线程调用中断之前线程一直处于阻塞状态。 ​ acquire(int permits) 从此信号量获取给定数目的令牌，在提供这些许可前一直将线程阻塞，或者线程已被中断。 acquireUninterruptibly() 获取一个令牌，在获取到令牌之前线程一直处于阻塞状态（忽略中断）。 tryAcquire() 尝试获得令牌，返回获取令牌成功或失败，不阻塞线程。 ​ tryAcquire(long timeout, TimeUnit unit) 尝试获得令牌，在超时时间内循环尝试获取，直到尝试获取成功或超时返回，不阻塞线程。 ​ release() 释放一个令牌，唤醒一个获取令牌不成功的阻塞线程。 ​release(int permits) 释放给定数目的令牌，将其返回到信号量。 hasQueuedThreads() 等待队列里是否还存在等待线程。 ​ getQueueLength() 获取等待队列里阻塞的线程数。 ​ drainPermits() 清空令牌把可用令牌数置为0，返回清空令牌的数量。 ​ availablePermits() 返回可用的令牌数量。 4、用semaphore 实现停车场提示牌功能# 每个停车场入口都有一个提示牌，上面显示着停车场的剩余车位还有多少，当剩余车位为0时，不允许车辆进入停车场，直到停车场里面有车离开停车场，这时提示牌上会显示新的剩余车位数</description>
    </item>
    
    <item>
      <title>CountDownLatch 和 CyclicBarrier</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/countdownlatch_cyclicbarrier/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/countdownlatch_cyclicbarrier/</guid>
      <description>CountDownLatch是减法操作 CyclicBarrier具有CountDownLatch的所有功能
 CountDownLatch#  CountDownLatch中count down是倒数的意思，latch则是门闩的含义。整体含义可以理解为倒数的门栓,所以当门打开时,N个人是不能进屋的,也就是N个线程是不能继续向下运行的,支持这样的特性可以控制线程执行任务的时机,使线程以 &amp;ldquo;组团&amp;quot;的方式一起执行任务
   CountDownLatch中count down是倒数的意思，latch则是门闩的含义。整体含义可以理解为倒数的门栓，似乎有一点“三二一，芝麻开门”的感觉。CountDownLatch的作用也是如此，在构造CountDownLatch的时候需要传入一个整数n，在这个整数“倒数”到0之前，主线程需要等待在门口，而这个“倒数”过程则是由各个执行线程驱动的，每个线程执行完一个任务“倒数”一次。总结来说，CountDownLatch的作用就是等待其他的线程都执行完任务，必要时可以对各个任务的执行结果进行汇总，然后主线程才继续往下执行
   CountDownLatch主要有两个方法：countDown()和await()。countDown()方法用于使计数器减一，其一般是执行任务的线程调用，await()方法则使调用该方法的线程处于等待状态，其一般是主线程调用。这里需要注意的是，countDown()方法并没有规定一个线程只能调用一次，当同一个线程调用多次countDown()方法时，每次都会使计数器减一；另外，await()方法也并没有规定只能有一个线程执行该方法，如果多个线程同时执行await()方法，那么这几个线程都将处于等待状态，并且以共享模式享有同一个锁。
   await()方法 一般是使用者或者主线程调用 countDown()方法 子任务线程组调用
  第一个例子
  import java.util.concurrent.CountDownLatch; public class CountDownLatchExample2 { public static class MyService { private CountDownLatch downLatch = new CountDownLatch(1) ; public void testMethod(){ try { System.out.println(&amp;#34;任务执行开始前!&amp;#34;); //await()方法则使调用该方法的线程处于等待状态，其一般是主线程调用  downLatch.await(); System.out.println(&amp;#34;任务执行结束!&amp;#34;); } catch (InterruptedException e) { e.printStackTrace(); } } public void downMethod(){ System.</description>
    </item>
    
    <item>
      <title>Phaser</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/phaser/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/phaser/</guid>
      <description>Phaser#java7中引入了一种新的可重复使用的同步屏障,称为移相器Phaser
Phaser拥有与CyclicBarrier和CountDownLatch类似的功劳.但是这个类提供了更加灵活的应用.CountDownLatch和CyclicBarrier都是只适用于固定数量的参与者.移相器适用于可变数目的屏障,在这个意义上,可以在任何时间注册新的参与者.并且在抵达屏障是可以注销已经注册的参与者.因此,注册到同步移相器的参与者的数目可能会随着时间的推移而变化
如CyclicBarrier一样,移相器可以重复使用,这意味着当前参与者到达移相器后,可以再一次注册自己并等待另一次到达.因此,移相器会有多代.一旦为某个特定相位注册的所有参与者都到达移相器,就增加相数.相数从零开始,在达到Integer.MAX_VALUE后,再次绕回0.当移相器发生变化时,通过重写onAdvance方法,可以自行可选操作.这个方法也可用于终止移相器.移相器一旦被终止,所有的同步方法就会立即返回,并尝试注册新的失败的参与者
移相器的另一个重要特征是:移相器可能是分层的,这允许你以树形结构来安排移相器以减少竞争.很明显,更小的组将拥有更少的竞争同步的参与者.因此,将大量的参与者分成较小的组可以减少竞争.虽然创建移相器能增加中的吞吐量,但是这需要更多的开销.最后,移相器的另一个重要的特征在于监控功能,使用独立的对象可以监视移相器的当前状态.监视器可以查询注册到移相器的参与者的数量,以及已经到达和还没有到达某个特定相数的参与者的数量
Phaser中是通过计数器来控制。在Phaser中计数器叫做parties， 我们可以通过Phaser的构造函数或者register()方法来注册
通过调用register()方法，我们可以动态的控制phaser的个数。如果我们需要取消注册，则可以调用arriveAndDeregister()方法
方法#  register()
  注册一个需要协作的线程。
  bulkRegister(int parties)
  批量注册需要协作的线程。
  arrive()
  到达屏障直接执行，无需等待其他线程。
  arriveAndAwaitAdvance()
  到达屏障，必须等待其他线程。
  arriveAndDeregister()
  到达屏障，注销自己，无需等待其他线程到达。
  onAdvance(int phase, int registeredParties)
  参与协作的线程都到达屏障后，会调用该方法。
  例子# case 1  final Phaser phaser = new Phaser(3) { @Override protected boolean onAdvance(int phase, int registeredParties) { System.</description>
    </item>
    
    <item>
      <title>Executor</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/executor/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/executor/</guid>
      <description>Executor#</description>
    </item>
    
    <item>
      <title>Future 和 callable</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/future_callable/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/future_callable/</guid>
      <description>Future#callable#</description>
    </item>
    
    <item>
      <title>CompletionService</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/completionservice/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/completionservice/</guid>
      <description>CompletionService#</description>
    </item>
    
    <item>
      <title>ExecutorService</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/executorservice/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/executorservice/</guid>
      <description>ExecutorService#</description>
    </item>
    
    <item>
      <title>Fork-Join</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/fork_join/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/fork_join/</guid>
      <description>Fork-Join#简介#从JDK1.7开始，Java提供Fork/Join框架用于并行执行任务，它的思想就是讲一个大任务分割成若干小任务，最终汇总每个小任务的结果得到这个大任务的结果。
这种思想和MapReduce很像（input &amp;ndash;&amp;gt; split &amp;ndash;&amp;gt; map &amp;ndash;&amp;gt; reduce &amp;ndash;&amp;gt; output）
 主要有两步：   第一、任务切分； 第二、结果合并  它的模型大致是这样的：线程池中的每个线程都有自己的工作队列（PS：这一点和ThreadPoolExecutor不同，ThreadPoolExecutor是所有线程公用一个工作队列， 所有线程都从这个工作队列中取任务），当自己队列中的任务都完成以后，会从其它线程的工作队列中偷一个任务执行，这样可以充分利用资源。
工作窃取（work-stealing）#工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。工作窃取的运行流程图如下：
那么为什么需要使用工作窃取算法呢？
假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。
工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。
API介绍#ForkJoinPool#ForkJoinPool与其它的ExecutorService区别主要在于它使用“工作窃取”：线程池中的所有线程都企图找到并执行提交给线程池的任务。当大量的任务产生子任务的时候，或者同时当有许多小任务被提交到线程池中的时候，这种处理是非常高效的。特别的，当在构造方法中设置asyncMode为true的时候这种处理更加高效。
ForkJoinTask#ForkJoinTask代表运行在ForkJoinPool中的任务。
主要方法：
 fork() 在当前线程运行的线程池中安排一个异步执行。简单的理解就是再创建一个子任务。 join() 当任务完成的时候返回计算结果。 invoke() 开始执行任务，如果必要，等待计算完成。  子类：
 RecursiveAction 一个递归无结果的ForkJoinTask（没有返回值） RecursiveTask 一个递归有结果的ForkJoinTask（有返回值）  ForkJoinWorkerThread#ForkJoinWorkerThread代表ForkJoinPool线程池中的一个执行任务的线程。
 类图  代码分析#WorkQueue是一个ForkJoinPool中的内部类，它是线程池中线程的工作队列的一个封装，支持任务窃取。</description>
    </item>
    
    <item>
      <title>并发集合框架</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/collection/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/collection/</guid>
      <description>collection#</description>
    </item>
    
  </channel>
</rss>
