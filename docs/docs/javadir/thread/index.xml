<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>多线程与并发  on 所悟所想</title>
    <link>https://huachengzhou.github.io/life/docs/javadir/thread/</link>
    <description>Recent content in 多线程与并发  on 所悟所想</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 15 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://huachengzhou.github.io/life/docs/javadir/thread/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ThreadLocal</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/tool/thread_local/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/tool/thread_local/</guid>
      <description>一:介绍# ThreadLocal直译为线程局部变量，或许将它命名为ThreadLocalVariable更为合适。其主要作用就是实现线程本地存储功能，通过线程本地资源隔离，解决多线程并发场景下线程安全问题
  类ThreadLocal 主要解决的就是每个线程绑定自己的值,可以将ThreadLocal类比喻成全局存放数据的盒子,盒子中可以存放每个线程 的私有数据
 二:用法举例#public class ToolsThreadLocal { public static ThreadLocal t1 = new ThreadLocal(); } public class ThreadLocalA extends Thread { @Override public void run() { for (int i = 0; i &amp;lt; 50; i++) { ToolsThreadLocal.t1.set(&amp;#34;thread a &amp;#34;+i); System.out.println(ToolsThreadLocal.t1.get()); } } } public class ThreadLocalB extends Thread { @Override public void run() { for (int i = 0; i &amp;lt; 50; i++) { ToolsThreadLocal.</description>
    </item>
    
    <item>
      <title>名词解释</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/glossary/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/glossary/</guid>
      <description>  FIFO队列 (先进先出队列)
  jni 远程调用 编译器代码
  LongAdder
  </description>
    </item>
    
    <item>
      <title>关键名词解释</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/essential_glossary/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/essential_glossary/</guid>
      <description>锁分类#轻量级锁# Displaced Mark Word(置换标记字)   线程在执行同步块之前,JVM会先在当前线程的栈帧中创建用于存储记录的空间,并将对象头中的Mark Word复制到锁记录中,官方称为Displaced Mark Word 。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功,当前线程获得锁,如果失败,表示其他线程竞争锁,当前线程便尝试 使用自旋来获取锁。
 白话#在进入同步块之前JVM会在当前线程的&amp;#34;栈帧中申请并创建锁记录的空间,接着把对象头的标识符写到锁记录中&amp;#34; 然后使用CAS将当前线程的锁记录的地址(指针)替换掉锁对应的对象中的标识符,CAS操作成功表示获得锁CAS 操作失败尝试使用自旋(就是在当前进程并且执行代码块的线程内的时间片下空循环烧CPU反正现代计算机大多都是多核处理器在短时间内不会太影响其他任务处理)来获取锁 锁的撤销#要想撤销轻量级锁(解锁) 对象头中标识符必须设回为Displaced Mark Word 因此使用CAS操作将Displaced Mark Word替换回到对象头里面,成功那么撤销成功,失败说明有其它线程还在竞争此对象的锁这个时候 锁就会立即膨胀成重量级锁,后续的加锁和解锁都按照重量级锁的操作来 偏向锁# 当一个线程访问同步块(部分文档和解释说也包括同步方法)并获取锁时,会在对象头和栈帧中的锁记录里存在存储偏向锁的线程ID, 以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁,只需要简单测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁 .如果测试成功,表示已经获取到了锁。如果测试失败,则需要再测试一下Mark word中偏向锁的标识符是否设置成1:如果没有设置,则使用CAS竞争锁; 如果设置了,则尝试使用CAS将对象头的偏向锁指向当前线程(实际就是在对象头锁记录存入线程标识的数据,当然顺带栈帧记录也得存入有关的锁记录数据)
 白话#当只有一个线程或者多个线程中最先执行到同步块的时候 这个时候测试完没有偏向锁立即设置完对应的标识记录和锁记录就开始执行同步代码了, 假如下次再进入并且锁没有升级那么仅仅简单测试通过又继续执行了 在这最开始到结束全程没有各种加锁操作甚至连CAS都很有可能没有(是有可能有CASC操作的这涉及到偏向锁的撤销机制) 相比同步操作消耗很少 因此很划算的 当有多个线程竞争锁的时候 这个时候系统检测到了并且达到了锁升级的约束条件那么就会立即执行升级操作即便获得执行条件正在的线程 (当然必须等执行线程中的某个原子操作或者若干原子操作组成的原语)也要对锁记录进行升级然后才开始升级 优点: 把整个同步都消除掉，连CAS操作都不去做了，优于轻量级锁 缺点: 如果程序中大多数的锁都总是被多个不同的线程访问，那偏向锁就是多余的   偏向锁是JDK6时加入的一种锁优化机制
  锁的撤销</description>
    </item>
    
    <item>
      <title>cas</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/cas/</link>
      <pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/cas/</guid>
      <description>概念# CAS即Compare and Swap，是基于硬件级别的指令实现的同步原语，Java并发包java.utile.concurrent许多同步类基于CAS构建，因此可见CAS的重要性  模拟# 有安全问题的一段code  public class Demo1 { public static void main(String[] args) throws Exception { long startTime = System.currentTimeMillis(); Demo_B demo_b = new Demo_B(); final int len = 10000000; Thread t1 = new Thread(() -&amp;gt; { for (int i = 0; i &amp;lt; len; i++) { demo_b.increase(); } }); t1.start(); for (int i = 0; i &amp;lt; len; i++) { demo_b.</description>
    </item>
    
    <item>
      <title>JOL工具 </title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/jol/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/jol/</guid>
      <description>引入jol依赖#&amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;org.openjdk.jol&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;jol-core&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;0.9&amp;lt;/version&amp;gt;&amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;&amp;lt;/dependency&amp;gt;相关方法#  1.使用jol计算对象的大小（单位为字节）：ClassLayout.parseInstance(obj).instanceSize()
  2.使用jol查看对象内部的内存布局：ClassLayout.parseInstance(obj).toPrintable()
  3.查看对象外部信息：包括引用的对象：GraphLayout.parseInstance(obj).toPrintable()
  4.查看对象占用空间总大小：GraphLayout.parseInstance(obj).totalSize()
  对象布局 空属性#import org.openjdk.jol.info.ClassLayout; public class Entity { public static void main(String[] args) { Entity entity = new Entity(); // 打印java 对象内存布局  System.out.println(ClassLayout.parseInstance(entity).toPrintable()); } } // 输出结果 com.brown.Entity object internals: // Entity对象内存布局  OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) 05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315) 12 4 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 4 bytes external = 4 bytes total OFFSET：偏移地址，单位字节 SIZE：占用的内存大小，单位为字节 TYPE DESCRIPTION： 类型描述，其中object header为对象头； object header：对象头 loss due to the next object alignment：由于下一个对象对齐而导致的丢失（有4Byte是对齐的字节（因为在64位虚拟机上对象的大小必须是8的倍数）,由于这个对象里面没有任何字段，故而对象的实例数据为0Byte）。 VALUE : 对应内存中当前存储的值； Instance size：实例字节数值大小（**此处一个空的java对象（不包含任意字段属性）实例，其实例大小为``16Byte**） 对象布局 有属性#/** * 带有属性的 实体类 */ public class Student { private String name; private Integer age; } public class DemoT1 { public static void main(String[] args) { Student o = new Student(); System.</description>
    </item>
    
    <item>
      <title>unsafe</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/unsafe/</link>
      <pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/unsafe/</guid>
      <description>前言# Unsafe类位于sun.misc包下，它是java实现高并发的基础，通过它可以执行一些不安全的操作，如像C语言一样直接操作内存资源，它提供的这些方法增强了java对底层资源的操作能力，但同时也增加了程序出错的风险，所以对它的使用一定要慎重  核心功能介绍# Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障相关、数组相关等。下面介绍几个方法的使用。  获取Unsafe对象#import sun.misc.Unsafe; import java.lang.reflect.Field; public final class UnsafeAccessor { private static Unsafe unsafe; //Unsafe提供的getUnsafe()方法只能被根类加载器加载的类所调用，也就是jdk内部的类。我们可以通过反射来获取Unsafe对象  static { try { //这个名字是 theUnsafe 里面的不要随便写  Field unsafeFile = Unsafe.class.getDeclaredField(&amp;#34;theUnsafe&amp;#34;); unsafeFile.setAccessible(true); //因为是静态属性  unsafe = (Unsafe) unsafeFile.get(null); } catch (Exception e) { } } public static Unsafe getUnsafe() { return unsafe; } } AtomicInteger实现# 在AtomicInteger的实现中，静态属性valueOffset即为属性value的内存偏移地址，在静态代码块中通过Unsafe的objectFieldOffset方法对valueOffset赋值。在AtomicInteger中提供的线程安全方法中，通过属性valueOffset可以定位到属性value的内存地址，从而可以根据CAS实现对value属性的原子操作。   上图为某个AtomicInteger对象自增操作前后的内存示意图，对象的基地址baseAddress=“0x110000”，通过baseAddress+valueOffset得到value的内存地址valueAddress=“0x11000c”；然后通过CAS进行原子性的更新操作，成功则返回，否则继续重试，直到更新成功为止。  CAS# CAS(compareAndSwap)即比较并替换，是实现并发算法时常用到的一种技术，CAS操作包含三个参数，要修改变量的内存位置、预期原值、要修改为的值，如果变量的值和预期原值相等，就修改为新值，否则不做处理。CAS底层为一条原子指令cmpxchg，可以保证原子性，Unsafe提供的CAS方法如compareAndSwapInt底层就是CPU指令cmpxchg  /** * CAS * @param o 包含要修改field的对象 * @param offset 对象中某field的偏移量 * @param expected 期望值 * @param update 更新值 * @return true | false */ public final native boolean compareAndSwapObject(Object o, long offset, Object expected, Object update); public final native boolean compareAndSwapInt(Object o, long offset, int expected,int update); public final native boolean compareAndSwapLong(Object o, long offset, long expected, long update);  compareAndSwapInt 使用 (AtomicInteger中也是使用这个)  public class Demo2 { public static void main(String[] args) throws Exception { long startTime = System.</description>
    </item>
    
    <item>
      <title>ReentrantLock</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/reentrantlock/</link>
      <pubDate>Sun, 11 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/reentrantlock/</guid>
      <description>ReentrantLock#ReentrantLock 介绍#  ReentrantLock是Java中常用的锁，属于乐观锁类型，多线程并发情况下。能保证共享数据安全性，线程间有序性
  ReentrantLock通过原子操作和阻塞实现锁原理，一般使用lock获取锁，unlock释放锁，
  下面说一下锁的基本使用和底层基本实现原理，lock和unlock底层
  lock的时候可能被其他线程获得所，那么此线程会阻塞自己，关键原理底层用到Unsafe类的API: CAS和park
  ReentrantLock是一个可重入的互斥锁，又被称为“独占锁”
  简单模拟 ReentrantLock# 不安全的例子  public class ReentrantLockDemo1 { public static void main(String[] args) { new Thread(() -&amp;gt; { drawMoney() ; },&amp;#34;线程1&amp;#34;).start(); new Thread(() -&amp;gt; { drawMoney() ; },&amp;#34;线程2&amp;#34;).start(); } private static void drawMoney(){ System.out.println(Thread.currentThread().getName()+&amp;#34;......&amp;#34;+&amp;#34;正在取钱!&amp;#34;); try { Thread.sleep(3000); } catch (InterruptedException e) { e.</description>
    </item>
    
    <item>
      <title>java重复加锁</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/repeat_lock/</link>
      <pubDate>Sun, 11 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/repeat_lock/</guid>
      <description>可重入锁，从字面来理解，就是可以重复进入的锁
   可重入锁，也叫做递归锁，指的是同一线程外层函数获得锁之后，内层递归函数仍然有获取该锁的代码，但不受影响
  在java环境下reentrantlock和synchronized都是可重入锁
  可重入锁的实现原理#  加锁时，需要判断锁是否已经被获取。如果已经被获取，则判断获取锁的线程是否是当前线程。如果是当前线程，则给获取次数加1。如果不是当前线程，则需要等待
  释放锁时，需要给锁的获取次数减1，然后判断，次数是否为0了。如果次数为0了，则需要调用锁的唤醒方法，让锁上阻塞的其他线程得到执行的机会
  模拟实现简单的可重入锁#public class RepeatLock { //private UnreentrantLock unreentrantLock = new UnreentrantLock();  private ReentrantLock reentrantLock = new ReentrantLock(); //加锁建议在try里面，解锁建议在finally  public void methodA() throws InterruptedException { try { reentrantLock.lock(); System.out.println(&amp;#34;methodA方法被调用&amp;#34;); methodB(); } finally { reentrantLock.unlock(); } } public void methodB() { try { reentrantLock.lock(); System.out.println(&amp;#34;methodB方法被调用&amp;#34;); } catch (InterruptedException e) { e.</description>
    </item>
    
    <item>
      <title>park</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/park/</link>
      <pubDate>Mon, 12 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/park/</guid>
      <description>LockSupport 原理和使用#一: 基本介绍#  LockSupport是一个线程阻塞工具类，所有的方法都是静态方法，可以让线程在任意位置阻塞，阻塞之后也有对应的唤醒方法。归根揭底，LockSupport调用的是Unsafe中的native代码
  LockSupport类使用了一种名为Permit（许可）的概念来做到阻塞和唤醒线程的功能，每个线程都有一个许可（permit）。
  permit只有两个值1和0，默认是0。
  可以把许可看成是一种（0，1）信号量（Semaphore），但与Semaphore不同的是，许可的累加上限是1。
  permit默认是0，所以一开始调用park()方法，当前线程就会阻塞，直到别的线程将当前线程的permit设置为1时，park()方法会被唤醒，然后会将permit再次设置为0并返回。
  面试题套路#为什么可以先唤醒线程后阻塞线程-----因为unpark获取了一个凭证，之后再调用park方法，就可以名正言顺的凭证消费，故不会阻塞。为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程？-----因为凭证的数量最多为1，连续调用两次unpark和调用一次unpark效果一样，只会增加一个凭证；而调用两次park却需要消费两个凭证，证不够，不能放行。可以把permit理解为boolean只有两个状态位置 大多数基本都使用int来描述booleanlet permit = 0;当 permit = 1是阻塞//第一次 unparkpermit--parkpermit++检测permit=0不会阻塞unparkunpark 第二次 permit由于只能是0和1 所以第二次没有效果park permit 回到初始值park permit达到了阻塞情况 阻塞  3种让线程等待和唤醒的方法
  1:使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程
  2:使用JUC包中Condition的await()方法让线程等待，使用signal()方法唤醒线程
  3:LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程</description>
    </item>
    
  </channel>
</rss>
