<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>多线程与并发  on 所悟所想</title>
    <link>https://huachengzhou.github.io/life/docs/javadir/thread/</link>
    <description>Recent content in 多线程与并发  on 所悟所想</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 15 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://huachengzhou.github.io/life/docs/javadir/thread/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>名词解释</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/glossary/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/glossary/</guid>
      <description></description>
    </item>
    
    <item>
      <title>关键名词解释</title>
      <link>https://huachengzhou.github.io/life/docs/javadir/thread/essential_glossary/</link>
      <pubDate>Fri, 17 Jan 2020 15:26:15 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/javadir/thread/essential_glossary/</guid>
      <description>锁分类#轻量级锁#偏向锁# 当一个线程访问同步块(部分文档和解释说也包括同步方法)并获取锁时,会在对象头和栈帧中的锁记录里存在存储偏向锁的线程ID, 以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁,只需要简单测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁 .如果测试成功,表示已经获取到了锁。如果测试失败,则需要再测试一下Mark word中偏向锁的标识符是否设置成1:如果没有设置,则使用CAS竞争锁; 如果设置了,则尝试使用CAS将对象头的偏向锁指向当前线程(实际就是在对象头锁记录存入线程标识的数据,当然顺带栈帧记录也得存入有关的锁记录数据)
 白话#当只有一个线程或者多个线程中最先执行到同步块的时候 这个时候测试完没有偏向锁立即设置完对应的标识记录和锁记录就开始执行同步代码了, 假如下次再进入并且锁没有升级那么仅仅简单测试通过又继续执行了 在这最开始到结束全程没有各种加锁操作甚至连CAS都很有可能没有(是有可能有CASC操作的这涉及到偏向锁的撤销机制) 相比同步操作消耗很少 因此很划算的 当有多个线程竞争锁的时候 这个时候系统检测到了并且达到了锁升级的约束条件那么就会立即执行升级操作即便获得执行条件正在的线程 (当然必须等执行线程中的某个原子操作或者若干原子操作组成的原语)也要对锁记录进行升级然后才开始升级 优点: 把整个同步都消除掉，连CAS操作都不去做了，优于轻量级锁 缺点: 如果程序中大多数的锁都总是被多个不同的线程访问，那偏向锁就是多余的  锁的撤销  偏向锁使用了一种等到竞争出现才释放锁的机制,所以当其他线程尝试竞争偏向锁时,持有偏向锁的线程才会释放锁。偏向锁的撤销, 需要等待全局安全点(在这个时间点上没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程,然后检查持有偏向锁的线程是否活着, 如果线程不处于活动状态,则将对象头设置成无锁状态;如果线程仍然活着,拥有偏向锁的栈会被执行,遍历偏向对象的锁记录, 栈中的锁记录和对象头的mark word要么重新偏向于其它线程,要么恢复到无锁或者标记对象不适合作为偏向锁,最后唤醒暂停的线程。  关闭锁  可以考虑通过JVM参数关闭偏向锁 -XX:-UseBiasedLocking=false 重量级锁#自旋锁 || 适应性自旋锁#悲观锁# 悲观锁是一种悲观思想，即认为写多读少，遇到并发写的可能性高，每次去拿数据的时候都认为其他线程会修改，所以每次读写数据都会认为其他线程会修改，所以每次读写数据时都会上锁。其他线程想要读写这个数据时，会被这个线程block，直到这个线程释放锁然后其他线程获取到锁。
 白话#首先主观判断是需要写的操作高于读操作，因为你经常去写 假如你使用乐观锁那样烧cpu的方式进行那么非常浪费资源(计算机世界中CPU也是资源,甚至时间都是), 然后线程申请锁的时候要么被阻塞要么拿到锁(加锁成功) 拿到锁的继续执行没拿到的立即阻塞进入阻塞队列中等待 等待唤醒的时机 最后说下 悲观锁中如果存在数据库操作不管你是关系数据库,非关系数据库或者NOSQL这些 要小心数据处理的操作 特别是多个服务器对应到一个数据库或者多个服务器对应多个数据库等 要么你的数据处理在某个时刻只会运行在一台服务器上要么数据运行到多台服务器的时候在某个唯一服务器上进行唯一运行检验 实现例子# 关系型数据库锁机制  行锁、表锁、读锁、写锁  Java 里面的同步 synchronized 关键字的实现  乐观锁# 乐观锁是一种乐观思想，假定当前环境是读多写少，遇到并发写的概率比较低，读数据时认为别的线程不会正在进行修改（所以没有上锁）。写数据时，判断当前 与期望值是否相同，如果相同则进行更新（更新期间加锁，保证是原子性的）</description>
    </item>
    
  </channel>
</rss>
