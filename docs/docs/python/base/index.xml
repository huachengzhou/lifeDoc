<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>python 基础学习 on 所悟所想</title>
    <link>https://huachengzhou.github.io/life/docs/python/base/</link>
    <description>Recent content in python 基础学习 on 所悟所想</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 15 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://huachengzhou.github.io/life/docs/python/base/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>python 面向对象</title>
      <link>https://huachengzhou.github.io/life/docs/python/base/python-object/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/python/base/python-object/</guid>
      <description>面向对象# 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或者实例变量, 用于处理类及其实例对象的相关的数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 局部变量：定义在方法中的变量，只作用于当前实例的类。 实例变量：在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟&amp;quot;是一个（is-a）&amp;ldquo;关系（例图，Dog是一个Animal）。 实例化：创建一个类的实例，类的具体对象。 方法：类中定义的函数。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。  import random class Employee: # 所有员工的基类 empCount 变量是一个类变量，它的值将在这个类的所有实例之间共享 empCount = 0 # 类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法 def __init__(self, name, salary): self.name = name self.salary = salary Employee.empCount += 1 def displayCount(self): print(&amp;#34;Total Employee&amp;#34;, Employee.empCount, sep=&amp;#34; _&amp;#34;) def displayEmployee(self): print(&amp;#34;name:&amp;#34;, self.name, &amp;#34; ;&amp;#34;, &amp;#34;salary:&amp;#34;, self.salary) # 定义实例 1 t1 = Employee(&amp;#34;张三&amp;#34;, random.random() * random.random() * 10000) t1.</description>
    </item>
    
    <item>
      <title>python 文件</title>
      <link>https://huachengzhou.github.io/life/docs/python/base/file/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/life/docs/python/base/file/</guid>
      <description>文件# open()  open() 函数用于创建或打开指定文件，该函数的常用语法格式如下：
file = open(file_name [, mode=&#39;r&#39; [ , buffering=-1 [ , encoding = None ]]])此格式中，用 [] 括起来的部分为可选参数，即可以使用也可以省略。其中，各个参数所代表的含义如下：
  file：表示要创建的文件对象。
  file_name：要创建或打开文件的文件名称，该名称要用引号（单引号或双引号都可以）括起来。需要注意的是，如果要打开的文件和当前执行的代码文件位于同一目录，则直接写文件名即可；否则，此参数需要指定打开文件所在的完整路径。
  mode：可选参数，用于指定文件的打开模式。可选的打开模式如表 1 所示。如果不写，则默认以只读（r）模式打开文件。
  buffering：可选参数，用于指定对文件做读写操作时，是否使用缓冲区（本节后续会详细介绍）。
  encoding：手动设定打开文件时所使用的编码格式，不同平台的 ecoding 参数值也不同，以 Windows 为例，其默认为 cp936（实际上就是 GBK 编码）。
  open 函数支持的文件打开模式
     模式 意义 注意事项     r 只读模式打开文件，读文件内容的指针会放在文件的开头。 操作的文件必须存在。   rb 以二进制格式、采用只读模式打开文件，读文件内容的指针位于文件的开头，一般用于非文本文件，如图片文件、音频文件等。    r+ 打开文件后，既可以从头读取文件内容，也可以从开头向文件中写入新的内容，写入的新内容会覆盖文件中等长度的原有内容。    rb+ 以二进制格式、采用读写模式打开文件，读写文件的指针会放在文件的开头，通常针对非文本文件（如音频文件）。    w 以只写模式打开文件，若该文件存在，打开时会清空文件中原有的内容。 若文件存在，会清空其原有内容（覆盖文件）；反之，则创建新文件。   wb 以二进制格式、只写模式打开文件，一般用于非文本文件（如音频文件）    w+ 打开文件后，会对原有内容进行清空，并对该文件有读写权限。    wb+ 以二进制格式、读写模式打开文件，一般用于非文本文件    a 以追加模式打开一个文件，对文件只有写入权限，如果文件已经存在，文件指针将放在文件的末尾（即新写入内容会位于已有内容之后）；反之，则会创建新文件。     ab 以二进制格式打开文件，并采用追加模式，对文件只有写权限。如果该文件已存在，文件指针位于文件末尾（新写入文件会位于已有内容之后）；反之，则创建新文件。     a+ 以读写模式打开文件；如果文件存在，文件指针放在文件的末尾（新写入文件会位于已有内容之后）；反之，则创建新文件。     ab+ 以二进制模式打开文件，并采用追加模式，对文件具有读写权限，如果文件存在，则文件指针位于文件的末尾（新写入文件会位于已有内容之后）；反之，则创建新文件。       File对象的属性     属性 描述     file.</description>
    </item>
    
  </channel>
</rss>
