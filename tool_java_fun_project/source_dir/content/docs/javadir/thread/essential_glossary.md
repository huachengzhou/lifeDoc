---
title: "关键名词解释"
date: 2020-01-17T15:26:15Z
draft: false
weight: 2
---



# 锁分类

## 轻量级锁

![][img1]
![][img1_]

+ Displaced Mark Word(置换标记字)

> 线程在执行同步块之前,JVM会先在当前线程的栈帧中创建用于存储记录的空间,并将对象头中的Mark Word复制到锁记录中,官方称为Displaced Mark Word
。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功,当前线程获得锁,如果失败,表示其他线程竞争锁,当前线程便尝试
使用自旋来获取锁。

### 白话

```shell
在进入同步块之前JVM会在当前线程的"栈帧中申请并创建锁记录的空间,接着把对象头的标识符写到锁记录中"
然后使用CAS将当前线程的锁记录的地址(指针)替换掉锁对应的对象中的标识符,CAS操作成功表示获得锁CAS
操作失败尝试使用自旋(就是在当前进程并且执行代码块的线程内的时间片下空循环烧CPU反正现代计算机大多都是多核处理器在短时间内不会太影响其他任务处理)来获取锁

```

### 锁的撤销

```shell
要想撤销轻量级锁(解锁) 对象头中标识符必须设回为Displaced Mark Word
因此使用CAS操作将Displaced Mark Word替换回到对象头里面,成功那么撤销成功,失败说明有其它线程还在竞争此对象的锁这个时候
锁就会立即膨胀成重量级锁,后续的加锁和解锁都按照重量级锁的操作来
```

## 偏向锁

![][img2]
![][img2_]


> 当一个线程访问同步块(部分文档和解释说也包括同步方法)并获取锁时,会在对象头和栈帧中的锁记录里存在存储偏向锁的线程ID,
以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁,只需要简单测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁
.如果测试成功,表示已经获取到了锁。如果测试失败,则需要再测试一下Mark word中偏向锁的标识符是否设置成1:如果没有设置,则使用CAS竞争锁;
如果设置了,则尝试使用CAS将对象头的偏向锁指向当前线程(实际就是在对象头锁记录存入线程标识的数据,当然顺带栈帧记录也得存入有关的锁记录数据)


### 白话
```shell
当只有一个线程或者多个线程中最先执行到同步块的时候 这个时候测试完没有偏向锁立即设置完对应的标识记录和锁记录就开始执行同步代码了,
假如下次再进入并且锁没有升级那么仅仅简单测试通过又继续执行了 在这最开始到结束全程没有各种加锁操作甚至连CAS都很有可能没有(是有可能有CASC操作的这涉及到偏向锁的撤销机制)
相比同步操作消耗很少  因此很划算的

当有多个线程竞争锁的时候 这个时候系统检测到了并且达到了锁升级的约束条件那么就会立即执行升级操作即便获得执行条件正在的线程
(当然必须等执行线程中的某个原子操作或者若干原子操作组成的原语)也要对锁记录进行升级然后才开始升级

优点: 把整个同步都消除掉，连CAS操作都不去做了，优于轻量级锁
缺点: 如果程序中大多数的锁都总是被多个不同的线程访问，那偏向锁就是多余的
```

+ 偏向锁是JDK6时加入的一种锁优化机制

+ 锁的撤销

```shell
偏向锁使用了一种等到竞争出现才释放锁的机制,所以当其他线程尝试竞争偏向锁时,持有偏向锁的线程才会释放锁。偏向锁的撤销,
需要等待全局安全点(在这个时间点上没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程,然后检查持有偏向锁的线程是否活着,
如果线程不处于活动状态,则将对象头设置成无锁状态;如果线程仍然活着,拥有偏向锁的栈会被执行,遍历偏向对象的锁记录,
栈中的锁记录和对象头的mark word要么重新偏向于其它线程,要么恢复到无锁或者标记对象不适合作为偏向锁,最后唤醒暂停的线程。
```

+ 关闭锁

```shell
可以考虑通过JVM参数关闭偏向锁
-XX:-UseBiasedLocking=false
```

## 重量级锁

![][img3]
![][img3_]

+ 重量级锁是一种称谓

```shell
synchronized是通过对象内部的一个叫做监视器锁
（monitor）来实现的，监视器锁本身依赖底层的操作系统的 Mutex Lock来实现。操
作系统实现线程的切换需要从用户态切换到核心态，成本非常高。这种依赖于操作系
统 Mutex Lock来实现的锁称为重量级锁。为了优化synchonized，引入了轻量级锁，
偏向锁
```

+ Java中的重量级锁： synchronized

## 自旋锁 || 适应性自旋锁

![][img4]
![][img4_]

> 自旋是一种技术理念,使线程忙等待,只需要让线程执行一个忙循环(自旋)。
  现在绝大多数的计算机都是多核处理器,如果物理机器有一个以上的处理器或者处理器核心,
  能让两个或以上的线程同时并行执行,就可以让后面请求锁的那个线程"稍等一会",
  但不放弃处理器的执行时间,看看持有锁的线程是否很快就会释放锁。
  
+ 自旋锁的优点

```shell
避免了线程切换的开销。挂起线程和恢复线程的操作都需要转入内核
态中完成，这些操作给Java虚拟机的并发性能带来了很大的压力。
```

+ 自旋锁的缺点

```shell
占用处理器的时间，如果占用的时间很长，会白白消耗处理器资源，
而不会做任何有价值的工作，带来性能的浪费。因此自旋等待的时间必须有一定的限
度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起
线程。
```

+ 自旋次数默认值

```shell
0次，可以使用参数-XX:PreBlockSpin来自行更改。
```

+ 自适应自旋

```shell
自适应意味着自旋的时间不再是固定的，而是由前一次在同一个锁上的
自旋时间及锁的拥有者的状态来决定的。有了自适应自旋，随着程序运行时间的增长
及性能监控信息的不断完善，虚拟机对程序锁的状态预测就会越来越精准。
```

+ Java中的自旋锁： CAS操作中的比较操作失败后的自旋等待。

## 悲观锁

![][img5]
![][img5_]

> 悲观锁是一种悲观思想，即认为写多读少，遇到并发写的可能性高，每次去拿数据的时候都认为其他线程会修改，所以每次读写数据都会认为其他线程会修改，所以每次读写数据时都会上锁。其他线程想要读写这个数据时，会被这个线程block，直到这个线程释放锁然后其他线程获取到锁。

### 白话

```shell
首先主观判断是需要写的操作高于读操作，因为你经常去写 假如你使用乐观锁那样烧cpu的方式进行那么非常浪费资源(计算机世界中CPU也是资源,甚至时间都是),
然后线程申请锁的时候要么被阻塞要么拿到锁(加锁成功) 拿到锁的继续执行没拿到的立即阻塞进入阻塞队列中等待 等待唤醒的时机
最后说下 悲观锁中如果存在数据库操作不管你是关系数据库,非关系数据库或者NOSQL这些 要小心数据处理的操作 特别是多个服务器对应到一个数据库或者多个服务器对应多个数据库等
要么你的数据处理在某个时刻只会运行在一台服务器上要么数据运行到多台服务器的时候在某个唯一服务器上进行唯一运行检验
```

### 实现例子

+ 关系型数据库锁机制

```shell
行锁、表锁、读锁、写锁
```

+ Java 里面的同步 synchronized 关键字的实现

## 乐观锁

![][img6]
![][img6_]

> 乐观锁是一种乐观思想，假定当前环境是读多写少，遇到并发写的概率比较低，读数据时认为别的线程不会正在进行修改（所以没有上锁）。写数据时，判断当前 与期望值是否相同，如果相同则进行更新（更新期间加锁，保证是原子性的）

### 白话

```shell
当以这种模式运行时  我们预估大多数都能够实现  那么就以烧CPU轮询方式进行
在 当前运行的进程内的并且运行的线程一直轮询  只要不被阻塞或者其他什么引起线程不执行了就一直轮训知道成功为止
稍微提一下  必须满足运行的当前进程被操作系统调度进入CPU运行 因为操作系统内核对所有进程有一套调度算法一个进程正在执行中即便没有执行完也有可能被暂停,如时间片已经用完
```

### 实现例子

+ CAS 实现

```shell
Java 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式
CAS，比较并替换，比较当前值（主内存中的值），与预期值（当前线程中的值，主内存中值的一份拷贝）是否一样，一样则更新，否则继续进行CAS操作
```

+ 版本号控制

```shell
般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。
当数据被修改时，version 值会 +1。当线程 A 要更新数据时，在读取数据的同时也会读取 version 值，
在提交更新时，若刚才读取到的 version 值与当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功
```


## 互斥锁

![][img7]
![][img7_]

> 互斥锁与悲观锁、独占锁同义，表示某个资源只能被一个线程访问，其他线程不能访问

+ 读-读互斥
+ 读-写互斥
+ 写-读互斥
+ 写-写互斥

## 公平锁

![][img8]
![][img8_]

> 公平锁是一种思想： 多个线程按照申请锁的顺序来获取锁。在并发环境中，每个线程
  会先查看此锁维护的等待队列，如果当前等待队列为空，则占有锁，如果等待队列不
  为空，则加入到等待队列的末尾，按照FIFO的原则从队列中拿到线程，然后占有锁。

## 非公平锁

![][img9]
![][img9_]

> 非公平锁是一种思想： 线程尝试获取锁，如果获取不到，则再采用公平锁的方式。多
  个线程获取锁的顺序，不是按照先到先得的顺序，有可能后申请锁的线程比先申请的
  线程优先获取锁。

+ 优点： 非公平锁的性能高于公平锁。
+ 缺点： 有可能造成线程饥饿（某个线程很长一段时间获取不到锁）
+ Java中的非公平锁：synchronized是非公平锁，ReentrantLock通过构造函数指定该锁是公平的还是非公平的，默认是非公平的。

## 分段锁

![][img10]
![][img10_]

> 分段锁是一种机制： 最好的例子来说明分段锁是ConcurrentHashMap。

+ ConcurrentHashMap原理

```shell
它内部细分了若干个小的 HashMap，称之为段
(Segment)。 默认情况下一个 ConcurrentHashMap 被进一步细分为 16 个段，既
就是锁的并发度。如果需要在 ConcurrentHashMap 添加一项key-value，并不是将
整个 HashMap 加锁，而是首先根据 hashcode 得到该key-value应该存放在哪个段
中，然后对该段加锁，并完成 put 操作。在多线程环境中，如果多个线程同时进行
put操作，只要被加入的key-value不存放在同一个段中，则线程间可以做到真正的并
行。
```

+ 线程安全

```shell
：ConcurrentHashMap 是一个 Segment 数组， Segment 通过继承
ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这
样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全
```

## 读写锁

## 共享锁、独占锁

# 获取锁的某些方式

> 仅仅是加锁过程中一个或者一些操作

## CAS

## AQS

# 其它

## 同步术语

+ volatile类型的变量
+ 显示锁 Explicit Lock
+ 原子变量
+ synchronized



[img1]:../.././imgs/java/thread/屏幕截图2022-08-25211506.png
[img1_]:../../../imgs/java/thread/屏幕截图2022-08-25211506.png
[img2]:../.././imgs/java/thread/屏幕截图2022-08-25-211557.png
[img2_]:../../../imgs/java/thread/屏幕截图2022-08-25-211557.png
[img3]:../.././imgs/java/thread/屏幕截图2022-08-25211708.png
[img3_]:../../../imgs/java/thread/屏幕截图2022-08-25211708.png
[img4]:../.././imgs/java/thread/屏幕截图2022-08-25211817.png
[img4_]:../../../imgs/java/thread/屏幕截图2022-08-25211817.png

[img5]:../.././imgs/java/thread/屏幕截图2022-08-25212015.png
[img5_]:../../../imgs/java/thread/屏幕截图2022-08-25212015.png
[img6]:../.././imgs/java/thread/屏幕截图2022-08-25212447.png
[img6_]:../../../imgs/java/thread/屏幕截图2022-08-25212447.png
[img7]:../.././imgs/java/thread/屏幕截图2022-08-25-212556.png
[img7_]:../../../imgs/java/thread/屏幕截图2022-08-25-212556.png


[img8]:../.././imgs/java/thread/屏幕截图2022-08-25215628.png
[img8_]:../../../imgs/java/thread/屏幕截图2022-08-25215628.png

[img9]:../.././imgs/java/thread/屏幕截图2022-08-25215700.png
[img9_]:../../../imgs/java/thread/屏幕截图2022-08-25215700.png
[img10]:../.././imgs/java/thread/屏幕截图2022-08-25215732.png
[img10_]:../../../imgs/java/thread/屏幕截图2022-08-25215732.png



