---
title : 'java > 多线程synchronized.answer'
date : '2021-02-15'
draft : false
tags : ["多线程"]
categories : ["java","index"]
author : 'zch'
description : '测试博客'
lastmod : '2021-02-15'
---






```
1
3
4
2
```

+ 首先t1线程最先执行所以输出1没问题

+ 输出t1后执行了object.wait(),当前执行线程放弃了此监视器上的锁,并且被挂起(等待此监视器上的其它线程来唤醒) 这里最重要的是把此监视器上的锁给放弃了

+ t2线程去竞争object上的锁,由于目前只有它一个线程是属于非挂起状态因此t2就获得了object上的锁.因此输出了3没问题

+ 接着t2线程又执行了object.notify(),这个方法是随机唤醒此监视器上被挂起的线程,并且刚好只有2个线程中的一个被挂起那么t1就被唤醒了,注意仅仅是唤醒而已,并没有使得t2放弃锁或者t1获得锁,因此t1还是不能执行

+ 接着t2线程执行了sleep(500)这个方法,但是这个方法同样并没有使得t2线程放弃锁,仅仅是暂停了那么一会,这就像打战弱势的一方拿空间换时间做战略撤退，实际上并没有投降依然属于不投降状态
+ 因此当t2线程执行完之后t1最好才能执行接着打印出2
























