---
title : '精选17道海量数量处理面试题'
date : '2021-02-15'
draft : false
tags : ["面试"]
categories : ["java","index"]
author : 'zch'
description : '测试博客'
lastmod : '2021-02-15'
---

1.  给定 a、b 两个文件，各存放 50 亿个 url，每个 url 各占 64 字节，内存限制是 4G，让你找出 a、b 文件共同的 url？

> 方案 1：可以估计每个文件安的大小为 50G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。
>
> ![](media/image2.png){width="1.0729166666666667in" height="0.1358464566929134in"}![](media/image3.png){width="0.8659722222222223in" height="0.10449693788276465in"}s 遍历文件 a，对每个 url 求取 ，然后根据所取得的值将 url 分别存储到 1000 个小文件（记为 ）中。这样每个小文件的大约为300M。
>
> s 遍历文件 b，采取和 a 相同的方式将 url 分别存储到 1000 各小文件（记为
>
> ![](media/image4.png){width="0.8416655730533683in" height="0.1358464566929134in"}）。这样处理后，所有可能相同的 url 都在对应的小文件
>
> ![](media/image5.png){width="1.8659722222222221in" height="0.1358464566929134in"}（ ）中，不对应的小文件不可能有相同的 url。然后我们只要求出 1000 对小文件中相同的 url 即可。
>
> s 求每对小文件中相同的 url 时，可以把其中一个小文件的 url 存储到hash\_set 中。然后遍历另一个小文件的每个 url，看其是否在刚才构建的hash\_set 中，如果是，那么就是共同的 url，存到文件里面就可以了。
>
> 方案 2：如果允许有一定的错误率，可以使用 Bloom filter，4G 内存大概可以表示 340 亿 bit。将其中一个文件中的 url 使用 Bloom filter 映射为这 340 亿
>
> bit，然后挨个读取另外一个文件的 url，检查是否与 Bloom filter，如果是，那么该 url 应该是共同的 url（注意会有一定的错误率）。

1.  有 10 个文件，每个文件 1G，每个文件的每一行存放的都是用户的 query，每个文件的 query 都可能重复。要求你按照 query 的频度排序。

> 方案 1：
>
> ![](media/image6.png){width="0.75625in" height="0.10449693788276465in"}s 顺序读取 10 个文件，按照 hash(query)%10 的结果将 query 写入到另外 10 个文件（记为 ）中。这样新生成的文件每个的大小大约也 1G（假设 hash 函数是随机的）。
>
> ![](media/image6.png){width="0.7562489063867016in" height="0.10449693788276465in"}![](media/image7.png){width="0.7805544619422572in" height="0.1358464566929134in"}s 找一台内存在 2G 左右的机器，依次对 用 hash\_map(query, query\_count)来统计每个 query 出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的 query 和对应的 query\_cout 输出到文件中。这样得到了 10 个排好序的文件（记为 ）。
>
> ![](media/image7.png){width="0.7805544619422572in" height="0.1358464566929134in"}s 对 这 10 个文件进行归并排序（内排序与外排序相结合）。方案 2：
>
> 一般 query 的总量是有限的，只是重复的次数比较多而已，可能对于所有的
>
> query，一次性就可以加入到内存了。这样，我们就可以采用 trie 树/hash\_map
>
> 等直接来统计每个 query 出现的次数，然后按出现次数做快速/堆/归并排序就可以了。
>
> 方案 3：
>
> 与方案 1 类似，但在做完 hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如 MapReduce），最后再进行合并。

1.  有一个 1G 大小的一个文件，里面每一行是一个词，词的大小不超过 16

> 字节，内存限制大小是 1M。返回频数最高的 100 个词。
>
> ![](media/image8.png){width="0.9513888888888888in" height="0.1358464566929134in"}![](media/image9.png){width="0.9027777777777778in" height="0.10449693788276465in"}方案 1：顺序读文件中，对于每个词 x，取 ，然后按照该值存到5000 个小文件（记为 ）中。这样每个文件大概是 200k 左右。如果其中的有的文件超过了 1M 大小，还可以按照类似的方法继续往下分，知道分解得到的小文件的大小都不超过 1M。对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用 trie 树/hash\_map 等），并取出出现频率最大的 100 个词（可以用含 100 个结点的最小堆），并把 100 词及相应的频
>
> 率存入文件，这样又得到了 5000 个文件。下一步就是把这 5000 个文件进行归并（类似与归并排序）的过程了。

1.  海量日志数据，提取出某日访问百度次数最多的那个 IP。

> ![](media/image10.png){width="0.20763779527559056in" height="0.11494641294838145in"}方案 1：首先是这一天，并且是访问百度的日志中的 IP 取出来，逐个写入到一个大文件中。注意到 IP 是 32 位的，最多有 个 IP。同样可以采用映射的方法，比如模 1000，把整个大文件映射为 1000 个小文件，再找出每个小文中出现频率最大的 IP（可以采用 hash\_map 进行频率统计，然后再找出频率最大的几个）及相应的频率。然后再在这 1000 个最大的 IP 中，找出那个频率最大的 IP，即为所求。

1.  在 2.5 亿个整数中找出不重复的整数，内存不足以容纳这 2.5 亿个整数。

> ![](media/image11.png){width="1.1097222222222223in" height="0.11494641294838145in"}方案 1：采用 2-Bitmap（每个数分配 2bit，00 表示不存在，01 表示出现一次， 10 表示多次，11 无意义）进行，共需内存 内存，还可以接受。然后扫描这 2.5 亿个整数，查看 Bitmap 中相对应位，如果是 00 变 01，01 变 10，10 保持不变。所描完事后，查看 bitmap，把对应位是 01 的整数输出即可。
>
> 方案 2：也可采用上题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。

1.  海量数据分布在 100 台电脑中，想个办法高校统计出这批数据的 TOP10。方案 1：

> s 在每台电脑上求出TOP10，可以采用包含 10 个元素的堆完成（TOP10 小，用最大堆，TOP10 大，用最小堆）。比如求 TOP10 大，我们首先取前 10 个元素调整成最小堆，如果发现，然后扫描后面的数据，并与堆顶元素比较， 如果比堆顶元素大，那么用该元素替换堆顶，然后再调整为最小堆。最后堆中的元素就是 TOP10 大。
>
> s 求出每台电脑上的TOP10 后，然后把这 100 台电脑上的TOP10 组合起来， 共 1000 个数据，再利用上面类似的方法求出 TOP10 就可以了。

1.  怎么在海量数据中找出重复次数最多的一个？

> 方案 1：先做 hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。

1.  上千万或上亿数据（有重复），统计其中出现次数最多的钱 N 个数据。

> 方案 1：上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用 hash\_map/搜索二叉树/红黑树等来进行统计次数。然后就是取出前 N 个出现次数最多的数据了，可以用第 6 题提到的堆机制完成。

1.  1000 万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？

> 方案 1：这题用 trie 树比较合适，hash\_map 也应该能行。

1.  一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前 10 个词，请给出思想，给出时间复杂度分析。

> 方案 1：这题是考虑时间效率。用 trie 树统计每个词出现的次数，时间复杂度是 O(n\*le)（le 表示单词的平准长度）。然后是找出出现最频繁的前 10 个词， 可以用堆来实现，前面的题中已经讲到了，时间复杂度是 O(n\*lg10)。所以总的时间复杂度，是 O(n\*le)与 O(n\*lg10)中较大的哪一个。

1.  一个文本文件，找出前 10 个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。

> 方案 1：首先根据用 hash 并求模，将文件分解为多个小文件，对于单个文件利用上题的方法求出每个文件件中 10 个最常出现的词。然后再进行归并处理，
>
> 找出最终的 10 个最常出现的词。

1.  100w 个数中找出最大的 100 个数。

> 方案 1：在前面的题中，我们已经提到了，用一个含 100 个元素的最小堆完成。复杂度为 O(100w\*lg100)。
>
> 方案 2：采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比 100 多的时候，采用传统排序算法排序，取前 100 个。复杂度为 O(100w\*100)。
>
> 方案 3：采用局部淘汰法。选取前 100 个元素，并排序，记为序列 L。然后一次扫描剩余的元素 x，与排好序的 100 个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除，并把 x 利用插入排序的思想， 插入到序列 L 中。依次循环，知道扫描了所有的元素。复杂度为 O(100w\*100)。

1.  寻找热门查询：

> 搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为 1-255 字节。假设目前有一千万个记录，这些查询串的重
>
> 复读比较高，虽然总数是 1 千万，但是如果去除重复和，不超过 3 百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的 10 个查询串，要求使用的内存不能超过 1G。

(1) 请描述你解决这个问题的思路；

(2) 请给出主要的处理流程，算法，以及算法的复杂度。

> 方案 1：采用 trie 树，关键字域存该查询串出现的次数，没有出现为 0。最后用 10 个元素的最小推来对出现频率进行排序。

1.  ![](media/image12.png){width="0.17083333333333334in" height="0.11494641294838145in"}一共有 N 个机器，每个机器上有 N 个数。每个机器最多存 O(N)个数并对它们操作。如何找到 个数中的中数？

> ![](media/image10.png){width="0.20763779527559056in" height="0.11494641294838145in"}![](media/image13.png){width="0.46319444444444446in" height="0.11494641294838145in"}![](media/image14.png){width="0.17083333333333334in" height="0.2507928696412948in"}![](media/image15.png){width="0.40421806649168857in" height="0.2507928696412948in"}![](media/image14.png){width="0.17083333333333334in" height="0.2507928696412948in"}![](media/image16.png){width="0.40421806649168857in" height="0.2507928696412948in"}方案 1：先大体估计一下这些数的范围，比如这里假设这些数都是 32 位无符号整数（共有 个）。我们把 0 到 的整数划分为 N 个范围段，每个段
>
> 包含 个整数。比如，第一个段位 0 到 ，第二段为 到 ，...，第
>
> ![](media/image17.png){width="0.4631933508311461in" height="0.2507928696412948in"}![](media/image13.png){width="0.4631933508311461in" height="0.11494641294838145in"}![](media/image18.png){width="0.1340255905511811in" height="0.2507928696412948in"}N 个段为 到 。然后，扫描每个机器上的 N 个数，把属于第一个区段的数放到第一个机器上，属于第二个区段的数放到第二个机器上，...， 属于第 N 个区段的数放到第 N 个机器上。注意这个过程每个机器上存储的数应该是 O(N)的。下面我们依次统计每个机器上数的个数，一次累加，直到找
>
> 到第 k 个机器，在该机器上累加的数大于或等于 ，而在第 k-1 个机器上的累加数小于 ![](media/image19.png){width="0.1340255905511811in" height="0.4388888888888889in"}，并把这个数记为 x。那么我们要找的中位数在第 k 个机器中，
>
> ![](media/image20.png){width="0.37777668416447946in" height="0.2507928696412948in"}![](media/image20.png){width="0.37777668416447946in" height="0.2507928696412948in"}![](media/image21.png){width="0.3902777777777778in" height="0.1358464566929134in"}排在第 位。然后我们对第 k 个机器的数排序，并找出第 个数，即为所求的中位数。复杂度是 的。
>
> 方案 2：先对每台机器上的数进行排序。排好序后，我们采用归并排序的思
>
> ![](media/image18.png){width="0.1340255905511811in" height="0.2507928696412948in"}![](media/image22.png){width="0.7194444444444444in" height="0.14629593175853017in"}想，将这 N 个机器上的数归并起来得到最终的排序。找到第 个便是所求。复杂度是 的。

1.  最大间隙问题

> ![](media/image23.png){width="0.9388877952755905in" height="0.10449693788276465in"}给定 n 个实数 ，求着 n 个实数在实轴上向量 2 个数之间的最大差值，要求线性的时间算法。
>
> 方案 1：最先想到的方法就是先对这 n 个数据进行排序，然后一遍扫描即可确定相邻的最大间隙。但该方法不能满足线性时间的要求。故采取如下方法：
>
> s 找到 n 个数据中最大和最小数据 max 和 min。
>
> ![](media/image24.png){width="1.1847462817147856in" height="0.11494641294838145in"}![](media/image25.png){width="1.4513888888888888in" height="0.4388877952755906in"}s 用 n-2 个点等分区间\[min, max\]，即将\[min, max\]等分为 n-1 个区间（前闭后开区间），将这些区间看作桶，编号为 ，且桶 ![](media/image26.png){width="8.541447944007e-2in" height="0.25624890638670167in"}的上界和桶
>
> i+1 的下届相同，即每个桶的大小相同。每个桶的大小为： 。
>
> 实际上，这些桶的边界构成了一个等差数列（首项为 min，公差为
>
> ![](media/image27.png){width="0.9270833333333334in" height="0.1358464566929134in"}），且认为将 min 放入第一个桶，将 max 放入第 n-1 个桶。
>
> ![](media/image28.png){width="0.20763779527559056in" height="0.1358464566929134in"}![](media/image29.png){width="1.5749857830271217in" height="0.26124234470691166in"}s 将 n 个数放入 n-1 个桶中：将每个元素 分配到某个桶（编号为 index）， 其中 ，并求出分到每个桶的最大最小数据。
>
> s 最大间隙：除最大最小数据max 和min 以外的n-2 个数据放入n-1 个桶中，
>
> ![](media/image30.png){width="0.5243055555555556in" height="0.1358464566929134in"}由抽屉原理可知至少有一个桶是空的，又因为每个桶的大小相同，所以最大间隙不会在同一桶中出现，一定是某个桶的上界和气候某个桶的下界之间隙， 且该量筒之间的桶（即便好在该连个便好之间的桶）一定是空桶。也就是说， 最大间隙在桶 i 的上界和桶 j 的下界之间产生 。一遍扫描即可完成。

1.  将多个集合合并成没有交集的集合：给定一个字符串的集合，格式如：

> ![](media/image31.png){width="2.5in" height="0.12666666666666668in"}。要求将其中交集不为空的集合合并，要求合并完成的集合之间无交集，例如上例应输出
>
> ![](media/image32.png){width="2.5in" height="0.15572834645669292in"}。

(1) 请描述你解决这个问题的思路；

(2) 给出主要的处理流程，算法，以及算法的复杂度；

(3) 请描述可能的改进。

> ![](media/image33.png){width="0.9041896325459318in" height="0.1358464566929134in"}方案 1：采用并查集。首先所有的字符串都在单独的并查集中。然后依扫描每个集合，顺序合并将两个相邻元素合并。例如，对于 ，首先查看 aaa 和 bbb 是否在同一个并查集中，如果不在，那么把它们所在的并查集合并，然后再看 bbb 和 ccc 是否在同一个并查集中，如果不在，那么也把它们所在的并查集合并。接下来再扫描其他的集合，当所有的集合都扫描完了， 并查集代表的集合便是所求。复杂度应该是 O(NlgN)的。改进的话，首先可 以记录每个节点的根结点，改进查询。合并的时候，可以把大的和小的进行合，这样也减少复杂度。

1.  最大子序列与最大子矩阵问题

> 数组的最大子序列问题：给定一个数组，其中元素有正，也有负，找出其中一个连续子序列，使和最大。
>
> ![](media/image34.png){width="0.21944444444444444in" height="0.1358464566929134in"}![](media/image35.png){width="0.2089938757655293in" height="0.1358464566929134in"}方案 1：这个问题可以动态规划的思想解决。设 表示以第 i 个元素 结尾的最大子序列，那么显然 ![](media/image36.png){width="2.499998906386702in" height="0.15572834645669292in"}。基于这一点可以很快用代码实现。
>
> 最大子矩阵问题：给定一个矩阵（二维数组），其中数据有大有小，请找一个子矩阵，使得子矩阵的和最大，并输出这个和。
>
> 方案 1：可以采用与最大子序列类似的思想来解决。如果我们确定了选择第 i 列和第 j 列之间的元素，那么在这个范围内，其实就是一个最大子序列问题。如何确定第 i 列和第 j 列可以词用暴搜的方法进行。
>
> 更多请关注微信公众号：Java 技术栈，回复：面试
