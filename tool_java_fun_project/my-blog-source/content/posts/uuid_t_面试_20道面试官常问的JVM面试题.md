---
title : '20道面试官常问的JVM面试题'
date : '2021-02-15'
draft : false
tags : ["面试"]
categories : ["java","index"]
author : 'zch'
description : '测试博客'
lastmod : '2021-02-15'
---

1.  内存模型以及分区，需要详细到每个区放什么。

2.  堆里面的分区：Eden，survival （from+ to），老年代，各自的特点。

3.  对象创建方法，对象的内存分配，对象的访问定位。

> new 一个对象

1.  GC 的两种判定方法：

2.  SafePoint 是什么

3.  GC 的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在

> 什么地方，如果让你优化收集方法，有什么思路？

1.  GC 收集器有哪些？CMS 收集器与 G1 收集器的特点。

2.  Minor GC 与 Full GC 分别在什么时候发生？

> 新生代内存不够用时候发生 MGC 也叫 YGC，JVM 内存不够的时候发生 FGC

1.  几种常用的内存调试工具：jmap、jstack、jconsole、jhat

2.  类加载的几个过程：

3.  **JVM 内存分哪几个区，每个区的作用是什么?**

4.  **如和判断一个对象是否存活?(或者 GC 对象的判定方法)**

![](media/image2.png){width="5.8093055555555555in" height="3.4669444444444446in"}

-   ![](media/image3.png){width="5.8093055555555555in" height="1.733665791776028in"}![](media/image4.png){width="5.8093055555555555in" height="5.884444444444444in"}虚拟机栈中引用的对象

-   方法区类静态属性引用的对象

-   方法区常量池引用的对象

-   本地方法栈 JNI 引用的对象

> 虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比**不一定**
>
> **会被回收**。当一个对象不可达 GC Root 时，这个对象并
>
> **不会立马被回收**，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记
>
> 如果对象在可达性分析中没有与 GC Root 的引用链，那么此时就会被第一次标记并且进行
>
> 一次筛选，筛选的条件是是否有必要执行finalize()方法。当对象没有覆盖 finalize()方法或
>
> 者已被虚拟机调用过，那么就认为是没必要的。
>
> 如果该对象有必要执行finalize()方法，那么这个对象将会放在一个称为 F-Queue 的对队列
>
> 中，虚拟机会触发一个Finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承诺
>
> 一直等待它运行完，这是因为如果finalize()执行缓慢或者发生了死锁，那么就会造成

1.  **简述 java 垃圾回收机制?**

2.  **java 中垃圾收集的方法有哪些?**

![](media/image5.png){width="5.6426388888888885in" height="4.4173600174978125in"}

> ![](media/image6.png){width="5.6426388888888885in" height="6.234360236220472in"}于是将该算法进行了改进，内存区域不再是按照 1：1 去划分，而是将内存划分为 8:1:1
>
> 三部分，较大那份内存交Eden 区，其余是两块较小的内存区叫 Survior 区。每次都
>
> 会优先使用Eden 区，若 Eden 区满，就将对象复制到第二块内存区上，然后清除 Eden
>
> 区，如果此时存活的对象太多，以至于 Survivor 不够时，会将这些对象通过分配担
>
> 保机制复制到老年代中。(java 堆又分为新生代和老年代)

# 标记-整理

> 该算法主要是为了解决标记-清除，产生大量内存碎片的问题；当对象存活率较高时，
>
> 也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收对象
>
> 移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。

# 分代收集

> 现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代
>
> 和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这
>
> 时就采用**复制**算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所
>
> 以可以使用**标记-整理** 或者 **标记-清除**。

1.  **java 内存模型**

2.  **java 类加载过程?**

<!-- -->

2.  ![](media/image7.png){width="5.8093055555555555in" height="5.6343602362204726in"}元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被

> 继承的类等。

2.  字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，

> 确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指
>
> 令是否正确等。

2.  符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执

> 行。

# 准备

> 准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行
>
> 分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起
>
> 分配在 Java 堆中。
>
> public static int value=123;*//在准备阶段 value 初始值为 0 。在初始化阶段才会变*
>
> *为 123 。*

-   1

-   2

17. ![](media/image8.png){width="5.8093055555555555in" height="3.0340824584426946in"}**简述java 类加载机制?**

18. **类加载器双亲委派模型机制？**

19. **什么是类加载器，类加载器有哪些?**

20. **简述 java 内存分配与回收策率以及 Minor GC 和Major GC**
